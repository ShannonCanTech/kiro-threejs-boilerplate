# three.js 

> JavaScript 3D Library. 

<a name="AnimationClipCreator"></a>


## CatmullRom(t, p0, p1, p2, p3) ⇒ <code>number</code>
Computes a point on a Catmull-Rom spline.

**Kind**: global function  
**Returns**: <code>number</code> - The calculated point on a Catmull-Rom spline.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |
| p0 | <code>number</code> | The first control point. |
| p1 | <code>number</code> | The second control point. |
| p2 | <code>number</code> | The third control point. |
| p3 | <code>number</code> | The fourth control point. |

<a name="QuadraticBezier"></a>

## QuadraticBezier(t, p0, p1, p2) ⇒ <code>number</code>
Computes a point on a Quadratic Bezier curve.

**Kind**: global function  
**Returns**: <code>number</code> - The calculated point on a Quadratic Bezier curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |
| p0 | <code>number</code> | The first control point. |
| p1 | <code>number</code> | The second control point. |
| p2 | <code>number</code> | The third control point. |

<a name="CubicBezier"></a>

## CubicBezier(t, p0, p1, p2, p3) ⇒ <code>number</code>
Computes a point on a Cubic Bezier curve.

**Kind**: global function  
**Returns**: <code>number</code> - The calculated point on a Cubic Bezier curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |
| p0 | <code>number</code> | The first control point. |
| p1 | <code>number</code> | The second control point. |
| p2 | <code>number</code> | The third control point. |
| p3 | <code>number</code> | The fourth control point. |

<a name="Path"></a>

## Path ⇐ <code>CurvePath</code>
A 2D path representation. The class provides methods for creating paths
and contours of 2D shapes similar to the 2D Canvas API.

```js
const path = new THREE.Path();

path.lineTo( 0, 0.8 );
path.quadraticCurveTo( 0, 1, 0.2, 1 );
path.lineTo( 1, 1 );

const points = path.getPoints();

const geometry = new THREE.BufferGeometry().setFromPoints( points );
const material = new THREE.LineBasicMaterial( { color: 0xffffff } );

const line = new THREE.Line( geometry, material );
scene.add( line );
```

**Kind**: global class  
**Extends**: <code>CurvePath</code>  

* [Path](#Path) ⇐ <code>CurvePath</code>
    * [new Path([points])](#new_Path_new)
    * [.currentPoint](#Path+currentPoint) : <code>Vector2</code>
    * [.setFromPoints(points)](#Path+setFromPoints) ⇒ [<code>Path</code>](#Path)
    * [.moveTo(x, y)](#Path+moveTo) ⇒ [<code>Path</code>](#Path)
    * [.lineTo(x, y)](#Path+lineTo) ⇒ [<code>Path</code>](#Path)
    * [.quadraticCurveTo(aCPx, aCPy, aX, aY)](#Path+quadraticCurveTo) ⇒ [<code>Path</code>](#Path)
    * [.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY)](#Path+bezierCurveTo) ⇒ [<code>Path</code>](#Path)
    * [.splineThru(pts)](#Path+splineThru) ⇒ [<code>Path</code>](#Path)
    * [.arc(aX, aY, aRadius, aStartAngle, aEndAngle, [aClockwise])](#Path+arc) ⇒ [<code>Path</code>](#Path)
    * [.absarc(aX, aY, aRadius, aStartAngle, aEndAngle, [aClockwise])](#Path+absarc) ⇒ [<code>Path</code>](#Path)
    * [.ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, [aClockwise], [aRotation])](#Path+ellipse) ⇒ [<code>Path</code>](#Path)
    * [.absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, [aClockwise], [aRotation])](#Path+absellipse) ⇒ [<code>Path</code>](#Path)

<a name="new_Path_new"></a>

### new Path([points])
Constructs a new path.


| Param | Type | Description |
| --- | --- | --- |
| [points] | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points defining the path. |

<a name="Path+currentPoint"></a>

### path.currentPoint : <code>Vector2</code>
The current offset of the path. Any new curve added will start here.

**Kind**: instance property of [<code>Path</code>](#Path)  
<a name="Path+setFromPoints"></a>

### path.setFromPoints(points) ⇒ [<code>Path</code>](#Path)
Creates a path from the given list of points. The points are added
to the path as instances of [LineCurve](LineCurve).

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points. |

<a name="Path+moveTo"></a>

### path.moveTo(x, y) ⇒ [<code>Path</code>](#Path)
Moves [currentPoint](#Path+currentPoint) to the given point.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate. |
| y | <code>number</code> | The y coordinate. |

<a name="Path+lineTo"></a>

### path.lineTo(x, y) ⇒ [<code>Path</code>](#Path)
Adds an instance of [LineCurve](LineCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate of the end point. |
| y | <code>number</code> | The y coordinate of the end point. |

<a name="Path+quadraticCurveTo"></a>

### path.quadraticCurveTo(aCPx, aCPy, aX, aY) ⇒ [<code>Path</code>](#Path)
Adds an instance of [QuadraticBezierCurve](QuadraticBezierCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| aCPx | <code>number</code> | The x coordinate of the control point. |
| aCPy | <code>number</code> | The y coordinate of the control point. |
| aX | <code>number</code> | The x coordinate of the end point. |
| aY | <code>number</code> | The y coordinate of the end point. |

<a name="Path+bezierCurveTo"></a>

### path.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) ⇒ [<code>Path</code>](#Path)
Adds an instance of [CubicBezierCurve](CubicBezierCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| aCP1x | <code>number</code> | The x coordinate of the first control point. |
| aCP1y | <code>number</code> | The y coordinate of the first control point. |
| aCP2x | <code>number</code> | The x coordinate of the second control point. |
| aCP2y | <code>number</code> | The y coordinate of the second control point. |
| aX | <code>number</code> | The x coordinate of the end point. |
| aY | <code>number</code> | The y coordinate of the end point. |

<a name="Path+splineThru"></a>

### path.splineThru(pts) ⇒ [<code>Path</code>](#Path)
Adds an instance of [SplineCurve](SplineCurve) to the path by connecting
the current point with the given list of points.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Description |
| --- | --- | --- |
| pts | <code>Array.&lt;Vector2&gt;</code> | An array of points in 2D space. |

<a name="Path+arc"></a>

### path.arc(aX, aY, aRadius, aStartAngle, aEndAngle, [aClockwise]) ⇒ [<code>Path</code>](#Path)
Adds an arc as an instance of [EllipseCurve](EllipseCurve) to the path, positioned relative
to the current point.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| aX | <code>number</code> |  | The x coordinate of the center of the arc offsetted from the previous curve. |
| aY | <code>number</code> |  | The y coordinate of the center of the arc offsetted from the previous curve. |
| aRadius | <code>number</code> |  | The radius of the arc. |
| aStartAngle | <code>number</code> |  | The start angle in radians. |
| aEndAngle | <code>number</code> |  | The end angle in radians. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether to sweep the arc clockwise or not. |

<a name="Path+absarc"></a>

### path.absarc(aX, aY, aRadius, aStartAngle, aEndAngle, [aClockwise]) ⇒ [<code>Path</code>](#Path)
Adds an absolutely positioned arc as an instance of [EllipseCurve](EllipseCurve) to the path.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| aX | <code>number</code> |  | The x coordinate of the center of the arc. |
| aY | <code>number</code> |  | The y coordinate of the center of the arc. |
| aRadius | <code>number</code> |  | The radius of the arc. |
| aStartAngle | <code>number</code> |  | The start angle in radians. |
| aEndAngle | <code>number</code> |  | The end angle in radians. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether to sweep the arc clockwise or not. |

<a name="Path+ellipse"></a>

### path.ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, [aClockwise], [aRotation]) ⇒ [<code>Path</code>](#Path)
Adds an ellipse as an instance of [EllipseCurve](EllipseCurve) to the path, positioned relative
to the current point

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| aX | <code>number</code> |  | The x coordinate of the center of the ellipse offsetted from the previous curve. |
| aY | <code>number</code> |  | The y coordinate of the center of the ellipse offsetted from the previous curve. |
| xRadius | <code>number</code> |  | The radius of the ellipse in the x axis. |
| yRadius | <code>number</code> |  | The radius of the ellipse in the y axis. |
| aStartAngle | <code>number</code> |  | The start angle in radians. |
| aEndAngle | <code>number</code> |  | The end angle in radians. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether to sweep the ellipse clockwise or not. |
| [aRotation] | <code>number</code> | <code>0</code> | The rotation angle of the ellipse in radians, counterclockwise from the positive X axis. |

<a name="Path+absellipse"></a>

### path.absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, [aClockwise], [aRotation]) ⇒ [<code>Path</code>](#Path)
Adds an absolutely positioned ellipse as an instance of [EllipseCurve](EllipseCurve) to the path.

**Kind**: instance method of [<code>Path</code>](#Path)  
**Returns**: [<code>Path</code>](#Path) - A reference to this path.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| aX | <code>number</code> |  | The x coordinate of the absolute center of the ellipse. |
| aY | <code>number</code> |  | The y coordinate of the absolute center of the ellipse. |
| xRadius | <code>number</code> |  | The radius of the ellipse in the x axis. |
| yRadius | <code>number</code> |  | The radius of the ellipse in the y axis. |
| aStartAngle | <code>number</code> |  | The start angle in radians. |
| aEndAngle | <code>number</code> |  | The end angle in radians. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether to sweep the ellipse clockwise or not. |
| [aRotation] | <code>number</code> | <code>0</code> | The rotation angle of the ellipse in radians, counterclockwise from the positive X axis. |

<a name="Shape"></a>

## Shape ⇐ <code>Path</code>
Defines an arbitrary 2d shape plane using paths with optional holes. It
can be used with [ExtrudeGeometry](ExtrudeGeometry), [ShapeGeometry](ShapeGeometry), to get
points, or to get triangulated faces.

```js
const heartShape = new THREE.Shape();

heartShape.moveTo( 25, 25 );
heartShape.bezierCurveTo( 25, 25, 20, 0, 0, 0 );
heartShape.bezierCurveTo( - 30, 0, - 30, 35, - 30, 35 );
heartShape.bezierCurveTo( - 30, 55, - 10, 77, 25, 95 );
heartShape.bezierCurveTo( 60, 77, 80, 55, 80, 35 );
heartShape.bezierCurveTo( 80, 35, 80, 0, 50, 0 );
heartShape.bezierCurveTo( 35, 0, 25, 25, 25, 25 );

const extrudeSettings = {
	depth: 8,
	bevelEnabled: true,
	bevelSegments: 2,
	steps: 2,
	bevelSize: 1,
	bevelThickness: 1
};

const geometry = new THREE.ExtrudeGeometry( heartShape, extrudeSettings );
const mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial() );
```

**Kind**: global class  
**Extends**: <code>Path</code>  

* [Shape](#Shape) ⇐ <code>Path</code>
    * [new Shape([points])](#new_Shape_new)
    * [.uuid](#Shape+uuid) : <code>string</code>
    * [.holes](#Shape+holes) : <code>Array.&lt;Path&gt;</code>
    * [.getPointsHoles(divisions)](#Shape+getPointsHoles) ⇒ <code>Array.&lt;Array.&lt;Vector2&gt;&gt;</code>
    * [.extractPoints(divisions)](#Shape+extractPoints) ⇒ <code>Object</code>

<a name="new_Shape_new"></a>

### new Shape([points])
Constructs a new shape.


| Param | Type | Description |
| --- | --- | --- |
| [points] | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points defining the shape. |

<a name="Shape+uuid"></a>

### shape.uuid : <code>string</code>
The UUID of the shape.

**Kind**: instance property of [<code>Shape</code>](#Shape)  
**Read only**: true  
<a name="Shape+holes"></a>

### shape.holes : <code>Array.&lt;Path&gt;</code>
Defines the holes in the shape. Hole definitions must use the
opposite winding order (CW/CCW) than the outer shape.

**Kind**: instance property of [<code>Shape</code>](#Shape)  
**Read only**: true  
<a name="Shape+getPointsHoles"></a>

### shape.getPointsHoles(divisions) ⇒ <code>Array.&lt;Array.&lt;Vector2&gt;&gt;</code>
Returns an array representing each contour of the holes
as a list of 2D points.

**Kind**: instance method of [<code>Shape</code>](#Shape)  
**Returns**: <code>Array.&lt;Array.&lt;Vector2&gt;&gt;</code> - The holes as a series of 2D points.  

| Param | Type | Description |
| --- | --- | --- |
| divisions | <code>number</code> | The fineness of the result. |

<a name="Shape+extractPoints"></a>

### shape.extractPoints(divisions) ⇒ <code>Object</code>
Returns an object that holds contour data for the shape and its holes as
arrays of 2D points.

**Kind**: instance method of [<code>Shape</code>](#Shape)  
**Returns**: <code>Object</code> - An object with contour data.  

| Param | Type | Description |
| --- | --- | --- |
| divisions | <code>number</code> | The fineness of the result. |

<a name="ShapePath"></a>

## ShapePath
This class is used to convert a series of paths to an array of
shapes. It is specifically used in context of fonts and SVG.

**Kind**: global class  

* [ShapePath](#ShapePath)
    * [new ShapePath()](#new_ShapePath_new)
    * [.color](#ShapePath+color) : <code>Color</code>
    * [.subPaths](#ShapePath+subPaths) : <code>Array.&lt;Path&gt;</code>
    * [.currentPath](#ShapePath+currentPath) : <code>Path</code>
    * [.moveTo(x, y)](#ShapePath+moveTo) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.lineTo(x, y)](#ShapePath+lineTo) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.quadraticCurveTo(aCPx, aCPy, aX, aY)](#ShapePath+quadraticCurveTo) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY)](#ShapePath+bezierCurveTo) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.splineThru(pts)](#ShapePath+splineThru) ⇒ [<code>ShapePath</code>](#ShapePath)
    * [.toShapes(isCCW)](#ShapePath+toShapes) ⇒ <code>Array.&lt;Shape&gt;</code>

<a name="new_ShapePath_new"></a>

### new ShapePath()
Constructs a new shape path.

<a name="ShapePath+color"></a>

### shapePath.color : <code>Color</code>
The color of the shape.

**Kind**: instance property of [<code>ShapePath</code>](#ShapePath)  
<a name="ShapePath+subPaths"></a>

### shapePath.subPaths : <code>Array.&lt;Path&gt;</code>
The paths that have been generated for this shape.

**Kind**: instance property of [<code>ShapePath</code>](#ShapePath)  
**Default**: <code>null</code>  
<a name="ShapePath+currentPath"></a>

### shapePath.currentPath : <code>Path</code>
The current path that is being generated.

**Kind**: instance property of [<code>ShapePath</code>](#ShapePath)  
**Default**: <code>null</code>  
<a name="ShapePath+moveTo"></a>

### shapePath.moveTo(x, y) ⇒ [<code>ShapePath</code>](#ShapePath)
Creates a new path and moves it current point to the given one.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate. |
| y | <code>number</code> | The y coordinate. |

<a name="ShapePath+lineTo"></a>

### shapePath.lineTo(x, y) ⇒ [<code>ShapePath</code>](#ShapePath)
Adds an instance of [LineCurve](LineCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate of the end point. |
| y | <code>number</code> | The y coordinate of the end point. |

<a name="ShapePath+quadraticCurveTo"></a>

### shapePath.quadraticCurveTo(aCPx, aCPy, aX, aY) ⇒ [<code>ShapePath</code>](#ShapePath)
Adds an instance of [QuadraticBezierCurve](QuadraticBezierCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| aCPx | <code>number</code> | The x coordinate of the control point. |
| aCPy | <code>number</code> | The y coordinate of the control point. |
| aX | <code>number</code> | The x coordinate of the end point. |
| aY | <code>number</code> | The y coordinate of the end point. |

<a name="ShapePath+bezierCurveTo"></a>

### shapePath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) ⇒ [<code>ShapePath</code>](#ShapePath)
Adds an instance of [CubicBezierCurve](CubicBezierCurve) to the path by connecting
the current point with the given one.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| aCP1x | <code>number</code> | The x coordinate of the first control point. |
| aCP1y | <code>number</code> | The y coordinate of the first control point. |
| aCP2x | <code>number</code> | The x coordinate of the second control point. |
| aCP2y | <code>number</code> | The y coordinate of the second control point. |
| aX | <code>number</code> | The x coordinate of the end point. |
| aY | <code>number</code> | The y coordinate of the end point. |

<a name="ShapePath+splineThru"></a>

### shapePath.splineThru(pts) ⇒ [<code>ShapePath</code>](#ShapePath)
Adds an instance of [SplineCurve](SplineCurve) to the path by connecting
the current point with the given list of points.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: [<code>ShapePath</code>](#ShapePath) - A reference to this shape path.  

| Param | Type | Description |
| --- | --- | --- |
| pts | <code>Array.&lt;Vector2&gt;</code> | An array of points in 2D space. |

<a name="ShapePath+toShapes"></a>

### shapePath.toShapes(isCCW) ⇒ <code>Array.&lt;Shape&gt;</code>
Converts the paths into an array of shapes.

**Kind**: instance method of [<code>ShapePath</code>](#ShapePath)  
**Returns**: <code>Array.&lt;Shape&gt;</code> - An array of shapes.  

| Param | Type | Description |
| --- | --- | --- |
| isCCW | <code>boolean</code> | By default solid shapes are  defined clockwise (CW) and holes are defined counterclockwise (CCW). If this flag is set to `true`, then those are flipped. |

<a name="ArcCurve"></a>

## ArcCurve ⇐ <code>EllipseCurve</code>
A curve representing an arc.

**Kind**: global class  
**Extends**: <code>EllipseCurve</code>  

* [ArcCurve](#ArcCurve) ⇐ <code>EllipseCurve</code>
    * [new ArcCurve([aX], [aY], [aRadius], [aStartAngle], [aEndAngle], [aClockwise])](#new_ArcCurve_new)
    * [.isArcCurve](#ArcCurve+isArcCurve) : <code>boolean</code>

<a name="new_ArcCurve_new"></a>

### new ArcCurve([aX], [aY], [aRadius], [aStartAngle], [aEndAngle], [aClockwise])
Constructs a new arc curve.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [aX] | <code>number</code> | <code>0</code> | The X center of the ellipse. |
| [aY] | <code>number</code> | <code>0</code> | The Y center of the ellipse. |
| [aRadius] | <code>number</code> | <code>1</code> | The radius of the ellipse in the x direction. |
| [aStartAngle] | <code>number</code> | <code>0</code> | The start angle of the curve in radians starting from the positive X axis. |
| [aEndAngle] | <code>number</code> | <code>Math.PI*2</code> | The end angle of the curve in radians starting from the positive X axis. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether the ellipse is drawn clockwise or not. |

<a name="ArcCurve+isArcCurve"></a>

### arcCurve.isArcCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ArcCurve</code>](#ArcCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CatmullRomCurve3"></a>

## CatmullRomCurve3 ⇐ <code>Curve</code>
A curve representing a Catmull-Rom spline.

```js
//Create a closed wavey loop
const curve = new THREE.CatmullRomCurve3( [
	new THREE.Vector3( -10, 0, 10 ),
	new THREE.Vector3( -5, 5, 5 ),
	new THREE.Vector3( 0, 0, 0 ),
	new THREE.Vector3( 5, -5, 5 ),
	new THREE.Vector3( 10, 0, 10 )
] );

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const curveObject = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [CatmullRomCurve3](#CatmullRomCurve3) ⇐ <code>Curve</code>
    * [new CatmullRomCurve3([points], [closed], [curveType], [tension])](#new_CatmullRomCurve3_new)
    * [.isCatmullRomCurve3](#CatmullRomCurve3+isCatmullRomCurve3) : <code>boolean</code>
    * [.points](#CatmullRomCurve3+points) : <code>Array.&lt;Vector3&gt;</code>
    * [.closed](#CatmullRomCurve3+closed) : <code>boolean</code>
    * [.curveType](#CatmullRomCurve3+curveType) : <code>&#x27;centripetal&#x27;</code> \| <code>&#x27;chordal&#x27;</code> \| <code>&#x27;catmullrom&#x27;</code>
    * [.tension](#CatmullRomCurve3+tension) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#CatmullRomCurve3+getPoint) ⇒ <code>Vector3</code>

<a name="new_CatmullRomCurve3_new"></a>

### new CatmullRomCurve3([points], [closed], [curveType], [tension])
Constructs a new Catmull-Rom curve.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [points] | <code>Array.&lt;Vector3&gt;</code> |  | An array of 3D points defining the curve. |
| [closed] | <code>boolean</code> | <code>false</code> | Whether the curve is closed or not. |
| [curveType] | <code>&#x27;centripetal&#x27;</code> \| <code>&#x27;chordal&#x27;</code> \| <code>&#x27;catmullrom&#x27;</code> | <code>&#x27;centripetal&#x27;</code> | The curve type. |
| [tension] | <code>number</code> | <code>0.5</code> | Tension of the curve. |

<a name="CatmullRomCurve3+isCatmullRomCurve3"></a>

### catmullRomCurve3.isCatmullRomCurve3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CatmullRomCurve3+points"></a>

### catmullRomCurve3.points : <code>Array.&lt;Vector3&gt;</code>
An array of 3D points defining the curve.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
<a name="CatmullRomCurve3+closed"></a>

### catmullRomCurve3.closed : <code>boolean</code>
Whether the curve is closed or not.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Default**: <code>false</code>  
<a name="CatmullRomCurve3+curveType"></a>

### catmullRomCurve3.curveType : <code>&#x27;centripetal&#x27;</code> \| <code>&#x27;chordal&#x27;</code> \| <code>&#x27;catmullrom&#x27;</code>
The curve type.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Default**: <code>&#x27;centripetal&#x27;</code>  
<a name="CatmullRomCurve3+tension"></a>

### catmullRomCurve3.tension : <code>number</code>
Tension of the curve.

**Kind**: instance property of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Default**: <code>0.5</code>  
<a name="CatmullRomCurve3+getPoint"></a>

### catmullRomCurve3.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
Returns a point on the curve.

**Kind**: instance method of [<code>CatmullRomCurve3</code>](#CatmullRomCurve3)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="CubicBezierCurve"></a>

## CubicBezierCurve ⇐ <code>Curve</code>
A curve representing a 2D Cubic Bezier curve.

```js
const curve = new THREE.CubicBezierCurve(
	new THREE.Vector2( - 0, 0 ),
	new THREE.Vector2( - 5, 15 ),
	new THREE.Vector2( 20, 15 ),
	new THREE.Vector2( 10, 0 )
);

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const curveObject = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [CubicBezierCurve](#CubicBezierCurve) ⇐ <code>Curve</code>
    * [new CubicBezierCurve([v0], [v1], [v2], [v3])](#new_CubicBezierCurve_new)
    * [.isCubicBezierCurve](#CubicBezierCurve+isCubicBezierCurve) : <code>boolean</code>
    * [.v0](#CubicBezierCurve+v0) : <code>Vector2</code>
    * [.v1](#CubicBezierCurve+v1) : <code>Vector2</code>
    * [.v2](#CubicBezierCurve+v2) : <code>Vector2</code>
    * [.v3](#CubicBezierCurve+v3) : <code>Vector2</code>
    * [.getPoint(t, [optionalTarget])](#CubicBezierCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_CubicBezierCurve_new"></a>

### new CubicBezierCurve([v0], [v1], [v2], [v3])
Constructs a new Cubic Bezier curve.


| Param | Type | Description |
| --- | --- | --- |
| [v0] | <code>Vector2</code> | The start point. |
| [v1] | <code>Vector2</code> | The first control point. |
| [v2] | <code>Vector2</code> | The second control point. |
| [v3] | <code>Vector2</code> | The end point. |

<a name="CubicBezierCurve+isCubicBezierCurve"></a>

### cubicBezierCurve.isCubicBezierCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubicBezierCurve+v0"></a>

### cubicBezierCurve.v0 : <code>Vector2</code>
The start point.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
<a name="CubicBezierCurve+v1"></a>

### cubicBezierCurve.v1 : <code>Vector2</code>
The first control point.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
<a name="CubicBezierCurve+v2"></a>

### cubicBezierCurve.v2 : <code>Vector2</code>
The second control point.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
<a name="CubicBezierCurve+v3"></a>

### cubicBezierCurve.v3 : <code>Vector2</code>
The end point.

**Kind**: instance property of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
<a name="CubicBezierCurve+getPoint"></a>

### cubicBezierCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the curve.

**Kind**: instance method of [<code>CubicBezierCurve</code>](#CubicBezierCurve)  
**Returns**: <code>Vector2</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="CubicBezierCurve3"></a>

## CubicBezierCurve3 ⇐ <code>Curve</code>
A curve representing a 3D Cubic Bezier curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [CubicBezierCurve3](#CubicBezierCurve3) ⇐ <code>Curve</code>
    * [new CubicBezierCurve3([v0], [v1], [v2], [v3])](#new_CubicBezierCurve3_new)
    * [.isCubicBezierCurve3](#CubicBezierCurve3+isCubicBezierCurve3) : <code>boolean</code>
    * [.v0](#CubicBezierCurve3+v0) : <code>Vector3</code>
    * [.v1](#CubicBezierCurve3+v1) : <code>Vector3</code>
    * [.v2](#CubicBezierCurve3+v2) : <code>Vector3</code>
    * [.v3](#CubicBezierCurve3+v3) : <code>Vector3</code>
    * [.getPoint(t, [optionalTarget])](#CubicBezierCurve3+getPoint) ⇒ <code>Vector3</code>

<a name="new_CubicBezierCurve3_new"></a>

### new CubicBezierCurve3([v0], [v1], [v2], [v3])
Constructs a new Cubic Bezier curve.


| Param | Type | Description |
| --- | --- | --- |
| [v0] | <code>Vector3</code> | The start point. |
| [v1] | <code>Vector3</code> | The first control point. |
| [v2] | <code>Vector3</code> | The second control point. |
| [v3] | <code>Vector3</code> | The end point. |

<a name="CubicBezierCurve3+isCubicBezierCurve3"></a>

### cubicBezierCurve3.isCubicBezierCurve3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubicBezierCurve3+v0"></a>

### cubicBezierCurve3.v0 : <code>Vector3</code>
The start point.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
<a name="CubicBezierCurve3+v1"></a>

### cubicBezierCurve3.v1 : <code>Vector3</code>
The first control point.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
<a name="CubicBezierCurve3+v2"></a>

### cubicBezierCurve3.v2 : <code>Vector3</code>
The second control point.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
<a name="CubicBezierCurve3+v3"></a>

### cubicBezierCurve3.v3 : <code>Vector3</code>
The end point.

**Kind**: instance property of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
<a name="CubicBezierCurve3+getPoint"></a>

### cubicBezierCurve3.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
Returns a point on the curve.

**Kind**: instance method of [<code>CubicBezierCurve3</code>](#CubicBezierCurve3)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="EllipseCurve"></a>

## EllipseCurve ⇐ <code>Curve</code>
A curve representing an ellipse.

```js
const curve = new THREE.EllipseCurve(
	0, 0,
	10, 10,
	0, 2 * Math.PI,
	false,
	0
);

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const ellipse = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [EllipseCurve](#EllipseCurve) ⇐ <code>Curve</code>
    * [new EllipseCurve([aX], [aY], [xRadius], [yRadius], [aStartAngle], [aEndAngle], [aClockwise], [aRotation])](#new_EllipseCurve_new)
    * [.isEllipseCurve](#EllipseCurve+isEllipseCurve) : <code>boolean</code>
    * [.aX](#EllipseCurve+aX) : <code>number</code>
    * [.aY](#EllipseCurve+aY) : <code>number</code>
    * [.xRadius](#EllipseCurve+xRadius) : <code>number</code>
    * [.yRadius](#EllipseCurve+yRadius) : <code>number</code>
    * [.aStartAngle](#EllipseCurve+aStartAngle) : <code>number</code>
    * [.aEndAngle](#EllipseCurve+aEndAngle) : <code>number</code>
    * [.aClockwise](#EllipseCurve+aClockwise) : <code>boolean</code>
    * [.aRotation](#EllipseCurve+aRotation) : <code>number</code>
    * [.getPoint(t, [optionalTarget])](#EllipseCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_EllipseCurve_new"></a>

### new EllipseCurve([aX], [aY], [xRadius], [yRadius], [aStartAngle], [aEndAngle], [aClockwise], [aRotation])
Constructs a new ellipse curve.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [aX] | <code>number</code> | <code>0</code> | The X center of the ellipse. |
| [aY] | <code>number</code> | <code>0</code> | The Y center of the ellipse. |
| [xRadius] | <code>number</code> | <code>1</code> | The radius of the ellipse in the x direction. |
| [yRadius] | <code>number</code> | <code>1</code> | The radius of the ellipse in the y direction. |
| [aStartAngle] | <code>number</code> | <code>0</code> | The start angle of the curve in radians starting from the positive X axis. |
| [aEndAngle] | <code>number</code> | <code>Math.PI*2</code> | The end angle of the curve in radians starting from the positive X axis. |
| [aClockwise] | <code>boolean</code> | <code>false</code> | Whether the ellipse is drawn clockwise or not. |
| [aRotation] | <code>number</code> | <code>0</code> | The rotation angle of the ellipse in radians, counterclockwise from the positive X axis. |

<a name="EllipseCurve+isEllipseCurve"></a>

### ellipseCurve.isEllipseCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="EllipseCurve+aX"></a>

### ellipseCurve.aX : <code>number</code>
The X center of the ellipse.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>0</code>  
<a name="EllipseCurve+aY"></a>

### ellipseCurve.aY : <code>number</code>
The Y center of the ellipse.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>0</code>  
<a name="EllipseCurve+xRadius"></a>

### ellipseCurve.xRadius : <code>number</code>
The radius of the ellipse in the x direction.
Setting the this value equal to the [yRadius](#EllipseCurve+yRadius) will result in a circle.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>1</code>  
<a name="EllipseCurve+yRadius"></a>

### ellipseCurve.yRadius : <code>number</code>
The radius of the ellipse in the y direction.
Setting the this value equal to the [xRadius](#EllipseCurve+xRadius) will result in a circle.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>1</code>  
<a name="EllipseCurve+aStartAngle"></a>

### ellipseCurve.aStartAngle : <code>number</code>
The start angle of the curve in radians starting from the positive X axis.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>0</code>  
<a name="EllipseCurve+aEndAngle"></a>

### ellipseCurve.aEndAngle : <code>number</code>
The end angle of the curve in radians starting from the positive X axis.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>Math.PI*2</code>  
<a name="EllipseCurve+aClockwise"></a>

### ellipseCurve.aClockwise : <code>boolean</code>
Whether the ellipse is drawn clockwise or not.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>false</code>  
<a name="EllipseCurve+aRotation"></a>

### ellipseCurve.aRotation : <code>number</code>
The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.

**Kind**: instance property of [<code>EllipseCurve</code>](#EllipseCurve)  
**Default**: <code>0</code>  
<a name="EllipseCurve+getPoint"></a>

### ellipseCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the curve.

**Kind**: instance method of [<code>EllipseCurve</code>](#EllipseCurve)  
**Returns**: <code>Vector2</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="LineCurve"></a>

## LineCurve ⇐ <code>Curve</code>
A curve representing a 2D line segment.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [LineCurve](#LineCurve) ⇐ <code>Curve</code>
    * [new LineCurve([v1], [v2])](#new_LineCurve_new)
    * [.isLineCurve](#LineCurve+isLineCurve) : <code>boolean</code>
    * [.v1](#LineCurve+v1) : <code>Vector2</code>
    * [.v2](#LineCurve+v2) : <code>Vector2</code>
    * [.getPoint(t, [optionalTarget])](#LineCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_LineCurve_new"></a>

### new LineCurve([v1], [v2])
Constructs a new line curve.


| Param | Type | Description |
| --- | --- | --- |
| [v1] | <code>Vector2</code> | The start point. |
| [v2] | <code>Vector2</code> | The end point. |

<a name="LineCurve+isLineCurve"></a>

### lineCurve.isLineCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineCurve</code>](#LineCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineCurve+v1"></a>

### lineCurve.v1 : <code>Vector2</code>
The start point.

**Kind**: instance property of [<code>LineCurve</code>](#LineCurve)  
<a name="LineCurve+v2"></a>

### lineCurve.v2 : <code>Vector2</code>
The end point.

**Kind**: instance property of [<code>LineCurve</code>](#LineCurve)  
<a name="LineCurve+getPoint"></a>

### lineCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the line.

**Kind**: instance method of [<code>LineCurve</code>](#LineCurve)  
**Returns**: <code>Vector2</code> - The position on the line.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the line. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="LineCurve3"></a>

## LineCurve3 ⇐ <code>Curve</code>
A curve representing a 3D line segment.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [LineCurve3](#LineCurve3) ⇐ <code>Curve</code>
    * [new LineCurve3([v1], [v2])](#new_LineCurve3_new)
    * [.isLineCurve3](#LineCurve3+isLineCurve3) : <code>boolean</code>
    * [.v1](#LineCurve3+v1) : <code>Vector3</code>
    * [.v2](#LineCurve3+v2) : <code>Vector2</code>
    * [.getPoint(t, [optionalTarget])](#LineCurve3+getPoint) ⇒ <code>Vector3</code>

<a name="new_LineCurve3_new"></a>

### new LineCurve3([v1], [v2])
Constructs a new line curve.


| Param | Type | Description |
| --- | --- | --- |
| [v1] | <code>Vector3</code> | The start point. |
| [v2] | <code>Vector3</code> | The end point. |

<a name="LineCurve3+isLineCurve3"></a>

### lineCurve3.isLineCurve3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineCurve3</code>](#LineCurve3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineCurve3+v1"></a>

### lineCurve3.v1 : <code>Vector3</code>
The start point.

**Kind**: instance property of [<code>LineCurve3</code>](#LineCurve3)  
<a name="LineCurve3+v2"></a>

### lineCurve3.v2 : <code>Vector2</code>
The end point.

**Kind**: instance property of [<code>LineCurve3</code>](#LineCurve3)  
<a name="LineCurve3+getPoint"></a>

### lineCurve3.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
Returns a point on the line.

**Kind**: instance method of [<code>LineCurve3</code>](#LineCurve3)  
**Returns**: <code>Vector3</code> - The position on the line.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the line. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="QuadraticBezierCurve"></a>

## QuadraticBezierCurve ⇐ <code>Curve</code>
A curve representing a 2D Quadratic Bezier curve.

```js
const curve = new THREE.QuadraticBezierCurve(
	new THREE.Vector2( - 10, 0 ),
	new THREE.Vector2( 20, 15 ),
	new THREE.Vector2( 10, 0 )
)

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const curveObject = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [QuadraticBezierCurve](#QuadraticBezierCurve) ⇐ <code>Curve</code>
    * [new QuadraticBezierCurve([v0], [v1], [v2])](#new_QuadraticBezierCurve_new)
    * [.isQuadraticBezierCurve](#QuadraticBezierCurve+isQuadraticBezierCurve) : <code>boolean</code>
    * [.v0](#QuadraticBezierCurve+v0) : <code>Vector2</code>
    * [.v1](#QuadraticBezierCurve+v1) : <code>Vector2</code>
    * [.v2](#QuadraticBezierCurve+v2) : <code>Vector2</code>
    * [.getPoint(t, [optionalTarget])](#QuadraticBezierCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_QuadraticBezierCurve_new"></a>

### new QuadraticBezierCurve([v0], [v1], [v2])
Constructs a new Quadratic Bezier curve.


| Param | Type | Description |
| --- | --- | --- |
| [v0] | <code>Vector2</code> | The start point. |
| [v1] | <code>Vector2</code> | The control point. |
| [v2] | <code>Vector2</code> | The end point. |

<a name="QuadraticBezierCurve+isQuadraticBezierCurve"></a>

### quadraticBezierCurve.isQuadraticBezierCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="QuadraticBezierCurve+v0"></a>

### quadraticBezierCurve.v0 : <code>Vector2</code>
The start point.

**Kind**: instance property of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
<a name="QuadraticBezierCurve+v1"></a>

### quadraticBezierCurve.v1 : <code>Vector2</code>
The control point.

**Kind**: instance property of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
<a name="QuadraticBezierCurve+v2"></a>

### quadraticBezierCurve.v2 : <code>Vector2</code>
The end point.

**Kind**: instance property of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
<a name="QuadraticBezierCurve+getPoint"></a>

### quadraticBezierCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the curve.

**Kind**: instance method of [<code>QuadraticBezierCurve</code>](#QuadraticBezierCurve)  
**Returns**: <code>Vector2</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="QuadraticBezierCurve3"></a>

## QuadraticBezierCurve3 ⇐ <code>Curve</code>
A curve representing a 3D Quadratic Bezier curve.

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [QuadraticBezierCurve3](#QuadraticBezierCurve3) ⇐ <code>Curve</code>
    * [new QuadraticBezierCurve3([v0], [v1], [v2])](#new_QuadraticBezierCurve3_new)
    * [.isQuadraticBezierCurve3](#QuadraticBezierCurve3+isQuadraticBezierCurve3) : <code>boolean</code>
    * [.v0](#QuadraticBezierCurve3+v0) : <code>Vector3</code>
    * [.v1](#QuadraticBezierCurve3+v1) : <code>Vector3</code>
    * [.v2](#QuadraticBezierCurve3+v2) : <code>Vector3</code>
    * [.getPoint(t, [optionalTarget])](#QuadraticBezierCurve3+getPoint) ⇒ <code>Vector3</code>

<a name="new_QuadraticBezierCurve3_new"></a>

### new QuadraticBezierCurve3([v0], [v1], [v2])
Constructs a new Quadratic Bezier curve.


| Param | Type | Description |
| --- | --- | --- |
| [v0] | <code>Vector3</code> | The start point. |
| [v1] | <code>Vector3</code> | The control point. |
| [v2] | <code>Vector3</code> | The end point. |

<a name="QuadraticBezierCurve3+isQuadraticBezierCurve3"></a>

### quadraticBezierCurve3.isQuadraticBezierCurve3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="QuadraticBezierCurve3+v0"></a>

### quadraticBezierCurve3.v0 : <code>Vector3</code>
The start point.

**Kind**: instance property of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
<a name="QuadraticBezierCurve3+v1"></a>

### quadraticBezierCurve3.v1 : <code>Vector3</code>
The control point.

**Kind**: instance property of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
<a name="QuadraticBezierCurve3+v2"></a>

### quadraticBezierCurve3.v2 : <code>Vector3</code>
The end point.

**Kind**: instance property of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
<a name="QuadraticBezierCurve3+getPoint"></a>

### quadraticBezierCurve3.getPoint(t, [optionalTarget]) ⇒ <code>Vector3</code>
Returns a point on the curve.

**Kind**: instance method of [<code>QuadraticBezierCurve3</code>](#QuadraticBezierCurve3)  
**Returns**: <code>Vector3</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector3</code> | The optional target vector the result is written to. |

<a name="SplineCurve"></a>

## SplineCurve ⇐ <code>Curve</code>
A curve representing a 2D spline curve.

```js
// Create a sine-like wave
const curve = new THREE.SplineCurve( [
	new THREE.Vector2( -10, 0 ),
	new THREE.Vector2( -5, 5 ),
	new THREE.Vector2( 0, 0 ),
	new THREE.Vector2( 5, -5 ),
	new THREE.Vector2( 10, 0 )
] );

const points = curve.getPoints( 50 );
const geometry = new THREE.BufferGeometry().setFromPoints( points );

const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// Create the final object to add to the scene
const splineObject = new THREE.Line( geometry, material );
```

**Kind**: global class  
**Extends**: <code>Curve</code>  

* [SplineCurve](#SplineCurve) ⇐ <code>Curve</code>
    * [new SplineCurve([points])](#new_SplineCurve_new)
    * [.isSplineCurve](#SplineCurve+isSplineCurve) : <code>boolean</code>
    * [.points](#SplineCurve+points) : <code>Array.&lt;Vector2&gt;</code>
    * [.getPoint(t, [optionalTarget])](#SplineCurve+getPoint) ⇒ <code>Vector2</code>

<a name="new_SplineCurve_new"></a>

### new SplineCurve([points])
Constructs a new 2D spline curve.


| Param | Type | Description |
| --- | --- | --- |
| [points] | <code>Array.&lt;Vector2&gt;</code> | An array of 2D points defining the curve. |

<a name="SplineCurve+isSplineCurve"></a>

### splineCurve.isSplineCurve : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SplineCurve</code>](#SplineCurve)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SplineCurve+points"></a>

### splineCurve.points : <code>Array.&lt;Vector2&gt;</code>
An array of 2D points defining the curve.

**Kind**: instance property of [<code>SplineCurve</code>](#SplineCurve)  
<a name="SplineCurve+getPoint"></a>

### splineCurve.getPoint(t, [optionalTarget]) ⇒ <code>Vector2</code>
Returns a point on the curve.

**Kind**: instance method of [<code>SplineCurve</code>](#SplineCurve)  
**Returns**: <code>Vector2</code> - The position on the curve.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A interpolation factor representing a position on the curve. Must be in the range `[0,1]`. |
| [optionalTarget] | <code>Vector2</code> | The optional target vector the result is written to. |

<a name="BoxGeometry"></a>

## BoxGeometry ⇐ <code>BufferGeometry</code>
A geometry class for a rectangular cuboid with a given width, height, and depth.
On creation, the cuboid is centred on the origin, with each edge parallel to one
of the axes.

```js
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const cube = new THREE.Mesh( geometry, material );
scene.add( cube );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [BoxGeometry](#BoxGeometry) ⇐ <code>BufferGeometry</code>
    * [new BoxGeometry([width], [height], [depth], [widthSegments], [heightSegments], [depthSegments])](#new_BoxGeometry_new)
    * _instance_
        * [.parameters](#BoxGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#BoxGeometry.fromJSON) ⇒ [<code>BoxGeometry</code>](#BoxGeometry)

<a name="new_BoxGeometry_new"></a>

### new BoxGeometry([width], [height], [depth], [widthSegments], [heightSegments], [depthSegments])
Constructs a new box geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width. That is, the length of the edges parallel to the X axis. |
| [height] | <code>number</code> | <code>1</code> | The height. That is, the length of the edges parallel to the Y axis. |
| [depth] | <code>number</code> | <code>1</code> | The depth. That is, the length of the edges parallel to the Z axis. |
| [widthSegments] | <code>number</code> | <code>1</code> | Number of segmented rectangular faces along the width of the sides. |
| [heightSegments] | <code>number</code> | <code>1</code> | Number of segmented rectangular faces along the height of the sides. |
| [depthSegments] | <code>number</code> | <code>1</code> | Number of segmented rectangular faces along the depth of the sides. |

<a name="BoxGeometry+parameters"></a>

### boxGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>BoxGeometry</code>](#BoxGeometry)  
<a name="BoxGeometry.fromJSON"></a>

### BoxGeometry.fromJSON(data) ⇒ [<code>BoxGeometry</code>](#BoxGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>BoxGeometry</code>](#BoxGeometry)  
**Returns**: [<code>BoxGeometry</code>](#BoxGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="CapsuleGeometry"></a>

## CapsuleGeometry ⇐ <code>LatheGeometry</code>
A geometry class for a capsule with given radii and height. It is constructed using a lathe.

```js
const geometry = new THREE.CapsuleGeometry( 1, 1, 4, 8 );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const capsule = new THREE.Mesh( geometry, material );
scene.add( capsule );
```

**Kind**: global class  
**Extends**: <code>LatheGeometry</code>  

* [CapsuleGeometry](#CapsuleGeometry) ⇐ <code>LatheGeometry</code>
    * [new CapsuleGeometry([radius], [length], [capSegments], [radialSegments])](#new_CapsuleGeometry_new)
    * _instance_
        * [.parameters](#CapsuleGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#CapsuleGeometry.fromJSON) ⇒ [<code>CapsuleGeometry</code>](#CapsuleGeometry)

<a name="new_CapsuleGeometry_new"></a>

### new CapsuleGeometry([radius], [length], [capSegments], [radialSegments])
Constructs a new capsule geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the capsule. |
| [length] | <code>number</code> | <code>1</code> | Length of the middle section. |
| [capSegments] | <code>number</code> | <code>4</code> | Number of curve segments used to build the caps. |
| [radialSegments] | <code>number</code> | <code>8</code> | Number of segmented faces around the circumference of the capsule. |

<a name="CapsuleGeometry+parameters"></a>

### capsuleGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>CapsuleGeometry</code>](#CapsuleGeometry)  
<a name="CapsuleGeometry.fromJSON"></a>

### CapsuleGeometry.fromJSON(data) ⇒ [<code>CapsuleGeometry</code>](#CapsuleGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>CapsuleGeometry</code>](#CapsuleGeometry)  
**Returns**: [<code>CapsuleGeometry</code>](#CapsuleGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="CircleGeometry"></a>

## CircleGeometry ⇐ <code>BufferGeometry</code>
A simple shape of Euclidean geometry. It is constructed from a
number of triangular segments that are oriented around a central point and
extend as far out as a given radius. It is built counter-clockwise from a
start angle and a given central angle. It can also be used to create
regular polygons, where the number of segments determines the number of
sides.

```js
const geometry = new THREE.CircleGeometry( 5, 32 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const circle = new THREE.Mesh( geometry, material );
scene.add( circle )
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [CircleGeometry](#CircleGeometry) ⇐ <code>BufferGeometry</code>
    * [new CircleGeometry([radius], [segments], [thetaStart], [thetaLength])](#new_CircleGeometry_new)
    * _instance_
        * [.parameters](#CircleGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#CircleGeometry.fromJSON) ⇒ [<code>CircleGeometry</code>](#CircleGeometry)

<a name="new_CircleGeometry_new"></a>

### new CircleGeometry([radius], [segments], [thetaStart], [thetaLength])
Constructs a new circle geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the circle. |
| [segments] | <code>number</code> | <code>32</code> | Number of segments (triangles), minimum = `3`. |
| [thetaStart] | <code>number</code> | <code>0</code> | Start angle for first segment in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI*2</code> | The central angle, often called theta, of the circular sector in radians. The default value results in a complete circle. |

<a name="CircleGeometry+parameters"></a>

### circleGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>CircleGeometry</code>](#CircleGeometry)  
<a name="CircleGeometry.fromJSON"></a>

### CircleGeometry.fromJSON(data) ⇒ [<code>CircleGeometry</code>](#CircleGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>CircleGeometry</code>](#CircleGeometry)  
**Returns**: [<code>CircleGeometry</code>](#CircleGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="ConeGeometry"></a>

## ConeGeometry ⇐ <code>CylinderGeometry</code>
A geometry class for representing a cone.

```js
const geometry = new THREE.ConeGeometry( 5, 20, 32 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const cone = new THREE.Mesh(geometry, material );
scene.add( cone );
```

**Kind**: global class  
**Extends**: <code>CylinderGeometry</code>  

* [ConeGeometry](#ConeGeometry) ⇐ <code>CylinderGeometry</code>
    * [new ConeGeometry([radius], [height], [radialSegments], [heightSegments], [openEnded], [thetaStart], [thetaLength])](#new_ConeGeometry_new)
    * _instance_
        * [.parameters](#ConeGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#ConeGeometry.fromJSON) ⇒ [<code>ConeGeometry</code>](#ConeGeometry)

<a name="new_ConeGeometry_new"></a>

### new ConeGeometry([radius], [height], [radialSegments], [heightSegments], [openEnded], [thetaStart], [thetaLength])
Constructs a new cone geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the cone base. |
| [height] | <code>number</code> | <code>1</code> | Height of the cone. |
| [radialSegments] | <code>number</code> | <code>32</code> | Number of segmented faces around the circumference of the cone. |
| [heightSegments] | <code>number</code> | <code>1</code> | Number of rows of faces along the height of the cone. |
| [openEnded] | <code>boolean</code> | <code>false</code> | Whether the base of the cone is open or capped. |
| [thetaStart] | <code>number</code> | <code>0</code> | Start angle for first segment, in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI*2</code> | The central angle, often called theta, of the circular sector, in radians. The default value results in a complete cone. |

<a name="ConeGeometry+parameters"></a>

### coneGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>ConeGeometry</code>](#ConeGeometry)  
<a name="ConeGeometry.fromJSON"></a>

### ConeGeometry.fromJSON(data) ⇒ [<code>ConeGeometry</code>](#ConeGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>ConeGeometry</code>](#ConeGeometry)  
**Returns**: [<code>ConeGeometry</code>](#ConeGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="CylinderGeometry"></a>

## CylinderGeometry ⇐ <code>BufferGeometry</code>
A geometry class for representing a cylinder.

```js
const geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const cylinder = new THREE.Mesh( geometry, material );
scene.add( cylinder );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [CylinderGeometry](#CylinderGeometry) ⇐ <code>BufferGeometry</code>
    * [new CylinderGeometry([radiusTop], [radiusBottom], [height], [radialSegments], [heightSegments], [openEnded], [thetaStart], [thetaLength])](#new_CylinderGeometry_new)
    * _instance_
        * [.parameters](#CylinderGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#CylinderGeometry.fromJSON) ⇒ [<code>CylinderGeometry</code>](#CylinderGeometry)

<a name="new_CylinderGeometry_new"></a>

### new CylinderGeometry([radiusTop], [radiusBottom], [height], [radialSegments], [heightSegments], [openEnded], [thetaStart], [thetaLength])
Constructs a new cylinder geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radiusTop] | <code>number</code> | <code>1</code> | Radius of the cylinder at the top. |
| [radiusBottom] | <code>number</code> | <code>1</code> | Radius of the cylinder at the bottom. |
| [height] | <code>number</code> | <code>1</code> | Height of the cylinder. |
| [radialSegments] | <code>number</code> | <code>32</code> | Number of segmented faces around the circumference of the cylinder. |
| [heightSegments] | <code>number</code> | <code>1</code> | Number of rows of faces along the height of the cylinder. |
| [openEnded] | <code>boolean</code> | <code>false</code> | Whether the base of the cylinder is open or capped. |
| [thetaStart] | <code>number</code> | <code>0</code> | Start angle for first segment, in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI*2</code> | The central angle, often called theta, of the circular sector, in radians. The default value results in a complete cylinder. |

<a name="CylinderGeometry+parameters"></a>

### cylinderGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>CylinderGeometry</code>](#CylinderGeometry)  
<a name="CylinderGeometry.fromJSON"></a>

### CylinderGeometry.fromJSON(data) ⇒ [<code>CylinderGeometry</code>](#CylinderGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>CylinderGeometry</code>](#CylinderGeometry)  
**Returns**: [<code>CylinderGeometry</code>](#CylinderGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="DodecahedronGeometry"></a>

## DodecahedronGeometry ⇐ <code>PolyhedronGeometry</code>
A geometry class for representing a dodecahedron.

```js
const geometry = new THREE.DodecahedronGeometry();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const dodecahedron = new THREE.Mesh( geometry, material );
scene.add( dodecahedron );
```

**Kind**: global class  
**Extends**: <code>PolyhedronGeometry</code>  

* [DodecahedronGeometry](#DodecahedronGeometry) ⇐ <code>PolyhedronGeometry</code>
    * [new DodecahedronGeometry([radius], [detail])](#new_DodecahedronGeometry_new)
    * _instance_
        * [.parameters](#DodecahedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#DodecahedronGeometry.fromJSON) ⇒ [<code>DodecahedronGeometry</code>](#DodecahedronGeometry)

<a name="new_DodecahedronGeometry_new"></a>

### new DodecahedronGeometry([radius], [detail])
Constructs a new dodecahedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the dodecahedron. |
| [detail] | <code>number</code> | <code>0</code> | Setting this to a value greater than `0` adds vertices making it no longer a dodecahedron. |

<a name="DodecahedronGeometry+parameters"></a>

### dodecahedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>DodecahedronGeometry</code>](#DodecahedronGeometry)  
<a name="DodecahedronGeometry.fromJSON"></a>

### DodecahedronGeometry.fromJSON(data) ⇒ [<code>DodecahedronGeometry</code>](#DodecahedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>DodecahedronGeometry</code>](#DodecahedronGeometry)  
**Returns**: [<code>DodecahedronGeometry</code>](#DodecahedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="EdgesGeometry"></a>

## EdgesGeometry ⇐ <code>BufferGeometry</code>
Can be used as a helper object to view the edges of a geometry.

```js
const geometry = new THREE.BoxGeometry();
const edges = new THREE.EdgesGeometry( geometry );
const line = new THREE.LineSegments( edges );
scene.add( line );
```

Note: It is not yet possible to serialize/deserialize instances of this class.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [EdgesGeometry](#EdgesGeometry) ⇐ <code>BufferGeometry</code>
    * [new EdgesGeometry([geometry], [thresholdAngle])](#new_EdgesGeometry_new)
    * [.parameters](#EdgesGeometry+parameters) : <code>Object</code>

<a name="new_EdgesGeometry_new"></a>

### new EdgesGeometry([geometry], [thresholdAngle])
Constructs a new edges geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | <code></code> | The geometry. |
| [thresholdAngle] | <code>number</code> | <code>1</code> | An edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. |

<a name="EdgesGeometry+parameters"></a>

### edgesGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>EdgesGeometry</code>](#EdgesGeometry)  
<a name="ExtrudeGeometry"></a>

## ExtrudeGeometry ⇐ <code>BufferGeometry</code>
Creates extruded geometry from a path shape.

```js
const length = 12, width = 8;

const shape = new THREE.Shape();
shape.moveTo( 0,0 );
shape.lineTo( 0, width );
shape.lineTo( length, width );
shape.lineTo( length, 0 );
shape.lineTo( 0, 0 );

const geometry = new THREE.ExtrudeGeometry( shape );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const mesh = new THREE.Mesh( geometry, material ) ;
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [ExtrudeGeometry](#ExtrudeGeometry) ⇐ <code>BufferGeometry</code>
    * [new ExtrudeGeometry([shapes], [options])](#new_ExtrudeGeometry_new)
    * _instance_
        * [.parameters](#ExtrudeGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data, shapes)](#ExtrudeGeometry.fromJSON) ⇒ [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)
    * _inner_
        * [~Options](#ExtrudeGeometry..Options) : <code>Object</code>

<a name="new_ExtrudeGeometry_new"></a>

### new ExtrudeGeometry([shapes], [options])
Constructs a new extrude geometry.


| Param | Type | Description |
| --- | --- | --- |
| [shapes] | <code>Shape</code> \| <code>Array.&lt;Shape&gt;</code> | A shape or an array of shapes. |
| [options] | [<code>Options</code>](#ExtrudeGeometry..Options) | The extrude settings. |

<a name="ExtrudeGeometry+parameters"></a>

### extrudeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)  
<a name="ExtrudeGeometry.fromJSON"></a>

### ExtrudeGeometry.fromJSON(data, shapes) ⇒ [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)  
**Returns**: [<code>ExtrudeGeometry</code>](#ExtrudeGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |
| shapes | <code>Array.&lt;Shape&gt;</code> | An array of shapes. |

<a name="ExtrudeGeometry..Options"></a>

### ExtrudeGeometry~Options : <code>Object</code>
Represents the `options` type of the geometry's constructor.

**Kind**: inner typedef of [<code>ExtrudeGeometry</code>](#ExtrudeGeometry)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [curveSegments] | <code>number</code> | <code>12</code> | Number of points on the curves. |
| [steps] | <code>number</code> | <code>1</code> | Number of points used for subdividing segments along the depth of the extruded spline. |
| [depth] | <code>number</code> | <code>1</code> | Depth to extrude the shape. |
| [bevelEnabled] | <code>boolean</code> | <code>true</code> | Whether to beveling to the shape or not. |
| [bevelThickness] | <code>number</code> | <code>0.2</code> | How deep into the original shape the bevel goes. |
| [bevelSize] | <code>number</code> | <code>bevelThickness-0.1</code> | Distance from the shape outline that the bevel extends. |
| [bevelOffset] | <code>number</code> | <code>0</code> | Distance from the shape outline that the bevel starts. |
| [bevelSegments] | <code>number</code> | <code>3</code> | Number of bevel layers. |
| [extrudePath] | <code>Curve</code> | <code></code> | A 3D spline path along which the shape should be extruded. Bevels not supported for path extrusion. |
| [UVGenerator] | <code>Object</code> |  | An object that provides UV generator functions for custom UV generation. |

<a name="IcosahedronGeometry"></a>

## IcosahedronGeometry ⇐ <code>PolyhedronGeometry</code>
A geometry class for representing an icosahedron.

```js
const geometry = new THREE.IcosahedronGeometry();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const icosahedron = new THREE.Mesh( geometry, material );
scene.add( icosahedron );
```

**Kind**: global class  
**Extends**: <code>PolyhedronGeometry</code>  

* [IcosahedronGeometry](#IcosahedronGeometry) ⇐ <code>PolyhedronGeometry</code>
    * [new IcosahedronGeometry([radius], [detail])](#new_IcosahedronGeometry_new)
    * _instance_
        * [.parameters](#IcosahedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#IcosahedronGeometry.fromJSON) ⇒ [<code>IcosahedronGeometry</code>](#IcosahedronGeometry)

<a name="new_IcosahedronGeometry_new"></a>

### new IcosahedronGeometry([radius], [detail])
Constructs a new icosahedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the icosahedron. |
| [detail] | <code>number</code> | <code>0</code> | Setting this to a value greater than `0` adds vertices making it no longer a icosahedron. |

<a name="IcosahedronGeometry+parameters"></a>

### icosahedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>IcosahedronGeometry</code>](#IcosahedronGeometry)  
<a name="IcosahedronGeometry.fromJSON"></a>

### IcosahedronGeometry.fromJSON(data) ⇒ [<code>IcosahedronGeometry</code>](#IcosahedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>IcosahedronGeometry</code>](#IcosahedronGeometry)  
**Returns**: [<code>IcosahedronGeometry</code>](#IcosahedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="LatheGeometry"></a>

## LatheGeometry ⇐ <code>BufferGeometry</code>
Creates meshes with axial symmetry like vases. The lathe rotates around the Y axis.

```js
const points = [];
for ( let i = 0; i < 10; i ++ ) {
	points.push( new THREE.Vector2( Math.sin( i * 0.2 ) * 10 + 5, ( i - 5 ) * 2 ) );
}
const geometry = new THREE.LatheGeometry( points );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const lathe = new THREE.Mesh( geometry, material );
scene.add( lathe );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [LatheGeometry](#LatheGeometry) ⇐ <code>BufferGeometry</code>
    * [new LatheGeometry([points], [segments], [phiStart], [phiLength])](#new_LatheGeometry_new)
    * _instance_
        * [.parameters](#LatheGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#LatheGeometry.fromJSON) ⇒ [<code>LatheGeometry</code>](#LatheGeometry)

<a name="new_LatheGeometry_new"></a>

### new LatheGeometry([points], [segments], [phiStart], [phiLength])
Constructs a new lathe geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [points] | <code>Array.&lt;(Vector2\|Vector3)&gt;</code> |  | An array of points in 2D space. The x-coordinate of each point must be greater than zero. |
| [segments] | <code>number</code> | <code>12</code> | The number of circumference segments to generate. |
| [phiStart] | <code>number</code> | <code>0</code> | The starting angle in radians. |
| [phiLength] | <code>number</code> | <code>Math.PI*2</code> | The radian (0 to 2PI) range of the lathed section 2PI is a closed lathe, less than 2PI is a portion. |

<a name="LatheGeometry+parameters"></a>

### latheGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>LatheGeometry</code>](#LatheGeometry)  
<a name="LatheGeometry.fromJSON"></a>

### LatheGeometry.fromJSON(data) ⇒ [<code>LatheGeometry</code>](#LatheGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>LatheGeometry</code>](#LatheGeometry)  
**Returns**: [<code>LatheGeometry</code>](#LatheGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="OctahedronGeometry"></a>

## OctahedronGeometry ⇐ <code>PolyhedronGeometry</code>
A geometry class for representing an octahedron.

```js
const geometry = new THREE.OctahedronGeometry();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const octahedron = new THREE.Mesh( geometry, material );
scene.add( octahedron );
```

**Kind**: global class  
**Extends**: <code>PolyhedronGeometry</code>  

* [OctahedronGeometry](#OctahedronGeometry) ⇐ <code>PolyhedronGeometry</code>
    * [new OctahedronGeometry([radius], [detail])](#new_OctahedronGeometry_new)
    * _instance_
        * [.parameters](#OctahedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#OctahedronGeometry.fromJSON) ⇒ [<code>OctahedronGeometry</code>](#OctahedronGeometry)

<a name="new_OctahedronGeometry_new"></a>

### new OctahedronGeometry([radius], [detail])
Constructs a new octahedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the octahedron. |
| [detail] | <code>number</code> | <code>0</code> | Setting this to a value greater than `0` adds vertices making it no longer a octahedron. |

<a name="OctahedronGeometry+parameters"></a>

### octahedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>OctahedronGeometry</code>](#OctahedronGeometry)  
<a name="OctahedronGeometry.fromJSON"></a>

### OctahedronGeometry.fromJSON(data) ⇒ [<code>OctahedronGeometry</code>](#OctahedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>OctahedronGeometry</code>](#OctahedronGeometry)  
**Returns**: [<code>OctahedronGeometry</code>](#OctahedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="PlaneGeometry"></a>

## PlaneGeometry ⇐ <code>BufferGeometry</code>
A geometry class for representing a plane.

```js
const geometry = new THREE.PlaneGeometry( 1, 1 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
const plane = new THREE.Mesh( geometry, material );
scene.add( plane );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [PlaneGeometry](#PlaneGeometry) ⇐ <code>BufferGeometry</code>
    * [new PlaneGeometry([width], [height], [widthSegments], [heightSegments])](#new_PlaneGeometry_new)
    * _instance_
        * [.parameters](#PlaneGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#PlaneGeometry.fromJSON) ⇒ [<code>PlaneGeometry</code>](#PlaneGeometry)

<a name="new_PlaneGeometry_new"></a>

### new PlaneGeometry([width], [height], [widthSegments], [heightSegments])
Constructs a new plane geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width along the X axis. |
| [height] | <code>number</code> | <code>1</code> | The height along the Y axis |
| [widthSegments] | <code>number</code> | <code>1</code> | The number of segments along the X axis. |
| [heightSegments] | <code>number</code> | <code>1</code> | The number of segments along the Y axis. |

<a name="PlaneGeometry+parameters"></a>

### planeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>PlaneGeometry</code>](#PlaneGeometry)  
<a name="PlaneGeometry.fromJSON"></a>

### PlaneGeometry.fromJSON(data) ⇒ [<code>PlaneGeometry</code>](#PlaneGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>PlaneGeometry</code>](#PlaneGeometry)  
**Returns**: [<code>PlaneGeometry</code>](#PlaneGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="PolyhedronGeometry"></a>

## PolyhedronGeometry ⇐ <code>BufferGeometry</code>
A polyhedron is a solid in three dimensions with flat faces. This class
will take an array of vertices, project them onto a sphere, and then
divide them up to the desired level of detail.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [PolyhedronGeometry](#PolyhedronGeometry) ⇐ <code>BufferGeometry</code>
    * [new PolyhedronGeometry([vertices], [indices], [radius], [detail])](#new_PolyhedronGeometry_new)
    * _instance_
        * [.parameters](#PolyhedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#PolyhedronGeometry.fromJSON) ⇒ [<code>PolyhedronGeometry</code>](#PolyhedronGeometry)

<a name="new_PolyhedronGeometry_new"></a>

### new PolyhedronGeometry([vertices], [indices], [radius], [detail])
Constructs a new polyhedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [vertices] | <code>Array.&lt;number&gt;</code> |  | A flat array of vertices describing the base shape. |
| [indices] | <code>Array.&lt;number&gt;</code> |  | A flat array of indices describing the base shape. |
| [radius] | <code>number</code> | <code>1</code> | The radius of the shape. |
| [detail] | <code>number</code> | <code>0</code> | How many levels to subdivide the geometry. The more detail, the smoother the shape. |

<a name="PolyhedronGeometry+parameters"></a>

### polyhedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>PolyhedronGeometry</code>](#PolyhedronGeometry)  
<a name="PolyhedronGeometry.fromJSON"></a>

### PolyhedronGeometry.fromJSON(data) ⇒ [<code>PolyhedronGeometry</code>](#PolyhedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>PolyhedronGeometry</code>](#PolyhedronGeometry)  
**Returns**: [<code>PolyhedronGeometry</code>](#PolyhedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="RingGeometry"></a>

## RingGeometry ⇐ <code>BufferGeometry</code>
A class for generating a two-dimensional ring geometry.

```js
const geometry = new THREE.RingGeometry( 1, 5, 32 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00, side: THREE.DoubleSide } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [RingGeometry](#RingGeometry) ⇐ <code>BufferGeometry</code>
    * [new RingGeometry([innerRadius], [outerRadius], [thetaSegments], [phiSegments], [thetaStart], [thetaLength])](#new_RingGeometry_new)
    * _instance_
        * [.parameters](#RingGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#RingGeometry.fromJSON) ⇒ [<code>RingGeometry</code>](#RingGeometry)

<a name="new_RingGeometry_new"></a>

### new RingGeometry([innerRadius], [outerRadius], [thetaSegments], [phiSegments], [thetaStart], [thetaLength])
Constructs a new ring geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [innerRadius] | <code>number</code> | <code>0.5</code> | The inner radius of the ring. |
| [outerRadius] | <code>number</code> | <code>1</code> | The outer radius of the ring. |
| [thetaSegments] | <code>number</code> | <code>32</code> | Number of segments. A higher number means the ring will be more round. Minimum is `3`. |
| [phiSegments] | <code>number</code> | <code>1</code> | Number of segments per ring segment. Minimum is `1`. |
| [thetaStart] | <code>number</code> | <code>0</code> | Starting angle in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI*2</code> | Central angle in radians. |

<a name="RingGeometry+parameters"></a>

### ringGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>RingGeometry</code>](#RingGeometry)  
<a name="RingGeometry.fromJSON"></a>

### RingGeometry.fromJSON(data) ⇒ [<code>RingGeometry</code>](#RingGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>RingGeometry</code>](#RingGeometry)  
**Returns**: [<code>RingGeometry</code>](#RingGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="ShapeGeometry"></a>

## ShapeGeometry ⇐ <code>BufferGeometry</code>
Creates an one-sided polygonal geometry from one or more path shapes.

```js
const arcShape = new THREE.Shape()
	.moveTo( 5, 1 )
	.absarc( 1, 1, 4, 0, Math.PI * 2, false );

const geometry = new THREE.ShapeGeometry( arcShape );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00, side: THREE.DoubleSide } );
const mesh = new THREE.Mesh( geometry, material ) ;
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [ShapeGeometry](#ShapeGeometry) ⇐ <code>BufferGeometry</code>
    * [new ShapeGeometry([shapes], [curveSegments])](#new_ShapeGeometry_new)
    * _instance_
        * [.parameters](#ShapeGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data, shapes)](#ShapeGeometry.fromJSON) ⇒ [<code>ShapeGeometry</code>](#ShapeGeometry)

<a name="new_ShapeGeometry_new"></a>

### new ShapeGeometry([shapes], [curveSegments])
Constructs a new shape geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [shapes] | <code>Shape</code> \| <code>Array.&lt;Shape&gt;</code> |  | A shape or an array of shapes. |
| [curveSegments] | <code>number</code> | <code>12</code> | Number of segments per shape. |

<a name="ShapeGeometry+parameters"></a>

### shapeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>ShapeGeometry</code>](#ShapeGeometry)  
<a name="ShapeGeometry.fromJSON"></a>

### ShapeGeometry.fromJSON(data, shapes) ⇒ [<code>ShapeGeometry</code>](#ShapeGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>ShapeGeometry</code>](#ShapeGeometry)  
**Returns**: [<code>ShapeGeometry</code>](#ShapeGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |
| shapes | <code>Array.&lt;Shape&gt;</code> | An array of shapes. |

<a name="SphereGeometry"></a>

## SphereGeometry ⇐ <code>BufferGeometry</code>
A class for generating a sphere geometry.

```js
const geometry = new THREE.SphereGeometry( 15, 32, 16 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const sphere = new THREE.Mesh( geometry, material );
scene.add( sphere );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [SphereGeometry](#SphereGeometry) ⇐ <code>BufferGeometry</code>
    * [new SphereGeometry([radius], [widthSegments], [heightSegments], [phiStart], [phiLength], [thetaStart], [thetaLength])](#new_SphereGeometry_new)
    * _instance_
        * [.parameters](#SphereGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#SphereGeometry.fromJSON) ⇒ [<code>SphereGeometry</code>](#SphereGeometry)

<a name="new_SphereGeometry_new"></a>

### new SphereGeometry([radius], [widthSegments], [heightSegments], [phiStart], [phiLength], [thetaStart], [thetaLength])
Constructs a new sphere geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | The sphere radius. |
| [widthSegments] | <code>number</code> | <code>32</code> | The number of horizontal segments. Minimum value is `3`. |
| [heightSegments] | <code>number</code> | <code>16</code> | The number of vertical segments. Minimum value is `2`. |
| [phiStart] | <code>number</code> | <code>0</code> | The horizontal starting angle in radians. |
| [phiLength] | <code>number</code> | <code>Math.PI*2</code> | The horizontal sweep angle size. |
| [thetaStart] | <code>number</code> | <code>0</code> | The vertical starting angle in radians. |
| [thetaLength] | <code>number</code> | <code>Math.PI</code> | The vertical sweep angle size. |

<a name="SphereGeometry+parameters"></a>

### sphereGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>SphereGeometry</code>](#SphereGeometry)  
<a name="SphereGeometry.fromJSON"></a>

### SphereGeometry.fromJSON(data) ⇒ [<code>SphereGeometry</code>](#SphereGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>SphereGeometry</code>](#SphereGeometry)  
**Returns**: [<code>SphereGeometry</code>](#SphereGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="TetrahedronGeometry"></a>

## TetrahedronGeometry ⇐ <code>PolyhedronGeometry</code>
A geometry class for representing an tetrahedron.

```js
const geometry = new THREE.TetrahedronGeometry();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const tetrahedron = new THREE.Mesh( geometry, material );
scene.add( tetrahedron );
```

**Kind**: global class  
**Extends**: <code>PolyhedronGeometry</code>  

* [TetrahedronGeometry](#TetrahedronGeometry) ⇐ <code>PolyhedronGeometry</code>
    * [new TetrahedronGeometry([radius], [detail])](#new_TetrahedronGeometry_new)
    * _instance_
        * [.parameters](#TetrahedronGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#TetrahedronGeometry.fromJSON) ⇒ [<code>TetrahedronGeometry</code>](#TetrahedronGeometry)

<a name="new_TetrahedronGeometry_new"></a>

### new TetrahedronGeometry([radius], [detail])
Constructs a new tetrahedron geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the tetrahedron. |
| [detail] | <code>number</code> | <code>0</code> | Setting this to a value greater than `0` adds vertices making it no longer a tetrahedron. |

<a name="TetrahedronGeometry+parameters"></a>

### tetrahedronGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>TetrahedronGeometry</code>](#TetrahedronGeometry)  
<a name="TetrahedronGeometry.fromJSON"></a>

### TetrahedronGeometry.fromJSON(data) ⇒ [<code>TetrahedronGeometry</code>](#TetrahedronGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>TetrahedronGeometry</code>](#TetrahedronGeometry)  
**Returns**: [<code>TetrahedronGeometry</code>](#TetrahedronGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="TorusGeometry"></a>

## TorusGeometry ⇐ <code>BufferGeometry</code>
A geometry class for representing an torus.

```js
const geometry = new THREE.TorusGeometry( 10, 3, 16, 100 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const torus = new THREE.Mesh( geometry, material );
scene.add( torus );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [TorusGeometry](#TorusGeometry) ⇐ <code>BufferGeometry</code>
    * [new TorusGeometry([radius], [tube], [radialSegments], [tubularSegments], [arc])](#new_TorusGeometry_new)
    * _instance_
        * [.parameters](#TorusGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#TorusGeometry.fromJSON) ⇒ [<code>TorusGeometry</code>](#TorusGeometry)

<a name="new_TorusGeometry_new"></a>

### new TorusGeometry([radius], [tube], [radialSegments], [tubularSegments], [arc])
Constructs a new torus geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the torus, from the center of the torus to the center of the tube. |
| [tube] | <code>number</code> | <code>0.4</code> | Radius of the tube. Must be smaller than `radius`. |
| [radialSegments] | <code>number</code> | <code>12</code> | The number of radial segments. |
| [tubularSegments] | <code>number</code> | <code>48</code> | The number of tubular segments. |
| [arc] | <code>number</code> | <code>Math.PI*2</code> | Central angle in radians. |

<a name="TorusGeometry+parameters"></a>

### torusGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>TorusGeometry</code>](#TorusGeometry)  
<a name="TorusGeometry.fromJSON"></a>

### TorusGeometry.fromJSON(data) ⇒ [<code>TorusGeometry</code>](#TorusGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>TorusGeometry</code>](#TorusGeometry)  
**Returns**: [<code>TorusGeometry</code>](#TorusGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="TorusKnotGeometry"></a>

## TorusKnotGeometry ⇐ <code>BufferGeometry</code>
Creates a torus knot, the particular shape of which is defined by a pair
of coprime integers, p and q. If p and q are not coprime, the result will
be a torus link.

```js
const geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const torusKnot = new THREE.Mesh( geometry, material );
scene.add( torusKnot );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [TorusKnotGeometry](#TorusKnotGeometry) ⇐ <code>BufferGeometry</code>
    * [new TorusKnotGeometry([radius], [tube], [tubularSegments], [radialSegments], [p], [q])](#new_TorusKnotGeometry_new)
    * _instance_
        * [.parameters](#TorusKnotGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#TorusKnotGeometry.fromJSON) ⇒ [<code>TorusKnotGeometry</code>](#TorusKnotGeometry)

<a name="new_TorusKnotGeometry_new"></a>

### new TorusKnotGeometry([radius], [tube], [tubularSegments], [radialSegments], [p], [q])
Constructs a new torus knot geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | Radius of the torus knot. |
| [tube] | <code>number</code> | <code>0.4</code> | Radius of the tube. |
| [tubularSegments] | <code>number</code> | <code>64</code> | The number of tubular segments. |
| [radialSegments] | <code>number</code> | <code>8</code> | The number of radial segments. |
| [p] | <code>number</code> | <code>2</code> | This value determines, how many times the geometry winds around its axis of rotational symmetry. |
| [q] | <code>number</code> | <code>3</code> | This value determines, how many times the geometry winds around a circle in the interior of the torus. |

<a name="TorusKnotGeometry+parameters"></a>

### torusKnotGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>TorusKnotGeometry</code>](#TorusKnotGeometry)  
<a name="TorusKnotGeometry.fromJSON"></a>

### TorusKnotGeometry.fromJSON(data) ⇒ [<code>TorusKnotGeometry</code>](#TorusKnotGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>TorusKnotGeometry</code>](#TorusKnotGeometry)  
**Returns**: [<code>TorusKnotGeometry</code>](#TorusKnotGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="TubeGeometry"></a>

## TubeGeometry ⇐ <code>BufferGeometry</code>
Creates a tube that extrudes along a 3D curve.

```js
class CustomSinCurve extends THREE.Curve {

	getPoint( t, optionalTarget = new THREE.Vector3() ) {

		const tx = t * 3 - 1.5;
		const ty = Math.sin( 2 * Math.PI * t );
		const tz = 0;

		return optionalTarget.set( tx, ty, tz );
	}

}

const path = new CustomSinCurve( 10 );
const geometry = new THREE.TubeGeometry( path, 20, 2, 8, false );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [TubeGeometry](#TubeGeometry) ⇐ <code>BufferGeometry</code>
    * [new TubeGeometry([path], [tubularSegments], [radius], [radialSegments], [closed])](#new_TubeGeometry_new)
    * _instance_
        * [.parameters](#TubeGeometry+parameters) : <code>Object</code>
    * _static_
        * [.fromJSON(data)](#TubeGeometry.fromJSON) ⇒ [<code>TubeGeometry</code>](#TubeGeometry)

<a name="new_TubeGeometry_new"></a>

### new TubeGeometry([path], [tubularSegments], [radius], [radialSegments], [closed])
Constructs a new tube geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [path] | <code>Curve</code> | <code>QuadraticBezierCurve3</code> | A 3D curve defining the path of the tube. |
| [tubularSegments] | <code>number</code> | <code>64</code> | The number of segments that make up the tube. |
| [radius] | <code>number</code> | <code>1</code> | The radius of the tube. |
| [radialSegments] | <code>number</code> | <code>8</code> | The number of segments that make up the cross-section. |
| [closed] | <code>boolean</code> | <code>false</code> | Whether the tube is closed or not. |

<a name="TubeGeometry+parameters"></a>

### tubeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>TubeGeometry</code>](#TubeGeometry)  
<a name="TubeGeometry.fromJSON"></a>

### TubeGeometry.fromJSON(data) ⇒ [<code>TubeGeometry</code>](#TubeGeometry)
Factory method for creating an instance of this class from the given
JSON object.

**Kind**: static method of [<code>TubeGeometry</code>](#TubeGeometry)  
**Returns**: [<code>TubeGeometry</code>](#TubeGeometry) - A new instance.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | A JSON object representing the serialized geometry. |

<a name="WireframeGeometry"></a>

## WireframeGeometry ⇐ <code>BufferGeometry</code>
Can be used as a helper object to visualize a geometry as a wireframe.

```js
const geometry = new THREE.SphereGeometry();

const wireframe = new THREE.WireframeGeometry( geometry );

const line = new THREE.LineSegments( wireframe );
line.material.depthWrite = false;
line.material.opacity = 0.25;
line.material.transparent = true;

scene.add( line );
```

Note: It is not yet possible to serialize/deserialize instances of this class.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  

* [WireframeGeometry](#WireframeGeometry) ⇐ <code>BufferGeometry</code>
    * [new WireframeGeometry([geometry])](#new_WireframeGeometry_new)
    * [.parameters](#WireframeGeometry+parameters) : <code>Object</code>

<a name="new_WireframeGeometry_new"></a>

### new WireframeGeometry([geometry])
Constructs a new wireframe geometry.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | <code></code> | The geometry. |

<a name="WireframeGeometry+parameters"></a>

### wireframeGeometry.parameters : <code>Object</code>
Holds the constructor parameters that have been
used to generate the geometry. Any modification
after instantiation does not change the geometry.

**Kind**: instance property of [<code>WireframeGeometry</code>](#WireframeGeometry)  
<a name="ArrowHelper"></a>

## ArrowHelper ⇐ <code>Object3D</code>
An 3D arrow object for visualizing directions.

```js
const dir = new THREE.Vector3( 1, 2, 0 );

//normalize the direction vector (convert to vector of length 1)
dir.normalize();

const origin = new THREE.Vector3( 0, 0, 0 );
const length = 1;
const hex = 0xffff00;

const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
scene.add( arrowHelper );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [ArrowHelper](#ArrowHelper) ⇐ <code>Object3D</code>
    * [new ArrowHelper([dir], [origin], [length], [color], [headLength], [headWidth])](#new_ArrowHelper_new)
    * [.line](#ArrowHelper+line) : <code>Line</code>
    * [.cone](#ArrowHelper+cone) : <code>Mesh</code>
    * [.setDirection(dir)](#ArrowHelper+setDirection)
    * [.setLength(length, [headLength], [headWidth])](#ArrowHelper+setLength)
    * [.setColor(color)](#ArrowHelper+setColor)
    * [.dispose()](#ArrowHelper+dispose)

<a name="new_ArrowHelper_new"></a>

### new ArrowHelper([dir], [origin], [length], [color], [headLength], [headWidth])
Constructs a new arrow helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [dir] | <code>Vector3</code> | <code>(0, 0, 1)</code> | The (normalized) direction vector. |
| [origin] | <code>Vector3</code> | <code>(0, 0, 0)</code> | Point at which the arrow starts. |
| [length] | <code>number</code> | <code>1</code> | Length of the arrow in world units. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffff00</code> | Color of the arrow. |
| [headLength] | <code>number</code> | <code>length*0.2</code> | The length of the head of the arrow. |
| [headWidth] | <code>number</code> | <code>headLength*0.2</code> | The width of the head of the arrow. |

<a name="ArrowHelper+line"></a>

### arrowHelper.line : <code>Line</code>
The line part of the arrow helper.

**Kind**: instance property of [<code>ArrowHelper</code>](#ArrowHelper)  
<a name="ArrowHelper+cone"></a>

### arrowHelper.cone : <code>Mesh</code>
The cone part of the arrow helper.

**Kind**: instance property of [<code>ArrowHelper</code>](#ArrowHelper)  
<a name="ArrowHelper+setDirection"></a>

### arrowHelper.setDirection(dir)
Sets the direction of the helper.

**Kind**: instance method of [<code>ArrowHelper</code>](#ArrowHelper)  

| Param | Type | Description |
| --- | --- | --- |
| dir | <code>Vector3</code> | The normalized direction vector. |

<a name="ArrowHelper+setLength"></a>

### arrowHelper.setLength(length, [headLength], [headWidth])
Sets the length of the helper.

**Kind**: instance method of [<code>ArrowHelper</code>](#ArrowHelper)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| length | <code>number</code> |  | Length of the arrow in world units. |
| [headLength] | <code>number</code> | <code>length*0.2</code> | The length of the head of the arrow. |
| [headWidth] | <code>number</code> | <code>headLength*0.2</code> | The width of the head of the arrow. |

<a name="ArrowHelper+setColor"></a>

### arrowHelper.setColor(color)
Sets the color of the helper.

**Kind**: instance method of [<code>ArrowHelper</code>](#ArrowHelper)  

| Param | Type | Description |
| --- | --- | --- |
| color | <code>number</code> \| <code>Color</code> \| <code>string</code> | The color to set. |

<a name="ArrowHelper+dispose"></a>

### arrowHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>ArrowHelper</code>](#ArrowHelper)  
<a name="AxesHelper"></a>

## AxesHelper ⇐ <code>LineSegments</code>
An axis object to visualize the 3 axes in a simple way.
The X axis is red. The Y axis is green. The Z axis is blue.

```js
const axesHelper = new THREE.AxesHelper( 5 );
scene.add( axesHelper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [AxesHelper](#AxesHelper) ⇐ <code>LineSegments</code>
    * [new AxesHelper([size])](#new_AxesHelper_new)
    * [.setColors(xAxisColor, yAxisColor, zAxisColor)](#AxesHelper+setColors) ⇒ [<code>AxesHelper</code>](#AxesHelper)
    * [.dispose()](#AxesHelper+dispose)

<a name="new_AxesHelper_new"></a>

### new AxesHelper([size])
Constructs a new axes helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>1</code> | Size of the lines representing the axes. |

<a name="AxesHelper+setColors"></a>

### axesHelper.setColors(xAxisColor, yAxisColor, zAxisColor) ⇒ [<code>AxesHelper</code>](#AxesHelper)
Defines the colors of the axes helper.

**Kind**: instance method of [<code>AxesHelper</code>](#AxesHelper)  
**Returns**: [<code>AxesHelper</code>](#AxesHelper) - A reference to this axes helper.  

| Param | Type | Description |
| --- | --- | --- |
| xAxisColor | <code>number</code> \| <code>Color</code> \| <code>string</code> | The color for the x axis. |
| yAxisColor | <code>number</code> \| <code>Color</code> \| <code>string</code> | The color for the y axis. |
| zAxisColor | <code>number</code> \| <code>Color</code> \| <code>string</code> | The color for the z axis. |

<a name="AxesHelper+dispose"></a>

### axesHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>AxesHelper</code>](#AxesHelper)  
<a name="Box3Helper"></a>

## Box3Helper ⇐ <code>LineSegments</code>
A helper object to visualize an instance of [Box3](Box3).

```js
const box = new THREE.Box3();
box.setFromCenterAndSize( new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 2, 1, 3 ) );

const helper = new THREE.Box3Helper( box, 0xffff00 );
scene.add( helper )
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [Box3Helper](#Box3Helper) ⇐ <code>LineSegments</code>
    * [new Box3Helper(box, [color])](#new_Box3Helper_new)
    * [.box](#Box3Helper+box) : <code>Box3</code>
    * [.dispose()](#Box3Helper+dispose)

<a name="new_Box3Helper_new"></a>

### new Box3Helper(box, [color])
Constructs a new box3 helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| box | <code>Box3</code> |  | The box to visualize. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffff00</code> | The box's color. |

<a name="Box3Helper+box"></a>

### box3Helper.box : <code>Box3</code>
The box being visualized.

**Kind**: instance property of [<code>Box3Helper</code>](#Box3Helper)  
<a name="Box3Helper+dispose"></a>

### box3Helper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Box3Helper</code>](#Box3Helper)  
<a name="BoxHelper"></a>

## BoxHelper ⇐ <code>LineSegments</code>
Helper object to graphically show the world-axis-aligned bounding box
around an object. The actual bounding box is handled with [Box3](Box3),
this is just a visual helper for debugging. It can be automatically
resized with [update](#BoxHelper+update) when the object it's created from
is transformed. Note that the object must have a geometry for this to work,
so it won't work with sprites.

```js
const sphere = new THREE.SphereGeometry();
const object = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( 0xff0000 ) );
const box = new THREE.BoxHelper( object, 0xffff00 );
scene.add( box );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [BoxHelper](#BoxHelper) ⇐ <code>LineSegments</code>
    * [new BoxHelper([object], [color])](#new_BoxHelper_new)
    * [.object](#BoxHelper+object) : <code>Object3D</code>
    * [.update()](#BoxHelper+update)
    * [.setFromObject(object)](#BoxHelper+setFromObject) ⇒ [<code>BoxHelper</code>](#BoxHelper)
    * [.dispose()](#BoxHelper+dispose)

<a name="new_BoxHelper_new"></a>

### new BoxHelper([object], [color])
Constructs a new box helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [object] | <code>Object3D</code> |  | The 3D object to show the world-axis-aligned bounding box. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffff00</code> | The box's color. |

<a name="BoxHelper+object"></a>

### boxHelper.object : <code>Object3D</code>
The 3D object being visualized.

**Kind**: instance property of [<code>BoxHelper</code>](#BoxHelper)  
<a name="BoxHelper+update"></a>

### boxHelper.update()
Updates the helper's geometry to match the dimensions of the object,
including any children.

**Kind**: instance method of [<code>BoxHelper</code>](#BoxHelper)  
<a name="BoxHelper+setFromObject"></a>

### boxHelper.setFromObject(object) ⇒ [<code>BoxHelper</code>](#BoxHelper)
Updates the wireframe box for the passed object.

**Kind**: instance method of [<code>BoxHelper</code>](#BoxHelper)  
**Returns**: [<code>BoxHelper</code>](#BoxHelper) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to create the helper for. |

<a name="BoxHelper+dispose"></a>

### boxHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>BoxHelper</code>](#BoxHelper)  
<a name="CameraHelper"></a>

## CameraHelper ⇐ <code>LineSegments</code>
This helps with visualizing what a camera contains in its frustum. It
visualizes the frustum of a camera using a line segments.

Based on frustum visualization in [lightgl.js shadowmap example](https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html).

`CameraHelper` must be a child of the scene.

```js
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
const helper = new THREE.CameraHelper( camera );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [CameraHelper](#CameraHelper) ⇐ <code>LineSegments</code>
    * [new CameraHelper(camera)](#new_CameraHelper_new)
    * [.camera](#CameraHelper+camera) : <code>Camera</code>
    * [.pointMap](#CameraHelper+pointMap) : <code>Object.&lt;string, Array.&lt;number&gt;&gt;</code>
    * [.setColors(frustum, cone, up, target, cross)](#CameraHelper+setColors)
    * [.update()](#CameraHelper+update)
    * [.dispose()](#CameraHelper+dispose)

<a name="new_CameraHelper_new"></a>

### new CameraHelper(camera)
Constructs a new arrow helper.


| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera to visualize. |

<a name="CameraHelper+camera"></a>

### cameraHelper.camera : <code>Camera</code>
The camera being visualized.

**Kind**: instance property of [<code>CameraHelper</code>](#CameraHelper)  
<a name="CameraHelper+pointMap"></a>

### cameraHelper.pointMap : <code>Object.&lt;string, Array.&lt;number&gt;&gt;</code>
This contains the points used to visualize the camera.

**Kind**: instance property of [<code>CameraHelper</code>](#CameraHelper)  
<a name="CameraHelper+setColors"></a>

### cameraHelper.setColors(frustum, cone, up, target, cross)
Defines the colors of the helper.

**Kind**: instance method of [<code>CameraHelper</code>](#CameraHelper)  

| Param | Type | Description |
| --- | --- | --- |
| frustum | <code>Color</code> | The frustum line color. |
| cone | <code>Color</code> | The cone line color. |
| up | <code>Color</code> | The up line color. |
| target | <code>Color</code> | The target line color. |
| cross | <code>Color</code> | The cross line color. |

<a name="CameraHelper+update"></a>

### cameraHelper.update()
Updates the helper based on the projection matrix of the camera.

**Kind**: instance method of [<code>CameraHelper</code>](#CameraHelper)  
<a name="CameraHelper+dispose"></a>

### cameraHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>CameraHelper</code>](#CameraHelper)  
<a name="DirectionalLightHelper"></a>

## DirectionalLightHelper ⇐ <code>Object3D</code>
Helper object to assist with visualizing a [DirectionalLight](DirectionalLight)'s
effect on the scene. This consists of plane and a line representing the
light's position and direction.

```js
const light = new THREE.DirectionalLight( 0xFFFFFF );
scene.add( light );

const helper = new THREE.DirectionalLightHelper( light, 5 );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [DirectionalLightHelper](#DirectionalLightHelper) ⇐ <code>Object3D</code>
    * [new DirectionalLightHelper(light, [size], [color])](#new_DirectionalLightHelper_new)
    * [.light](#DirectionalLightHelper+light) : <code>DirectionalLight</code>
    * [.color](#DirectionalLightHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.lightPlane](#DirectionalLightHelper+lightPlane) : <code>Line</code>
    * [.targetLine](#DirectionalLightHelper+targetLine) : <code>Line</code>
    * [.dispose()](#DirectionalLightHelper+dispose)
    * [.update()](#DirectionalLightHelper+update)

<a name="new_DirectionalLightHelper_new"></a>

### new DirectionalLightHelper(light, [size], [color])
Constructs a new directional light helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>DirectionalLight</code> |  | The light to be visualized. |
| [size] | <code>number</code> | <code>1</code> | The dimensions of the plane. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> |  | The helper's color. If not set, the helper will take the color of the light. |

<a name="DirectionalLightHelper+light"></a>

### directionalLightHelper.light : <code>DirectionalLight</code>
The light being visualized.

**Kind**: instance property of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+color"></a>

### directionalLightHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code>
The color parameter passed in the constructor.
If not set, the helper will take the color of the light.

**Kind**: instance property of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+lightPlane"></a>

### directionalLightHelper.lightPlane : <code>Line</code>
Contains the line showing the location of the directional light.

**Kind**: instance property of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+targetLine"></a>

### directionalLightHelper.targetLine : <code>Line</code>
Represents the target line of the directional light.

**Kind**: instance property of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+dispose"></a>

### directionalLightHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="DirectionalLightHelper+update"></a>

### directionalLightHelper.update()
Updates the helper to match the position and direction of the
light being visualized.

**Kind**: instance method of [<code>DirectionalLightHelper</code>](#DirectionalLightHelper)  
<a name="GridHelper"></a>

## GridHelper ⇐ <code>LineSegments</code>
The helper is an object to define grids. Grids are two-dimensional
arrays of lines.

```js
const size = 10;
const divisions = 10;

const gridHelper = new THREE.GridHelper( size, divisions );
scene.add( gridHelper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [GridHelper](#GridHelper) ⇐ <code>LineSegments</code>
    * [new GridHelper([size], [divisions], [color1], [color2])](#new_GridHelper_new)
    * [.dispose()](#GridHelper+dispose)

<a name="new_GridHelper_new"></a>

### new GridHelper([size], [divisions], [color1], [color2])
Constructs a new grid helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>10</code> | The size of the grid. |
| [divisions] | <code>number</code> | <code>10</code> | The number of divisions across the grid. |
| [color1] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x444444</code> | The color of the center line. |
| [color2] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x888888</code> | The color of the lines of the grid. |

<a name="GridHelper+dispose"></a>

### gridHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>GridHelper</code>](#GridHelper)  
<a name="HemisphereLightHelper"></a>

## HemisphereLightHelper ⇐ <code>Object3D</code>
Creates a visual aid consisting of a spherical mesh for a
given [HemisphereLight](HemisphereLight).

```js
const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
const helper = new THREE.HemisphereLightHelper( light, 5 );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [HemisphereLightHelper](#HemisphereLightHelper) ⇐ <code>Object3D</code>
    * [new HemisphereLightHelper(light, [size], [color])](#new_HemisphereLightHelper_new)
    * [.light](#HemisphereLightHelper+light) : <code>HemisphereLight</code>
    * [.color](#HemisphereLightHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.dispose()](#HemisphereLightHelper+dispose)
    * [.update()](#HemisphereLightHelper+update)

<a name="new_HemisphereLightHelper_new"></a>

### new HemisphereLightHelper(light, [size], [color])
Constructs a new hemisphere light helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>HemisphereLight</code> |  | The light to be visualized. |
| [size] | <code>number</code> | <code>1</code> | The size of the mesh used to visualize the light. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> |  | The helper's color. If not set, the helper will take the color of the light. |

<a name="HemisphereLightHelper+light"></a>

### hemisphereLightHelper.light : <code>HemisphereLight</code>
The light being visualized.

**Kind**: instance property of [<code>HemisphereLightHelper</code>](#HemisphereLightHelper)  
<a name="HemisphereLightHelper+color"></a>

### hemisphereLightHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code>
The color parameter passed in the constructor.
If not set, the helper will take the color of the light.

**Kind**: instance property of [<code>HemisphereLightHelper</code>](#HemisphereLightHelper)  
<a name="HemisphereLightHelper+dispose"></a>

### hemisphereLightHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>HemisphereLightHelper</code>](#HemisphereLightHelper)  
<a name="HemisphereLightHelper+update"></a>

### hemisphereLightHelper.update()
Updates the helper to match the position and direction of the
light being visualized.

**Kind**: instance method of [<code>HemisphereLightHelper</code>](#HemisphereLightHelper)  
<a name="PlaneHelper"></a>

## PlaneHelper ⇐ <code>Line</code>
A helper object to visualize an instance of [Plane](Plane).

```js
const plane = new THREE.Plane( new THREE.Vector3( 1, 1, 0.2 ), 3 );
const helper = new THREE.PlaneHelper( plane, 1, 0xffff00 );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>Line</code>  

* [PlaneHelper](#PlaneHelper) ⇐ <code>Line</code>
    * [new PlaneHelper(plane, [size], [hex])](#new_PlaneHelper_new)
    * [.plane](#PlaneHelper+plane) : <code>Plane</code>
    * [.size](#PlaneHelper+size) : <code>number</code>
    * [.dispose()](#PlaneHelper+dispose)

<a name="new_PlaneHelper_new"></a>

### new PlaneHelper(plane, [size], [hex])
Constructs a new plane helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| plane | <code>Plane</code> |  | The plane to be visualized. |
| [size] | <code>number</code> | <code>1</code> | The side length of plane helper. |
| [hex] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffff00</code> | The helper's color. |

<a name="PlaneHelper+plane"></a>

### planeHelper.plane : <code>Plane</code>
The plane being visualized.

**Kind**: instance property of [<code>PlaneHelper</code>](#PlaneHelper)  
<a name="PlaneHelper+size"></a>

### planeHelper.size : <code>number</code>
The side length of plane helper.

**Kind**: instance property of [<code>PlaneHelper</code>](#PlaneHelper)  
**Default**: <code>1</code>  
<a name="PlaneHelper+dispose"></a>

### planeHelper.dispose()
Updates the helper to match the position and direction of the
light being visualized.

**Kind**: instance method of [<code>PlaneHelper</code>](#PlaneHelper)  
<a name="PointLightHelper"></a>

## PointLightHelper ⇐ <code>Mesh</code>
This displays a helper object consisting of a spherical mesh for
visualizing an instance of [PointLight](PointLight).

```js
const pointLight = new THREE.PointLight( 0xff0000, 1, 100 );
pointLight.position.set( 10, 10, 10 );
scene.add( pointLight );

const sphereSize = 1;
const pointLightHelper = new THREE.PointLightHelper( pointLight, sphereSize );
scene.add( pointLightHelper );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [PointLightHelper](#PointLightHelper) ⇐ <code>Mesh</code>
    * [new PointLightHelper(light, [sphereSize], [color])](#new_PointLightHelper_new)
    * [.light](#PointLightHelper+light) : <code>HemisphereLight</code>
    * [.color](#PointLightHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.dispose()](#PointLightHelper+dispose)
    * [.update()](#PointLightHelper+update)

<a name="new_PointLightHelper_new"></a>

### new PointLightHelper(light, [sphereSize], [color])
Constructs a new point light helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>PointLight</code> |  | The light to be visualized. |
| [sphereSize] | <code>number</code> | <code>1</code> | The size of the sphere helper. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> |  | The helper's color. If not set, the helper will take the color of the light. |

<a name="PointLightHelper+light"></a>

### pointLightHelper.light : <code>HemisphereLight</code>
The light being visualized.

**Kind**: instance property of [<code>PointLightHelper</code>](#PointLightHelper)  
<a name="PointLightHelper+color"></a>

### pointLightHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code>
The color parameter passed in the constructor.
If not set, the helper will take the color of the light.

**Kind**: instance property of [<code>PointLightHelper</code>](#PointLightHelper)  
<a name="PointLightHelper+dispose"></a>

### pointLightHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>PointLightHelper</code>](#PointLightHelper)  
<a name="PointLightHelper+update"></a>

### pointLightHelper.update()
Updates the helper to match the position of the
light being visualized.

**Kind**: instance method of [<code>PointLightHelper</code>](#PointLightHelper)  
<a name="PolarGridHelper"></a>

## PolarGridHelper ⇐ <code>LineSegments</code>
This helper is an object to define polar grids. Grids are
two-dimensional arrays of lines.

```js
const radius = 10;
const sectors = 16;
const rings = 8;
const divisions = 64;

const helper = new THREE.PolarGridHelper( radius, sectors, rings, divisions );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [PolarGridHelper](#PolarGridHelper) ⇐ <code>LineSegments</code>
    * [new PolarGridHelper([radius], [sectors], [rings], [divisions], [color1], [color2])](#new_PolarGridHelper_new)
    * [.dispose()](#PolarGridHelper+dispose)

<a name="new_PolarGridHelper_new"></a>

### new PolarGridHelper([radius], [sectors], [rings], [divisions], [color1], [color2])
Constructs a new polar grid helper.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>10</code> | The radius of the polar grid. This can be any positive number. |
| [sectors] | <code>number</code> | <code>16</code> | The number of sectors the grid will be divided into. This can be any positive integer. |
| [rings] | <code>number</code> | <code>16</code> | The number of rings. This can be any positive integer. |
| [divisions] | <code>number</code> | <code>64</code> | The number of line segments used for each circle. This can be any positive integer. |
| [color1] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x444444</code> | The first color used for grid elements. |
| [color2] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x888888</code> | The second color used for grid elements. |

<a name="PolarGridHelper+dispose"></a>

### polarGridHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>PolarGridHelper</code>](#PolarGridHelper)  
<a name="SkeletonHelper"></a>

## SkeletonHelper ⇐ <code>LineSegments</code>
A helper object to assist with visualizing a [Skeleton](Skeleton).

```js
const helper = new THREE.SkeletonHelper( skinnedMesh );
scene.add( helper );
```

**Kind**: global class  
**Extends**: <code>LineSegments</code>  

* [SkeletonHelper](#SkeletonHelper) ⇐ <code>LineSegments</code>
    * [new SkeletonHelper(object)](#new_SkeletonHelper_new)
    * [.isSkeletonHelper](#SkeletonHelper+isSkeletonHelper) : <code>boolean</code>
    * [.root](#SkeletonHelper+root) : <code>Object3D</code>
    * [.bones](#SkeletonHelper+bones) : <code>Array.&lt;Bone&gt;</code>
    * [.dispose()](#SkeletonHelper+dispose)

<a name="new_SkeletonHelper_new"></a>

### new SkeletonHelper(object)
Constructs a new hemisphere light helper.


| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | Usually an instance of [SkinnedMesh](SkinnedMesh). However, any 3D object can be used if it represents a hierarchy of bones (see [Bone](Bone)). |

<a name="SkeletonHelper+isSkeletonHelper"></a>

### skeletonHelper.isSkeletonHelper : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SkeletonHelper</code>](#SkeletonHelper)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SkeletonHelper+root"></a>

### skeletonHelper.root : <code>Object3D</code>
The object being visualized.

**Kind**: instance property of [<code>SkeletonHelper</code>](#SkeletonHelper)  
<a name="SkeletonHelper+bones"></a>

### skeletonHelper.bones : <code>Array.&lt;Bone&gt;</code>
he list of bones that the helper visualizes.

**Kind**: instance property of [<code>SkeletonHelper</code>](#SkeletonHelper)  
<a name="SkeletonHelper+dispose"></a>

### skeletonHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>SkeletonHelper</code>](#SkeletonHelper)  
<a name="SpotLightHelper"></a>

## SpotLightHelper ⇐ <code>Object3D</code>
This displays a cone shaped helper object for a [SpotLight](SpotLight).

```js
const spotLight = new THREE.SpotLight( 0xffffff );
spotLight.position.set( 10, 10, 10 );
scene.add( spotLight );

const spotLightHelper = new THREE.SpotLightHelper( spotLight );
scene.add( spotLightHelper );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [SpotLightHelper](#SpotLightHelper) ⇐ <code>Object3D</code>
    * [new SpotLightHelper(light, [color])](#new_SpotLightHelper_new)
    * [.light](#SpotLightHelper+light) : <code>SpotLight</code>
    * [.color](#SpotLightHelper+color) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.dispose()](#SpotLightHelper+dispose)
    * [.update()](#SpotLightHelper+update)

<a name="new_SpotLightHelper_new"></a>

### new SpotLightHelper(light, [color])
Constructs a new spot light helper.


| Param | Type | Description |
| --- | --- | --- |
| light | <code>HemisphereLight</code> | The light to be visualized. |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | The helper's color. If not set, the helper will take the color of the light. |

<a name="SpotLightHelper+light"></a>

### spotLightHelper.light : <code>SpotLight</code>
The light being visualized.

**Kind**: instance property of [<code>SpotLightHelper</code>](#SpotLightHelper)  
<a name="SpotLightHelper+color"></a>

### spotLightHelper.color : <code>number</code> \| <code>Color</code> \| <code>string</code>
The color parameter passed in the constructor.
If not set, the helper will take the color of the light.

**Kind**: instance property of [<code>SpotLightHelper</code>](#SpotLightHelper)  
<a name="SpotLightHelper+dispose"></a>

### spotLightHelper.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>SpotLightHelper</code>](#SpotLightHelper)  
<a name="SpotLightHelper+update"></a>

### spotLightHelper.update()
Updates the helper to match the position and direction of the
light being visualized.

**Kind**: instance method of [<code>SpotLightHelper</code>](#SpotLightHelper)  
<a name="AmbientLight"></a>

## AmbientLight ⇐ <code>Light</code>
This light globally illuminates all objects in the scene equally.

It cannot be used to cast shadows as it does not have a direction.

```js
const light = new THREE.AmbientLight( 0x404040 ); // soft white light
scene.add( light );
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [AmbientLight](#AmbientLight) ⇐ <code>Light</code>
    * [new AmbientLight([color], [intensity])](#new_AmbientLight_new)
    * [.isAmbientLight](#AmbientLight+isAmbientLight) : <code>boolean</code>

<a name="new_AmbientLight_new"></a>

### new AmbientLight([color], [intensity])
Constructs a new ambient light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="AmbientLight+isAmbientLight"></a>

### ambientLight.isAmbientLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>AmbientLight</code>](#AmbientLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DirectionalLight"></a>

## DirectionalLight ⇐ <code>Light</code>
A light that gets emitted in a specific direction. This light will behave
as though it is infinitely far away and the rays produced from it are all
parallel. The common use case for this is to simulate daylight; the sun is
far enough away that its position can be considered to be infinite, and
all light rays coming from it are parallel.

A common point of confusion for directional lights is that setting the
rotation has no effect. This is because three.js's DirectionalLight is the
equivalent to what is often called a 'Target Direct Light' in other
applications.

This means that its direction is calculated as pointing from the light's
[Object3D#position](Object3D#position) to the [target](#DirectionalLight+target) position
(as opposed to a 'Free Direct Light' that just has a rotation
component).

This light can cast shadows - see the [DirectionalLightShadow](DirectionalLightShadow) for details.

```js
// White directional light at half intensity shining from the top.
const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
scene.add( directionalLight );
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [DirectionalLight](#DirectionalLight) ⇐ <code>Light</code>
    * [new DirectionalLight([color], [intensity])](#new_DirectionalLight_new)
    * [.isDirectionalLight](#DirectionalLight+isDirectionalLight) : <code>boolean</code>
    * [.target](#DirectionalLight+target) : <code>Object3D</code>
    * [.shadow](#DirectionalLight+shadow) : <code>DirectionalLightShadow</code>

<a name="new_DirectionalLight_new"></a>

### new DirectionalLight([color], [intensity])
Constructs a new directional light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="DirectionalLight+isDirectionalLight"></a>

### directionalLight.isDirectionalLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DirectionalLight</code>](#DirectionalLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DirectionalLight+target"></a>

### directionalLight.target : <code>Object3D</code>
The directional light points from its position to the
target's position.

For the target's position to be changed to anything other
than the default, it must be added to the scene.

It is also possible to set the target to be another 3D object
in the scene. The light will now track the target object.

**Kind**: instance property of [<code>DirectionalLight</code>](#DirectionalLight)  
<a name="DirectionalLight+shadow"></a>

### directionalLight.shadow : <code>DirectionalLightShadow</code>
This property holds the light's shadow configuration.

**Kind**: instance property of [<code>DirectionalLight</code>](#DirectionalLight)  
<a name="DirectionalLightShadow"></a>

## DirectionalLightShadow ⇐ <code>LightShadow</code>
Represents the shadow configuration of directional lights.

**Kind**: global class  
**Extends**: <code>LightShadow</code>  

* [DirectionalLightShadow](#DirectionalLightShadow) ⇐ <code>LightShadow</code>
    * [new DirectionalLightShadow()](#new_DirectionalLightShadow_new)
    * [.isDirectionalLightShadow](#DirectionalLightShadow+isDirectionalLightShadow) : <code>boolean</code>

<a name="new_DirectionalLightShadow_new"></a>

### new DirectionalLightShadow()
Constructs a new directional light shadow.

<a name="DirectionalLightShadow+isDirectionalLightShadow"></a>

### directionalLightShadow.isDirectionalLightShadow : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DirectionalLightShadow</code>](#DirectionalLightShadow)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="HemisphereLight"></a>

## HemisphereLight ⇐ <code>Light</code>
A light source positioned directly above the scene, with color fading from
the sky color to the ground color.

This light cannot be used to cast shadows.

```js
const light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
scene.add( light );
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [HemisphereLight](#HemisphereLight) ⇐ <code>Light</code>
    * [new HemisphereLight([skyColor], [groundColor], [intensity])](#new_HemisphereLight_new)
    * [.isHemisphereLight](#HemisphereLight+isHemisphereLight) : <code>boolean</code>
    * [.groundColor](#HemisphereLight+groundColor) : <code>Color</code>

<a name="new_HemisphereLight_new"></a>

### new HemisphereLight([skyColor], [groundColor], [intensity])
Constructs a new hemisphere light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [skyColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's sky color. |
| [groundColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's ground color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="HemisphereLight+isHemisphereLight"></a>

### hemisphereLight.isHemisphereLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>HemisphereLight</code>](#HemisphereLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="HemisphereLight+groundColor"></a>

### hemisphereLight.groundColor : <code>Color</code>
The light's ground color.

**Kind**: instance property of [<code>HemisphereLight</code>](#HemisphereLight)  
<a name="Light"></a>

## *Light ⇐ <code>Object3D</code>*
Abstract base class for lights - all other light types inherit the
properties and methods described here.

**Kind**: global abstract class  
**Extends**: <code>Object3D</code>  

* *[Light](#Light) ⇐ <code>Object3D</code>*
    * *[new Light([color], [intensity])](#new_Light_new)*
    * *[.isLight](#Light+isLight) : <code>boolean</code>*
    * *[.color](#Light+color) : <code>Color</code>*
    * *[.intensity](#Light+intensity) : <code>number</code>*
    * *[.dispose()](#Light+dispose)*

<a name="new_Light_new"></a>

### *new Light([color], [intensity])*
Constructs a new light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="Light+isLight"></a>

### *light.isLight : <code>boolean</code>*
This flag can be used for type testing.

**Kind**: instance property of [<code>Light</code>](#Light)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Light+color"></a>

### *light.color : <code>Color</code>*
The light's color.

**Kind**: instance property of [<code>Light</code>](#Light)  
<a name="Light+intensity"></a>

### *light.intensity : <code>number</code>*
The light's intensity.

**Kind**: instance property of [<code>Light</code>](#Light)  
**Default**: <code>1</code>  
<a name="Light+dispose"></a>

### *light.dispose()*
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Light</code>](#Light)  
<a name="LightProbe"></a>

## LightProbe ⇐ <code>Light</code>
Light probes are an alternative way of adding light to a 3D scene. Unlike
classical light sources (e.g. directional, point or spot lights), light
probes do not emit light. Instead they store information about light
passing through 3D space. During rendering, the light that hits a 3D
object is approximated by using the data from the light probe.

Light probes are usually created from (radiance) environment maps. The
class [LightProbeGenerator](LightProbeGenerator) can be used to create light probes from
cube textures or render targets. However, light estimation data could also
be provided in other forms e.g. by WebXR. This enables the rendering of
augmented reality content that reacts to real world lighting.

The current probe implementation in three.js supports so-called diffuse
light probes. This type of light probe is functionally equivalent to an
irradiance environment map.

**Kind**: global class  
**Extends**: <code>Light</code>  

* [LightProbe](#LightProbe) ⇐ <code>Light</code>
    * [new LightProbe(sh, [intensity])](#new_LightProbe_new)
    * [.isLightProbe](#LightProbe+isLightProbe) : <code>boolean</code>
    * [.sh](#LightProbe+sh) : <code>SphericalHarmonics3</code>
    * [.fromJSON(json)](#LightProbe+fromJSON) ⇒ [<code>LightProbe</code>](#LightProbe)

<a name="new_LightProbe_new"></a>

### new LightProbe(sh, [intensity])
Constructs a new light probe.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| sh | <code>SphericalHarmonics3</code> |  | The spherical harmonics which represents encoded lighting information. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |

<a name="LightProbe+isLightProbe"></a>

### lightProbe.isLightProbe : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LightProbe</code>](#LightProbe)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LightProbe+sh"></a>

### lightProbe.sh : <code>SphericalHarmonics3</code>
A light probe uses spherical harmonics to encode lighting information.

**Kind**: instance property of [<code>LightProbe</code>](#LightProbe)  
<a name="LightProbe+fromJSON"></a>

### lightProbe.fromJSON(json) ⇒ [<code>LightProbe</code>](#LightProbe)
Deserializes the light prove from the given JSON.

**Kind**: instance method of [<code>LightProbe</code>](#LightProbe)  
**Returns**: [<code>LightProbe</code>](#LightProbe) - A reference to this light probe.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON holding the serialized light probe. |

<a name="LightShadow"></a>

## *LightShadow*
Abstract base class for light shadow classes. These classes
represent the shadow configuration for different light types.

**Kind**: global abstract class  

* *[LightShadow](#LightShadow)*
    * *[new LightShadow(camera)](#new_LightShadow_new)*
    * *[.camera](#LightShadow+camera) : <code>Camera</code>*
    * *[.intensity](#LightShadow+intensity) : <code>number</code>*
    * *[.bias](#LightShadow+bias) : <code>number</code>*
    * *[.normalBias](#LightShadow+normalBias) : <code>number</code>*
    * *[.radius](#LightShadow+radius) : <code>number</code>*
    * *[.blurSamples](#LightShadow+blurSamples) : <code>number</code>*
    * *[.mapSize](#LightShadow+mapSize) : <code>Vector2</code>*
    * *[.map](#LightShadow+map) : <code>RenderTarget</code>*
    * *[.mapPass](#LightShadow+mapPass) : <code>RenderTarget</code>*
    * *[.matrix](#LightShadow+matrix) : <code>Matrix4</code>*
    * *[.autoUpdate](#LightShadow+autoUpdate) : <code>boolean</code>*
    * *[.needsUpdate](#LightShadow+needsUpdate) : <code>boolean</code>*
    * *[.getViewportCount()](#LightShadow+getViewportCount) ⇒ <code>number</code>*
    * *[.getFrustum()](#LightShadow+getFrustum) ⇒ <code>Frustum</code>*
    * *[.updateMatrices(light)](#LightShadow+updateMatrices)*
    * *[.getViewport(viewportIndex)](#LightShadow+getViewport) ⇒ <code>Vector4</code>*
    * *[.getFrameExtents()](#LightShadow+getFrameExtents) ⇒ <code>Vector2</code>*
    * *[.dispose()](#LightShadow+dispose)*
    * *[.copy(source)](#LightShadow+copy) ⇒ [<code>LightShadow</code>](#LightShadow)*
    * *[.clone()](#LightShadow+clone) ⇒ [<code>LightShadow</code>](#LightShadow)*
    * *[.toJSON()](#LightShadow+toJSON) ⇒ <code>Object</code>*

<a name="new_LightShadow_new"></a>

### *new LightShadow(camera)*
Constructs a new light shadow.


| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The light's view of the world. |

<a name="LightShadow+camera"></a>

### *lightShadow.camera : <code>Camera</code>*
The light's view of the world.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
<a name="LightShadow+intensity"></a>

### *lightShadow.intensity : <code>number</code>*
The intensity of the shadow. The default is `1`.
Valid values are in the range `[0, 1]`.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>1</code>  
<a name="LightShadow+bias"></a>

### *lightShadow.bias : <code>number</code>*
Shadow map bias, how much to add or subtract from the normalized depth
when deciding whether a surface is in shadow.

The default is `0`. Very tiny adjustments here (in the order of `0.0001`)
may help reduce artifacts in shadows.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>0</code>  
<a name="LightShadow+normalBias"></a>

### *lightShadow.normalBias : <code>number</code>*
Defines how much the position used to query the shadow map is offset along
the object normal. The default is `0`. Increasing this value can be used to
reduce shadow acne especially in large scenes where light shines onto
geometry at a shallow angle. The cost is that shadows may appear distorted.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>0</code>  
<a name="LightShadow+radius"></a>

### *lightShadow.radius : <code>number</code>*
Setting this to values greater than 1 will blur the edges of the shadow.
High values will cause unwanted banding effects in the shadows - a greater
map size will allow for a higher value to be used here before these effects
become visible.

The property has no effect when the shadow map type is `PCFSoftShadowMap` and
and it is recommended to increase softness by decreasing the shadow map size instead.

The property has no effect when the shadow map type is `BasicShadowMap`.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>1</code>  
<a name="LightShadow+blurSamples"></a>

### *lightShadow.blurSamples : <code>number</code>*
The amount of samples to use when blurring a VSM shadow map.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>8</code>  
<a name="LightShadow+mapSize"></a>

### *lightShadow.mapSize : <code>Vector2</code>*
Defines the width and height of the shadow map. Higher values give better quality
shadows at the cost of computation time. Values must be powers of two.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>(512,512)</code>  
<a name="LightShadow+map"></a>

### *lightShadow.map : <code>RenderTarget</code>*
The depth map generated using the internal camera; a location beyond a
pixel's depth is in shadow. Computed internally during rendering.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>null</code>  
<a name="LightShadow+mapPass"></a>

### *lightShadow.mapPass : <code>RenderTarget</code>*
The distribution map generated using the internal camera; an occlusion is
calculated based on the distribution of depths. Computed internally during
rendering.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>null</code>  
<a name="LightShadow+matrix"></a>

### *lightShadow.matrix : <code>Matrix4</code>*
Model to shadow camera space, to compute location and depth in shadow map.
This is computed internally during rendering.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
<a name="LightShadow+autoUpdate"></a>

### *lightShadow.autoUpdate : <code>boolean</code>*
Enables automatic updates of the light's shadow. If you do not require dynamic
lighting / shadows, you may set this to `false`.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>true</code>  
<a name="LightShadow+needsUpdate"></a>

### *lightShadow.needsUpdate : <code>boolean</code>*
When set to `true`, shadow maps will be updated in the next `render` call.
If you have set [autoUpdate](#LightShadow+autoUpdate) to `false`, you will need to
set this property to `true` and then make a render call to update the light's shadow.

**Kind**: instance property of [<code>LightShadow</code>](#LightShadow)  
**Default**: <code>false</code>  
<a name="LightShadow+getViewportCount"></a>

### *lightShadow.getViewportCount() ⇒ <code>number</code>*
Used internally by the renderer to get the number of viewports that need
to be rendered for this shadow.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>number</code> - The viewport count.  
<a name="LightShadow+getFrustum"></a>

### *lightShadow.getFrustum() ⇒ <code>Frustum</code>*
Gets the shadow cameras frustum. Used internally by the renderer to cull objects.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>Frustum</code> - The shadow camera frustum.  
<a name="LightShadow+updateMatrices"></a>

### *lightShadow.updateMatrices(light)*
Update the matrices for the camera and shadow, used internally by the renderer.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light for which the shadow is being rendered. |

<a name="LightShadow+getViewport"></a>

### *lightShadow.getViewport(viewportIndex) ⇒ <code>Vector4</code>*
Returns a viewport definition for the given viewport index.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>Vector4</code> - The viewport.  

| Param | Type | Description |
| --- | --- | --- |
| viewportIndex | <code>number</code> | The viewport index. |

<a name="LightShadow+getFrameExtents"></a>

### *lightShadow.getFrameExtents() ⇒ <code>Vector2</code>*
Returns the frame extends.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>Vector2</code> - The frame extends.  
<a name="LightShadow+dispose"></a>

### *lightShadow.dispose()*
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
<a name="LightShadow+copy"></a>

### *lightShadow.copy(source) ⇒ [<code>LightShadow</code>](#LightShadow)*
Copies the values of the given light shadow instance to this instance.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: [<code>LightShadow</code>](#LightShadow) - A reference to this light shadow instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>LightShadow</code>](#LightShadow) | The light shadow to copy. |

<a name="LightShadow+clone"></a>

### *lightShadow.clone() ⇒ [<code>LightShadow</code>](#LightShadow)*
Returns a new light shadow instance with copied values from this instance.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: [<code>LightShadow</code>](#LightShadow) - A clone of this instance.  
<a name="LightShadow+toJSON"></a>

### *lightShadow.toJSON() ⇒ <code>Object</code>*
Serializes the light shadow into JSON.

**Kind**: instance method of [<code>LightShadow</code>](#LightShadow)  
**Returns**: <code>Object</code> - A JSON object representing the serialized light shadow.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  
<a name="PointLight"></a>

## PointLight ⇐ <code>Light</code>
A light that gets emitted from a single point in all directions. A common
use case for this is to replicate the light emitted from a bare
lightbulb.

This light can cast shadows - see the [PointLightShadow](PointLightShadow) for details.

```js
const light = new THREE.PointLight( 0xff0000, 1, 100 );
light.position.set( 50, 50, 50 );
scene.add( light );
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [PointLight](#PointLight) ⇐ <code>Light</code>
    * [new PointLight([color], [intensity], [distance], [decay])](#new_PointLight_new)
    * [.isPointLight](#PointLight+isPointLight) : <code>boolean</code>
    * [.distance](#PointLight+distance) : <code>number</code>
    * [.decay](#PointLight+decay) : <code>number</code>
    * [.shadow](#PointLight+shadow) : <code>PointLightShadow</code>
    * [.power](#PointLight+power) : <code>number</code>

<a name="new_PointLight_new"></a>

### new PointLight([color], [intensity], [distance], [decay])
Constructs a new point light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity measured in candela (cd). |
| [distance] | <code>number</code> | <code>0</code> | Maximum range of the light. `0` means no limit. |
| [decay] | <code>number</code> | <code>2</code> | The amount the light dims along the distance of the light. |

<a name="PointLight+isPointLight"></a>

### pointLight.isPointLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PointLight+distance"></a>

### pointLight.distance : <code>number</code>
When distance is zero, light will attenuate according to inverse-square
law to infinite distance. When distance is non-zero, light will attenuate
according to inverse-square law until near the distance cutoff, where it
will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not
physically correct.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
**Default**: <code>0</code>  
<a name="PointLight+decay"></a>

### pointLight.decay : <code>number</code>
The amount the light dims along the distance of the light. In context of
physically-correct rendering the default value should not be changed.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
**Default**: <code>2</code>  
<a name="PointLight+shadow"></a>

### pointLight.shadow : <code>PointLightShadow</code>
This property holds the light's shadow configuration.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
<a name="PointLight+power"></a>

### pointLight.power : <code>number</code>
The light's power. Power is the luminous power of the light measured in lumens (lm).
Changing the power will also change the light's intensity.

**Kind**: instance property of [<code>PointLight</code>](#PointLight)  
<a name="PointLightShadow"></a>

## PointLightShadow ⇐ <code>LightShadow</code>
Represents the shadow configuration of point lights.

**Kind**: global class  
**Extends**: <code>LightShadow</code>  

* [PointLightShadow](#PointLightShadow) ⇐ <code>LightShadow</code>
    * [new PointLightShadow()](#new_PointLightShadow_new)
    * [.isPointLightShadow](#PointLightShadow+isPointLightShadow) : <code>boolean</code>
    * [.updateMatrices(light, [viewportIndex])](#PointLightShadow+updateMatrices)

<a name="new_PointLightShadow_new"></a>

### new PointLightShadow()
Constructs a new point light shadow.

<a name="PointLightShadow+isPointLightShadow"></a>

### pointLightShadow.isPointLightShadow : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointLightShadow</code>](#PointLightShadow)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PointLightShadow+updateMatrices"></a>

### pointLightShadow.updateMatrices(light, [viewportIndex])
Update the matrices for the camera and shadow, used internally by the renderer.

**Kind**: instance method of [<code>PointLightShadow</code>](#PointLightShadow)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>Light</code> |  | The light for which the shadow is being rendered. |
| [viewportIndex] | <code>number</code> | <code>0</code> | The viewport index. |

<a name="RectAreaLight"></a>

## RectAreaLight ⇐ <code>Light</code>
This class emits light uniformly across the face a rectangular plane.
This light type can be used to simulate light sources such as bright
windows or strip lighting.

Important Notes:

- There is no shadow support.
- Only PBR materials are supported.
- You have to include `RectAreaLightUniformsLib` (`WebGLRenderer`) or `RectAreaLightTexturesLib` (`WebGPURenderer`)
into your app and init the uniforms/textures.

```js
RectAreaLightUniformsLib.init(); // only relevant for WebGLRenderer
THREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() ); //  only relevant for WebGPURenderer

const intensity = 1; const width = 10; const height = 10;
const rectLight = new THREE.RectAreaLight( 0xffffff, intensity, width, height );
rectLight.position.set( 5, 5, 0 );
rectLight.lookAt( 0, 0, 0 );
scene.add( rectLight )
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [RectAreaLight](#RectAreaLight) ⇐ <code>Light</code>
    * [new RectAreaLight([color], [intensity], [width], [height])](#new_RectAreaLight_new)
    * [.isRectAreaLight](#RectAreaLight+isRectAreaLight) : <code>boolean</code>
    * [.width](#RectAreaLight+width) : <code>number</code>
    * [.height](#RectAreaLight+height) : <code>number</code>
    * [.power](#RectAreaLight+power) : <code>number</code>

<a name="new_RectAreaLight_new"></a>

### new RectAreaLight([color], [intensity], [width], [height])
Constructs a new area light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity. |
| [width] | <code>number</code> | <code>10</code> | The width of the light. |
| [height] | <code>number</code> | <code>10</code> | The height of the light. |

<a name="RectAreaLight+isRectAreaLight"></a>

### rectAreaLight.isRectAreaLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>RectAreaLight</code>](#RectAreaLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="RectAreaLight+width"></a>

### rectAreaLight.width : <code>number</code>
The width of the light.

**Kind**: instance property of [<code>RectAreaLight</code>](#RectAreaLight)  
**Default**: <code>10</code>  
<a name="RectAreaLight+height"></a>

### rectAreaLight.height : <code>number</code>
The height of the light.

**Kind**: instance property of [<code>RectAreaLight</code>](#RectAreaLight)  
**Default**: <code>10</code>  
<a name="RectAreaLight+power"></a>

### rectAreaLight.power : <code>number</code>
The light's power. Power is the luminous power of the light measured in lumens (lm).
Changing the power will also change the light's intensity.

**Kind**: instance property of [<code>RectAreaLight</code>](#RectAreaLight)  
<a name="SpotLight"></a>

## SpotLight ⇐ <code>Light</code>
This light gets emitted from a single point in one direction, along a cone
that increases in size the further from the light it gets.

This light can cast shadows - see the [SpotLightShadow](SpotLightShadow) for details.

```js
// white spotlight shining from the side, modulated by a texture
const spotLight = new THREE.SpotLight( 0xffffff );
spotLight.position.set( 100, 1000, 100 );
spotLight.map = new THREE.TextureLoader().load( url );

spotLight.castShadow = true;
spotLight.shadow.mapSize.width = 1024;
spotLight.shadow.mapSize.height = 1024;
spotLight.shadow.camera.near = 500;
spotLight.shadow.camera.far = 4000;
spotLight.shadow.camera.fov = 30;s
```

**Kind**: global class  
**Extends**: <code>Light</code>  

* [SpotLight](#SpotLight) ⇐ <code>Light</code>
    * [new SpotLight([color], [intensity], [distance], [angle], [penumbra], [decay])](#new_SpotLight_new)
    * [.isSpotLight](#SpotLight+isSpotLight) : <code>boolean</code>
    * [.target](#SpotLight+target) : <code>Object3D</code>
    * [.distance](#SpotLight+distance) : <code>number</code>
    * [.angle](#SpotLight+angle) : <code>number</code>
    * [.penumbra](#SpotLight+penumbra) : <code>number</code>
    * [.decay](#SpotLight+decay) : <code>number</code>
    * [.map](#SpotLight+map) : <code>Texture</code>
    * [.shadow](#SpotLight+shadow) : <code>SpotLightShadow</code>
    * [.power](#SpotLight+power) : <code>number</code>

<a name="new_SpotLight_new"></a>

### new SpotLight([color], [intensity], [distance], [angle], [penumbra], [decay])
Constructs a new spot light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity measured in candela (cd). |
| [distance] | <code>number</code> | <code>0</code> | Maximum range of the light. `0` means no limit. |
| [angle] | <code>number</code> | <code>Math.PI/3</code> | Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`. |
| [penumbra] | <code>number</code> | <code>0</code> | Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`. |
| [decay] | <code>number</code> | <code>2</code> | The amount the light dims along the distance of the light. |

<a name="SpotLight+isSpotLight"></a>

### spotLight.isSpotLight : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SpotLight+target"></a>

### spotLight.target : <code>Object3D</code>
The spot light points from its position to the
target's position.

For the target's position to be changed to anything other
than the default, it must be added to the scene.

It is also possible to set the target to be another 3D object
in the scene. The light will now track the target object.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
<a name="SpotLight+distance"></a>

### spotLight.distance : <code>number</code>
Maximum range of the light. `0` means no limit.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>0</code>  
<a name="SpotLight+angle"></a>

### spotLight.angle : <code>number</code>
Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>Math.PI/3</code>  
<a name="SpotLight+penumbra"></a>

### spotLight.penumbra : <code>number</code>
Percent of the spotlight cone that is attenuated due to penumbra.
Value range is `[0,1]`.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>0</code>  
<a name="SpotLight+decay"></a>

### spotLight.decay : <code>number</code>
The amount the light dims along the distance of the light. In context of
physically-correct rendering the default value should not be changed.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>2</code>  
<a name="SpotLight+map"></a>

### spotLight.map : <code>Texture</code>
A texture used to modulate the color of the light. The spot light
color is mixed with the RGB value of this texture, with a ratio
corresponding to its alpha value. The cookie-like masking effect is
reproduced using pixel values (0, 0, 0, 1-cookie_value).

*Warning*: This property is disabled if [Object3D#castShadow](Object3D#castShadow) is set to `false`.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
**Default**: <code>null</code>  
<a name="SpotLight+shadow"></a>

### spotLight.shadow : <code>SpotLightShadow</code>
This property holds the light's shadow configuration.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
<a name="SpotLight+power"></a>

### spotLight.power : <code>number</code>
The light's power. Power is the luminous power of the light measured in lumens (lm).
 Changing the power will also change the light's intensity.

**Kind**: instance property of [<code>SpotLight</code>](#SpotLight)  
<a name="SpotLightShadow"></a>

## SpotLightShadow ⇐ <code>LightShadow</code>
Represents the shadow configuration of directional lights.

**Kind**: global class  
**Extends**: <code>LightShadow</code>  

* [SpotLightShadow](#SpotLightShadow) ⇐ <code>LightShadow</code>
    * [new SpotLightShadow()](#new_SpotLightShadow_new)
    * [.isSpotLightShadow](#SpotLightShadow+isSpotLightShadow) : <code>boolean</code>
    * [.focus](#SpotLightShadow+focus) : <code>number</code>

<a name="new_SpotLightShadow_new"></a>

### new SpotLightShadow()
Constructs a new spot light shadow.

<a name="SpotLightShadow+isSpotLightShadow"></a>

### spotLightShadow.isSpotLightShadow : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SpotLightShadow</code>](#SpotLightShadow)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SpotLightShadow+focus"></a>

### spotLightShadow.focus : <code>number</code>
Used to focus the shadow camera. The camera's field of view is set as a
percentage of the spotlight's field-of-view. Range is `[0, 1]`.

**Kind**: instance property of [<code>SpotLightShadow</code>](#SpotLightShadow)  
**Default**: <code>1</code>  
<a name="IESSpotLight"></a>

## IESSpotLight ⇐ <code>SpotLight</code>
A IES version of [SpotLight](SpotLight). Can only be used with [WebGPURenderer](WebGPURenderer).

**Kind**: global class  
**Extends**: <code>SpotLight</code>  

* [IESSpotLight](#IESSpotLight) ⇐ <code>SpotLight</code>
    * [new IESSpotLight([color], [intensity], [distance], [angle], [penumbra], [decay])](#new_IESSpotLight_new)
    * [.iesMap](#IESSpotLight+iesMap) : <code>Texture</code>

<a name="new_IESSpotLight_new"></a>

### new IESSpotLight([color], [intensity], [distance], [angle], [penumbra], [decay])
Constructs a new IES spot light.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The light's color. |
| [intensity] | <code>number</code> | <code>1</code> | The light's strength/intensity measured in candela (cd). |
| [distance] | <code>number</code> | <code>0</code> | Maximum range of the light. `0` means no limit. |
| [angle] | <code>number</code> | <code>Math.PI/3</code> | Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`. |
| [penumbra] | <code>number</code> | <code>0</code> | Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`. |
| [decay] | <code>number</code> | <code>2</code> | The amount the light dims along the distance of the light. |

<a name="IESSpotLight+iesMap"></a>

### iesSpotLight.iesMap : <code>Texture</code>
TODO

**Kind**: instance property of [<code>IESSpotLight</code>](#IESSpotLight)  
**Default**: <code>null</code>  
<a name="AnimationLoader"></a>

## AnimationLoader ⇐ <code>Loader</code>
Class for loading animation clips in the JSON format. The files are internally
loaded via [FileLoader](FileLoader).

```js
const loader = new THREE.AnimationLoader();
const animations = await loader.loadAsync( 'animations/animation.js' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [AnimationLoader](#AnimationLoader) ⇐ <code>Loader</code>
    * [new AnimationLoader([manager])](#new_AnimationLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#AnimationLoader+load)
    * [.parse(json)](#AnimationLoader+parse) ⇒ <code>Array.&lt;AnimationClip&gt;</code>

<a name="new_AnimationLoader_new"></a>

### new AnimationLoader([manager])
Constructs a new animation loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="AnimationLoader+load"></a>

### animationLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and pass the loaded animations as an array
holding instances of [AnimationClip](AnimationClip) to the `onLoad()` callback.

**Kind**: instance method of [<code>AnimationLoader</code>](#AnimationLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="AnimationLoader+parse"></a>

### animationLoader.parse(json) ⇒ <code>Array.&lt;AnimationClip&gt;</code>
Parses the given JSON object and returns an array of animation clips.

**Kind**: instance method of [<code>AnimationLoader</code>](#AnimationLoader)  
**Returns**: <code>Array.&lt;AnimationClip&gt;</code> - The parsed animation clips.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized animation clips. |

<a name="AudioLoader"></a>

## AudioLoader ⇐ <code>Loader</code>
Class for loading audio buffers. Audios are internally
loaded via [FileLoader](FileLoader).

```js
const audioListener = new THREE.AudioListener();
const ambientSound = new THREE.Audio( audioListener );

const loader = new THREE.AudioLoader();
const audioBuffer = await loader.loadAsync( 'audio/ambient_ocean.ogg' );

ambientSound.setBuffer( audioBuffer );
ambientSound.play();
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [AudioLoader](#AudioLoader) ⇐ <code>Loader</code>
    * [new AudioLoader([manager])](#new_AudioLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#AudioLoader+load)

<a name="new_AudioLoader_new"></a>

### new AudioLoader([manager])
Constructs a new audio loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="AudioLoader+load"></a>

### audioLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded audio buffer
to the `onLoad()` callback.

**Kind**: instance method of [<code>AudioLoader</code>](#AudioLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="BufferGeometryLoader"></a>

## BufferGeometryLoader ⇐ <code>Loader</code>
Class for loading geometries. The files are internally
loaded via [FileLoader](FileLoader).

```js
const loader = new THREE.BufferGeometryLoader();
const geometry = await loader.loadAsync( 'models/json/pressure.json' );

const material = new THREE.MeshBasicMaterial( { color: 0xF5F5F5 } );
const object = new THREE.Mesh( geometry, material );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [BufferGeometryLoader](#BufferGeometryLoader) ⇐ <code>Loader</code>
    * [new BufferGeometryLoader([manager])](#new_BufferGeometryLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#BufferGeometryLoader+load)
    * [.parse(json)](#BufferGeometryLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_BufferGeometryLoader_new"></a>

### new BufferGeometryLoader([manager])
Constructs a new geometry loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="BufferGeometryLoader+load"></a>

### bufferGeometryLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and pass the loaded geometry to the `onLoad()` callback.

**Kind**: instance method of [<code>BufferGeometryLoader</code>](#BufferGeometryLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="BufferGeometryLoader+parse"></a>

### bufferGeometryLoader.parse(json) ⇒ <code>BufferGeometry</code>
Parses the given JSON object and returns a geometry.

**Kind**: instance method of [<code>BufferGeometryLoader</code>](#BufferGeometryLoader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized geometry. |

<a name="Cache"></a>

## Cache
A simple caching system, used internally by [FileLoader](FileLoader).
To enable caching across all loaders that use [FileLoader](FileLoader), add `THREE.Cache.enabled = true.` once in your app.

**Kind**: global class  

* [Cache](#Cache)
    * [.enabled](#Cache.enabled) : <code>boolean</code>
    * [.files](#Cache.files) : <code>Object.&lt;string, Object&gt;</code>
    * [.add(key, file)](#Cache.add)
    * [.get(key)](#Cache.get) ⇒ <code>Object</code> \| <code>undefined</code>
    * [.remove(key)](#Cache.remove)
    * [.clear()](#Cache.clear)

<a name="Cache.enabled"></a>

### Cache.enabled : <code>boolean</code>
Whether caching is enabled or not.

**Kind**: static property of [<code>Cache</code>](#Cache)  
**Default**: <code>false</code>  
<a name="Cache.files"></a>

### Cache.files : <code>Object.&lt;string, Object&gt;</code>
A dictionary that holds cached files.

**Kind**: static property of [<code>Cache</code>](#Cache)  
<a name="Cache.add"></a>

### Cache.add(key, file)
Adds a cache entry with a key to reference the file. If this key already
holds a file, it is overwritten.

**Kind**: static method of [<code>Cache</code>](#Cache)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | The key to reference the cached file. |
| file | <code>Object</code> | The file to be cached. |

<a name="Cache.get"></a>

### Cache.get(key) ⇒ <code>Object</code> \| <code>undefined</code>
Gets the cached value for the given key.

**Kind**: static method of [<code>Cache</code>](#Cache)  
**Returns**: <code>Object</code> \| <code>undefined</code> - The cached file. If the key does not exist `undefined` is returned.  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | The key to reference the cached file. |

<a name="Cache.remove"></a>

### Cache.remove(key)
Removes the cached file associated with the given key.

**Kind**: static method of [<code>Cache</code>](#Cache)  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>string</code> | The key to reference the cached file. |

<a name="Cache.clear"></a>

### Cache.clear()
Remove all values from the cache.

**Kind**: static method of [<code>Cache</code>](#Cache)  
<a name="CompressedTextureLoader"></a>

## *CompressedTextureLoader ⇐ <code>Loader</code>*
Abstract base class for loading compressed texture formats S3TC, ASTC or ETC.
Textures are internally loaded via [FileLoader](FileLoader).

Derived classes have to implement the `parse()` method which holds the parsing
for the respective format.

**Kind**: global abstract class  
**Extends**: <code>Loader</code>  

* *[CompressedTextureLoader](#CompressedTextureLoader) ⇐ <code>Loader</code>*
    * *[new CompressedTextureLoader([manager])](#new_CompressedTextureLoader_new)*
    * _instance_
        * *[.load(url, onLoad, onProgress, onError)](#CompressedTextureLoader+load) ⇒ <code>CompressedTexture</code>*
    * _inner_
        * *[~TexData](#CompressedTextureLoader..TexData) : <code>Object</code>*

<a name="new_CompressedTextureLoader_new"></a>

### *new CompressedTextureLoader([manager])*
Constructs a new compressed texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="CompressedTextureLoader+load"></a>

### *compressedTextureLoader.load(url, onLoad, onProgress, onError) ⇒ <code>CompressedTexture</code>*
Starts loading from the given URL and passes the loaded compressed texture
to the `onLoad()` callback. The method also returns a new texture object which can
directly be used for material creation. If you do it this way, the texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>CompressedTextureLoader</code>](#CompressedTextureLoader)  
**Returns**: <code>CompressedTexture</code> - The compressed texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="CompressedTextureLoader..TexData"></a>

### *CompressedTextureLoader~TexData : <code>Object</code>*
Represents the result object type of the `parse()` method.

**Kind**: inner typedef of [<code>CompressedTextureLoader</code>](#CompressedTextureLoader)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the base mip. |
| height | <code>number</code> | The width of the base mip. |
| isCubemap | <code>boolean</code> | Whether the data represent a cubemap or not. |
| mipmapCount | <code>number</code> | The mipmap count. |
| mipmaps | <code>Array.&lt;{data:TypedArray, width:number, height:number}&gt;</code> | An array holding the mipmaps. Each entry holds the data and the dimensions for each level. |
| format | <code>number</code> | The texture format. |

<a name="CubeTextureLoader"></a>

## CubeTextureLoader ⇐ <code>Loader</code>
Class for loading cube textures. Images are internally loaded via [ImageLoader](ImageLoader).

The loader returns an instance of [CubeTexture](CubeTexture) and expects the cube map to
be defined as six separate images representing the sides of a cube. Other cube map definitions
like vertical and horizontal cross, column and row layouts are not supported.

Note that, by convention, cube maps are specified in a coordinate system
in which positive-x is to the right when looking up the positive-z axis --
in other words, using a left-handed coordinate system. Since three.js uses
a right-handed coordinate system, environment maps used in three.js will
have pos-x and neg-x swapped.

The loaded cube texture is in sRGB color space. Meaning [Texture#colorSpace](Texture#colorSpace)
is set to `SRGBColorSpace` by default.

```js
const loader = new THREE.CubeTextureLoader().setPath( 'textures/cubeMaps/' );
const cubeTexture = await loader.loadAsync( [
	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
] );
scene.background = cubeTexture;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [CubeTextureLoader](#CubeTextureLoader) ⇐ <code>Loader</code>
    * [new CubeTextureLoader([manager])](#new_CubeTextureLoader_new)
    * [.load(urls, onLoad, onProgress, onError)](#CubeTextureLoader+load) ⇒ <code>CubeTexture</code>

<a name="new_CubeTextureLoader_new"></a>

### new CubeTextureLoader([manager])
Constructs a new cube texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="CubeTextureLoader+load"></a>

### cubeTextureLoader.load(urls, onLoad, onProgress, onError) ⇒ <code>CubeTexture</code>
Starts loading from the given URL and pass the fully loaded cube texture
to the `onLoad()` callback. The method also returns a new cube texture object which can
directly be used for material creation. If you do it this way, the cube texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>CubeTextureLoader</code>](#CubeTextureLoader)  
**Returns**: <code>CubeTexture</code> - The cube texture.  

| Param | Type | Description |
| --- | --- | --- |
| urls | <code>Array.&lt;string&gt;</code> | Array of 6 URLs to images, one for each side of the cube texture. The urls should be specified in the following order: pos-x, neg-x, pos-y, neg-y, pos-z, neg-z. An array of data URIs are allowed as well. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Unsupported in this loader. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="DataTextureLoader"></a>

## *DataTextureLoader ⇐ <code>Loader</code>*
Abstract base class for loading binary texture formats RGBE, EXR or TGA.
Textures are internally loaded via [FileLoader](FileLoader).

Derived classes have to implement the `parse()` method which holds the parsing
for the respective format.

**Kind**: global abstract class  
**Extends**: <code>Loader</code>  

* *[DataTextureLoader](#DataTextureLoader) ⇐ <code>Loader</code>*
    * *[new DataTextureLoader([manager])](#new_DataTextureLoader_new)*
    * _instance_
        * *[.load(url, onLoad, onProgress, onError)](#DataTextureLoader+load) ⇒ <code>DataTexture</code>*
    * _inner_
        * *[~TexData](#DataTextureLoader..TexData) : <code>Object</code>*

<a name="new_DataTextureLoader_new"></a>

### *new DataTextureLoader([manager])*
Constructs a new data texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="DataTextureLoader+load"></a>

### *dataTextureLoader.load(url, onLoad, onProgress, onError) ⇒ <code>DataTexture</code>*
Starts loading from the given URL and passes the loaded data texture
to the `onLoad()` callback. The method also returns a new texture object which can
directly be used for material creation. If you do it this way, the texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>DataTextureLoader</code>](#DataTextureLoader)  
**Returns**: <code>DataTexture</code> - The data texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="DataTextureLoader..TexData"></a>

### *DataTextureLoader~TexData : <code>Object</code>*
Represents the result object type of the `parse()` method.

**Kind**: inner typedef of [<code>DataTextureLoader</code>](#DataTextureLoader)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [image] | <code>Object</code> |  | An object holding width, height and the texture data. |
| [width] | <code>number</code> |  | The width of the base mip. |
| [height] | <code>number</code> |  | The width of the base mip. |
| [data] | <code>TypedArray</code> |  | The texture data. |
| [format] | <code>number</code> |  | The texture format. |
| [type] | <code>number</code> |  | The texture type. |
| [flipY] | <code>boolean</code> |  | If set to `true`, the texture is flipped along the vertical axis when uploaded to the GPU. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [anisotropy] | <code>number</code> | <code>1</code> | The anisotropy value. |
| [generateMipmaps] | <code>boolean</code> |  | Whether to generate mipmaps or not. |
| [colorSpace] | <code>string</code> |  | The color space. |
| [magFilter] | <code>number</code> |  | The mag filter. |
| [minFilter] | <code>number</code> |  | The min filter. |
| [mipmaps] | <code>Array.&lt;Object&gt;</code> |  | The mipmaps. |

<a name="FileLoader"></a>

## FileLoader ⇐ <code>Loader</code>
A low level class for loading resources with the Fetch API, used internally by
most loaders. It can also be used directly to load any file type that does
not have a loader.

This loader supports caching. If you want to use it, add `THREE.Cache.enabled = true;`
once to your application.

```js
const loader = new THREE.FileLoader();
const data = await loader.loadAsync( 'example.txt' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [FileLoader](#FileLoader) ⇐ <code>Loader</code>
    * [new FileLoader([manager])](#new_FileLoader_new)
    * [.mimeType](#FileLoader+mimeType) : <code>string</code>
    * [.responseType](#FileLoader+responseType) : <code>&#x27;arraybuffer&#x27;</code> \| <code>&#x27;blob&#x27;</code> \| <code>&#x27;document&#x27;</code> \| <code>&#x27;json&#x27;</code> \| <code>&#x27;&#x27;</code>
    * [.load(url, onLoad, [onProgress], [onError])](#FileLoader+load) ⇒ <code>any</code> \| <code>undefined</code>
    * [.setResponseType(value)](#FileLoader+setResponseType) ⇒ [<code>FileLoader</code>](#FileLoader)
    * [.setMimeType(value)](#FileLoader+setMimeType) ⇒ [<code>FileLoader</code>](#FileLoader)

<a name="new_FileLoader_new"></a>

### new FileLoader([manager])
Constructs a new file loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="FileLoader+mimeType"></a>

### fileLoader.mimeType : <code>string</code>
The expected mime type.

**Kind**: instance property of [<code>FileLoader</code>](#FileLoader)  
<a name="FileLoader+responseType"></a>

### fileLoader.responseType : <code>&#x27;arraybuffer&#x27;</code> \| <code>&#x27;blob&#x27;</code> \| <code>&#x27;document&#x27;</code> \| <code>&#x27;json&#x27;</code> \| <code>&#x27;&#x27;</code>
The expected response type.

**Kind**: instance property of [<code>FileLoader</code>](#FileLoader)  
**Default**: <code>&#x27;&#x27;</code>  
<a name="FileLoader+load"></a>

### fileLoader.load(url, onLoad, [onProgress], [onError]) ⇒ <code>any</code> \| <code>undefined</code>
Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.

**Kind**: instance method of [<code>FileLoader</code>](#FileLoader)  
**Returns**: <code>any</code> \| <code>undefined</code> - The cached resource if available.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| [onProgress] | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| [onError] | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="FileLoader+setResponseType"></a>

### fileLoader.setResponseType(value) ⇒ [<code>FileLoader</code>](#FileLoader)
Sets the expected response type.

**Kind**: instance method of [<code>FileLoader</code>](#FileLoader)  
**Returns**: [<code>FileLoader</code>](#FileLoader) - A reference to this file loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>&#x27;arraybuffer&#x27;</code> \| <code>&#x27;blob&#x27;</code> \| <code>&#x27;document&#x27;</code> \| <code>&#x27;json&#x27;</code> \| <code>&#x27;&#x27;</code> | The response type. |

<a name="FileLoader+setMimeType"></a>

### fileLoader.setMimeType(value) ⇒ [<code>FileLoader</code>](#FileLoader)
Sets the expected mime type of the loaded file.

**Kind**: instance method of [<code>FileLoader</code>](#FileLoader)  
**Returns**: [<code>FileLoader</code>](#FileLoader) - A reference to this file loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>string</code> | The mime type. |

<a name="ImageBitmapLoader"></a>

## ImageBitmapLoader ⇐ <code>Loader</code>
A loader for loading images as an [ImageBitmap](https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap).
An `ImageBitmap` provides an asynchronous and resource efficient pathway to prepare
textures for rendering.

Note that [Texture#flipY](Texture#flipY) and [Texture#premultiplyAlpha](Texture#premultiplyAlpha) are ignored with image bitmaps.
They needs these configuration on bitmap creation unlike regular images need them on uploading to GPU.

You need to set the equivalent options via [setOptions](#ImageBitmapLoader+setOptions) instead.

Also note that unlike [FileLoader](FileLoader), this loader does not avoid multiple concurrent requests to the same URL.

```js
const loader = new THREE.ImageBitmapLoader();
loader.setOptions( { imageOrientation: 'flipY' } ); // set options if needed
const imageBitmap = await loader.loadAsync( 'image.png' );

const texture = new THREE.Texture( imageBitmap );
texture.needsUpdate = true;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ImageBitmapLoader](#ImageBitmapLoader) ⇐ <code>Loader</code>
    * [new ImageBitmapLoader([manager])](#new_ImageBitmapLoader_new)
    * [.isImageBitmapLoader](#ImageBitmapLoader+isImageBitmapLoader) : <code>boolean</code>
    * [.options](#ImageBitmapLoader+options) : <code>Object</code>
    * [.setOptions(options)](#ImageBitmapLoader+setOptions) ⇒ [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)
    * [.load(url, onLoad, onProgress, onError)](#ImageBitmapLoader+load) ⇒ <code>ImageBitmap</code> \| <code>undefined</code>

<a name="new_ImageBitmapLoader_new"></a>

### new ImageBitmapLoader([manager])
Constructs a new image bitmap loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="ImageBitmapLoader+isImageBitmapLoader"></a>

### imageBitmapLoader.isImageBitmapLoader : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ImageBitmapLoader+options"></a>

### imageBitmapLoader.options : <code>Object</code>
Represents the loader options.

**Kind**: instance property of [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)  
**Default**: <code>{premultiplyAlpha:&#x27;none&#x27;}</code>  
<a name="ImageBitmapLoader+setOptions"></a>

### imageBitmapLoader.setOptions(options) ⇒ [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)
Sets the given loader options. The structure of the object must match the `options` parameter of
[createImageBitmap](https://developer.mozilla.org/en-US/docs/Web/API/Window/createImageBitmap).

**Kind**: instance method of [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)  
**Returns**: [<code>ImageBitmapLoader</code>](#ImageBitmapLoader) - A reference to this image bitmap loader.  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>Object</code> | The loader options to set. |

<a name="ImageBitmapLoader+load"></a>

### imageBitmapLoader.load(url, onLoad, onProgress, onError) ⇒ <code>ImageBitmap</code> \| <code>undefined</code>
Starts loading from the given URL and pass the loaded image bitmap to the `onLoad()` callback.

**Kind**: instance method of [<code>ImageBitmapLoader</code>](#ImageBitmapLoader)  
**Returns**: <code>ImageBitmap</code> \| <code>undefined</code> - The image bitmap.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Unsupported in this loader. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="ImageLoader"></a>

## ImageLoader ⇐ <code>Loader</code>
A loader for loading images. The class loads images with the HTML `Image` API.

```js
const loader = new THREE.ImageLoader();
const image = await loader.loadAsync( 'image.png' );
```
Please note that `ImageLoader` has dropped support for progress
events in `r84`. For an `ImageLoader` that supports progress events, see
[this thread](https://github.com/mrdoob/three.js/issues/10439#issuecomment-275785639).

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ImageLoader](#ImageLoader) ⇐ <code>Loader</code>
    * [new ImageLoader([manager])](#new_ImageLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#ImageLoader+load) ⇒ <code>Image</code>

<a name="new_ImageLoader_new"></a>

### new ImageLoader([manager])
Constructs a new image loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="ImageLoader+load"></a>

### imageLoader.load(url, onLoad, onProgress, onError) ⇒ <code>Image</code>
Starts loading from the given URL and passes the loaded image
to the `onLoad()` callback. The method also returns a new `Image` object which can
directly be used for texture creation. If you do it this way, the texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>ImageLoader</code>](#ImageLoader)  
**Returns**: <code>Image</code> - The image.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Unsupported in this loader. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

## Classes

<dl>
<dt><a href="#Loader">Loader</a></dt>
<dd><p>Abstract base class for loaders.</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#onProgressCallback">onProgressCallback</a> : <code>function</code></dt>
<dd><p>Callback for onProgress in loaders.</p>
</dd>
<dt><a href="#onErrorCallback">onErrorCallback</a> : <code>function</code></dt>
<dd><p>Callback for onError in loaders.</p>
</dd>
</dl>

<a name="Loader"></a>

## *Loader*
Abstract base class for loaders.

**Kind**: global abstract class  

* *[Loader](#Loader)*
    * *[new Loader([manager])](#new_Loader_new)*
    * _instance_
        * *[.manager](#Loader+manager) : <code>LoadingManager</code>*
        * *[.crossOrigin](#Loader+crossOrigin) : <code>string</code>*
        * *[.withCredentials](#Loader+withCredentials) : <code>boolean</code>*
        * *[.path](#Loader+path) : <code>string</code>*
        * *[.resourcePath](#Loader+resourcePath) : <code>string</code>*
        * *[.requestHeader](#Loader+requestHeader) : <code>Object.&lt;string, any&gt;</code>*
        * *[.load(url, onLoad, [onProgress], [onError])](#Loader+load)*
        * *[.loadAsync(url, [onProgress])](#Loader+loadAsync) ⇒ <code>Promise</code>*
        * *[.parse(data)](#Loader+parse)*
        * *[.setCrossOrigin(crossOrigin)](#Loader+setCrossOrigin) ⇒ [<code>Loader</code>](#Loader)*
        * *[.setWithCredentials(value)](#Loader+setWithCredentials) ⇒ [<code>Loader</code>](#Loader)*
        * *[.setPath(path)](#Loader+setPath) ⇒ [<code>Loader</code>](#Loader)*
        * *[.setResourcePath(resourcePath)](#Loader+setResourcePath) ⇒ [<code>Loader</code>](#Loader)*
        * *[.setRequestHeader(requestHeader)](#Loader+setRequestHeader) ⇒ [<code>Loader</code>](#Loader)*
    * _static_
        * *[.DEFAULT_MATERIAL_NAME](#Loader.DEFAULT_MATERIAL_NAME) : <code>string</code>*

<a name="new_Loader_new"></a>

### *new Loader([manager])*
Constructs a new loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="Loader+manager"></a>

### *loader.manager : <code>LoadingManager</code>*
The loading manager.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
**Default**: <code>DefaultLoadingManager</code>  
<a name="Loader+crossOrigin"></a>

### *loader.crossOrigin : <code>string</code>*
The crossOrigin string to implement CORS for loading the url from a
different domain that allows CORS.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
**Default**: <code>&quot;&#x27;anonymous&#x27;&quot;</code>  
<a name="Loader+withCredentials"></a>

### *loader.withCredentials : <code>boolean</code>*
Whether the XMLHttpRequest uses credentials.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
**Default**: <code>false</code>  
<a name="Loader+path"></a>

### *loader.path : <code>string</code>*
The base path from which the asset will be loaded.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
<a name="Loader+resourcePath"></a>

### *loader.resourcePath : <code>string</code>*
The base path from which additional resources like textures will be loaded.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
<a name="Loader+requestHeader"></a>

### *loader.requestHeader : <code>Object.&lt;string, any&gt;</code>*
The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header)
used in HTTP request.

**Kind**: instance property of [<code>Loader</code>](#Loader)  
<a name="Loader+load"></a>

### *loader.load(url, onLoad, [onProgress], [onError])*
This method needs to be implemented by all concrete loaders. It holds the
logic for loading assets from the backend.

**Kind**: instance method of [<code>Loader</code>](#Loader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| [onProgress] | [<code>onProgressCallback</code>](#onProgressCallback) | Executed while the loading is in progress. |
| [onError] | [<code>onErrorCallback</code>](#onErrorCallback) | Executed when errors occur. |

<a name="Loader+loadAsync"></a>

### *loader.loadAsync(url, [onProgress]) ⇒ <code>Promise</code>*
A async version of [load](#Loader+load).

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: <code>Promise</code> - A Promise that resolves when the asset has been loaded.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. |
| [onProgress] | [<code>onProgressCallback</code>](#onProgressCallback) | Executed while the loading is in progress. |

<a name="Loader+parse"></a>

### *loader.parse(data)*
This method needs to be implemented by all concrete loaders. It holds the
logic for parsing the asset into three.js entities.

**Kind**: instance method of [<code>Loader</code>](#Loader)  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>any</code> | The data to parse. |

<a name="Loader+setCrossOrigin"></a>

### *loader.setCrossOrigin(crossOrigin) ⇒ [<code>Loader</code>](#Loader)*
Sets the `crossOrigin` String to implement CORS for loading the URL
from a different domain that allows CORS.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| crossOrigin | <code>string</code> | The `crossOrigin` value. |

<a name="Loader+setWithCredentials"></a>

### *loader.setWithCredentials(value) ⇒ [<code>Loader</code>](#Loader)*
Whether the XMLHttpRequest uses credentials such as cookies, authorization
headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials).

Note: This setting has no effect if you are loading files locally or from the same domain.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The `withCredentials` value. |

<a name="Loader+setPath"></a>

### *loader.setPath(path) ⇒ [<code>Loader</code>](#Loader)*
Sets the base path for the asset.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The base path. |

<a name="Loader+setResourcePath"></a>

### *loader.setResourcePath(resourcePath) ⇒ [<code>Loader</code>](#Loader)*
Sets the base path for dependent resources like textures.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| resourcePath | <code>string</code> | The resource path. |

<a name="Loader+setRequestHeader"></a>

### *loader.setRequestHeader(requestHeader) ⇒ [<code>Loader</code>](#Loader)*
Sets the given request header.

**Kind**: instance method of [<code>Loader</code>](#Loader)  
**Returns**: [<code>Loader</code>](#Loader) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| requestHeader | <code>Object</code> | A [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) for configuring the HTTP request. |

<a name="Loader.DEFAULT_MATERIAL_NAME"></a>

### *Loader.DEFAULT\_MATERIAL\_NAME : <code>string</code>*
The default material name that is used by loaders
when creating materials for loaded 3D objects.

Note: Not all loaders might honor this setting.

**Kind**: static property of [<code>Loader</code>](#Loader)  
**Default**: <code>&quot;&#x27;__DEFAULT&#x27;&quot;</code>  
<a name="onProgressCallback"></a>

## onProgressCallback : <code>function</code>
Callback for onProgress in loaders.

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| event | <code>ProgressEvent</code> | An instance of `ProgressEvent` that represents the current loading status. |

<a name="onErrorCallback"></a>

## onErrorCallback : <code>function</code>
Callback for onError in loaders.

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| error | <code>Error</code> | The error which occurred during the loading process. |

<a name="LoaderUtils"></a>

## LoaderUtils
A class with loader utility functions.

**Kind**: global class  

* [LoaderUtils](#LoaderUtils)
    * [.extractUrlBase(url)](#LoaderUtils.extractUrlBase) ⇒ <code>string</code>
    * [.resolveURL(url, path)](#LoaderUtils.resolveURL) ⇒ <code>string</code>

<a name="LoaderUtils.extractUrlBase"></a>

### LoaderUtils.extractUrlBase(url) ⇒ <code>string</code>
Extracts the base URL from the given URL.

**Kind**: static method of [<code>LoaderUtils</code>](#LoaderUtils)  
**Returns**: <code>string</code> - The extracted base URL.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL to extract the base URL from. |

<a name="LoaderUtils.resolveURL"></a>

### LoaderUtils.resolveURL(url, path) ⇒ <code>string</code>
Resolves relative URLs against the given path. Absolute paths, data urls,
and blob URLs will be returned as is. Invalid URLs will return an empty
string.

**Kind**: static method of [<code>LoaderUtils</code>](#LoaderUtils)  
**Returns**: <code>string</code> - The resolved URL.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL to resolve. |
| path | <code>string</code> | The base path for relative URLs to be resolved against. |

## Classes

<dl>
<dt><a href="#LoadingManager">LoadingManager</a></dt>
<dd><p>Handles and keeps track of loaded and pending data. A default global
instance of this class is created and used by loaders if not supplied
manually.</p>
<p>In general that should be sufficient, however there are times when it can
be useful to have separate loaders - for example if you want to show
separate loading bars for objects and textures.</p>
<pre><code class="language-js">const manager = new THREE.LoadingManager();
manager.onLoad = () =&gt; console.log( &#39;Loading complete!&#39; );

const loader1 = new OBJLoader( manager );
const loader2 = new ColladaLoader( manager );
</code></pre>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#DefaultLoadingManager">DefaultLoadingManager</a> : <code><a href="#LoadingManager">LoadingManager</a></code></dt>
<dd><p>The global default loading manager.</p>
</dd>
</dl>

<a name="LoadingManager"></a>

## LoadingManager
Handles and keeps track of loaded and pending data. A default global
instance of this class is created and used by loaders if not supplied
manually.

In general that should be sufficient, however there are times when it can
be useful to have separate loaders - for example if you want to show
separate loading bars for objects and textures.

```js
const manager = new THREE.LoadingManager();
manager.onLoad = () => console.log( 'Loading complete!' );

const loader1 = new OBJLoader( manager );
const loader2 = new ColladaLoader( manager );
```

**Kind**: global class  

* [LoadingManager](#LoadingManager)
    * [new LoadingManager([onLoad], [onProgress], [onError])](#new_LoadingManager_new)
    * [.onStart](#LoadingManager+onStart) : <code>function</code> \| <code>undefined</code>
    * [.onLoad](#LoadingManager+onLoad) : <code>function</code> \| <code>undefined</code>
    * [.onProgress](#LoadingManager+onProgress) : <code>function</code> \| <code>undefined</code>
    * [.onError](#LoadingManager+onError) : <code>function</code> \| <code>undefined</code>
    * [.itemStart(url)](#LoadingManager+itemStart)
    * [.itemEnd(url)](#LoadingManager+itemEnd)
    * [.itemError(url)](#LoadingManager+itemError)
    * [.resolveURL(url)](#LoadingManager+resolveURL) ⇒ <code>string</code>
    * [.setURLModifier(transform)](#LoadingManager+setURLModifier) ⇒ [<code>LoadingManager</code>](#LoadingManager)
    * [.addHandler(regex, loader)](#LoadingManager+addHandler) ⇒ [<code>LoadingManager</code>](#LoadingManager)
    * [.removeHandler(regex)](#LoadingManager+removeHandler) ⇒ [<code>LoadingManager</code>](#LoadingManager)
    * [.getHandler(file)](#LoadingManager+getHandler) ⇒ <code>Loader</code>

<a name="new_LoadingManager_new"></a>

### new LoadingManager([onLoad], [onProgress], [onError])
Constructs a new loading manager.


| Param | Type | Description |
| --- | --- | --- |
| [onLoad] | <code>function</code> | Executes when all items have been loaded. |
| [onProgress] | <code>function</code> | Executes when single items have been loaded. |
| [onError] | <code>function</code> | Executes when an error occurs. |

<a name="LoadingManager+onStart"></a>

### loadingManager.onStart : <code>function</code> \| <code>undefined</code>
Executes when an item starts loading.

**Kind**: instance property of [<code>LoadingManager</code>](#LoadingManager)  
**Default**: <code>undefined</code>  
<a name="LoadingManager+onLoad"></a>

### loadingManager.onLoad : <code>function</code> \| <code>undefined</code>
Executes when all items have been loaded.

**Kind**: instance property of [<code>LoadingManager</code>](#LoadingManager)  
**Default**: <code>undefined</code>  
<a name="LoadingManager+onProgress"></a>

### loadingManager.onProgress : <code>function</code> \| <code>undefined</code>
Executes when single items have been loaded.

**Kind**: instance property of [<code>LoadingManager</code>](#LoadingManager)  
**Default**: <code>undefined</code>  
<a name="LoadingManager+onError"></a>

### loadingManager.onError : <code>function</code> \| <code>undefined</code>
Executes when an error occurs.

**Kind**: instance property of [<code>LoadingManager</code>](#LoadingManager)  
**Default**: <code>undefined</code>  
<a name="LoadingManager+itemStart"></a>

### loadingManager.itemStart(url)
This should be called by any loader using the manager when the loader
starts loading an item.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL to load. |

<a name="LoadingManager+itemEnd"></a>

### loadingManager.itemEnd(url)
This should be called by any loader using the manager when the loader
ended loading an item.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL of the loaded item. |

<a name="LoadingManager+itemError"></a>

### loadingManager.itemError(url)
This should be called by any loader using the manager when the loader
encounters an error when loading an item.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL of the item that produces an error. |

<a name="LoadingManager+resolveURL"></a>

### loadingManager.resolveURL(url) ⇒ <code>string</code>
Given a URL, uses the URL modifier callback (if any) and returns a
resolved URL. If no URL modifier is set, returns the original URL.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: <code>string</code> - The resolved URL.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The URL to load. |

<a name="LoadingManager+setURLModifier"></a>

### loadingManager.setURLModifier(transform) ⇒ [<code>LoadingManager</code>](#LoadingManager)
If provided, the callback will be passed each resource URL before a
request is sent. The callback may return the original URL, or a new URL to
override loading behavior. This behavior can be used to load assets from
.ZIP files, drag-and-drop APIs, and Data URIs.

```js
const blobs = {'fish.gltf': blob1, 'diffuse.png': blob2, 'normal.png': blob3};

const manager = new THREE.LoadingManager();

// Initialize loading manager with URL callback.
const objectURLs = [];
manager.setURLModifier( ( url ) => {

	url = URL.createObjectURL( blobs[ url ] );
	objectURLs.push( url );
	return url;

} );

// Load as usual, then revoke the blob URLs.
const loader = new GLTFLoader( manager );
loader.load( 'fish.gltf', (gltf) => {

	scene.add( gltf.scene );
	objectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) );

} );
```

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: [<code>LoadingManager</code>](#LoadingManager) - A reference to this loading manager.  

| Param | Type | Description |
| --- | --- | --- |
| transform | <code>function</code> | URL modifier callback. Called with an URL and must return a resolved URL. |

<a name="LoadingManager+addHandler"></a>

### loadingManager.addHandler(regex, loader) ⇒ [<code>LoadingManager</code>](#LoadingManager)
Registers a loader with the given regular expression. Can be used to
define what loader should be used in order to load specific files. A
typical use case is to overwrite the default loader for textures.

```js
// add handler for TGA textures
manager.addHandler( /\.tga$/i, new TGALoader() );
```

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: [<code>LoadingManager</code>](#LoadingManager) - A reference to this loading manager.  

| Param | Type | Description |
| --- | --- | --- |
| regex | <code>string</code> | A regular expression. |
| loader | <code>Loader</code> | A loader that should handle matched cases. |

<a name="LoadingManager+removeHandler"></a>

### loadingManager.removeHandler(regex) ⇒ [<code>LoadingManager</code>](#LoadingManager)
Removes the loader for the given regular expression.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: [<code>LoadingManager</code>](#LoadingManager) - A reference to this loading manager.  

| Param | Type | Description |
| --- | --- | --- |
| regex | <code>string</code> | A regular expression. |

<a name="LoadingManager+getHandler"></a>

### loadingManager.getHandler(file) ⇒ <code>Loader</code>
Can be used to retrieve the registered loader for the given file path.

**Kind**: instance method of [<code>LoadingManager</code>](#LoadingManager)  
**Returns**: <code>Loader</code> - The registered loader. Returns `null` if no loader was found.  

| Param | Type | Description |
| --- | --- | --- |
| file | <code>string</code> | The file path. |

<a name="DefaultLoadingManager"></a>

## DefaultLoadingManager : [<code>LoadingManager</code>](#LoadingManager)
The global default loading manager.

**Kind**: global constant  
<a name="MaterialLoader"></a>

## MaterialLoader ⇐ <code>Loader</code>
Class for loading geometries. The files are internally
loaded via [FileLoader](FileLoader).

```js
const loader = new THREE.MaterialLoader();
const material = await loader.loadAsync( 'material.json' );
```
This loader does not support node materials. Use [NodeMaterialLoader](NodeMaterialLoader) instead.

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MaterialLoader](#MaterialLoader) ⇐ <code>Loader</code>
    * [new MaterialLoader([manager])](#new_MaterialLoader_new)
    * _instance_
        * [.textures](#MaterialLoader+textures) : <code>Object.&lt;string, Texture&gt;</code>
        * [.load(url, onLoad, onProgress, onError)](#MaterialLoader+load)
        * [.parse(json)](#MaterialLoader+parse) ⇒ <code>Material</code>
        * [.setTextures(value)](#MaterialLoader+setTextures) ⇒ [<code>MaterialLoader</code>](#MaterialLoader)
        * [.createMaterialFromType(type)](#MaterialLoader+createMaterialFromType) ⇒ <code>Material</code>
    * _static_
        * [.createMaterialFromType(type)](#MaterialLoader.createMaterialFromType) ⇒ <code>Material</code>

<a name="new_MaterialLoader_new"></a>

### new MaterialLoader([manager])
Constructs a new material loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="MaterialLoader+textures"></a>

### materialLoader.textures : <code>Object.&lt;string, Texture&gt;</code>
A dictionary holding textures used by the material.

**Kind**: instance property of [<code>MaterialLoader</code>](#MaterialLoader)  
<a name="MaterialLoader+load"></a>

### materialLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and pass the loaded material to the `onLoad()` callback.

**Kind**: instance method of [<code>MaterialLoader</code>](#MaterialLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MaterialLoader+parse"></a>

### materialLoader.parse(json) ⇒ <code>Material</code>
Parses the given JSON object and returns a material.

**Kind**: instance method of [<code>MaterialLoader</code>](#MaterialLoader)  
**Returns**: <code>Material</code> - The parsed material.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized material. |

<a name="MaterialLoader+setTextures"></a>

### materialLoader.setTextures(value) ⇒ [<code>MaterialLoader</code>](#MaterialLoader)
Textures are not embedded in the material JSON so they have
to be injected before the loading process starts.

**Kind**: instance method of [<code>MaterialLoader</code>](#MaterialLoader)  
**Returns**: [<code>MaterialLoader</code>](#MaterialLoader) - A reference to this material loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object</code> | A dictionary holding textures for material properties. |

<a name="MaterialLoader+createMaterialFromType"></a>

### materialLoader.createMaterialFromType(type) ⇒ <code>Material</code>
Creates a material for the given type.

**Kind**: instance method of [<code>MaterialLoader</code>](#MaterialLoader)  
**Returns**: <code>Material</code> - The new material.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The material type. |

<a name="MaterialLoader.createMaterialFromType"></a>

### MaterialLoader.createMaterialFromType(type) ⇒ <code>Material</code>
Creates a material for the given type.

**Kind**: static method of [<code>MaterialLoader</code>](#MaterialLoader)  
**Returns**: <code>Material</code> - The new material.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The material type. |

<a name="ObjectLoader"></a>

## ObjectLoader ⇐ <code>Loader</code>
A loader for loading a JSON resource in the [JSON Object/Scene format](https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4).
The files are internally loaded via [FileLoader](FileLoader).

```js
const loader = new THREE.ObjectLoader();
const obj = await loader.loadAsync( 'models/json/example.json' );
scene.add( obj );

// Alternatively, to parse a previously loaded JSON structure
const object = await loader.parseAsync( a_json_object );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ObjectLoader](#ObjectLoader) ⇐ <code>Loader</code>
    * [new ObjectLoader([manager])](#new_ObjectLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#ObjectLoader+load)
    * [.loadAsync(url, onProgress)](#ObjectLoader+loadAsync) ⇒ <code>Promise.&lt;Object3D&gt;</code>
    * [.parse(json, onLoad)](#ObjectLoader+parse) ⇒ <code>Object3D</code>
    * [.parseAsync(json)](#ObjectLoader+parseAsync) ⇒ <code>Promise.&lt;Object3D&gt;</code>

<a name="new_ObjectLoader_new"></a>

### new ObjectLoader([manager])
Constructs a new object loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="ObjectLoader+load"></a>

### objectLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and pass the loaded 3D object to the `onLoad()` callback.

**Kind**: instance method of [<code>ObjectLoader</code>](#ObjectLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="ObjectLoader+loadAsync"></a>

### objectLoader.loadAsync(url, onProgress) ⇒ <code>Promise.&lt;Object3D&gt;</code>
Async version of [load](#ObjectLoader+load).

**Kind**: instance method of [<code>ObjectLoader</code>](#ObjectLoader)  
**Returns**: <code>Promise.&lt;Object3D&gt;</code> - A Promise that resolves with the loaded 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |

<a name="ObjectLoader+parse"></a>

### objectLoader.parse(json, onLoad) ⇒ <code>Object3D</code>
Parses the given JSON. This is used internally by [load](#ObjectLoader+load)
but can also be used directly to parse a previously loaded JSON structure.

**Kind**: instance method of [<code>ObjectLoader</code>](#ObjectLoader)  
**Returns**: <code>Object3D</code> - The parsed 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized 3D object. |
| onLoad | <code>onLoad</code> | Executed when all resources (e.g. textures) have been fully loaded. |

<a name="ObjectLoader+parseAsync"></a>

### objectLoader.parseAsync(json) ⇒ <code>Promise.&lt;Object3D&gt;</code>
Async version of [parse](#ObjectLoader+parse).

**Kind**: instance method of [<code>ObjectLoader</code>](#ObjectLoader)  
**Returns**: <code>Promise.&lt;Object3D&gt;</code> - A Promise that resolves with the parsed 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The serialized 3D object. |

<a name="TextureLoader"></a>

## TextureLoader ⇐ <code>Loader</code>
Class for loading textures. Images are internally
loaded via [ImageLoader](ImageLoader).

```js
const loader = new THREE.TextureLoader();
const texture = await loader.loadAsync( 'textures/land_ocean_ice_cloud_2048.jpg' );

const material = new THREE.MeshBasicMaterial( { map:texture } );
```
Please note that `TextureLoader` has dropped support for progress
events in `r84`. For a `TextureLoader` that supports progress events, see
[this thread](https://github.com/mrdoob/three.js/issues/10439#issuecomment-293260145).

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [TextureLoader](#TextureLoader) ⇐ <code>Loader</code>
    * [new TextureLoader([manager])](#new_TextureLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#TextureLoader+load) ⇒ <code>Texture</code>

<a name="new_TextureLoader_new"></a>

### new TextureLoader([manager])
Constructs a new texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TextureLoader+load"></a>

### textureLoader.load(url, onLoad, onProgress, onError) ⇒ <code>Texture</code>
Starts loading from the given URL and pass the fully loaded texture
to the `onLoad()` callback. The method also returns a new texture object which can
directly be used for material creation. If you do it this way, the texture
may pop up in your scene once the respective loading process is finished.

**Kind**: instance method of [<code>TextureLoader</code>](#TextureLoader)  
**Returns**: <code>Texture</code> - The texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Unsupported in this loader. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="NodeLoader"></a>

## NodeLoader ⇐ <code>Loader</code>
A loader for loading node objects in the three.js JSON Object/Scene format.

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [NodeLoader](#NodeLoader) ⇐ <code>Loader</code>
    * [new NodeLoader([manager])](#new_NodeLoader_new)
    * [.textures](#NodeLoader+textures) : <code>Object.&lt;string, Texture&gt;</code>
    * [.nodes](#NodeLoader+nodes) : <code>Object.&lt;string, Node.constructor&gt;</code>
    * [.load(url, onLoad, onProgress, onError)](#NodeLoader+load)
    * [.parseNodes([json])](#NodeLoader+parseNodes) ⇒ <code>Object.&lt;string, Node&gt;</code>
    * [.parse(json)](#NodeLoader+parse) ⇒ <code>Node</code>
    * [.setTextures(value)](#NodeLoader+setTextures) ⇒ [<code>NodeLoader</code>](#NodeLoader)
    * [.setNodes(value)](#NodeLoader+setNodes) ⇒ [<code>NodeLoader</code>](#NodeLoader)
    * [.createNodeFromType(type)](#NodeLoader+createNodeFromType) ⇒ <code>Node</code>

<a name="new_NodeLoader_new"></a>

### new NodeLoader([manager])
Constructs a new node loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | A reference to a loading manager. |

<a name="NodeLoader+textures"></a>

### nodeLoader.textures : <code>Object.&lt;string, Texture&gt;</code>
Represents a dictionary of textures.

**Kind**: instance property of [<code>NodeLoader</code>](#NodeLoader)  
<a name="NodeLoader+nodes"></a>

### nodeLoader.nodes : <code>Object.&lt;string, Node.constructor&gt;</code>
Represents a dictionary of node types.

**Kind**: instance property of [<code>NodeLoader</code>](#NodeLoader)  
<a name="NodeLoader+load"></a>

### nodeLoader.load(url, onLoad, onProgress, onError)
Loads the node definitions from the given URL.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. |
| onLoad | <code>function</code> | Will be called when load completes. |
| onProgress | <code>function</code> | Will be called while load progresses. |
| onError | <code>function</code> | Will be called when errors are thrown during the loading process. |

<a name="NodeLoader+parseNodes"></a>

### nodeLoader.parseNodes([json]) ⇒ <code>Object.&lt;string, Node&gt;</code>
Parse the node dependencies for the loaded node.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: <code>Object.&lt;string, Node&gt;</code> - A dictionary with node dependencies.  

| Param | Type | Description |
| --- | --- | --- |
| [json] | <code>Array.&lt;Object&gt;</code> | The JSON definition |

<a name="NodeLoader+parse"></a>

### nodeLoader.parse(json) ⇒ <code>Node</code>
Parses the node from the given JSON.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: <code>Node</code> - The parsed node.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |
| json.type | <code>string</code> | The node type. |
| json.uuid | <code>string</code> | The node UUID. |
| [json.nodes] | <code>Array.&lt;Object&gt;</code> | The node dependencies. |
| [json.meta] | <code>Object</code> | The meta data. |

<a name="NodeLoader+setTextures"></a>

### nodeLoader.setTextures(value) ⇒ [<code>NodeLoader</code>](#NodeLoader)
Defines the dictionary of textures.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: [<code>NodeLoader</code>](#NodeLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, Texture&gt;</code> | The texture library defines as `<uuid,texture>`. |

<a name="NodeLoader+setNodes"></a>

### nodeLoader.setNodes(value) ⇒ [<code>NodeLoader</code>](#NodeLoader)
Defines the dictionary of node types.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: [<code>NodeLoader</code>](#NodeLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, Node.constructor&gt;</code> | The node library defined as `<classname,class>`. |

<a name="NodeLoader+createNodeFromType"></a>

### nodeLoader.createNodeFromType(type) ⇒ <code>Node</code>
Creates a node object from the given type.

**Kind**: instance method of [<code>NodeLoader</code>](#NodeLoader)  
**Returns**: <code>Node</code> - The created node instance.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The node type. |

<a name="NodeMaterialLoader"></a>

## NodeMaterialLoader ⇐ <code>MaterialLoader</code>
A special type of material loader for loading node materials.

**Kind**: global class  
**Extends**: <code>MaterialLoader</code>  

* [NodeMaterialLoader](#NodeMaterialLoader) ⇐ <code>MaterialLoader</code>
    * [new NodeMaterialLoader([manager])](#new_NodeMaterialLoader_new)
    * [.nodes](#NodeMaterialLoader+nodes) : <code>Object.&lt;string, Node.constructor&gt;</code>
    * [.nodeMaterials](#NodeMaterialLoader+nodeMaterials) : <code>Object.&lt;string, NodeMaterial.constructor&gt;</code>
    * [.parse(json)](#NodeMaterialLoader+parse) ⇒ <code>NodeMaterial</code>
    * [.setNodes(value)](#NodeMaterialLoader+setNodes) ⇒ <code>NodeLoader</code>
    * [.setNodeMaterials(value)](#NodeMaterialLoader+setNodeMaterials) ⇒ <code>NodeLoader</code>
    * [.createMaterialFromType(type)](#NodeMaterialLoader+createMaterialFromType) ⇒ <code>Node</code>

<a name="new_NodeMaterialLoader_new"></a>

### new NodeMaterialLoader([manager])
Constructs a new node material loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | A reference to a loading manager. |

<a name="NodeMaterialLoader+nodes"></a>

### nodeMaterialLoader.nodes : <code>Object.&lt;string, Node.constructor&gt;</code>
Represents a dictionary of node types.

**Kind**: instance property of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
<a name="NodeMaterialLoader+nodeMaterials"></a>

### nodeMaterialLoader.nodeMaterials : <code>Object.&lt;string, NodeMaterial.constructor&gt;</code>
Represents a dictionary of node material types.

**Kind**: instance property of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
<a name="NodeMaterialLoader+parse"></a>

### nodeMaterialLoader.parse(json) ⇒ <code>NodeMaterial</code>
Parses the node material from the given JSON.

**Kind**: instance method of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
**Returns**: <code>NodeMaterial</code> - . The parsed material.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |

<a name="NodeMaterialLoader+setNodes"></a>

### nodeMaterialLoader.setNodes(value) ⇒ <code>NodeLoader</code>
Defines the dictionary of node types.

**Kind**: instance method of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
**Returns**: <code>NodeLoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, Node.constructor&gt;</code> | The node library defined as `<classname,class>`. |

<a name="NodeMaterialLoader+setNodeMaterials"></a>

### nodeMaterialLoader.setNodeMaterials(value) ⇒ <code>NodeLoader</code>
Defines the dictionary of node material types.

**Kind**: instance method of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
**Returns**: <code>NodeLoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, NodeMaterial.constructor&gt;</code> | The node material library defined as `<classname,class>`. |

<a name="NodeMaterialLoader+createMaterialFromType"></a>

### nodeMaterialLoader.createMaterialFromType(type) ⇒ <code>Node</code>
Creates a node material from the given type.

**Kind**: instance method of [<code>NodeMaterialLoader</code>](#NodeMaterialLoader)  
**Returns**: <code>Node</code> - The created node material instance.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The node material type. |

<a name="NodeObjectLoader"></a>

## NodeObjectLoader ⇐ <code>ObjectLoader</code>
A special type of object loader for loading 3D objects using
node materials.

**Kind**: global class  
**Extends**: <code>ObjectLoader</code>  

* [NodeObjectLoader](#NodeObjectLoader) ⇐ <code>ObjectLoader</code>
    * [new NodeObjectLoader([manager])](#new_NodeObjectLoader_new)
    * [.nodes](#NodeObjectLoader+nodes) : <code>Object.&lt;string, Node.constructor&gt;</code>
    * [.nodeMaterials](#NodeObjectLoader+nodeMaterials) : <code>Object.&lt;string, NodeMaterial.constructor&gt;</code>
    * [.setNodes(value)](#NodeObjectLoader+setNodes) ⇒ [<code>NodeObjectLoader</code>](#NodeObjectLoader)
    * [.setNodeMaterials(value)](#NodeObjectLoader+setNodeMaterials) ⇒ [<code>NodeObjectLoader</code>](#NodeObjectLoader)
    * [.parse(json, onLoad)](#NodeObjectLoader+parse) ⇒ <code>Object3D</code>
    * [.parseNodes(json, textures)](#NodeObjectLoader+parseNodes) ⇒ <code>Object.&lt;string, Node&gt;</code>
    * [.parseMaterials(json, textures)](#NodeObjectLoader+parseMaterials) ⇒ <code>Object.&lt;string, NodeMaterial&gt;</code>

<a name="new_NodeObjectLoader_new"></a>

### new NodeObjectLoader([manager])
Constructs a new node object loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | A reference to a loading manager. |

<a name="NodeObjectLoader+nodes"></a>

### nodeObjectLoader.nodes : <code>Object.&lt;string, Node.constructor&gt;</code>
Represents a dictionary of node types.

**Kind**: instance property of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
<a name="NodeObjectLoader+nodeMaterials"></a>

### nodeObjectLoader.nodeMaterials : <code>Object.&lt;string, NodeMaterial.constructor&gt;</code>
Represents a dictionary of node material types.

**Kind**: instance property of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
<a name="NodeObjectLoader+setNodes"></a>

### nodeObjectLoader.setNodes(value) ⇒ [<code>NodeObjectLoader</code>](#NodeObjectLoader)
Defines the dictionary of node types.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: [<code>NodeObjectLoader</code>](#NodeObjectLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, Node.constructor&gt;</code> | The node library defined as `<classname,class>`. |

<a name="NodeObjectLoader+setNodeMaterials"></a>

### nodeObjectLoader.setNodeMaterials(value) ⇒ [<code>NodeObjectLoader</code>](#NodeObjectLoader)
Defines the dictionary of node material types.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: [<code>NodeObjectLoader</code>](#NodeObjectLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Object.&lt;string, NodeMaterial.constructor&gt;</code> | The node material library defined as `<classname,class>`. |

<a name="NodeObjectLoader+parse"></a>

### nodeObjectLoader.parse(json, onLoad) ⇒ <code>Object3D</code>
Parses the node objects from the given JSON.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: <code>Object3D</code> - . The parsed 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |
| onLoad | <code>function</code> | The onLoad callback function. |

<a name="NodeObjectLoader+parseNodes"></a>

### nodeObjectLoader.parseNodes(json, textures) ⇒ <code>Object.&lt;string, Node&gt;</code>
Parses the node objects from the given JSON and textures.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: <code>Object.&lt;string, Node&gt;</code> - . The parsed nodes.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |
| textures | <code>Object.&lt;string, Texture&gt;</code> | The texture library. |

<a name="NodeObjectLoader+parseMaterials"></a>

### nodeObjectLoader.parseMaterials(json, textures) ⇒ <code>Object.&lt;string, NodeMaterial&gt;</code>
Parses the node objects from the given JSON and textures.

**Kind**: instance method of [<code>NodeObjectLoader</code>](#NodeObjectLoader)  
**Returns**: <code>Object.&lt;string, NodeMaterial&gt;</code> - . The parsed materials.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON definition |
| textures | <code>Object.&lt;string, Texture&gt;</code> | The texture library. |

<a name="LineBasicMaterial"></a>

## LineBasicMaterial ⇐ <code>Material</code>
A material for rendering line primitives.

Materials define the appearance of renderable 3D objects.

```js
const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [LineBasicMaterial](#LineBasicMaterial) ⇐ <code>Material</code>
    * [new LineBasicMaterial([parameters])](#new_LineBasicMaterial_new)
    * [.isLineBasicMaterial](#LineBasicMaterial+isLineBasicMaterial) : <code>boolean</code>
    * [.color](#LineBasicMaterial+color) : <code>Color</code>
    * [.map](#LineBasicMaterial+map) : <code>Texture</code>
    * [.linewidth](#LineBasicMaterial+linewidth) : <code>number</code>
    * [.linecap](#LineBasicMaterial+linecap) : <code>&#x27;butt&#x27;</code> \| <code>&#x27;round&#x27;</code> \| <code>&#x27;square&#x27;</code>
    * [.linejoin](#LineBasicMaterial+linejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.fog](#LineBasicMaterial+fog) : <code>boolean</code>

<a name="new_LineBasicMaterial_new"></a>

### new LineBasicMaterial([parameters])
Constructs a new line basic material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="LineBasicMaterial+isLineBasicMaterial"></a>

### lineBasicMaterial.isLineBasicMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineBasicMaterial+color"></a>

### lineBasicMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="LineBasicMaterial+map"></a>

### lineBasicMaterial.map : <code>Texture</code>
Sets the color of the lines using data from a texture. The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>null</code>  
<a name="LineBasicMaterial+linewidth"></a>

### lineBasicMaterial.linewidth : <code>number</code>
Controls line thickness or lines.

Can only be used with [SVGRenderer](SVGRenderer). WebGL and WebGPU
ignore this setting and always render line primitives with a
width of one pixel.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>1</code>  
<a name="LineBasicMaterial+linecap"></a>

### lineBasicMaterial.linecap : <code>&#x27;butt&#x27;</code> \| <code>&#x27;round&#x27;</code> \| <code>&#x27;square&#x27;</code>
Defines appearance of line ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="LineBasicMaterial+linejoin"></a>

### lineBasicMaterial.linejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of line joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="LineBasicMaterial+fog"></a>

### lineBasicMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>LineBasicMaterial</code>](#LineBasicMaterial)  
**Default**: <code>true</code>  
<a name="LineDashedMaterial"></a>

## LineDashedMaterial ⇐ <code>LineBasicMaterial</code>
A material for rendering line primitives.

Materials define the appearance of renderable 3D objects.

```js
const material = new THREE.LineDashedMaterial( {
	color: 0xffffff,
	scale: 1,
	dashSize: 3,
	gapSize: 1,
} );
```

**Kind**: global class  
**Extends**: <code>LineBasicMaterial</code>  

* [LineDashedMaterial](#LineDashedMaterial) ⇐ <code>LineBasicMaterial</code>
    * [new LineDashedMaterial([parameters])](#new_LineDashedMaterial_new)
    * [.isLineDashedMaterial](#LineDashedMaterial+isLineDashedMaterial) : <code>boolean</code>
    * [.scale](#LineDashedMaterial+scale) : <code>number</code>
    * [.dashSize](#LineDashedMaterial+dashSize) : <code>number</code>
    * [.gapSize](#LineDashedMaterial+gapSize) : <code>number</code>

<a name="new_LineDashedMaterial_new"></a>

### new LineDashedMaterial([parameters])
Constructs a new line dashed material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="LineDashedMaterial+isLineDashedMaterial"></a>

### lineDashedMaterial.isLineDashedMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineDashedMaterial</code>](#LineDashedMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineDashedMaterial+scale"></a>

### lineDashedMaterial.scale : <code>number</code>
The scale of the dashed part of a line.

**Kind**: instance property of [<code>LineDashedMaterial</code>](#LineDashedMaterial)  
**Default**: <code>1</code>  
<a name="LineDashedMaterial+dashSize"></a>

### lineDashedMaterial.dashSize : <code>number</code>
The size of the dash. This is both the gap with the stroke.

**Kind**: instance property of [<code>LineDashedMaterial</code>](#LineDashedMaterial)  
**Default**: <code>3</code>  
<a name="LineDashedMaterial+gapSize"></a>

### lineDashedMaterial.gapSize : <code>number</code>
The size of the gap.

**Kind**: instance property of [<code>LineDashedMaterial</code>](#LineDashedMaterial)  
**Default**: <code>1</code>  
<a name="Material"></a>

## *Material ⇐ <code>EventDispatcher</code>*
Abstract base class for materials.

Materials define the appearance of renderable 3D objects.

**Kind**: global abstract class  
**Extends**: <code>EventDispatcher</code>  

* *[Material](#Material) ⇐ <code>EventDispatcher</code>*
    * *[new Material()](#new_Material_new)*
    * *[.isMaterial](#Material+isMaterial) : <code>boolean</code>*
    * *[.id](#Material+id) : <code>number</code>*
    * *[.uuid](#Material+uuid) : <code>string</code>*
    * *[.name](#Material+name) : <code>string</code>*
    * *[.type](#Material+type) : <code>string</code>*
    * *[.blending](#Material+blending) : <code>NoBlending</code> \| <code>NormalBlending</code> \| <code>AdditiveBlending</code> \| <code>SubtractiveBlending</code> \| <code>MultiplyBlending</code> \| <code>CustomBlending</code>*
    * *[.side](#Material+side) : <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code>*
    * *[.vertexColors](#Material+vertexColors) : <code>boolean</code>*
    * *[.opacity](#Material+opacity) : <code>number</code>*
    * *[.transparent](#Material+transparent) : <code>boolean</code>*
    * *[.alphaHash](#Material+alphaHash) : <code>boolean</code>*
    * *[.blendSrc](#Material+blendSrc) : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
    * *[.blendDst](#Material+blendDst) : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
    * *[.blendEquation](#Material+blendEquation) : <code>AddEquation</code> \| <code>SubtractEquation</code> \| <code>ReverseSubtractEquation</code> \| <code>MinEquation</code> \| <code>MaxEquation</code>*
    * *[.blendSrcAlpha](#Material+blendSrcAlpha) : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
    * *[.blendDstAlpha](#Material+blendDstAlpha) : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
    * *[.blendEquationAlpha](#Material+blendEquationAlpha) : <code>AddEquation</code> \| <code>SubtractEquation</code> \| <code>ReverseSubtractEquation</code> \| <code>MinEquation</code> \| <code>MaxEquation</code>*
    * *[.blendColor](#Material+blendColor) : <code>Color</code>*
    * *[.blendAlpha](#Material+blendAlpha) : <code>number</code>*
    * *[.depthFunc](#Material+depthFunc) : <code>NeverDepth</code> \| <code>AlwaysDepth</code> \| <code>LessDepth</code> \| <code>LessEqualDepth</code> \| <code>EqualDepth</code> \| <code>GreaterEqualDepth</code> \| <code>GreaterDepth</code> \| <code>NotEqualDepth</code>*
    * *[.depthTest](#Material+depthTest) : <code>boolean</code>*
    * *[.depthWrite](#Material+depthWrite) : <code>boolean</code>*
    * *[.stencilWriteMask](#Material+stencilWriteMask) : <code>number</code>*
    * *[.stencilFunc](#Material+stencilFunc) : <code>NeverStencilFunc</code> \| <code>LessStencilFunc</code> \| <code>EqualStencilFunc</code> \| <code>LessEqualStencilFunc</code> \| <code>GreaterStencilFunc</code> \| <code>NotEqualStencilFunc</code> \| <code>GreaterEqualStencilFunc</code> \| <code>AlwaysStencilFunc</code>*
    * *[.stencilRef](#Material+stencilRef) : <code>number</code>*
    * *[.stencilFuncMask](#Material+stencilFuncMask) : <code>number</code>*
    * *[.stencilFail](#Material+stencilFail) : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
    * *[.stencilZFail](#Material+stencilZFail) : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
    * *[.stencilZPass](#Material+stencilZPass) : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
    * *[.stencilWrite](#Material+stencilWrite) : <code>boolean</code>*
    * *[.clippingPlanes](#Material+clippingPlanes) : <code>Array.&lt;Plane&gt;</code>*
    * *[.clipIntersection](#Material+clipIntersection) : <code>boolean</code>*
    * *[.clipShadows](#Material+clipShadows) : <code>boolean</code>*
    * *[.shadowSide](#Material+shadowSide) : <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code>*
    * *[.colorWrite](#Material+colorWrite) : <code>boolean</code>*
    * *[.precision](#Material+precision) : <code>&#x27;highp&#x27;</code> \| <code>&#x27;mediump&#x27;</code> \| <code>&#x27;lowp&#x27;</code>*
    * *[.polygonOffset](#Material+polygonOffset) : <code>boolean</code>*
    * *[.polygonOffsetFactor](#Material+polygonOffsetFactor) : <code>number</code>*
    * *[.polygonOffsetUnits](#Material+polygonOffsetUnits) : <code>number</code>*
    * *[.dithering](#Material+dithering) : <code>boolean</code>*
    * *[.alphaToCoverage](#Material+alphaToCoverage) : <code>boolean</code>*
    * *[.premultipliedAlpha](#Material+premultipliedAlpha) : <code>boolean</code>*
    * *[.forceSinglePass](#Material+forceSinglePass) : <code>boolean</code>*
    * *[.allowOverride](#Material+allowOverride) : <code>boolean</code>*
    * *[.visible](#Material+visible) : <code>boolean</code>*
    * *[.toneMapped](#Material+toneMapped) : <code>boolean</code>*
    * *[.userData](#Material+userData) : <code>Object</code>*
    * *[.version](#Material+version) : <code>number</code>*
    * *[.alphaTest](#Material+alphaTest) : <code>number</code>*
    * *[.needsUpdate](#Material+needsUpdate) : <code>boolean</code>*
    * *[.onBeforeRender(renderer, scene, camera, geometry, object, group)](#Material+onBeforeRender)*
    * *[.onBeforeCompile(shaderobject, renderer)](#Material+onBeforeCompile)*
    * *[.customProgramCacheKey()](#Material+customProgramCacheKey) ⇒ <code>string</code>*
    * *[.setValues([values])](#Material+setValues)*
    * *[.toJSON(meta)](#Material+toJSON) ⇒ <code>Object</code>*
    * *[.clone()](#Material+clone) ⇒ [<code>Material</code>](#Material)*
    * *[.copy(source)](#Material+copy) ⇒ [<code>Material</code>](#Material)*
    * *[.dispose()](#Material+dispose)*
    * *["dispose"](#Material+event_dispose)*

<a name="new_Material_new"></a>

### *new Material()*
Constructs a new material.

<a name="Material+isMaterial"></a>

### *material.isMaterial : <code>boolean</code>*
This flag can be used for type testing.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Material+id"></a>

### *material.id : <code>number</code>*
The ID of the material.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Read only**: true  
<a name="Material+uuid"></a>

### *material.uuid : <code>string</code>*
The UUID of the material.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Read only**: true  
<a name="Material+name"></a>

### *material.name : <code>string</code>*
The name of the material.

**Kind**: instance property of [<code>Material</code>](#Material)  
<a name="Material+type"></a>

### *material.type : <code>string</code>*
The type property is used for detecting the object type
in context of serialization/deserialization.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Read only**: true  
<a name="Material+blending"></a>

### *material.blending : <code>NoBlending</code> \| <code>NormalBlending</code> \| <code>AdditiveBlending</code> \| <code>SubtractiveBlending</code> \| <code>MultiplyBlending</code> \| <code>CustomBlending</code>*
Defines the blending type of the material.

It must be set to `CustomBlending` if custom blending properties like
[blendSrc](#Material+blendSrc), [blendDst](#Material+blendDst) or [blendEquation](#Material+blendEquation)
should have any effect.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>NormalBlending</code>  
<a name="Material+side"></a>

### *material.side : <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code>*
Defines which side of faces will be rendered - front, back or both.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>FrontSide</code>  
<a name="Material+vertexColors"></a>

### *material.vertexColors : <code>boolean</code>*
If set to `true`, vertex colors should be used.

The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or
four (RGBA) component color buffer attribute is used.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+opacity"></a>

### *material.opacity : <code>number</code>*
Defines how transparent the material is.
A value of `0.0` indicates fully transparent, `1.0` is fully opaque.

If the [transparent](#Material+transparent) is not set to `true`,
the material will remain fully opaque and this value will only affect its color.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>1</code>  
<a name="Material+transparent"></a>

### *material.transparent : <code>boolean</code>*
Defines whether this material is transparent. This has an effect on
rendering as transparent objects need special treatment and are rendered
after non-transparent objects.

When set to true, the extent to which the material is transparent is
controlled by [opacity](#Material+opacity).

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+alphaHash"></a>

### *material.alphaHash : <code>boolean</code>*
Enables alpha hashed transparency, an alternative to [transparent](#Material+transparent) or
[alphaTest](#Material+alphaTest). The material will not be rendered if opacity is lower than
a random threshold. Randomization introduces some grain or noise, but approximates alpha
blending without the associated problems of sorting. Using TAA can reduce the resulting noise.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+blendSrc"></a>

### *material.blendSrc : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
Defines the blending source factor.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>SrcAlphaFactor</code>  
<a name="Material+blendDst"></a>

### *material.blendDst : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
Defines the blending destination factor.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>OneMinusSrcAlphaFactor</code>  
<a name="Material+blendEquation"></a>

### *material.blendEquation : <code>AddEquation</code> \| <code>SubtractEquation</code> \| <code>ReverseSubtractEquation</code> \| <code>MinEquation</code> \| <code>MaxEquation</code>*
Defines the blending equation.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>AddEquation</code>  
<a name="Material+blendSrcAlpha"></a>

### *material.blendSrcAlpha : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
Defines the blending source alpha factor.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+blendDstAlpha"></a>

### *material.blendDstAlpha : <code>ZeroFactor</code> \| <code>OneFactor</code> \| <code>SrcColorFactor</code> \| <code>OneMinusSrcColorFactor</code> \| <code>SrcAlphaFactor</code> \| <code>OneMinusSrcAlphaFactor</code> \| <code>DstAlphaFactor</code> \| <code>OneMinusDstAlphaFactor</code> \| <code>DstColorFactor</code> \| <code>OneMinusDstColorFactor</code> \| <code>SrcAlphaSaturateFactor</code> \| <code>ConstantColorFactor</code> \| <code>OneMinusConstantColorFactor</code> \| <code>ConstantAlphaFactor</code> \| <code>OneMinusConstantAlphaFactor</code>*
Defines the blending destination alpha factor.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+blendEquationAlpha"></a>

### *material.blendEquationAlpha : <code>AddEquation</code> \| <code>SubtractEquation</code> \| <code>ReverseSubtractEquation</code> \| <code>MinEquation</code> \| <code>MaxEquation</code>*
Defines the blending equation of the alpha channel.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+blendColor"></a>

### *material.blendColor : <code>Color</code>*
Represents the RGB values of the constant blend color.

This property has only an effect when using custom blending with `ConstantColor` or `OneMinusConstantColor`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>(0,0,0)</code>  
<a name="Material+blendAlpha"></a>

### *material.blendAlpha : <code>number</code>*
Represents the alpha value of the constant blend color.

This property has only an effect when using custom blending with `ConstantAlpha` or `OneMinusConstantAlpha`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
<a name="Material+depthFunc"></a>

### *material.depthFunc : <code>NeverDepth</code> \| <code>AlwaysDepth</code> \| <code>LessDepth</code> \| <code>LessEqualDepth</code> \| <code>EqualDepth</code> \| <code>GreaterEqualDepth</code> \| <code>GreaterDepth</code> \| <code>NotEqualDepth</code>*
Defines the depth function.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>LessEqualDepth</code>  
<a name="Material+depthTest"></a>

### *material.depthTest : <code>boolean</code>*
Whether to have depth test enabled when rendering this material.
When the depth test is disabled, the depth write will also be implicitly disabled.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+depthWrite"></a>

### *material.depthWrite : <code>boolean</code>*
Whether rendering this material has any effect on the depth buffer.

When drawing 2D overlays it can be useful to disable the depth writing in
order to layer several things together without creating z-index artifacts.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+stencilWriteMask"></a>

### *material.stencilWriteMask : <code>number</code>*
The bit mask to use when writing to the stencil buffer.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0xff</code>  
<a name="Material+stencilFunc"></a>

### *material.stencilFunc : <code>NeverStencilFunc</code> \| <code>LessStencilFunc</code> \| <code>EqualStencilFunc</code> \| <code>LessEqualStencilFunc</code> \| <code>GreaterStencilFunc</code> \| <code>NotEqualStencilFunc</code> \| <code>GreaterEqualStencilFunc</code> \| <code>AlwaysStencilFunc</code>*
The stencil comparison function to use.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>AlwaysStencilFunc</code>  
<a name="Material+stencilRef"></a>

### *material.stencilRef : <code>number</code>*
The value to use when performing stencil comparisons or stencil operations.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
<a name="Material+stencilFuncMask"></a>

### *material.stencilFuncMask : <code>number</code>*
The bit mask to use when comparing against the stencil buffer.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0xff</code>  
<a name="Material+stencilFail"></a>

### *material.stencilFail : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
Which stencil operation to perform when the comparison function returns `false`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>KeepStencilOp</code>  
<a name="Material+stencilZFail"></a>

### *material.stencilZFail : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
Which stencil operation to perform when the comparison function returns
`true` but the depth test fails.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>KeepStencilOp</code>  
<a name="Material+stencilZPass"></a>

### *material.stencilZPass : <code>ZeroStencilOp</code> \| <code>KeepStencilOp</code> \| <code>ReplaceStencilOp</code> \| <code>IncrementStencilOp</code> \| <code>DecrementStencilOp</code> \| <code>IncrementWrapStencilOp</code> \| <code>DecrementWrapStencilOp</code> \| <code>InvertStencilOp</code>*
Which stencil operation to perform when the comparison function returns
`true` and the depth test passes.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>KeepStencilOp</code>  
<a name="Material+stencilWrite"></a>

### *material.stencilWrite : <code>boolean</code>*
Whether stencil operations are performed against the stencil buffer. In
order to perform writes or comparisons against the stencil buffer this
value must be `true`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+clippingPlanes"></a>

### *material.clippingPlanes : <code>Array.&lt;Plane&gt;</code>*
User-defined clipping planes specified as THREE.Plane objects in world
space. These planes apply to the objects this material is attached to.
Points in space whose signed distance to the plane is negative are clipped
(not rendered). This requires [WebGLRenderer#localClippingEnabled](WebGLRenderer#localClippingEnabled) to
be `true`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+clipIntersection"></a>

### *material.clipIntersection : <code>boolean</code>*
Changes the behavior of clipping planes so that only their intersection is
clipped, rather than their union.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+clipShadows"></a>

### *material.clipShadows : <code>boolean</code>*
Defines whether to clip shadows according to the clipping planes specified
on this material.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+shadowSide"></a>

### *material.shadowSide : <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code>*
Defines which side of faces cast shadows. If `null`, the side casting shadows
is determined as follows:

- When [side](#Material+side) is set to `FrontSide`, the back side cast shadows.
- When [side](#Material+side) is set to `BackSide`, the front side cast shadows.
- When [side](#Material+side) is set to `DoubleSide`, both sides cast shadows.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+colorWrite"></a>

### *material.colorWrite : <code>boolean</code>*
Whether to render the material's color.

This can be used in conjunction with [Object3D#renderOder](Object3D#renderOder) to create invisible
objects that occlude other objects.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+precision"></a>

### *material.precision : <code>&#x27;highp&#x27;</code> \| <code>&#x27;mediump&#x27;</code> \| <code>&#x27;lowp&#x27;</code>*
Override the renderer's default precision for this material.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>null</code>  
<a name="Material+polygonOffset"></a>

### *material.polygonOffset : <code>boolean</code>*
Whether to use polygon offset or not. When enabled, each fragment's depth value will
be offset after it is interpolated from the depth values of the appropriate vertices.
The offset is added before the depth test is performed and before the value is written
into the depth buffer.

Can be useful for rendering hidden-line images, for applying decals to surfaces, and for
rendering solids with highlighted edges.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+polygonOffsetFactor"></a>

### *material.polygonOffsetFactor : <code>number</code>*
Specifies a scale factor that is used to create a variable depth offset for each polygon.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
<a name="Material+polygonOffsetUnits"></a>

### *material.polygonOffsetUnits : <code>number</code>*
Is multiplied by an implementation-specific value to create a constant depth offset.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
<a name="Material+dithering"></a>

### *material.dithering : <code>boolean</code>*
Whether to apply dithering to the color to remove the appearance of banding.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+alphaToCoverage"></a>

### *material.alphaToCoverage : <code>boolean</code>*
Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts
(meaning when the renderer was created with *antialias* parameter set to `true`). Enabling this
will smooth aliasing on clip plane edges and alphaTest-clipped edges.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+premultipliedAlpha"></a>

### *material.premultipliedAlpha : <code>boolean</code>*
Whether to premultiply the alpha (transparency) value.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+forceSinglePass"></a>

### *material.forceSinglePass : <code>boolean</code>*
Whether double-sided, transparent objects should be rendered with a single pass or not.

The engine renders double-sided, transparent objects with two draw calls (back faces first,
then front faces) to mitigate transparency artifacts. There are scenarios however where this
approach produces no quality gains but still doubles draw calls e.g. when rendering flat
vegetation like grass sprites. In these cases, set the `forceSinglePass` flag to `true` to
disable the two pass rendering to avoid performance issues.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  
<a name="Material+allowOverride"></a>

### *material.allowOverride : <code>boolean</code>*
Whether it's possible to override the material with [Scene#overrideMaterial](Scene#overrideMaterial) or not.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+visible"></a>

### *material.visible : <code>boolean</code>*
Defines whether 3D objects using this material are visible.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+toneMapped"></a>

### *material.toneMapped : <code>boolean</code>*
Defines whether this material is tone mapped according to the renderer's tone mapping setting.

It is ignored when rendering to a render target or using post processing or when using
`WebGPURenderer`. In all these cases, all materials are honored by tone mapping.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>true</code>  
<a name="Material+userData"></a>

### *material.userData : <code>Object</code>*
An object that can be used to store custom data about the Material. It
should not hold references to functions as these will not be cloned.

**Kind**: instance property of [<code>Material</code>](#Material)  
<a name="Material+version"></a>

### *material.version : <code>number</code>*
This starts at `0` and counts how many times [needsUpdate](#Material+needsUpdate) is set to `true`.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Material+alphaTest"></a>

### *material.alphaTest : <code>number</code>*
Sets the alpha value to be used when running an alpha test. The material
will not be rendered if the opacity is lower than this value.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Material+needsUpdate"></a>

### *material.needsUpdate : <code>boolean</code>*
Setting this property to `true` indicates the engine the material
needs to be recompiled.

**Kind**: instance property of [<code>Material</code>](#Material)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Material+onBeforeRender"></a>

### *material.onBeforeRender(renderer, scene, camera, geometry, object, group)*
An optional callback that is executed immediately before the material is used to render a 3D object.

This method can only be used when rendering with [WebGLRenderer](WebGLRenderer).

**Kind**: instance method of [<code>Material</code>](#Material)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| scene | <code>Scene</code> | The scene. |
| camera | <code>Camera</code> | The camera that is used to render the scene. |
| geometry | <code>BufferGeometry</code> | The 3D object's geometry. |
| object | <code>Object3D</code> | The 3D object. |
| group | <code>Object</code> | The geometry group data. |

<a name="Material+onBeforeCompile"></a>

### *material.onBeforeCompile(shaderobject, renderer)*
An optional callback that is executed immediately before the shader
program is compiled. This function is called with the shader source code
as a parameter. Useful for the modification of built-in materials.

This method can only be used when rendering with [WebGLRenderer](WebGLRenderer). The
recommended approach when customizing materials is to use `WebGPURenderer` with the new
Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).

**Kind**: instance method of [<code>Material</code>](#Material)  

| Param | Type | Description |
| --- | --- | --- |
| shaderobject | <code>Object</code> | The object holds the uniforms and the vertex and fragment shader source. |
| renderer | <code>WebGLRenderer</code> | A reference to the renderer. |

<a name="Material+customProgramCacheKey"></a>

### *material.customProgramCacheKey() ⇒ <code>string</code>*
In case [onBeforeCompile](#Material+onBeforeCompile) is used, this callback can be used to identify
values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
shader or recompile the shader for this material as needed.

This method can only be used when rendering with [WebGLRenderer](WebGLRenderer).

**Kind**: instance method of [<code>Material</code>](#Material)  
**Returns**: <code>string</code> - The custom program cache key.  
<a name="Material+setValues"></a>

### *material.setValues([values])*
This method can be used to set default values from parameter objects.
It is a generic implementation so it can be used with different types
of materials.

**Kind**: instance method of [<code>Material</code>](#Material)  

| Param | Type | Description |
| --- | --- | --- |
| [values] | <code>Object</code> | The material values to set. |

<a name="Material+toJSON"></a>

### *material.toJSON(meta) ⇒ <code>Object</code>*
Serializes the material into JSON.

**Kind**: instance method of [<code>Material</code>](#Material)  
**Returns**: <code>Object</code> - A JSON object representing the serialized material.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="Material+clone"></a>

### *material.clone() ⇒ [<code>Material</code>](#Material)*
Returns a new material with copied values from this instance.

**Kind**: instance method of [<code>Material</code>](#Material)  
**Returns**: [<code>Material</code>](#Material) - A clone of this instance.  
<a name="Material+copy"></a>

### *material.copy(source) ⇒ [<code>Material</code>](#Material)*
Copies the values of the given material to this instance.

**Kind**: instance method of [<code>Material</code>](#Material)  
**Returns**: [<code>Material</code>](#Material) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>Material</code>](#Material) | The material to copy. |

<a name="Material+dispose"></a>

### *material.dispose()*
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Material</code>](#Material)  
**Emits**: [<code>dispose</code>](#Material+event_dispose)  
<a name="Material+event_dispose"></a>

### *"dispose"*
Fires when the material has been disposed of.

**Kind**: event emitted by [<code>Material</code>](#Material)  
<a name="MeshBasicMaterial"></a>

## MeshBasicMaterial ⇐ <code>Material</code>
A material for drawing geometries in a simple shaded (flat or wireframe) way.

This material is not affected by lights.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshBasicMaterial](#MeshBasicMaterial) ⇐ <code>Material</code>
    * [new MeshBasicMaterial([parameters])](#new_MeshBasicMaterial_new)
    * [.isMeshBasicMaterial](#MeshBasicMaterial+isMeshBasicMaterial) : <code>boolean</code>
    * [.color](#MeshBasicMaterial+color) : <code>Color</code>
    * [.map](#MeshBasicMaterial+map) : <code>Texture</code>
    * [.lightMap](#MeshBasicMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshBasicMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshBasicMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshBasicMaterial+aoMapIntensity) : <code>number</code>
    * [.specularMap](#MeshBasicMaterial+specularMap) : <code>Texture</code>
    * [.alphaMap](#MeshBasicMaterial+alphaMap) : <code>Texture</code>
    * [.envMap](#MeshBasicMaterial+envMap) : <code>Texture</code>
    * [.envMapRotation](#MeshBasicMaterial+envMapRotation) : <code>Euler</code>
    * [.combine](#MeshBasicMaterial+combine) : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
    * [.reflectivity](#MeshBasicMaterial+reflectivity) : <code>number</code>
    * [.refractionRatio](#MeshBasicMaterial+refractionRatio) : <code>number</code>
    * [.wireframe](#MeshBasicMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshBasicMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshBasicMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshBasicMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.fog](#MeshBasicMaterial+fog) : <code>boolean</code>

<a name="new_MeshBasicMaterial_new"></a>

### new MeshBasicMaterial([parameters])
Constructs a new mesh basic material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshBasicMaterial+isMeshBasicMaterial"></a>

### meshBasicMaterial.isMeshBasicMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshBasicMaterial+color"></a>

### meshBasicMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshBasicMaterial+map"></a>

### meshBasicMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+lightMap"></a>

### meshBasicMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+lightMapIntensity"></a>

### meshBasicMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>1</code>  
<a name="MeshBasicMaterial+aoMap"></a>

### meshBasicMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+aoMapIntensity"></a>

### meshBasicMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>1</code>  
<a name="MeshBasicMaterial+specularMap"></a>

### meshBasicMaterial.specularMap : <code>Texture</code>
Specular map used by the material.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+alphaMap"></a>

### meshBasicMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+envMap"></a>

### meshBasicMaterial.envMap : <code>Texture</code>
The environment map.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>null</code>  
<a name="MeshBasicMaterial+envMapRotation"></a>

### meshBasicMaterial.envMapRotation : <code>Euler</code>
The rotation of the environment map in radians.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshBasicMaterial+combine"></a>

### meshBasicMaterial.combine : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
How to combine the result of the surface's color with the environment map, if any.

When set to `MixOperation`, the [reflectivity](#MeshBasicMaterial+reflectivity) is used to
blend between the two colors.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>MultiplyOperation</code>  
<a name="MeshBasicMaterial+reflectivity"></a>

### meshBasicMaterial.reflectivity : <code>number</code>
How much the environment map affects the surface.
The valid range is between `0` (no reflections) and `1` (full reflections).

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>1</code>  
<a name="MeshBasicMaterial+refractionRatio"></a>

### meshBasicMaterial.refractionRatio : <code>number</code>
The index of refraction (IOR) of air (approximately 1) divided by the
index of refraction of the material. It is used with environment mapping
modes [CubeRefractionMapping](CubeRefractionMapping) and [EquirectangularRefractionMapping](EquirectangularRefractionMapping).
The refraction ratio should not exceed `1`.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>0.98</code>  
<a name="MeshBasicMaterial+wireframe"></a>

### meshBasicMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>false</code>  
<a name="MeshBasicMaterial+wireframeLinewidth"></a>

### meshBasicMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>1</code>  
<a name="MeshBasicMaterial+wireframeLinecap"></a>

### meshBasicMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshBasicMaterial+wireframeLinejoin"></a>

### meshBasicMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshBasicMaterial+fog"></a>

### meshBasicMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshBasicMaterial</code>](#MeshBasicMaterial)  
**Default**: <code>true</code>  
<a name="MeshDepthMaterial"></a>

## MeshDepthMaterial ⇐ <code>Material</code>
A material for drawing geometry by depth. Depth is based off of the camera
near and far plane. White is nearest, black is farthest.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshDepthMaterial](#MeshDepthMaterial) ⇐ <code>Material</code>
    * [new MeshDepthMaterial([parameters])](#new_MeshDepthMaterial_new)
    * [.isMeshDepthMaterial](#MeshDepthMaterial+isMeshDepthMaterial) : <code>boolean</code>
    * [.depthPacking](#MeshDepthMaterial+depthPacking) : <code>BasicDepthPacking</code> \| <code>RGBADepthPacking</code> \| <code>RGBDepthPacking</code> \| <code>RGDepthPacking</code>
    * [.map](#MeshDepthMaterial+map) : <code>Texture</code>
    * [.alphaMap](#MeshDepthMaterial+alphaMap) : <code>Texture</code>
    * [.displacementMap](#MeshDepthMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshDepthMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshDepthMaterial+displacementBias) : <code>number</code>
    * [.wireframe](#MeshDepthMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshDepthMaterial+wireframeLinewidth) : <code>number</code>

<a name="new_MeshDepthMaterial_new"></a>

### new MeshDepthMaterial([parameters])
Constructs a new mesh depth material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshDepthMaterial+isMeshDepthMaterial"></a>

### meshDepthMaterial.isMeshDepthMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshDepthMaterial+depthPacking"></a>

### meshDepthMaterial.depthPacking : <code>BasicDepthPacking</code> \| <code>RGBADepthPacking</code> \| <code>RGBDepthPacking</code> \| <code>RGDepthPacking</code>
Type for depth packing.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>BasicDepthPacking</code>  
<a name="MeshDepthMaterial+map"></a>

### meshDepthMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest).

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>null</code>  
<a name="MeshDepthMaterial+alphaMap"></a>

### meshDepthMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>null</code>  
<a name="MeshDepthMaterial+displacementMap"></a>

### meshDepthMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>null</code>  
<a name="MeshDepthMaterial+displacementScale"></a>

### meshDepthMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>0</code>  
<a name="MeshDepthMaterial+displacementBias"></a>

### meshDepthMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>0</code>  
<a name="MeshDepthMaterial+wireframe"></a>

### meshDepthMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>false</code>  
<a name="MeshDepthMaterial+wireframeLinewidth"></a>

### meshDepthMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

WebGL and WebGPU ignore this property and always render
1 pixel wide lines.

**Kind**: instance property of [<code>MeshDepthMaterial</code>](#MeshDepthMaterial)  
**Default**: <code>1</code>  
<a name="MeshDistanceMaterial"></a>

## MeshDistanceMaterial ⇐ <code>Material</code>
A material used internally for implementing shadow mapping with
point lights.

Can also be used to customize the shadow casting of an object by assigning
an instance of `MeshDistanceMaterial` to [Object3D#customDistanceMaterial](Object3D#customDistanceMaterial).
The following examples demonstrates this approach in order to ensure
transparent parts of objects do no cast shadows.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshDistanceMaterial](#MeshDistanceMaterial) ⇐ <code>Material</code>
    * [new MeshDistanceMaterial([parameters])](#new_MeshDistanceMaterial_new)
    * [.isMeshDistanceMaterial](#MeshDistanceMaterial+isMeshDistanceMaterial) : <code>boolean</code>
    * [.map](#MeshDistanceMaterial+map) : <code>Texture</code>
    * [.alphaMap](#MeshDistanceMaterial+alphaMap) : <code>Texture</code>
    * [.displacementMap](#MeshDistanceMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshDistanceMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshDistanceMaterial+displacementBias) : <code>number</code>

<a name="new_MeshDistanceMaterial_new"></a>

### new MeshDistanceMaterial([parameters])
Constructs a new mesh distance material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshDistanceMaterial+isMeshDistanceMaterial"></a>

### meshDistanceMaterial.isMeshDistanceMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshDistanceMaterial+map"></a>

### meshDistanceMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest).

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>null</code>  
<a name="MeshDistanceMaterial+alphaMap"></a>

### meshDistanceMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>null</code>  
<a name="MeshDistanceMaterial+displacementMap"></a>

### meshDistanceMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>null</code>  
<a name="MeshDistanceMaterial+displacementScale"></a>

### meshDistanceMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>0</code>  
<a name="MeshDistanceMaterial+displacementBias"></a>

### meshDistanceMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshDistanceMaterial</code>](#MeshDistanceMaterial)  
**Default**: <code>0</code>  
<a name="MeshLambertMaterial"></a>

## MeshLambertMaterial ⇐ <code>Material</code>
A material for non-shiny surfaces, without specular highlights.

The material uses a non-physically based [Lambertian](https://en.wikipedia.org/wiki/Lambertian_reflectance)
model for calculating reflectance. This can simulate some surfaces (such
as untreated wood or stone) well, but cannot simulate shiny surfaces with
specular highlights (such as varnished wood). `MeshLambertMaterial` uses per-fragment
shading.

Due to the simplicity of the reflectance and illumination models,
performance will be greater when using this material over the
[MeshPhongMaterial](MeshPhongMaterial), [MeshStandardMaterial](MeshStandardMaterial) or
[MeshPhysicalMaterial](MeshPhysicalMaterial), at the cost of some graphical accuracy.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshLambertMaterial](#MeshLambertMaterial) ⇐ <code>Material</code>
    * [new MeshLambertMaterial([parameters])](#new_MeshLambertMaterial_new)
    * [.isMeshLambertMaterial](#MeshLambertMaterial+isMeshLambertMaterial) : <code>boolean</code>
    * [.color](#MeshLambertMaterial+color) : <code>Color</code>
    * [.map](#MeshLambertMaterial+map) : <code>Texture</code>
    * [.lightMap](#MeshLambertMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshLambertMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshLambertMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshLambertMaterial+aoMapIntensity) : <code>number</code>
    * [.emissive](#MeshLambertMaterial+emissive) : <code>Color</code>
    * [.emissiveIntensity](#MeshLambertMaterial+emissiveIntensity) : <code>number</code>
    * [.emissiveMap](#MeshLambertMaterial+emissiveMap) : <code>Texture</code>
    * [.bumpMap](#MeshLambertMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshLambertMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshLambertMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshLambertMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshLambertMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshLambertMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshLambertMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshLambertMaterial+displacementBias) : <code>number</code>
    * [.specularMap](#MeshLambertMaterial+specularMap) : <code>Texture</code>
    * [.alphaMap](#MeshLambertMaterial+alphaMap) : <code>Texture</code>
    * [.envMap](#MeshLambertMaterial+envMap) : <code>Texture</code>
    * [.envMapRotation](#MeshLambertMaterial+envMapRotation) : <code>Euler</code>
    * [.combine](#MeshLambertMaterial+combine) : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
    * [.reflectivity](#MeshLambertMaterial+reflectivity) : <code>number</code>
    * [.refractionRatio](#MeshLambertMaterial+refractionRatio) : <code>number</code>
    * [.wireframe](#MeshLambertMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshLambertMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshLambertMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshLambertMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.flatShading](#MeshLambertMaterial+flatShading) : <code>boolean</code>
    * [.fog](#MeshLambertMaterial+fog) : <code>boolean</code>

<a name="new_MeshLambertMaterial_new"></a>

### new MeshLambertMaterial([parameters])
Constructs a new mesh lambert material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshLambertMaterial+isMeshLambertMaterial"></a>

### meshLambertMaterial.isMeshLambertMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshLambertMaterial+color"></a>

### meshLambertMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshLambertMaterial+map"></a>

### meshLambertMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+lightMap"></a>

### meshLambertMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+lightMapIntensity"></a>

### meshLambertMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+aoMap"></a>

### meshLambertMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+aoMapIntensity"></a>

### meshLambertMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+emissive"></a>

### meshLambertMaterial.emissive : <code>Color</code>
Emissive (light) color of the material, essentially a solid color
unaffected by other lighting.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshLambertMaterial+emissiveIntensity"></a>

### meshLambertMaterial.emissiveIntensity : <code>number</code>
Intensity of the emissive light. Modulates the emissive color.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+emissiveMap"></a>

### meshLambertMaterial.emissiveMap : <code>Texture</code>
Set emissive (glow) map. The emissive map color is modulated by the
emissive color and the emissive intensity. If you have an emissive map,
be sure to set the emissive color to something other than black.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+bumpMap"></a>

### meshLambertMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+bumpScale"></a>

### meshLambertMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+normalMap"></a>

### meshLambertMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+normalMapType"></a>

### meshLambertMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshLambertMaterial+normalScale"></a>

### meshLambertMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshLambertMaterial+displacementMap"></a>

### meshLambertMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+displacementScale"></a>

### meshLambertMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>0</code>  
<a name="MeshLambertMaterial+displacementBias"></a>

### meshLambertMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>0</code>  
<a name="MeshLambertMaterial+specularMap"></a>

### meshLambertMaterial.specularMap : <code>Texture</code>
Specular map used by the material.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+alphaMap"></a>

### meshLambertMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+envMap"></a>

### meshLambertMaterial.envMap : <code>Texture</code>
The environment map.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>null</code>  
<a name="MeshLambertMaterial+envMapRotation"></a>

### meshLambertMaterial.envMapRotation : <code>Euler</code>
The rotation of the environment map in radians.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshLambertMaterial+combine"></a>

### meshLambertMaterial.combine : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
How to combine the result of the surface's color with the environment map, if any.

When set to `MixOperation`, the [MeshBasicMaterial#reflectivity](MeshBasicMaterial#reflectivity) is used to
blend between the two colors.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>MultiplyOperation</code>  
<a name="MeshLambertMaterial+reflectivity"></a>

### meshLambertMaterial.reflectivity : <code>number</code>
How much the environment map affects the surface.
The valid range is between `0` (no reflections) and `1` (full reflections).

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+refractionRatio"></a>

### meshLambertMaterial.refractionRatio : <code>number</code>
The index of refraction (IOR) of air (approximately 1) divided by the
index of refraction of the material. It is used with environment mapping
modes [CubeRefractionMapping](CubeRefractionMapping) and [EquirectangularRefractionMapping](EquirectangularRefractionMapping).
The refraction ratio should not exceed `1`.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>0.98</code>  
<a name="MeshLambertMaterial+wireframe"></a>

### meshLambertMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>false</code>  
<a name="MeshLambertMaterial+wireframeLinewidth"></a>

### meshLambertMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>1</code>  
<a name="MeshLambertMaterial+wireframeLinecap"></a>

### meshLambertMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshLambertMaterial+wireframeLinejoin"></a>

### meshLambertMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshLambertMaterial+flatShading"></a>

### meshLambertMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>false</code>  
<a name="MeshLambertMaterial+fog"></a>

### meshLambertMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshLambertMaterial</code>](#MeshLambertMaterial)  
**Default**: <code>true</code>  
<a name="MeshMatcapMaterial"></a>

## MeshMatcapMaterial ⇐ <code>Material</code>
This material is defined by a MatCap (or Lit Sphere) texture, which encodes the
material color and shading.

`MeshMatcapMaterial` does not respond to lights since the matcap image file encodes
baked lighting. It will cast a shadow onto an object that receives shadows
(and shadow clipping works), but it will not self-shadow or receive
shadows.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshMatcapMaterial](#MeshMatcapMaterial) ⇐ <code>Material</code>
    * [new MeshMatcapMaterial([parameters])](#new_MeshMatcapMaterial_new)
    * [.isMeshMatcapMaterial](#MeshMatcapMaterial+isMeshMatcapMaterial) : <code>boolean</code>
    * [.color](#MeshMatcapMaterial+color) : <code>Color</code>
    * [.matcap](#MeshMatcapMaterial+matcap) : <code>Texture</code>
    * [.map](#MeshMatcapMaterial+map) : <code>Texture</code>
    * [.bumpMap](#MeshMatcapMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshMatcapMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshMatcapMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshMatcapMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshMatcapMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshMatcapMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshMatcapMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshMatcapMaterial+displacementBias) : <code>number</code>
    * [.alphaMap](#MeshMatcapMaterial+alphaMap) : <code>Texture</code>
    * [.flatShading](#MeshMatcapMaterial+flatShading) : <code>boolean</code>
    * [.fog](#MeshMatcapMaterial+fog) : <code>boolean</code>

<a name="new_MeshMatcapMaterial_new"></a>

### new MeshMatcapMaterial([parameters])
Constructs a new mesh matcap material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshMatcapMaterial+isMeshMatcapMaterial"></a>

### meshMatcapMaterial.isMeshMatcapMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshMatcapMaterial+color"></a>

### meshMatcapMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshMatcapMaterial+matcap"></a>

### meshMatcapMaterial.matcap : <code>Texture</code>
The matcap map.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+map"></a>

### meshMatcapMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+bumpMap"></a>

### meshMatcapMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+bumpScale"></a>

### meshMatcapMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>1</code>  
<a name="MeshMatcapMaterial+normalMap"></a>

### meshMatcapMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+normalMapType"></a>

### meshMatcapMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshMatcapMaterial+normalScale"></a>

### meshMatcapMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshMatcapMaterial+displacementMap"></a>

### meshMatcapMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+displacementScale"></a>

### meshMatcapMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>0</code>  
<a name="MeshMatcapMaterial+displacementBias"></a>

### meshMatcapMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>0</code>  
<a name="MeshMatcapMaterial+alphaMap"></a>

### meshMatcapMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>null</code>  
<a name="MeshMatcapMaterial+flatShading"></a>

### meshMatcapMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>false</code>  
<a name="MeshMatcapMaterial+fog"></a>

### meshMatcapMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshMatcapMaterial</code>](#MeshMatcapMaterial)  
**Default**: <code>true</code>  
<a name="MeshNormalMaterial"></a>

## MeshNormalMaterial ⇐ <code>Material</code>
A material that maps the normal vectors to RGB colors.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshNormalMaterial](#MeshNormalMaterial) ⇐ <code>Material</code>
    * [new MeshNormalMaterial([parameters])](#new_MeshNormalMaterial_new)
    * [.isMeshNormalMaterial](#MeshNormalMaterial+isMeshNormalMaterial) : <code>boolean</code>
    * [.bumpMap](#MeshNormalMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshNormalMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshNormalMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshNormalMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshNormalMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshNormalMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshNormalMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshNormalMaterial+displacementBias) : <code>number</code>
    * [.wireframe](#MeshNormalMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshNormalMaterial+wireframeLinewidth) : <code>number</code>
    * [.flatShading](#MeshNormalMaterial+flatShading) : <code>boolean</code>

<a name="new_MeshNormalMaterial_new"></a>

### new MeshNormalMaterial([parameters])
Constructs a new mesh normal material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshNormalMaterial+isMeshNormalMaterial"></a>

### meshNormalMaterial.isMeshNormalMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshNormalMaterial+bumpMap"></a>

### meshNormalMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>null</code>  
<a name="MeshNormalMaterial+bumpScale"></a>

### meshNormalMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>1</code>  
<a name="MeshNormalMaterial+normalMap"></a>

### meshNormalMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>null</code>  
<a name="MeshNormalMaterial+normalMapType"></a>

### meshNormalMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshNormalMaterial+normalScale"></a>

### meshNormalMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshNormalMaterial+displacementMap"></a>

### meshNormalMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>null</code>  
<a name="MeshNormalMaterial+displacementScale"></a>

### meshNormalMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>0</code>  
<a name="MeshNormalMaterial+displacementBias"></a>

### meshNormalMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>0</code>  
<a name="MeshNormalMaterial+wireframe"></a>

### meshNormalMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>false</code>  
<a name="MeshNormalMaterial+wireframeLinewidth"></a>

### meshNormalMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

WebGL and WebGPU ignore this property and always render
1 pixel wide lines.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>1</code>  
<a name="MeshNormalMaterial+flatShading"></a>

### meshNormalMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshNormalMaterial</code>](#MeshNormalMaterial)  
**Default**: <code>false</code>  
<a name="MeshPhongMaterial"></a>

## MeshPhongMaterial ⇐ <code>Material</code>
A material for shiny surfaces with specular highlights.

The material uses a non-physically based [Blinn-Phong](https://en.wikipedia.org/wiki/Blinn-Phong_shading_model)
model for calculating reflectance. Unlike the Lambertian model used in the
[MeshLambertMaterial](MeshLambertMaterial) this can simulate shiny surfaces with specular
highlights (such as varnished wood). `MeshPhongMaterial` uses per-fragment shading.

Performance will generally be greater when using this material over the
[MeshStandardMaterial](MeshStandardMaterial) or [MeshPhysicalMaterial](MeshPhysicalMaterial), at the cost of
some graphical accuracy.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshPhongMaterial](#MeshPhongMaterial) ⇐ <code>Material</code>
    * [new MeshPhongMaterial([parameters])](#new_MeshPhongMaterial_new)
    * [.isMeshPhongMaterial](#MeshPhongMaterial+isMeshPhongMaterial) : <code>boolean</code>
    * [.color](#MeshPhongMaterial+color) : <code>Color</code>
    * [.specular](#MeshPhongMaterial+specular) : <code>Color</code>
    * [.shininess](#MeshPhongMaterial+shininess) : <code>number</code>
    * [.map](#MeshPhongMaterial+map) : <code>Texture</code>
    * [.lightMap](#MeshPhongMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshPhongMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshPhongMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshPhongMaterial+aoMapIntensity) : <code>number</code>
    * [.emissive](#MeshPhongMaterial+emissive) : <code>Color</code>
    * [.emissiveIntensity](#MeshPhongMaterial+emissiveIntensity) : <code>number</code>
    * [.emissiveMap](#MeshPhongMaterial+emissiveMap) : <code>Texture</code>
    * [.bumpMap](#MeshPhongMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshPhongMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshPhongMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshPhongMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshPhongMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshPhongMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshPhongMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshPhongMaterial+displacementBias) : <code>number</code>
    * [.specularMap](#MeshPhongMaterial+specularMap) : <code>Texture</code>
    * [.alphaMap](#MeshPhongMaterial+alphaMap) : <code>Texture</code>
    * [.envMap](#MeshPhongMaterial+envMap) : <code>Texture</code>
    * [.envMapRotation](#MeshPhongMaterial+envMapRotation) : <code>Euler</code>
    * [.combine](#MeshPhongMaterial+combine) : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
    * [.reflectivity](#MeshPhongMaterial+reflectivity) : <code>number</code>
    * [.refractionRatio](#MeshPhongMaterial+refractionRatio) : <code>number</code>
    * [.wireframe](#MeshPhongMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshPhongMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshPhongMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshPhongMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.flatShading](#MeshPhongMaterial+flatShading) : <code>boolean</code>
    * [.fog](#MeshPhongMaterial+fog) : <code>boolean</code>

<a name="new_MeshPhongMaterial_new"></a>

### new MeshPhongMaterial([parameters])
Constructs a new mesh phong material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshPhongMaterial+isMeshPhongMaterial"></a>

### meshPhongMaterial.isMeshPhongMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPhongMaterial+color"></a>

### meshPhongMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshPhongMaterial+specular"></a>

### meshPhongMaterial.specular : <code>Color</code>
Specular color of the material. The default color is set to `0x111111` (very dark grey)

This defines how shiny the material is and the color of its shine.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
<a name="MeshPhongMaterial+shininess"></a>

### meshPhongMaterial.shininess : <code>number</code>
How shiny the specular highlight is; a higher value gives a sharper highlight.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>30</code>  
<a name="MeshPhongMaterial+map"></a>

### meshPhongMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+lightMap"></a>

### meshPhongMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+lightMapIntensity"></a>

### meshPhongMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+aoMap"></a>

### meshPhongMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+aoMapIntensity"></a>

### meshPhongMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+emissive"></a>

### meshPhongMaterial.emissive : <code>Color</code>
Emissive (light) color of the material, essentially a solid color
unaffected by other lighting.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshPhongMaterial+emissiveIntensity"></a>

### meshPhongMaterial.emissiveIntensity : <code>number</code>
Intensity of the emissive light. Modulates the emissive color.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+emissiveMap"></a>

### meshPhongMaterial.emissiveMap : <code>Texture</code>
Set emissive (glow) map. The emissive map color is modulated by the
emissive color and the emissive intensity. If you have an emissive map,
be sure to set the emissive color to something other than black.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+bumpMap"></a>

### meshPhongMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+bumpScale"></a>

### meshPhongMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+normalMap"></a>

### meshPhongMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+normalMapType"></a>

### meshPhongMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshPhongMaterial+normalScale"></a>

### meshPhongMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshPhongMaterial+displacementMap"></a>

### meshPhongMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+displacementScale"></a>

### meshPhongMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhongMaterial+displacementBias"></a>

### meshPhongMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhongMaterial+specularMap"></a>

### meshPhongMaterial.specularMap : <code>Texture</code>
The specular map value affects both how much the specular surface
highlight contributes and how much of the environment map affects the
surface.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+alphaMap"></a>

### meshPhongMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+envMap"></a>

### meshPhongMaterial.envMap : <code>Texture</code>
The environment map.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongMaterial+envMapRotation"></a>

### meshPhongMaterial.envMapRotation : <code>Euler</code>
The rotation of the environment map in radians.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshPhongMaterial+combine"></a>

### meshPhongMaterial.combine : <code>MultiplyOperation</code> \| <code>MixOperation</code> \| <code>AddOperation</code>
How to combine the result of the surface's color with the environment map, if any.

When set to `MixOperation`, the [MeshBasicMaterial#reflectivity](MeshBasicMaterial#reflectivity) is used to
blend between the two colors.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>MultiplyOperation</code>  
<a name="MeshPhongMaterial+reflectivity"></a>

### meshPhongMaterial.reflectivity : <code>number</code>
How much the environment map affects the surface.
The valid range is between `0` (no reflections) and `1` (full reflections).

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+refractionRatio"></a>

### meshPhongMaterial.refractionRatio : <code>number</code>
The index of refraction (IOR) of air (approximately 1) divided by the
index of refraction of the material. It is used with environment mapping
modes [CubeRefractionMapping](CubeRefractionMapping) and [EquirectangularRefractionMapping](EquirectangularRefractionMapping).
The refraction ratio should not exceed `1`.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>0.98</code>  
<a name="MeshPhongMaterial+wireframe"></a>

### meshPhongMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>false</code>  
<a name="MeshPhongMaterial+wireframeLinewidth"></a>

### meshPhongMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhongMaterial+wireframeLinecap"></a>

### meshPhongMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshPhongMaterial+wireframeLinejoin"></a>

### meshPhongMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshPhongMaterial+flatShading"></a>

### meshPhongMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>false</code>  
<a name="MeshPhongMaterial+fog"></a>

### meshPhongMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshPhongMaterial</code>](#MeshPhongMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalMaterial"></a>

## MeshPhysicalMaterial ⇐ <code>MeshStandardMaterial</code>
An extension of the [MeshStandardMaterial](MeshStandardMaterial), providing more advanced
physically-based rendering properties:

- Anisotropy: Ability to represent the anisotropic property of materials
as observable with brushed metals.
- Clearcoat: Some materials — like car paints, carbon fiber, and wet surfaces — require
a clear, reflective layer on top of another layer that may be irregular or rough.
Clearcoat approximates this effect, without the need for a separate transparent surface.
- Iridescence: Allows to render the effect where hue varies  depending on the viewing
angle and illumination angle. This can be seen on soap bubbles, oil films, or on the
wings of many insects.
- Physically-based transparency: One limitation of [Material#opacity](Material#opacity) is that highly
transparent materials are less reflective. Physically-based transmission provides a more
realistic option for thin, transparent surfaces like glass.
- Advanced reflectivity: More flexible reflectivity for non-metallic materials.
- Sheen: Can be used for representing cloth and fabric materials.

As a result of these complex shading features, `MeshPhysicalMaterial` has a
higher performance cost, per pixel, than other three.js materials. Most
effects are disabled by default, and add cost as they are enabled. For
best results, always specify an environment map when using this material.

**Kind**: global class  
**Extends**: <code>MeshStandardMaterial</code>  

* [MeshPhysicalMaterial](#MeshPhysicalMaterial) ⇐ <code>MeshStandardMaterial</code>
    * [new MeshPhysicalMaterial([parameters])](#new_MeshPhysicalMaterial_new)
    * [.isMeshPhysicalMaterial](#MeshPhysicalMaterial+isMeshPhysicalMaterial) : <code>boolean</code>
    * [.anisotropyRotation](#MeshPhysicalMaterial+anisotropyRotation) : <code>number</code>
    * [.anisotropyMap](#MeshPhysicalMaterial+anisotropyMap) : <code>Texture</code>
    * [.clearcoatMap](#MeshPhysicalMaterial+clearcoatMap) : <code>Texture</code>
    * [.clearcoatRoughness](#MeshPhysicalMaterial+clearcoatRoughness) : <code>number</code>
    * [.clearcoatRoughnessMap](#MeshPhysicalMaterial+clearcoatRoughnessMap) : <code>Texture</code>
    * [.clearcoatNormalScale](#MeshPhysicalMaterial+clearcoatNormalScale) : <code>Vector2</code>
    * [.clearcoatNormalMap](#MeshPhysicalMaterial+clearcoatNormalMap) : <code>Texture</code>
    * [.ior](#MeshPhysicalMaterial+ior) : <code>number</code>
    * [.reflectivity](#MeshPhysicalMaterial+reflectivity) : <code>number</code>
    * [.iridescenceMap](#MeshPhysicalMaterial+iridescenceMap) : <code>Texture</code>
    * [.iridescenceIOR](#MeshPhysicalMaterial+iridescenceIOR) : <code>number</code>
    * [.iridescenceThicknessRange](#MeshPhysicalMaterial+iridescenceThicknessRange) : <code>Array.&lt;number, number&gt;</code>
    * [.iridescenceThicknessMap](#MeshPhysicalMaterial+iridescenceThicknessMap) : <code>Texture</code>
    * [.sheenColor](#MeshPhysicalMaterial+sheenColor) : <code>Color</code>
    * [.sheenColorMap](#MeshPhysicalMaterial+sheenColorMap) : <code>Texture</code>
    * [.sheenRoughness](#MeshPhysicalMaterial+sheenRoughness) : <code>number</code>
    * [.sheenRoughnessMap](#MeshPhysicalMaterial+sheenRoughnessMap) : <code>Texture</code>
    * [.transmissionMap](#MeshPhysicalMaterial+transmissionMap) : <code>Texture</code>
    * [.thickness](#MeshPhysicalMaterial+thickness) : <code>number</code>
    * [.thicknessMap](#MeshPhysicalMaterial+thicknessMap) : <code>Texture</code>
    * [.attenuationDistance](#MeshPhysicalMaterial+attenuationDistance) : <code>number</code>
    * [.attenuationColor](#MeshPhysicalMaterial+attenuationColor) : <code>Color</code>
    * [.specularIntensity](#MeshPhysicalMaterial+specularIntensity) : <code>number</code>
    * [.specularIntensityMap](#MeshPhysicalMaterial+specularIntensityMap) : <code>Texture</code>
    * [.specularColor](#MeshPhysicalMaterial+specularColor) : <code>Color</code>
    * [.specularColorMap](#MeshPhysicalMaterial+specularColorMap) : <code>Texture</code>
    * [.anisotropy](#MeshPhysicalMaterial+anisotropy) : <code>number</code>
    * [.clearcoat](#MeshPhysicalMaterial+clearcoat) : <code>number</code>
    * [.iridescence](#MeshPhysicalMaterial+iridescence) : <code>number</code>
    * [.dispersion](#MeshPhysicalMaterial+dispersion) : <code>number</code>
    * [.sheen](#MeshPhysicalMaterial+sheen) : <code>number</code>
    * [.transmission](#MeshPhysicalMaterial+transmission) : <code>number</code>

<a name="new_MeshPhysicalMaterial_new"></a>

### new MeshPhysicalMaterial([parameters])
Constructs a new mesh physical material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshPhysicalMaterial+isMeshPhysicalMaterial"></a>

### meshPhysicalMaterial.isMeshPhysicalMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPhysicalMaterial+anisotropyRotation"></a>

### meshPhysicalMaterial.anisotropyRotation : <code>number</code>
The rotation of the anisotropy in tangent, bitangent space, measured in radians
counter-clockwise from the tangent. When `anisotropyMap` is present, this
property provides additional rotation to the vectors in the texture.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhysicalMaterial+anisotropyMap"></a>

### meshPhysicalMaterial.anisotropyMap : <code>Texture</code>
Red and green channels represent the anisotropy direction in `[-1, 1]` tangent,
bitangent space, to be rotated by `anisotropyRotation`. The blue channel
contains strength as `[0, 1]` to be multiplied by `anisotropy`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+clearcoatMap"></a>

### meshPhysicalMaterial.clearcoatMap : <code>Texture</code>
The red channel of this texture is multiplied against `clearcoat`,
for per-pixel control over a coating's intensity.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+clearcoatRoughness"></a>

### meshPhysicalMaterial.clearcoatRoughness : <code>number</code>
Roughness of the clear coat layer, from `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+clearcoatRoughnessMap"></a>

### meshPhysicalMaterial.clearcoatRoughnessMap : <code>Texture</code>
The green channel of this texture is multiplied against
`clearcoatRoughness`, for per-pixel control over a coating's roughness.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+clearcoatNormalScale"></a>

### meshPhysicalMaterial.clearcoatNormalScale : <code>Vector2</code>
How much `clearcoatNormalMap` affects the clear coat layer, from
`(0,0)` to `(1,1)`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshPhysicalMaterial+clearcoatNormalMap"></a>

### meshPhysicalMaterial.clearcoatNormalMap : <code>Texture</code>
Can be used to enable independent normals for the clear coat layer.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+ior"></a>

### meshPhysicalMaterial.ior : <code>number</code>
Index-of-refraction for non-metallic materials, from `1.0` to `2.333`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1.5</code>  
<a name="MeshPhysicalMaterial+reflectivity"></a>

### meshPhysicalMaterial.reflectivity : <code>number</code>
Degree of reflectivity, from `0.0` to `1.0`. Default is `0.5`, which
corresponds to an index-of-refraction of `1.5`.

This models the reflectivity of non-metallic materials. It has no effect
when `metalness` is `1.0`

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0.5</code>  
<a name="MeshPhysicalMaterial+iridescenceMap"></a>

### meshPhysicalMaterial.iridescenceMap : <code>Texture</code>
The red channel of this texture is multiplied against `iridescence`, for per-pixel
control over iridescence.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+iridescenceIOR"></a>

### meshPhysicalMaterial.iridescenceIOR : <code>number</code>
Strength of the iridescence RGB color shift effect, represented by an index-of-refraction.
Between `1.0` to `2.333`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1.3</code>  
<a name="MeshPhysicalMaterial+iridescenceThicknessRange"></a>

### meshPhysicalMaterial.iridescenceThicknessRange : <code>Array.&lt;number, number&gt;</code>
Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer.
		 Thickness of iridescence layer has an equivalent effect of the one `thickness` has on `ior`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>[100,400]</code>  
<a name="MeshPhysicalMaterial+iridescenceThicknessMap"></a>

### meshPhysicalMaterial.iridescenceThicknessMap : <code>Texture</code>
A texture that defines the thickness of the iridescence layer, stored in the green channel.
Minimum and maximum values of thickness are defined by `iridescenceThicknessRange` array:
- `0.0` in the green channel will result in thickness equal to first element of the array.
- `1.0` in the green channel will result in thickness equal to second element of the array.
- Values in-between will linearly interpolate between the elements of the array.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+sheenColor"></a>

### meshPhysicalMaterial.sheenColor : <code>Color</code>
The sheen tint.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshPhysicalMaterial+sheenColorMap"></a>

### meshPhysicalMaterial.sheenColorMap : <code>Texture</code>
The RGB channels of this texture are multiplied against  `sheenColor`, for per-pixel control
over sheen tint.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+sheenRoughness"></a>

### meshPhysicalMaterial.sheenRoughness : <code>number</code>
Roughness of the sheen layer, from `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhysicalMaterial+sheenRoughnessMap"></a>

### meshPhysicalMaterial.sheenRoughnessMap : <code>Texture</code>
The alpha channel of this texture is multiplied against `sheenRoughness`, for per-pixel control
over sheen roughness.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+transmissionMap"></a>

### meshPhysicalMaterial.transmissionMap : <code>Texture</code>
The red channel of this texture is multiplied against `transmission`, for per-pixel control over
optical transparency.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+thickness"></a>

### meshPhysicalMaterial.thickness : <code>number</code>
The thickness of the volume beneath the surface. The value is given in the
coordinate space of the mesh. If the value is `0` the material is
thin-walled. Otherwise the material is a volume boundary.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+thicknessMap"></a>

### meshPhysicalMaterial.thicknessMap : <code>Texture</code>
A texture that defines the thickness, stored in the green channel. This will
be multiplied by `thickness`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+attenuationDistance"></a>

### meshPhysicalMaterial.attenuationDistance : <code>number</code>
Density of the medium given as the average distance that light travels in
the medium before interacting with a particle. The value is given in world
space units, and must be greater than zero.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>Infinity</code>  
<a name="MeshPhysicalMaterial+attenuationColor"></a>

### meshPhysicalMaterial.attenuationColor : <code>Color</code>
The color that white light turns into due to absorption when reaching the
attenuation distance.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshPhysicalMaterial+specularIntensity"></a>

### meshPhysicalMaterial.specularIntensity : <code>number</code>
A float that scales the amount of specular reflection for non-metals only.
When set to zero, the model is effectively Lambertian. From `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>1</code>  
<a name="MeshPhysicalMaterial+specularIntensityMap"></a>

### meshPhysicalMaterial.specularIntensityMap : <code>Texture</code>
The alpha channel of this texture is multiplied against `specularIntensity`,
for per-pixel control over specular intensity.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+specularColor"></a>

### meshPhysicalMaterial.specularColor : <code>Color</code>
Tints the specular reflection at normal incidence for non-metals only.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshPhysicalMaterial+specularColorMap"></a>

### meshPhysicalMaterial.specularColorMap : <code>Texture</code>
The RGB channels of this texture are multiplied against `specularColor`,
for per-pixel control over specular color.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalMaterial+anisotropy"></a>

### meshPhysicalMaterial.anisotropy : <code>number</code>
The anisotropy strength.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+clearcoat"></a>

### meshPhysicalMaterial.clearcoat : <code>number</code>
Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
clear coat related properties to enable multilayer materials that have a
thin translucent layer over the base layer.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+iridescence"></a>

### meshPhysicalMaterial.iridescence : <code>number</code>
The intensity of the iridescence layer, simulating RGB color shift based on the angle between
the surface and the viewer, from `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+dispersion"></a>

### meshPhysicalMaterial.dispersion : <code>number</code>
Defines the strength of the angular separation of colors (chromatic aberration) transmitting
through a relatively clear volume. Any value zero or larger is valid, the typical range of
realistic values is `[0, 1]`. This property can be only be used with transmissive objects.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+sheen"></a>

### meshPhysicalMaterial.sheen : <code>number</code>
The intensity of the sheen layer, from `0.0` to `1.0`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshPhysicalMaterial+transmission"></a>

### meshPhysicalMaterial.transmission : <code>number</code>
Degree of transmission (or optical transparency), from `0.0` to `1.0`.

Thin, transparent or semitransparent, plastic or glass materials remain
largely reflective even if they are fully transmissive. The transmission
property can be used to model these materials.

When transmission is non-zero, `opacity` should be  set to `1`.

**Kind**: instance property of [<code>MeshPhysicalMaterial</code>](#MeshPhysicalMaterial)  
**Default**: <code>0</code>  
<a name="MeshStandardMaterial"></a>

## MeshStandardMaterial ⇐ <code>Material</code>
A standard physically based material, using Metallic-Roughness workflow.

Physically based rendering (PBR) has recently become the standard in many
3D applications, such as [Unity](https://blogs.unity3d.com/2014/10/29/physically-based-shading-in-unity-5-a-primer/),
[Unreal](https://docs.unrealengine.com/latest/INT/Engine/Rendering/Materials/PhysicallyBased/) and
[3D Studio Max](http://area.autodesk.com/blogs/the-3ds-max-blog/what039s-new-for-rendering-in-3ds-max-2017).

This approach differs from older approaches in that instead of using
approximations for the way in which light interacts with a surface, a
physically correct model is used. The idea is that, instead of tweaking
materials to look good under specific lighting, a material can be created
that will react 'correctly' under all lighting scenarios.

In practice this gives a more accurate and realistic looking result than
the [MeshLambertMaterial](MeshLambertMaterial) or [MeshPhongMaterial](MeshPhongMaterial), at the cost of
being somewhat more computationally expensive. `MeshStandardMaterial` uses per-fragment
shading.

Note that for best results you should always specify an environment map when using this material.

For a non-technical introduction to the concept of PBR and how to set up a
PBR material, check out these articles by the people at [marmoset](https://www.marmoset.co):

- [Basic Theory of Physically Based Rendering](https://www.marmoset.co/posts/basic-theory-of-physically-based-rendering/)
- [Physically Based Rendering and You Can Too](https://www.marmoset.co/posts/physically-based-rendering-and-you-can-too/)

Technical details of the approach used in three.js (and most other PBR systems) can be found is this
[paper from Disney](https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf)
(pdf), by Brent Burley.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshStandardMaterial](#MeshStandardMaterial) ⇐ <code>Material</code>
    * [new MeshStandardMaterial([parameters])](#new_MeshStandardMaterial_new)
    * [.isMeshStandardMaterial](#MeshStandardMaterial+isMeshStandardMaterial) : <code>boolean</code>
    * [.color](#MeshStandardMaterial+color) : <code>Color</code>
    * [.roughness](#MeshStandardMaterial+roughness) : <code>number</code>
    * [.metalness](#MeshStandardMaterial+metalness) : <code>number</code>
    * [.map](#MeshStandardMaterial+map) : <code>Texture</code>
    * [.lightMap](#MeshStandardMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshStandardMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshStandardMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshStandardMaterial+aoMapIntensity) : <code>number</code>
    * [.emissive](#MeshStandardMaterial+emissive) : <code>Color</code>
    * [.emissiveIntensity](#MeshStandardMaterial+emissiveIntensity) : <code>number</code>
    * [.emissiveMap](#MeshStandardMaterial+emissiveMap) : <code>Texture</code>
    * [.bumpMap](#MeshStandardMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshStandardMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshStandardMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshStandardMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshStandardMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshStandardMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshStandardMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshStandardMaterial+displacementBias) : <code>number</code>
    * [.roughnessMap](#MeshStandardMaterial+roughnessMap) : <code>Texture</code>
    * [.metalnessMap](#MeshStandardMaterial+metalnessMap) : <code>Texture</code>
    * [.alphaMap](#MeshStandardMaterial+alphaMap) : <code>Texture</code>
    * [.envMap](#MeshStandardMaterial+envMap) : <code>Texture</code>
    * [.envMapRotation](#MeshStandardMaterial+envMapRotation) : <code>Euler</code>
    * [.envMapIntensity](#MeshStandardMaterial+envMapIntensity) : <code>number</code>
    * [.wireframe](#MeshStandardMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshStandardMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshStandardMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshStandardMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.flatShading](#MeshStandardMaterial+flatShading) : <code>boolean</code>
    * [.fog](#MeshStandardMaterial+fog) : <code>boolean</code>

<a name="new_MeshStandardMaterial_new"></a>

### new MeshStandardMaterial([parameters])
Constructs a new mesh standard material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshStandardMaterial+isMeshStandardMaterial"></a>

### meshStandardMaterial.isMeshStandardMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshStandardMaterial+color"></a>

### meshStandardMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshStandardMaterial+roughness"></a>

### meshStandardMaterial.roughness : <code>number</code>
How rough the material appears. `0.0` means a smooth mirror reflection, `1.0`
means fully diffuse. If `roughnessMap` is also provided,
both values are multiplied.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+metalness"></a>

### meshStandardMaterial.metalness : <code>number</code>
How much the material is like a metal. Non-metallic materials such as wood
or stone use `0.0`, metallic use `1.0`, with nothing (usually) in between.
A value between `0.0` and `1.0` could be used for a rusty metal look.
If `metalnessMap` is also provided, both values are multiplied.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>0</code>  
<a name="MeshStandardMaterial+map"></a>

### meshStandardMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+lightMap"></a>

### meshStandardMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+lightMapIntensity"></a>

### meshStandardMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+aoMap"></a>

### meshStandardMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+aoMapIntensity"></a>

### meshStandardMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+emissive"></a>

### meshStandardMaterial.emissive : <code>Color</code>
Emissive (light) color of the material, essentially a solid color
unaffected by other lighting.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshStandardMaterial+emissiveIntensity"></a>

### meshStandardMaterial.emissiveIntensity : <code>number</code>
Intensity of the emissive light. Modulates the emissive color.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+emissiveMap"></a>

### meshStandardMaterial.emissiveMap : <code>Texture</code>
Set emissive (glow) map. The emissive map color is modulated by the
emissive color and the emissive intensity. If you have an emissive map,
be sure to set the emissive color to something other than black.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+bumpMap"></a>

### meshStandardMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+bumpScale"></a>

### meshStandardMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+normalMap"></a>

### meshStandardMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+normalMapType"></a>

### meshStandardMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshStandardMaterial+normalScale"></a>

### meshStandardMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshStandardMaterial+displacementMap"></a>

### meshStandardMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+displacementScale"></a>

### meshStandardMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>0</code>  
<a name="MeshStandardMaterial+displacementBias"></a>

### meshStandardMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>0</code>  
<a name="MeshStandardMaterial+roughnessMap"></a>

### meshStandardMaterial.roughnessMap : <code>Texture</code>
The green channel of this texture is used to alter the roughness of the
material.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+metalnessMap"></a>

### meshStandardMaterial.metalnessMap : <code>Texture</code>
The blue channel of this texture is used to alter the metalness of the
material.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+alphaMap"></a>

### meshStandardMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+envMap"></a>

### meshStandardMaterial.envMap : <code>Texture</code>
The environment map. To ensure a physically correct rendering, environment maps
are internally pre-processed with [PMREMGenerator](PMREMGenerator).

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardMaterial+envMapRotation"></a>

### meshStandardMaterial.envMapRotation : <code>Euler</code>
The rotation of the environment map in radians.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshStandardMaterial+envMapIntensity"></a>

### meshStandardMaterial.envMapIntensity : <code>number</code>
Scales the effect of the environment map by multiplying its color.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+wireframe"></a>

### meshStandardMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>false</code>  
<a name="MeshStandardMaterial+wireframeLinewidth"></a>

### meshStandardMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>1</code>  
<a name="MeshStandardMaterial+wireframeLinecap"></a>

### meshStandardMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshStandardMaterial+wireframeLinejoin"></a>

### meshStandardMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshStandardMaterial+flatShading"></a>

### meshStandardMaterial.flatShading : <code>boolean</code>
Whether the material is rendered with flat shading or not.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>false</code>  
<a name="MeshStandardMaterial+fog"></a>

### meshStandardMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshStandardMaterial</code>](#MeshStandardMaterial)  
**Default**: <code>true</code>  
<a name="MeshToonMaterial"></a>

## MeshToonMaterial ⇐ <code>Material</code>
A material implementing toon shading.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [MeshToonMaterial](#MeshToonMaterial) ⇐ <code>Material</code>
    * [new MeshToonMaterial([parameters])](#new_MeshToonMaterial_new)
    * [.isMeshToonMaterial](#MeshToonMaterial+isMeshToonMaterial) : <code>boolean</code>
    * [.color](#MeshToonMaterial+color) : <code>Color</code>
    * [.map](#MeshToonMaterial+map) : <code>Texture</code>
    * [.gradientMap](#MeshToonMaterial+gradientMap) : <code>Texture</code>
    * [.lightMap](#MeshToonMaterial+lightMap) : <code>Texture</code>
    * [.lightMapIntensity](#MeshToonMaterial+lightMapIntensity) : <code>number</code>
    * [.aoMap](#MeshToonMaterial+aoMap) : <code>Texture</code>
    * [.aoMapIntensity](#MeshToonMaterial+aoMapIntensity) : <code>number</code>
    * [.emissive](#MeshToonMaterial+emissive) : <code>Color</code>
    * [.emissiveIntensity](#MeshToonMaterial+emissiveIntensity) : <code>number</code>
    * [.emissiveMap](#MeshToonMaterial+emissiveMap) : <code>Texture</code>
    * [.bumpMap](#MeshToonMaterial+bumpMap) : <code>Texture</code>
    * [.bumpScale](#MeshToonMaterial+bumpScale) : <code>number</code>
    * [.normalMap](#MeshToonMaterial+normalMap) : <code>Texture</code>
    * [.normalMapType](#MeshToonMaterial+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
    * [.normalScale](#MeshToonMaterial+normalScale) : <code>Vector2</code>
    * [.displacementMap](#MeshToonMaterial+displacementMap) : <code>Texture</code>
    * [.displacementScale](#MeshToonMaterial+displacementScale) : <code>number</code>
    * [.displacementBias](#MeshToonMaterial+displacementBias) : <code>number</code>
    * [.alphaMap](#MeshToonMaterial+alphaMap) : <code>Texture</code>
    * [.wireframe](#MeshToonMaterial+wireframe) : <code>boolean</code>
    * [.wireframeLinewidth](#MeshToonMaterial+wireframeLinewidth) : <code>number</code>
    * [.wireframeLinecap](#MeshToonMaterial+wireframeLinecap) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.wireframeLinejoin](#MeshToonMaterial+wireframeLinejoin) : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
    * [.fog](#MeshToonMaterial+fog) : <code>boolean</code>

<a name="new_MeshToonMaterial_new"></a>

### new MeshToonMaterial([parameters])
Constructs a new mesh toon material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshToonMaterial+isMeshToonMaterial"></a>

### meshToonMaterial.isMeshToonMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshToonMaterial+color"></a>

### meshToonMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="MeshToonMaterial+map"></a>

### meshToonMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+gradientMap"></a>

### meshToonMaterial.gradientMap : <code>Texture</code>
Gradient map for toon shading. It's required to set
[Texture#minFilter](Texture#minFilter) and [Texture#magFilter](Texture#magFilter) to {@linkNearestFilter}
when using this type of texture.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+lightMap"></a>

### meshToonMaterial.lightMap : <code>Texture</code>
The light map. Requires a second set of UVs.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+lightMapIntensity"></a>

### meshToonMaterial.lightMapIntensity : <code>number</code>
Intensity of the baked light.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+aoMap"></a>

### meshToonMaterial.aoMap : <code>Texture</code>
The red channel of this texture is used as the ambient occlusion map.
Requires a second set of UVs.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+aoMapIntensity"></a>

### meshToonMaterial.aoMapIntensity : <code>number</code>
Intensity of the ambient occlusion effect. Range is `[0,1]`, where `0`
disables ambient occlusion. Where intensity is `1` and the AO map's
red channel is also `1`, ambient light is fully occluded on a surface.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+emissive"></a>

### meshToonMaterial.emissive : <code>Color</code>
Emissive (light) color of the material, essentially a solid color
unaffected by other lighting.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="MeshToonMaterial+emissiveIntensity"></a>

### meshToonMaterial.emissiveIntensity : <code>number</code>
Intensity of the emissive light. Modulates the emissive color.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+emissiveMap"></a>

### meshToonMaterial.emissiveMap : <code>Texture</code>
Set emissive (glow) map. The emissive map color is modulated by the
emissive color and the emissive intensity. If you have an emissive map,
be sure to set the emissive color to something other than black.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+bumpMap"></a>

### meshToonMaterial.bumpMap : <code>Texture</code>
The texture to create a bump map. The black and white values map to the
perceived depth in relation to the lights. Bump doesn't actually affect
the geometry of the object, only the lighting. If a normal map is defined
this will be ignored.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+bumpScale"></a>

### meshToonMaterial.bumpScale : <code>number</code>
How much the bump map affects the material. Typical range is `[0,1]`.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+normalMap"></a>

### meshToonMaterial.normalMap : <code>Texture</code>
The texture to create a normal map. The RGB values affect the surface
normal for each pixel fragment and change the way the color is lit. Normal
maps do not change the actual shape of the surface, only the lighting. In
case the material has a normal map authored using the left handed
convention, the `y` component of `normalScale` should be negated to compensate
for the different handedness.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+normalMapType"></a>

### meshToonMaterial.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The type of normal map.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="MeshToonMaterial+normalScale"></a>

### meshToonMaterial.normalScale : <code>Vector2</code>
How much the normal map affects the material. Typical value range is `[0,1]`.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>(1,1)</code>  
<a name="MeshToonMaterial+displacementMap"></a>

### meshToonMaterial.displacementMap : <code>Texture</code>
The displacement map affects the position of the mesh's vertices. Unlike
other maps which only affect the light and shade of the material the
displaced vertices can cast shadows, block other objects, and otherwise
act as real geometry. The displacement texture is an image where the value
of each pixel (white being the highest) is mapped against, and
repositions, the vertices of the mesh.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+displacementScale"></a>

### meshToonMaterial.displacementScale : <code>number</code>
How much the displacement map affects the mesh (where black is no
displacement, and white is maximum displacement). Without a displacement
map set, this value is not applied.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>0</code>  
<a name="MeshToonMaterial+displacementBias"></a>

### meshToonMaterial.displacementBias : <code>number</code>
The offset of the displacement map's values on the mesh's vertices.
The bias is added to the scaled sample of the displacement map.
Without a displacement map set, this value is not applied.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>0</code>  
<a name="MeshToonMaterial+alphaMap"></a>

### meshToonMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>null</code>  
<a name="MeshToonMaterial+wireframe"></a>

### meshToonMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>false</code>  
<a name="MeshToonMaterial+wireframeLinewidth"></a>

### meshToonMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>1</code>  
<a name="MeshToonMaterial+wireframeLinecap"></a>

### meshToonMaterial.wireframeLinecap : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe ends.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshToonMaterial+wireframeLinejoin"></a>

### meshToonMaterial.wireframeLinejoin : <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code>
Defines appearance of wireframe joints.

Can only be used with [SVGRenderer](SVGRenderer).

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>&#x27;round&#x27;</code>  
<a name="MeshToonMaterial+fog"></a>

### meshToonMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>MeshToonMaterial</code>](#MeshToonMaterial)  
**Default**: <code>true</code>  
<a name="PointsMaterial"></a>

## PointsMaterial ⇐ <code>Material</code>
A material for rendering point primitives.

Materials define the appearance of renderable 3D objects.

```js
const vertices = [];

for ( let i = 0; i < 10000; i ++ ) {
	const x = THREE.MathUtils.randFloatSpread( 2000 );
	const y = THREE.MathUtils.randFloatSpread( 2000 );
	const z = THREE.MathUtils.randFloatSpread( 2000 );

	vertices.push( x, y, z );
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
const material = new THREE.PointsMaterial( { color: 0x888888 } );
const points = new THREE.Points( geometry, material );
scene.add( points );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [PointsMaterial](#PointsMaterial) ⇐ <code>Material</code>
    * [new PointsMaterial([parameters])](#new_PointsMaterial_new)
    * [.isPointsMaterial](#PointsMaterial+isPointsMaterial) : <code>boolean</code>
    * [.color](#PointsMaterial+color) : <code>Color</code>
    * [.map](#PointsMaterial+map) : <code>Texture</code>
    * [.alphaMap](#PointsMaterial+alphaMap) : <code>Texture</code>
    * [.size](#PointsMaterial+size) : <code>number</code>
    * [.sizeAttenuation](#PointsMaterial+sizeAttenuation) : <code>boolean</code>
    * [.fog](#PointsMaterial+fog) : <code>boolean</code>

<a name="new_PointsMaterial_new"></a>

### new PointsMaterial([parameters])
Constructs a new points material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="PointsMaterial+isPointsMaterial"></a>

### pointsMaterial.isPointsMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PointsMaterial+color"></a>

### pointsMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="PointsMaterial+map"></a>

### pointsMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>null</code>  
<a name="PointsMaterial+alphaMap"></a>

### pointsMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>null</code>  
<a name="PointsMaterial+size"></a>

### pointsMaterial.size : <code>number</code>
Defines the size of the points in pixels.

Might be capped if the value exceeds hardware dependent parameters like [gl.ALIASED_POINT_SIZE_RANGE](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParamete).

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>1</code>  
<a name="PointsMaterial+sizeAttenuation"></a>

### pointsMaterial.sizeAttenuation : <code>boolean</code>
Specifies whether size of individual points is attenuated by the camera depth (perspective camera only).

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>true</code>  
<a name="PointsMaterial+fog"></a>

### pointsMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>PointsMaterial</code>](#PointsMaterial)  
**Default**: <code>true</code>  
<a name="RawShaderMaterial"></a>

## RawShaderMaterial ⇐ <code>ShaderMaterial</code>
This class works just like [ShaderMaterial](ShaderMaterial), except that definitions
of built-in uniforms and attributes are not automatically prepended to the
GLSL shader code.

`RawShaderMaterial` can only be used with [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>ShaderMaterial</code>  

* [RawShaderMaterial](#RawShaderMaterial) ⇐ <code>ShaderMaterial</code>
    * [new RawShaderMaterial([parameters])](#new_RawShaderMaterial_new)
    * [.isRawShaderMaterial](#RawShaderMaterial+isRawShaderMaterial) : <code>boolean</code>

<a name="new_RawShaderMaterial_new"></a>

### new RawShaderMaterial([parameters])
Constructs a new raw shader material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="RawShaderMaterial+isRawShaderMaterial"></a>

### rawShaderMaterial.isRawShaderMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>RawShaderMaterial</code>](#RawShaderMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShaderMaterial"></a>

## ShaderMaterial ⇐ <code>Material</code>
A material rendered with custom shaders. A shader is a small program written in GLSL.
that runs on the GPU. You may want to use a custom shader if you need to implement an
effect not included with any of the built-in materials.

There are the following notes to bear in mind when using a `ShaderMaterial`:

- `ShaderMaterial` can only be used with [WebGLRenderer](WebGLRenderer).
- Built in attributes and uniforms are passed to the shaders along with your code. If
you don't want that, use [RawShaderMaterial](RawShaderMaterial) instead.
- You can use the directive `#pragma unroll_loop_start` and `#pragma unroll_loop_end`
in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has
to be placed right above the loop. The loop formatting has to correspond to a defined standard.
  - The loop has to be [normalized](https://en.wikipedia.org/wiki/Normalized_loop).
  - The loop variable has to be *i*.
  - The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly
value of *i* for the given iteration and can be used in preprocessor
statements.

```js
const material = new THREE.ShaderMaterial( {
	uniforms: {
		time: { value: 1.0 },
		resolution: { value: new THREE.Vector2() }
	},
	vertexShader: document.getElementById( 'vertexShader' ).textContent,
	fragmentShader: document.getElementById( 'fragmentShader' ).textContent
} );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [ShaderMaterial](#ShaderMaterial) ⇐ <code>Material</code>
    * [new ShaderMaterial([parameters])](#new_ShaderMaterial_new)
    * _instance_
        * [.isShaderMaterial](#ShaderMaterial+isShaderMaterial) : <code>boolean</code>
        * [.defines](#ShaderMaterial+defines) : <code>Object</code>
        * [.uniforms](#ShaderMaterial+uniforms) : <code>Object</code>
        * [.uniformsGroups](#ShaderMaterial+uniformsGroups) : <code>Array.&lt;UniformsGroup&gt;</code>
        * [.vertexShader](#ShaderMaterial+vertexShader) : <code>string</code>
        * [.fragmentShader](#ShaderMaterial+fragmentShader) : <code>string</code>
        * [.linewidth](#ShaderMaterial+linewidth) : <code>number</code>
        * [.wireframe](#ShaderMaterial+wireframe) : <code>boolean</code>
        * [.wireframeLinewidth](#ShaderMaterial+wireframeLinewidth) : <code>number</code>
        * [.fog](#ShaderMaterial+fog) : <code>boolean</code>
        * [.lights](#ShaderMaterial+lights) : <code>boolean</code>
        * [.clipping](#ShaderMaterial+clipping) : <code>boolean</code>
        * [.forceSinglePass](#ShaderMaterial+forceSinglePass) : <code>boolean</code>
        * [.extensions](#ShaderMaterial+extensions) : <code>Object</code>
        * [.defaultAttributeValues](#ShaderMaterial+defaultAttributeValues) : <code>Object</code>
        * [.index0AttributeName](#ShaderMaterial+index0AttributeName) : <code>string</code> \| <code>undefined</code>
        * [.uniformsNeedUpdate](#ShaderMaterial+uniformsNeedUpdate) : <code>boolean</code>
        * [.glslVersion](#ShaderMaterial+glslVersion) : <code>GLSL1</code> \| <code>GLSL3</code>
    * _inner_
        * [~Shader](#ShaderMaterial..Shader) : <code>Object</code>

<a name="new_ShaderMaterial_new"></a>

### new ShaderMaterial([parameters])
Constructs a new shader material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="ShaderMaterial+isShaderMaterial"></a>

### shaderMaterial.isShaderMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShaderMaterial+defines"></a>

### shaderMaterial.defines : <code>Object</code>
Defines custom constants using `#define` directives within the GLSL code
for both the vertex shader and the fragment shader; each key/value pair
yields another directive.
```js
defines: {
	FOO: 15,
	BAR: true
}
```
Yields the lines:
```
#define FOO 15
#define BAR true
```

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+uniforms"></a>

### shaderMaterial.uniforms : <code>Object</code>
An object of the form:
```js
{
	"uniform1": { value: 1.0 },
	"uniform2": { value: 2 }
}
```
specifying the uniforms to be passed to the shader code; keys are uniform
names, values are definitions of the form
```
{
	value: 1.0
}
```
where `value` is the value of the uniform. Names must match the name of
the uniform, as defined in the GLSL code. Note that uniforms are refreshed
on every frame, so updating the value of the uniform will immediately
update the value available to the GLSL code.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+uniformsGroups"></a>

### shaderMaterial.uniformsGroups : <code>Array.&lt;UniformsGroup&gt;</code>
An array holding uniforms groups for configuring UBOs.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+vertexShader"></a>

### shaderMaterial.vertexShader : <code>string</code>
Vertex shader GLSL code. This is the actual code for the shader.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+fragmentShader"></a>

### shaderMaterial.fragmentShader : <code>string</code>
Fragment shader GLSL code. This is the actual code for the shader.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+linewidth"></a>

### shaderMaterial.linewidth : <code>number</code>
Controls line thickness or lines.

WebGL and WebGPU ignore this setting and always render line primitives with a
width of one pixel.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>1</code>  
<a name="ShaderMaterial+wireframe"></a>

### shaderMaterial.wireframe : <code>boolean</code>
Renders the geometry as a wireframe.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+wireframeLinewidth"></a>

### shaderMaterial.wireframeLinewidth : <code>number</code>
Controls the thickness of the wireframe.

WebGL and WebGPU ignore this property and always render
1 pixel wide lines.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>1</code>  
<a name="ShaderMaterial+fog"></a>

### shaderMaterial.fog : <code>boolean</code>
Define whether the material color is affected by global fog settings; `true`
to pass fog uniforms to the shader.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+lights"></a>

### shaderMaterial.lights : <code>boolean</code>
Defines whether this material uses lighting; `true` to pass uniform data
related to lighting to this shader.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+clipping"></a>

### shaderMaterial.clipping : <code>boolean</code>
Defines whether this material supports clipping; `true` to let the renderer
pass the clippingPlanes uniform.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+forceSinglePass"></a>

### shaderMaterial.forceSinglePass : <code>boolean</code>
Overwritten and set to `true` by default.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>true</code>  
<a name="ShaderMaterial+extensions"></a>

### shaderMaterial.extensions : <code>Object</code>
This object allows to enable certain WebGL 2 extensions.

- clipCullDistance: set to `true` to use vertex shader clipping
- multiDraw: set to `true` to use vertex shader multi_draw / enable gl_DrawID

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+defaultAttributeValues"></a>

### shaderMaterial.defaultAttributeValues : <code>Object</code>
When the rendered geometry doesn't include these attributes but the
material does, these default values will be passed to the shaders. This
avoids errors when buffer data is missing.

- color: [ 1, 1, 1 ]
- uv: [ 0, 0 ]
- uv1: [ 0, 0 ]

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
<a name="ShaderMaterial+index0AttributeName"></a>

### shaderMaterial.index0AttributeName : <code>string</code> \| <code>undefined</code>
If set, this calls [gl.bindAttribLocation](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation)
to bind a generic vertex index to an attribute variable.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>&quot;undefined&quot;</code>  
<a name="ShaderMaterial+uniformsNeedUpdate"></a>

### shaderMaterial.uniformsNeedUpdate : <code>boolean</code>
Can be used to force a uniform update while changing uniforms in
[Object3D#onBeforeRender](Object3D#onBeforeRender).

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>false</code>  
<a name="ShaderMaterial+glslVersion"></a>

### shaderMaterial.glslVersion : <code>GLSL1</code> \| <code>GLSL3</code>
Defines the GLSL version of custom shader code.

**Kind**: instance property of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Default**: <code>null</code>  
<a name="ShaderMaterial..Shader"></a>

### ShaderMaterial~Shader : <code>Object</code>
This type represents the fields required to store and run the shader code.

**Kind**: inner typedef of [<code>ShaderMaterial</code>](#ShaderMaterial)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the shader. |
| uniforms | <code>Object.&lt;string, Uniform&gt;</code> | The uniforms of the shader. |
| defines | <code>Object.&lt;string, any&gt;</code> | The defines of the shader. |
| vertexShader | <code>string</code> | The vertex shader code. |
| fragmentShader | <code>string</code> | The fragment shader code. |

<a name="ShadowMaterial"></a>

## ShadowMaterial ⇐ <code>Material</code>
This material can receive shadows, but otherwise is completely transparent.

```js
const geometry = new THREE.PlaneGeometry( 2000, 2000 );
geometry.rotateX( - Math.PI / 2 );

const material = new THREE.ShadowMaterial();
material.opacity = 0.2;

const plane = new THREE.Mesh( geometry, material );
plane.position.y = -200;
plane.receiveShadow = true;
scene.add( plane );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [ShadowMaterial](#ShadowMaterial) ⇐ <code>Material</code>
    * [new ShadowMaterial([parameters])](#new_ShadowMaterial_new)
    * [.isShadowMaterial](#ShadowMaterial+isShadowMaterial) : <code>boolean</code>
    * [.color](#ShadowMaterial+color) : <code>Color</code>
    * [.transparent](#ShadowMaterial+transparent) : <code>boolean</code>
    * [.fog](#ShadowMaterial+fog) : <code>boolean</code>

<a name="new_ShadowMaterial_new"></a>

### new ShadowMaterial([parameters])
Constructs a new shadow material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="ShadowMaterial+isShadowMaterial"></a>

### shadowMaterial.isShadowMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowMaterial</code>](#ShadowMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowMaterial+color"></a>

### shadowMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>ShadowMaterial</code>](#ShadowMaterial)  
**Default**: <code>(0,0,0)</code>  
<a name="ShadowMaterial+transparent"></a>

### shadowMaterial.transparent : <code>boolean</code>
Overwritten since shadow materials are transparent
by default.

**Kind**: instance property of [<code>ShadowMaterial</code>](#ShadowMaterial)  
**Default**: <code>true</code>  
<a name="ShadowMaterial+fog"></a>

### shadowMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>ShadowMaterial</code>](#ShadowMaterial)  
**Default**: <code>true</code>  
<a name="SpriteMaterial"></a>

## SpriteMaterial ⇐ <code>Material</code>
A material for rendering instances of [Sprite](Sprite).

```js
const map = new THREE.TextureLoader().load( 'textures/sprite.png' );
const material = new THREE.SpriteMaterial( { map: map, color: 0xffffff } );

const sprite = new THREE.Sprite( material );
sprite.scale.set(200, 200, 1)
scene.add( sprite );
```

**Kind**: global class  
**Extends**: <code>Material</code>  

* [SpriteMaterial](#SpriteMaterial) ⇐ <code>Material</code>
    * [new SpriteMaterial([parameters])](#new_SpriteMaterial_new)
    * [.isSpriteMaterial](#SpriteMaterial+isSpriteMaterial) : <code>boolean</code>
    * [.color](#SpriteMaterial+color) : <code>Color</code>
    * [.map](#SpriteMaterial+map) : <code>Texture</code>
    * [.alphaMap](#SpriteMaterial+alphaMap) : <code>Texture</code>
    * [.rotation](#SpriteMaterial+rotation) : <code>number</code>
    * [.sizeAttenuation](#SpriteMaterial+sizeAttenuation) : <code>boolean</code>
    * [.transparent](#SpriteMaterial+transparent) : <code>boolean</code>
    * [.fog](#SpriteMaterial+fog) : <code>boolean</code>

<a name="new_SpriteMaterial_new"></a>

### new SpriteMaterial([parameters])
Constructs a new sprite material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="SpriteMaterial+isSpriteMaterial"></a>

### spriteMaterial.isSpriteMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SpriteMaterial+color"></a>

### spriteMaterial.color : <code>Color</code>
Color of the material.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="SpriteMaterial+map"></a>

### spriteMaterial.map : <code>Texture</code>
The color map. May optionally include an alpha channel, typically combined
with [Material#transparent](Material#transparent) or [Material#alphaTest](Material#alphaTest). The texture map
color is modulated by the diffuse `color`.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>null</code>  
<a name="SpriteMaterial+alphaMap"></a>

### spriteMaterial.alphaMap : <code>Texture</code>
The alpha map is a grayscale texture that controls the opacity across the
surface (black: fully transparent; white: fully opaque).

Only the color of the texture is used, ignoring the alpha channel if one
exists. For RGB and RGBA textures, the renderer will use the green channel
when sampling this texture due to the extra bit of precision provided for
green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and
luminance/alpha textures will also still work as expected.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>null</code>  
<a name="SpriteMaterial+rotation"></a>

### spriteMaterial.rotation : <code>number</code>
The rotation of the sprite in radians.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>0</code>  
<a name="SpriteMaterial+sizeAttenuation"></a>

### spriteMaterial.sizeAttenuation : <code>boolean</code>
Specifies whether size of the sprite is attenuated by the camera depth (perspective camera only).

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>true</code>  
<a name="SpriteMaterial+transparent"></a>

### spriteMaterial.transparent : <code>boolean</code>
Overwritten since sprite materials are transparent
by default.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>true</code>  
<a name="SpriteMaterial+fog"></a>

### spriteMaterial.fog : <code>boolean</code>
Whether the material is affected by fog or not.

**Kind**: instance property of [<code>SpriteMaterial</code>](#SpriteMaterial)  
**Default**: <code>true</code>  
<a name="Line2NodeMaterial"></a>

## Line2NodeMaterial ⇐ <code>NodeMaterial</code>
This node material can be used to render lines with a size larger than one
by representing them as instanced meshes.

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [Line2NodeMaterial](#Line2NodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new Line2NodeMaterial([parameters])](#new_Line2NodeMaterial_new)
    * [.isLine2NodeMaterial](#Line2NodeMaterial+isLine2NodeMaterial) : <code>boolean</code>
    * [.useColor](#Line2NodeMaterial+useColor) : <code>boolean</code>
    * [.dashOffset](#Line2NodeMaterial+dashOffset) : <code>number</code>
    * [.lineWidth](#Line2NodeMaterial+lineWidth) : <code>number</code>
    * [.lineColorNode](#Line2NodeMaterial+lineColorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.offsetNode](#Line2NodeMaterial+offsetNode) : <code>Node.&lt;float&gt;</code>
    * [.dashScaleNode](#Line2NodeMaterial+dashScaleNode) : <code>Node.&lt;float&gt;</code>
    * [.dashSizeNode](#Line2NodeMaterial+dashSizeNode) : <code>Node.&lt;float&gt;</code>
    * [.gapSizeNode](#Line2NodeMaterial+gapSizeNode) : <code>Node.&lt;float&gt;</code>
    * [.blending](#Line2NodeMaterial+blending) : <code>number</code>
    * [.worldUnits](#Line2NodeMaterial+worldUnits) : <code>boolean</code>
    * [.dashed](#Line2NodeMaterial+dashed) : <code>boolean</code>
    * [.alphaToCoverage](#Line2NodeMaterial+alphaToCoverage) : <code>boolean</code>
    * [.setup(builder)](#Line2NodeMaterial+setup)

<a name="new_Line2NodeMaterial_new"></a>

### new Line2NodeMaterial([parameters])
Constructs a new node material for wide line rendering.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parameters] | <code>Object</code> | <code>{}</code> | The configuration parameter. |

<a name="Line2NodeMaterial+isLine2NodeMaterial"></a>

### line2NodeMaterial.isLine2NodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Line2NodeMaterial+useColor"></a>

### line2NodeMaterial.useColor : <code>boolean</code>
Whether vertex colors should be used or not.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>false</code>  
<a name="Line2NodeMaterial+dashOffset"></a>

### line2NodeMaterial.dashOffset : <code>number</code>
The dash offset.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>0</code>  
<a name="Line2NodeMaterial+lineWidth"></a>

### line2NodeMaterial.lineWidth : <code>number</code>
The line width.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>0</code>  
<a name="Line2NodeMaterial+lineColorNode"></a>

### line2NodeMaterial.lineColorNode : <code>Node.&lt;vec3&gt;</code>
Defines the lines color.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+offsetNode"></a>

### line2NodeMaterial.offsetNode : <code>Node.&lt;float&gt;</code>
Defines the offset.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+dashScaleNode"></a>

### line2NodeMaterial.dashScaleNode : <code>Node.&lt;float&gt;</code>
Defines the dash scale.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+dashSizeNode"></a>

### line2NodeMaterial.dashSizeNode : <code>Node.&lt;float&gt;</code>
Defines the dash size.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+gapSizeNode"></a>

### line2NodeMaterial.gapSizeNode : <code>Node.&lt;float&gt;</code>
Defines the gap size.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>null</code>  
<a name="Line2NodeMaterial+blending"></a>

### line2NodeMaterial.blending : <code>number</code>
Blending is set to `NoBlending` since transparency
is not supported, yet.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>0</code>  
<a name="Line2NodeMaterial+worldUnits"></a>

### line2NodeMaterial.worldUnits : <code>boolean</code>
Whether the lines should sized in world units or not.
When set to `false` the unit is pixel.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>false</code>  
<a name="Line2NodeMaterial+dashed"></a>

### line2NodeMaterial.dashed : <code>boolean</code>
Whether the lines should be dashed or not.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>false</code>  
<a name="Line2NodeMaterial+alphaToCoverage"></a>

### line2NodeMaterial.alphaToCoverage : <code>boolean</code>
Whether alpha to coverage should be used or not.

**Kind**: instance property of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  
**Default**: <code>true</code>  
<a name="Line2NodeMaterial+setup"></a>

### line2NodeMaterial.setup(builder)
Setups the vertex and fragment stage of this node material.

**Kind**: instance method of [<code>Line2NodeMaterial</code>](#Line2NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LineBasicNodeMaterial"></a>

## LineBasicNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [LineBasicMaterial](LineBasicMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [LineBasicNodeMaterial](#LineBasicNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new LineBasicNodeMaterial([parameters])](#new_LineBasicNodeMaterial_new)
    * [.isLineBasicNodeMaterial](#LineBasicNodeMaterial+isLineBasicNodeMaterial) : <code>boolean</code>

<a name="new_LineBasicNodeMaterial_new"></a>

### new LineBasicNodeMaterial([parameters])
Constructs a new line basic node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="LineBasicNodeMaterial+isLineBasicNodeMaterial"></a>

### lineBasicNodeMaterial.isLineBasicNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineBasicNodeMaterial</code>](#LineBasicNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineDashedNodeMaterial"></a>

## LineDashedNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of  [LineDashedMaterial](LineDashedMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [LineDashedNodeMaterial](#LineDashedNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new LineDashedNodeMaterial([parameters])](#new_LineDashedNodeMaterial_new)
    * [.isLineDashedNodeMaterial](#LineDashedNodeMaterial+isLineDashedNodeMaterial) : <code>boolean</code>
    * [.dashOffset](#LineDashedNodeMaterial+dashOffset) : <code>number</code>
    * [.offsetNode](#LineDashedNodeMaterial+offsetNode) : <code>Node.&lt;float&gt;</code>
    * [.dashScaleNode](#LineDashedNodeMaterial+dashScaleNode) : <code>Node.&lt;float&gt;</code>
    * [.dashSizeNode](#LineDashedNodeMaterial+dashSizeNode) : <code>Node.&lt;float&gt;</code>
    * [.gapSizeNode](#LineDashedNodeMaterial+gapSizeNode) : <code>Node.&lt;float&gt;</code>
    * [.setupVariants(builder)](#LineDashedNodeMaterial+setupVariants)

<a name="new_LineDashedNodeMaterial_new"></a>

### new LineDashedNodeMaterial([parameters])
Constructs a new line dashed node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="LineDashedNodeMaterial+isLineDashedNodeMaterial"></a>

### lineDashedNodeMaterial.isLineDashedNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineDashedNodeMaterial+dashOffset"></a>

### lineDashedNodeMaterial.dashOffset : <code>number</code>
The dash offset.

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>0</code>  
<a name="LineDashedNodeMaterial+offsetNode"></a>

### lineDashedNodeMaterial.offsetNode : <code>Node.&lt;float&gt;</code>
The offset of dash materials is by default inferred from the `dashOffset`
property. This node property allows to overwrite the default
and define the offset with a node instead.

If you don't want to overwrite the offset but modify the existing
value instead, use [materialLineDashOffset](materialLineDashOffset).

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>null</code>  
<a name="LineDashedNodeMaterial+dashScaleNode"></a>

### lineDashedNodeMaterial.dashScaleNode : <code>Node.&lt;float&gt;</code>
The scale of dash materials is by default inferred from the `scale`
property. This node property allows to overwrite the default
and define the scale with a node instead.

If you don't want to overwrite the scale but modify the existing
value instead, use [materialLineScale](materialLineScale).

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>null</code>  
<a name="LineDashedNodeMaterial+dashSizeNode"></a>

### lineDashedNodeMaterial.dashSizeNode : <code>Node.&lt;float&gt;</code>
The dash size of dash materials is by default inferred from the `dashSize`
property. This node property allows to overwrite the default
and define the dash size with a node instead.

If you don't want to overwrite the dash size but modify the existing
value instead, use [materialLineDashSize](materialLineDashSize).

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>null</code>  
<a name="LineDashedNodeMaterial+gapSizeNode"></a>

### lineDashedNodeMaterial.gapSizeNode : <code>Node.&lt;float&gt;</code>
The gap size of dash materials is by default inferred from the `gapSize`
property. This node property allows to overwrite the default
and define the gap size with a node instead.

If you don't want to overwrite the gap size but modify the existing
value instead, use [materialLineGapSize](materialLineGapSize).

**Kind**: instance property of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  
**Default**: <code>null</code>  
<a name="LineDashedNodeMaterial+setupVariants"></a>

### lineDashedNodeMaterial.setupVariants(builder)
Setups the dash specific node variables.

**Kind**: instance method of [<code>LineDashedNodeMaterial</code>](#LineDashedNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshBasicNodeMaterial"></a>

## MeshBasicNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshBasicMaterial](MeshBasicMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshBasicNodeMaterial](#MeshBasicNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshBasicNodeMaterial([parameters])](#new_MeshBasicNodeMaterial_new)
    * [.isMeshBasicNodeMaterial](#MeshBasicNodeMaterial+isMeshBasicNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshBasicNodeMaterial+lights) : <code>boolean</code>
    * [.setupNormal()](#MeshBasicNodeMaterial+setupNormal) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupEnvironment(builder)](#MeshBasicNodeMaterial+setupEnvironment) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
    * [.setupLightMap(builder)](#MeshBasicNodeMaterial+setupLightMap) ⇒ <code>BasicLightMapNode.&lt;vec3&gt;</code>
    * [.setupOutgoingLight()](#MeshBasicNodeMaterial+setupOutgoingLight) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupLightingModel()](#MeshBasicNodeMaterial+setupLightingModel) ⇒ <code>BasicLightingModel</code>

<a name="new_MeshBasicNodeMaterial_new"></a>

### new MeshBasicNodeMaterial([parameters])
Constructs a new mesh basic node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshBasicNodeMaterial+isMeshBasicNodeMaterial"></a>

### meshBasicNodeMaterial.isMeshBasicNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshBasicNodeMaterial+lights"></a>

### meshBasicNodeMaterial.lights : <code>boolean</code>
Although the basic material is by definition unlit, we set
this property to `true` since we use a lighting model to compute
the outgoing light of the fragment shader.

**Kind**: instance property of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshBasicNodeMaterial+setupNormal"></a>

### meshBasicNodeMaterial.setupNormal() ⇒ <code>Node.&lt;vec3&gt;</code>
Basic materials are not affected by normal and bump maps so we
return by default [normalView](normalView).

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The normal node.  
<a name="MeshBasicNodeMaterial+setupEnvironment"></a>

### meshBasicNodeMaterial.setupEnvironment(builder) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
Overwritten since this type of material uses [BasicEnvironmentNode](BasicEnvironmentNode)
to implement the default environment mapping.

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>BasicEnvironmentNode.&lt;vec3&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshBasicNodeMaterial+setupLightMap"></a>

### meshBasicNodeMaterial.setupLightMap(builder) ⇒ <code>BasicLightMapNode.&lt;vec3&gt;</code>
This method must be overwritten since light maps are evaluated
with a special scaling factor for basic materials.

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>BasicLightMapNode.&lt;vec3&gt;</code> - The light map node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshBasicNodeMaterial+setupOutgoingLight"></a>

### meshBasicNodeMaterial.setupOutgoingLight() ⇒ <code>Node.&lt;vec3&gt;</code>
The material overwrites this method because `lights` is set to `true` but
we still want to return the diffuse color as the outgoing light.

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The outgoing light node.  
<a name="MeshBasicNodeMaterial+setupLightingModel"></a>

### meshBasicNodeMaterial.setupLightingModel() ⇒ <code>BasicLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshBasicNodeMaterial</code>](#MeshBasicNodeMaterial)  
**Returns**: <code>BasicLightingModel</code> - The lighting model.  
<a name="MeshLambertNodeMaterial"></a>

## MeshLambertNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshLambertMaterial](MeshLambertMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshLambertNodeMaterial](#MeshLambertNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshLambertNodeMaterial([parameters])](#new_MeshLambertNodeMaterial_new)
    * [.isMeshLambertNodeMaterial](#MeshLambertNodeMaterial+isMeshLambertNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshLambertNodeMaterial+lights) : <code>boolean</code>
    * [.setupEnvironment(builder)](#MeshLambertNodeMaterial+setupEnvironment) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
    * [.setupLightingModel()](#MeshLambertNodeMaterial+setupLightingModel) ⇒ <code>PhongLightingModel</code>

<a name="new_MeshLambertNodeMaterial_new"></a>

### new MeshLambertNodeMaterial([parameters])
Constructs a new mesh lambert node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshLambertNodeMaterial+isMeshLambertNodeMaterial"></a>

### meshLambertNodeMaterial.isMeshLambertNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshLambertNodeMaterial</code>](#MeshLambertNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshLambertNodeMaterial+lights"></a>

### meshLambertNodeMaterial.lights : <code>boolean</code>
Set to `true` because lambert materials react on lights.

**Kind**: instance property of [<code>MeshLambertNodeMaterial</code>](#MeshLambertNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshLambertNodeMaterial+setupEnvironment"></a>

### meshLambertNodeMaterial.setupEnvironment(builder) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
Overwritten since this type of material uses [BasicEnvironmentNode](BasicEnvironmentNode)
to implement the default environment mapping.

**Kind**: instance method of [<code>MeshLambertNodeMaterial</code>](#MeshLambertNodeMaterial)  
**Returns**: <code>BasicEnvironmentNode.&lt;vec3&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshLambertNodeMaterial+setupLightingModel"></a>

### meshLambertNodeMaterial.setupLightingModel() ⇒ <code>PhongLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshLambertNodeMaterial</code>](#MeshLambertNodeMaterial)  
**Returns**: <code>PhongLightingModel</code> - The lighting model.  
<a name="MeshMatcapNodeMaterial"></a>

## MeshMatcapNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshMatcapMaterial](MeshMatcapMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshMatcapNodeMaterial](#MeshMatcapNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshMatcapNodeMaterial([parameters])](#new_MeshMatcapNodeMaterial_new)
    * [.isMeshMatcapNodeMaterial](#MeshMatcapNodeMaterial+isMeshMatcapNodeMaterial) : <code>boolean</code>
    * [.setupVariants(builder)](#MeshMatcapNodeMaterial+setupVariants)

<a name="new_MeshMatcapNodeMaterial_new"></a>

### new MeshMatcapNodeMaterial([parameters])
Constructs a new mesh normal node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshMatcapNodeMaterial+isMeshMatcapNodeMaterial"></a>

### meshMatcapNodeMaterial.isMeshMatcapNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshMatcapNodeMaterial</code>](#MeshMatcapNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshMatcapNodeMaterial+setupVariants"></a>

### meshMatcapNodeMaterial.setupVariants(builder)
Setups the matcap specific node variables.

**Kind**: instance method of [<code>MeshMatcapNodeMaterial</code>](#MeshMatcapNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshNormalNodeMaterial"></a>

## MeshNormalNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshNormalMaterial](MeshNormalMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshNormalNodeMaterial](#MeshNormalNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshNormalNodeMaterial([parameters])](#new_MeshNormalNodeMaterial_new)
    * [.isMeshNormalNodeMaterial](#MeshNormalNodeMaterial+isMeshNormalNodeMaterial) : <code>boolean</code>
    * [.setupDiffuseColor()](#MeshNormalNodeMaterial+setupDiffuseColor)

<a name="new_MeshNormalNodeMaterial_new"></a>

### new MeshNormalNodeMaterial([parameters])
Constructs a new mesh normal node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshNormalNodeMaterial+isMeshNormalNodeMaterial"></a>

### meshNormalNodeMaterial.isMeshNormalNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshNormalNodeMaterial</code>](#MeshNormalNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshNormalNodeMaterial+setupDiffuseColor"></a>

### meshNormalNodeMaterial.setupDiffuseColor()
Overwrites the default implementation by computing the diffuse color
based on the normal data.

**Kind**: instance method of [<code>MeshNormalNodeMaterial</code>](#MeshNormalNodeMaterial)  
<a name="MeshPhongNodeMaterial"></a>

## MeshPhongNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshPhongMaterial](MeshPhongMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshPhongNodeMaterial](#MeshPhongNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshPhongNodeMaterial([parameters])](#new_MeshPhongNodeMaterial_new)
    * [.isMeshPhongNodeMaterial](#MeshPhongNodeMaterial+isMeshPhongNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshPhongNodeMaterial+lights) : <code>boolean</code>
    * [.shininessNode](#MeshPhongNodeMaterial+shininessNode) : <code>Node.&lt;float&gt;</code>
    * [.specularNode](#MeshPhongNodeMaterial+specularNode) : <code>Node.&lt;vec3&gt;</code>
    * [.setupEnvironment(builder)](#MeshPhongNodeMaterial+setupEnvironment) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
    * [.setupLightingModel()](#MeshPhongNodeMaterial+setupLightingModel) ⇒ <code>PhongLightingModel</code>
    * [.setupVariants(builder)](#MeshPhongNodeMaterial+setupVariants)

<a name="new_MeshPhongNodeMaterial_new"></a>

### new MeshPhongNodeMaterial([parameters])
Constructs a new mesh lambert node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshPhongNodeMaterial+isMeshPhongNodeMaterial"></a>

### meshPhongNodeMaterial.isMeshPhongNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPhongNodeMaterial+lights"></a>

### meshPhongNodeMaterial.lights : <code>boolean</code>
Set to `true` because phong materials react on lights.

**Kind**: instance property of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhongNodeMaterial+shininessNode"></a>

### meshPhongNodeMaterial.shininessNode : <code>Node.&lt;float&gt;</code>
The shininess of phong materials is by default inferred from the `shininess`
property. This node property allows to overwrite the default
and define the shininess with a node instead.

If you don't want to overwrite the shininess but modify the existing
value instead, use [materialShininess](materialShininess).

**Kind**: instance property of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongNodeMaterial+specularNode"></a>

### meshPhongNodeMaterial.specularNode : <code>Node.&lt;vec3&gt;</code>
The specular color of phong materials is by default inferred from the
`specular` property. This node property allows to overwrite the default
and define the specular color with a node instead.

If you don't want to overwrite the specular color but modify the existing
value instead, use [materialSpecular](materialSpecular).

**Kind**: instance property of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhongNodeMaterial+setupEnvironment"></a>

### meshPhongNodeMaterial.setupEnvironment(builder) ⇒ <code>BasicEnvironmentNode.&lt;vec3&gt;</code>
Overwritten since this type of material uses [BasicEnvironmentNode](BasicEnvironmentNode)
to implement the default environment mapping.

**Kind**: instance method of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Returns**: <code>BasicEnvironmentNode.&lt;vec3&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshPhongNodeMaterial+setupLightingModel"></a>

### meshPhongNodeMaterial.setupLightingModel() ⇒ <code>PhongLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  
**Returns**: <code>PhongLightingModel</code> - The lighting model.  
<a name="MeshPhongNodeMaterial+setupVariants"></a>

### meshPhongNodeMaterial.setupVariants(builder)
Setups the phong specific node variables.

**Kind**: instance method of [<code>MeshPhongNodeMaterial</code>](#MeshPhongNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshPhysicalNodeMaterial"></a>

## MeshPhysicalNodeMaterial ⇐ <code>MeshStandardNodeMaterial</code>
Node material version of [MeshPhysicalMaterial](MeshPhysicalMaterial).

**Kind**: global class  
**Extends**: <code>MeshStandardNodeMaterial</code>  

* [MeshPhysicalNodeMaterial](#MeshPhysicalNodeMaterial) ⇐ <code>MeshStandardNodeMaterial</code>
    * [new MeshPhysicalNodeMaterial([parameters])](#new_MeshPhysicalNodeMaterial_new)
    * [.isMeshPhysicalNodeMaterial](#MeshPhysicalNodeMaterial+isMeshPhysicalNodeMaterial) : <code>boolean</code>
    * [.clearcoatNode](#MeshPhysicalNodeMaterial+clearcoatNode) : <code>Node.&lt;float&gt;</code>
    * [.clearcoatRoughnessNode](#MeshPhysicalNodeMaterial+clearcoatRoughnessNode) : <code>Node.&lt;float&gt;</code>
    * [.clearcoatNormalNode](#MeshPhysicalNodeMaterial+clearcoatNormalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.sheenNode](#MeshPhysicalNodeMaterial+sheenNode) : <code>Node.&lt;vec3&gt;</code>
    * [.sheenRoughnessNode](#MeshPhysicalNodeMaterial+sheenRoughnessNode) : <code>Node.&lt;float&gt;</code>
    * [.iridescenceNode](#MeshPhysicalNodeMaterial+iridescenceNode) : <code>Node.&lt;float&gt;</code>
    * [.iridescenceIORNode](#MeshPhysicalNodeMaterial+iridescenceIORNode) : <code>Node.&lt;float&gt;</code>
    * [.iridescenceThicknessNode](#MeshPhysicalNodeMaterial+iridescenceThicknessNode) : <code>Node.&lt;float&gt;</code>
    * [.specularIntensityNode](#MeshPhysicalNodeMaterial+specularIntensityNode) : <code>Node.&lt;float&gt;</code>
    * [.specularColorNode](#MeshPhysicalNodeMaterial+specularColorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.iorNode](#MeshPhysicalNodeMaterial+iorNode) : <code>Node.&lt;float&gt;</code>
    * [.transmissionNode](#MeshPhysicalNodeMaterial+transmissionNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessNode](#MeshPhysicalNodeMaterial+thicknessNode) : <code>Node.&lt;float&gt;</code>
    * [.attenuationDistanceNode](#MeshPhysicalNodeMaterial+attenuationDistanceNode) : <code>Node.&lt;float&gt;</code>
    * [.attenuationColorNode](#MeshPhysicalNodeMaterial+attenuationColorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.dispersionNode](#MeshPhysicalNodeMaterial+dispersionNode) : <code>Node.&lt;float&gt;</code>
    * [.anisotropyNode](#MeshPhysicalNodeMaterial+anisotropyNode) : <code>Node.&lt;float&gt;</code>
    * [.useClearcoat](#MeshPhysicalNodeMaterial+useClearcoat) : <code>boolean</code>
    * [.useIridescence](#MeshPhysicalNodeMaterial+useIridescence) : <code>boolean</code>
    * [.useSheen](#MeshPhysicalNodeMaterial+useSheen) : <code>boolean</code>
    * [.useAnisotropy](#MeshPhysicalNodeMaterial+useAnisotropy) : <code>boolean</code>
    * [.useTransmission](#MeshPhysicalNodeMaterial+useTransmission) : <code>boolean</code>
    * [.useDispersion](#MeshPhysicalNodeMaterial+useDispersion) : <code>boolean</code>
    * [.setupSpecular()](#MeshPhysicalNodeMaterial+setupSpecular)
    * [.setupLightingModel()](#MeshPhysicalNodeMaterial+setupLightingModel) ⇒ <code>PhysicalLightingModel</code>
    * [.setupVariants(builder)](#MeshPhysicalNodeMaterial+setupVariants)
    * [.setupClearcoatNormal()](#MeshPhysicalNodeMaterial+setupClearcoatNormal) ⇒ <code>Node.&lt;vec3&gt;</code>

<a name="new_MeshPhysicalNodeMaterial_new"></a>

### new MeshPhysicalNodeMaterial([parameters])
Constructs a new mesh physical node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshPhysicalNodeMaterial+isMeshPhysicalNodeMaterial"></a>

### meshPhysicalNodeMaterial.isMeshPhysicalNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPhysicalNodeMaterial+clearcoatNode"></a>

### meshPhysicalNodeMaterial.clearcoatNode : <code>Node.&lt;float&gt;</code>
The clearcoat of physical materials is by default inferred from the `clearcoat`
and `clearcoatMap` properties. This node property allows to overwrite the default
and define the clearcoat with a node instead.

If you don't want to overwrite the clearcoat but modify the existing
value instead, use [materialClearcoat](materialClearcoat).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+clearcoatRoughnessNode"></a>

### meshPhysicalNodeMaterial.clearcoatRoughnessNode : <code>Node.&lt;float&gt;</code>
The clearcoat roughness of physical materials is by default inferred from the `clearcoatRoughness`
and `clearcoatRoughnessMap` properties. This node property allows to overwrite the default
and define the clearcoat roughness with a node instead.

If you don't want to overwrite the clearcoat roughness but modify the existing
value instead, use [materialClearcoatRoughness](materialClearcoatRoughness).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+clearcoatNormalNode"></a>

### meshPhysicalNodeMaterial.clearcoatNormalNode : <code>Node.&lt;vec3&gt;</code>
The clearcoat normal of physical materials is by default inferred from the `clearcoatNormalMap`
property. This node property allows to overwrite the default
and define the clearcoat normal with a node instead.

If you don't want to overwrite the clearcoat normal but modify the existing
value instead, use [materialClearcoatNormal](materialClearcoatNormal).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+sheenNode"></a>

### meshPhysicalNodeMaterial.sheenNode : <code>Node.&lt;vec3&gt;</code>
The sheen of physical materials is by default inferred from the `sheen`, `sheenColor`
and `sheenColorMap` properties. This node property allows to overwrite the default
and define the sheen with a node instead.

If you don't want to overwrite the sheen but modify the existing
value instead, use [materialSheen](materialSheen).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+sheenRoughnessNode"></a>

### meshPhysicalNodeMaterial.sheenRoughnessNode : <code>Node.&lt;float&gt;</code>
The sheen roughness of physical materials is by default inferred from the `sheenRoughness` and
`sheenRoughnessMap` properties. This node property allows to overwrite the default
and define the sheen roughness with a node instead.

If you don't want to overwrite the sheen roughness but modify the existing
value instead, use [materialSheenRoughness](materialSheenRoughness).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+iridescenceNode"></a>

### meshPhysicalNodeMaterial.iridescenceNode : <code>Node.&lt;float&gt;</code>
The iridescence of physical materials is by default inferred from the `iridescence`
property. This node property allows to overwrite the default
and define the iridescence with a node instead.

If you don't want to overwrite the iridescence but modify the existing
value instead, use [materialIridescence](materialIridescence).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+iridescenceIORNode"></a>

### meshPhysicalNodeMaterial.iridescenceIORNode : <code>Node.&lt;float&gt;</code>
The iridescence IOR of physical materials is by default inferred from the `iridescenceIOR`
property. This node property allows to overwrite the default
and define the iridescence IOR with a node instead.

If you don't want to overwrite the iridescence IOR but modify the existing
value instead, use [materialIridescenceIOR](materialIridescenceIOR).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+iridescenceThicknessNode"></a>

### meshPhysicalNodeMaterial.iridescenceThicknessNode : <code>Node.&lt;float&gt;</code>
The iridescence thickness of physical materials is by default inferred from the `iridescenceThicknessRange`
and `iridescenceThicknessMap` properties. This node property allows to overwrite the default
and define the iridescence thickness with a node instead.

If you don't want to overwrite the iridescence thickness but modify the existing
value instead, use [materialIridescenceThickness](materialIridescenceThickness).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+specularIntensityNode"></a>

### meshPhysicalNodeMaterial.specularIntensityNode : <code>Node.&lt;float&gt;</code>
The specular intensity of physical materials is by default inferred from the `specularIntensity`
and `specularIntensityMap` properties. This node property allows to overwrite the default
and define the specular intensity with a node instead.

If you don't want to overwrite the specular intensity but modify the existing
value instead, use [materialSpecularIntensity](materialSpecularIntensity).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+specularColorNode"></a>

### meshPhysicalNodeMaterial.specularColorNode : <code>Node.&lt;vec3&gt;</code>
The specular color of physical materials is by default inferred from the `specularColor`
and `specularColorMap` properties. This node property allows to overwrite the default
and define the specular color with a node instead.

If you don't want to overwrite the specular color but modify the existing
value instead, use [materialSpecularColor](materialSpecularColor).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+iorNode"></a>

### meshPhysicalNodeMaterial.iorNode : <code>Node.&lt;float&gt;</code>
The ior of physical materials is by default inferred from the `ior`
property. This node property allows to overwrite the default
and define the ior with a node instead.

If you don't want to overwrite the ior but modify the existing
value instead, use [materialIOR](materialIOR).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+transmissionNode"></a>

### meshPhysicalNodeMaterial.transmissionNode : <code>Node.&lt;float&gt;</code>
The transmission of physical materials is by default inferred from the `transmission` and
`transmissionMap` properties. This node property allows to overwrite the default
and define the transmission with a node instead.

If you don't want to overwrite the transmission but modify the existing
value instead, use [materialTransmission](materialTransmission).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+thicknessNode"></a>

### meshPhysicalNodeMaterial.thicknessNode : <code>Node.&lt;float&gt;</code>
The thickness of physical materials is by default inferred from the `thickness` and
`thicknessMap` properties. This node property allows to overwrite the default
and define the thickness with a node instead.

If you don't want to overwrite the thickness but modify the existing
value instead, use [materialThickness](materialThickness).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+attenuationDistanceNode"></a>

### meshPhysicalNodeMaterial.attenuationDistanceNode : <code>Node.&lt;float&gt;</code>
The attenuation distance of physical materials is by default inferred from the
`attenuationDistance` property. This node property allows to overwrite the default
and define the attenuation distance with a node instead.

If you don't want to overwrite the attenuation distance but modify the existing
value instead, use [materialAttenuationDistance](materialAttenuationDistance).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+attenuationColorNode"></a>

### meshPhysicalNodeMaterial.attenuationColorNode : <code>Node.&lt;vec3&gt;</code>
The attenuation color of physical materials is by default inferred from the
`attenuationColor` property. This node property allows to overwrite the default
and define the attenuation color with a node instead.

If you don't want to overwrite the attenuation color but modify the existing
value instead, use [materialAttenuationColor](materialAttenuationColor).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+dispersionNode"></a>

### meshPhysicalNodeMaterial.dispersionNode : <code>Node.&lt;float&gt;</code>
The dispersion of physical materials is by default inferred from the
`dispersion` property. This node property allows to overwrite the default
and define the dispersion with a node instead.

If you don't want to overwrite the dispersion but modify the existing
value instead, use [materialDispersion](materialDispersion).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+anisotropyNode"></a>

### meshPhysicalNodeMaterial.anisotropyNode : <code>Node.&lt;float&gt;</code>
The anisotropy of physical materials is by default inferred from the
`anisotropy` property. This node property allows to overwrite the default
and define the anisotropy with a node instead.

If you don't want to overwrite the anisotropy but modify the existing
value instead, use [materialAnisotropy](materialAnisotropy).

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshPhysicalNodeMaterial+useClearcoat"></a>

### meshPhysicalNodeMaterial.useClearcoat : <code>boolean</code>
Whether the lighting model should use clearcoat or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useIridescence"></a>

### meshPhysicalNodeMaterial.useIridescence : <code>boolean</code>
Whether the lighting model should use iridescence or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useSheen"></a>

### meshPhysicalNodeMaterial.useSheen : <code>boolean</code>
Whether the lighting model should use sheen or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useAnisotropy"></a>

### meshPhysicalNodeMaterial.useAnisotropy : <code>boolean</code>
Whether the lighting model should use anisotropy or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useTransmission"></a>

### meshPhysicalNodeMaterial.useTransmission : <code>boolean</code>
Whether the lighting model should use transmission or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+useDispersion"></a>

### meshPhysicalNodeMaterial.useDispersion : <code>boolean</code>
Whether the lighting model should use dispersion or not.

**Kind**: instance property of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshPhysicalNodeMaterial+setupSpecular"></a>

### meshPhysicalNodeMaterial.setupSpecular()
Setups the specular related node variables.

**Kind**: instance method of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
<a name="MeshPhysicalNodeMaterial+setupLightingModel"></a>

### meshPhysicalNodeMaterial.setupLightingModel() ⇒ <code>PhysicalLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Returns**: <code>PhysicalLightingModel</code> - The lighting model.  
<a name="MeshPhysicalNodeMaterial+setupVariants"></a>

### meshPhysicalNodeMaterial.setupVariants(builder)
Setups the physical specific node variables.

**Kind**: instance method of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshPhysicalNodeMaterial+setupClearcoatNormal"></a>

### meshPhysicalNodeMaterial.setupClearcoatNormal() ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the clearcoat normal node.

**Kind**: instance method of [<code>MeshPhysicalNodeMaterial</code>](#MeshPhysicalNodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The clearcoat normal.  
## Classes

<dl>
<dt><a href="#SSSLightingModel">SSSLightingModel</a> ⇐ <code>PhysicalLightingModel</code></dt>
<dd><p>Represents the lighting model for <a href="#MeshSSSNodeMaterial">MeshSSSNodeMaterial</a>.</p>
</dd>
<dt><a href="#MeshSSSNodeMaterial">MeshSSSNodeMaterial</a> ⇐ <code>MeshPhysicalNodeMaterial</code></dt>
<dd><p>This node material is an experimental extension of <a href="MeshPhysicalNodeMaterial">MeshPhysicalNodeMaterial</a>
that implements a Subsurface scattering (SSS) term.</p>
</dd>
</dl>

<a name="SSSLightingModel"></a>

## SSSLightingModel ⇐ <code>PhysicalLightingModel</code>
Represents the lighting model for [MeshSSSNodeMaterial](#MeshSSSNodeMaterial).

**Kind**: global class  
**Extends**: <code>PhysicalLightingModel</code>  

* [SSSLightingModel](#SSSLightingModel) ⇐ <code>PhysicalLightingModel</code>
    * [new SSSLightingModel([clearcoat], [sheen], [iridescence], [anisotropy], [transmission], [dispersion], [sss])](#new_SSSLightingModel_new)
    * [.useSSS](#SSSLightingModel+useSSS) : <code>boolean</code>
    * [.direct(input, builder)](#SSSLightingModel+direct)

<a name="new_SSSLightingModel_new"></a>

### new SSSLightingModel([clearcoat], [sheen], [iridescence], [anisotropy], [transmission], [dispersion], [sss])
Constructs a new physical lighting model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [clearcoat] | <code>boolean</code> | <code>false</code> | Whether clearcoat is supported or not. |
| [sheen] | <code>boolean</code> | <code>false</code> | Whether sheen is supported or not. |
| [iridescence] | <code>boolean</code> | <code>false</code> | Whether iridescence is supported or not. |
| [anisotropy] | <code>boolean</code> | <code>false</code> | Whether anisotropy is supported or not. |
| [transmission] | <code>boolean</code> | <code>false</code> | Whether transmission is supported or not. |
| [dispersion] | <code>boolean</code> | <code>false</code> | Whether dispersion is supported or not. |
| [sss] | <code>boolean</code> | <code>false</code> | Whether SSS is supported or not. |

<a name="SSSLightingModel+useSSS"></a>

### sssLightingModel.useSSS : <code>boolean</code>
Whether the lighting model should use SSS or not.

**Kind**: instance property of [<code>SSSLightingModel</code>](#SSSLightingModel)  
**Default**: <code>false</code>  
<a name="SSSLightingModel+direct"></a>

### sssLightingModel.direct(input, builder)
Extends the default implementation with a SSS term.

Reference: [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look](https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/)

**Kind**: instance method of [<code>SSSLightingModel</code>](#SSSLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Object</code> | The input data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshSSSNodeMaterial"></a>

## MeshSSSNodeMaterial ⇐ <code>MeshPhysicalNodeMaterial</code>
This node material is an experimental extension of [MeshPhysicalNodeMaterial](MeshPhysicalNodeMaterial)
that implements a Subsurface scattering (SSS) term.

**Kind**: global class  
**Extends**: <code>MeshPhysicalNodeMaterial</code>  

* [MeshSSSNodeMaterial](#MeshSSSNodeMaterial) ⇐ <code>MeshPhysicalNodeMaterial</code>
    * [new MeshSSSNodeMaterial([parameters])](#new_MeshSSSNodeMaterial_new)
    * [.thicknessColorNode](#MeshSSSNodeMaterial+thicknessColorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.thicknessDistortionNode](#MeshSSSNodeMaterial+thicknessDistortionNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessAmbientNode](#MeshSSSNodeMaterial+thicknessAmbientNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessAttenuationNode](#MeshSSSNodeMaterial+thicknessAttenuationNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessPowerNode](#MeshSSSNodeMaterial+thicknessPowerNode) : <code>Node.&lt;float&gt;</code>
    * [.thicknessScaleNode](#MeshSSSNodeMaterial+thicknessScaleNode) : <code>Node.&lt;float&gt;</code>
    * [.useSSS](#MeshSSSNodeMaterial+useSSS) : <code>boolean</code>
    * [.setupLightingModel()](#MeshSSSNodeMaterial+setupLightingModel) ⇒ [<code>SSSLightingModel</code>](#SSSLightingModel)

<a name="new_MeshSSSNodeMaterial_new"></a>

### new MeshSSSNodeMaterial([parameters])
Constructs a new mesh SSS node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshSSSNodeMaterial+thicknessColorNode"></a>

### meshSSSNodeMaterial.thicknessColorNode : <code>Node.&lt;vec3&gt;</code>
Represents the thickness color.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshSSSNodeMaterial+thicknessDistortionNode"></a>

### meshSSSNodeMaterial.thicknessDistortionNode : <code>Node.&lt;float&gt;</code>
Represents the distortion factor.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+thicknessAmbientNode"></a>

### meshSSSNodeMaterial.thicknessAmbientNode : <code>Node.&lt;float&gt;</code>
Represents the thickness ambient factor.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+thicknessAttenuationNode"></a>

### meshSSSNodeMaterial.thicknessAttenuationNode : <code>Node.&lt;float&gt;</code>
Represents the thickness attenuation.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+thicknessPowerNode"></a>

### meshSSSNodeMaterial.thicknessPowerNode : <code>Node.&lt;float&gt;</code>
Represents the thickness power.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+thicknessScaleNode"></a>

### meshSSSNodeMaterial.thicknessScaleNode : <code>Node.&lt;float&gt;</code>
Represents the thickness scale.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
<a name="MeshSSSNodeMaterial+useSSS"></a>

### meshSSSNodeMaterial.useSSS : <code>boolean</code>
Whether the lighting model should use SSS or not.

**Kind**: instance property of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshSSSNodeMaterial+setupLightingModel"></a>

### meshSSSNodeMaterial.setupLightingModel() ⇒ [<code>SSSLightingModel</code>](#SSSLightingModel)
Setups the lighting model.

**Kind**: instance method of [<code>MeshSSSNodeMaterial</code>](#MeshSSSNodeMaterial)  
**Returns**: [<code>SSSLightingModel</code>](#SSSLightingModel) - The lighting model.  
<a name="MeshStandardNodeMaterial"></a>

## MeshStandardNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshStandardMaterial](MeshStandardMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshStandardNodeMaterial](#MeshStandardNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshStandardNodeMaterial([parameters])](#new_MeshStandardNodeMaterial_new)
    * [.isMeshStandardNodeMaterial](#MeshStandardNodeMaterial+isMeshStandardNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshStandardNodeMaterial+lights) : <code>boolean</code>
    * [.emissiveNode](#MeshStandardNodeMaterial+emissiveNode) : <code>Node.&lt;vec3&gt;</code>
    * [.metalnessNode](#MeshStandardNodeMaterial+metalnessNode) : <code>Node.&lt;float&gt;</code>
    * [.roughnessNode](#MeshStandardNodeMaterial+roughnessNode) : <code>Node.&lt;float&gt;</code>
    * [.setupEnvironment(builder)](#MeshStandardNodeMaterial+setupEnvironment) ⇒ <code>EnvironmentNode.&lt;vec3&gt;</code>
    * [.setupLightingModel()](#MeshStandardNodeMaterial+setupLightingModel) ⇒ <code>PhysicalLightingModel</code>
    * [.setupSpecular()](#MeshStandardNodeMaterial+setupSpecular)
    * [.setupVariants(builder)](#MeshStandardNodeMaterial+setupVariants)

<a name="new_MeshStandardNodeMaterial_new"></a>

### new MeshStandardNodeMaterial([parameters])
Constructs a new mesh standard node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshStandardNodeMaterial+isMeshStandardNodeMaterial"></a>

### meshStandardNodeMaterial.isMeshStandardNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshStandardNodeMaterial+lights"></a>

### meshStandardNodeMaterial.lights : <code>boolean</code>
Set to `true` because standard materials react on lights.

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshStandardNodeMaterial+emissiveNode"></a>

### meshStandardNodeMaterial.emissiveNode : <code>Node.&lt;vec3&gt;</code>
The emissive color of standard materials is by default inferred from the `emissive`,
`emissiveIntensity` and `emissiveMap` properties. This node property allows to
overwrite the default and define the emissive color with a node instead.

If you don't want to overwrite the emissive color but modify the existing
value instead, use [materialEmissive](materialEmissive).

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardNodeMaterial+metalnessNode"></a>

### meshStandardNodeMaterial.metalnessNode : <code>Node.&lt;float&gt;</code>
The metalness of standard materials is by default inferred from the `metalness`,
and `metalnessMap` properties. This node property allows to
overwrite the default and define the metalness with a node instead.

If you don't want to overwrite the metalness but modify the existing
value instead, use [materialMetalness](materialMetalness).

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardNodeMaterial+roughnessNode"></a>

### meshStandardNodeMaterial.roughnessNode : <code>Node.&lt;float&gt;</code>
The roughness of standard materials is by default inferred from the `roughness`,
and `roughnessMap` properties. This node property allows to
overwrite the default and define the roughness with a node instead.

If you don't want to overwrite the roughness but modify the existing
value instead, use [materialRoughness](materialRoughness).

**Kind**: instance property of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Default**: <code>null</code>  
<a name="MeshStandardNodeMaterial+setupEnvironment"></a>

### meshStandardNodeMaterial.setupEnvironment(builder) ⇒ <code>EnvironmentNode.&lt;vec3&gt;</code>
Overwritten since this type of material uses [EnvironmentNode](EnvironmentNode)
to implement the PBR (PMREM based) environment mapping. Besides, the
method honors `Scene.environment`.

**Kind**: instance method of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Returns**: <code>EnvironmentNode.&lt;vec3&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshStandardNodeMaterial+setupLightingModel"></a>

### meshStandardNodeMaterial.setupLightingModel() ⇒ <code>PhysicalLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
**Returns**: <code>PhysicalLightingModel</code> - The lighting model.  
<a name="MeshStandardNodeMaterial+setupSpecular"></a>

### meshStandardNodeMaterial.setupSpecular()
Setups the specular related node variables.

**Kind**: instance method of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  
<a name="MeshStandardNodeMaterial+setupVariants"></a>

### meshStandardNodeMaterial.setupVariants(builder)
Setups the standard specific node variables.

**Kind**: instance method of [<code>MeshStandardNodeMaterial</code>](#MeshStandardNodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MeshToonNodeMaterial"></a>

## MeshToonNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [MeshToonMaterial](MeshToonMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [MeshToonNodeMaterial](#MeshToonNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new MeshToonNodeMaterial([parameters])](#new_MeshToonNodeMaterial_new)
    * [.isMeshToonNodeMaterial](#MeshToonNodeMaterial+isMeshToonNodeMaterial) : <code>boolean</code>
    * [.lights](#MeshToonNodeMaterial+lights) : <code>boolean</code>
    * [.setupLightingModel()](#MeshToonNodeMaterial+setupLightingModel) ⇒ <code>ToonLightingModel</code>

<a name="new_MeshToonNodeMaterial_new"></a>

### new MeshToonNodeMaterial([parameters])
Constructs a new mesh toon node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="MeshToonNodeMaterial+isMeshToonNodeMaterial"></a>

### meshToonNodeMaterial.isMeshToonNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MeshToonNodeMaterial</code>](#MeshToonNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshToonNodeMaterial+lights"></a>

### meshToonNodeMaterial.lights : <code>boolean</code>
Set to `true` because toon materials react on lights.

**Kind**: instance property of [<code>MeshToonNodeMaterial</code>](#MeshToonNodeMaterial)  
**Default**: <code>true</code>  
<a name="MeshToonNodeMaterial+setupLightingModel"></a>

### meshToonNodeMaterial.setupLightingModel() ⇒ <code>ToonLightingModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>MeshToonNodeMaterial</code>](#MeshToonNodeMaterial)  
**Returns**: <code>ToonLightingModel</code> - The lighting model.  
<a name="NodeMaterial"></a>

## NodeMaterial ⇐ <code>Material</code>
Base class for all node materials.

**Kind**: global class  
**Extends**: <code>Material</code>  

* [NodeMaterial](#NodeMaterial) ⇐ <code>Material</code>
    * [new NodeMaterial()](#new_NodeMaterial_new)
    * [.type](#NodeMaterial+type) : <code>string</code>
    * [.isNodeMaterial](#NodeMaterial+isNodeMaterial) : <code>boolean</code>
    * [.fog](#NodeMaterial+fog) : <code>boolean</code>
    * [.lights](#NodeMaterial+lights) : <code>boolean</code>
    * [.hardwareClipping](#NodeMaterial+hardwareClipping) : <code>boolean</code>
    * [.lightsNode](#NodeMaterial+lightsNode) : <code>LightsNode</code>
    * [.envNode](#NodeMaterial+envNode) : <code>Node.&lt;vec3&gt;</code>
    * [.aoNode](#NodeMaterial+aoNode) : <code>Node.&lt;float&gt;</code>
    * [.colorNode](#NodeMaterial+colorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.normalNode](#NodeMaterial+normalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.opacityNode](#NodeMaterial+opacityNode) : <code>Node.&lt;float&gt;</code>
    * [.backdropNode](#NodeMaterial+backdropNode) : <code>Node.&lt;vec3&gt;</code>
    * [.backdropAlphaNode](#NodeMaterial+backdropAlphaNode) : <code>Node.&lt;float&gt;</code>
    * [.alphaTestNode](#NodeMaterial+alphaTestNode) : <code>Node.&lt;float&gt;</code>
    * [.positionNode](#NodeMaterial+positionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.geometryNode](#NodeMaterial+geometryNode) : <code>function</code>
    * [.depthNode](#NodeMaterial+depthNode) : <code>Node.&lt;float&gt;</code>
    * [.shadowPositionNode](#NodeMaterial+shadowPositionNode) : <code>Node.&lt;float&gt;</code>
    * [.receivedShadowNode](#NodeMaterial+receivedShadowNode) : <code>function</code> \| <code>FunctionNode.&lt;vec4&gt;</code>
    * [.castShadowNode](#NodeMaterial+castShadowNode) : <code>Node.&lt;vec4&gt;</code>
    * [.outputNode](#NodeMaterial+outputNode) : <code>Node.&lt;vec4&gt;</code>
    * [.mrtNode](#NodeMaterial+mrtNode) : <code>MRTNode</code>
    * [.fragmentNode](#NodeMaterial+fragmentNode) : <code>Node.&lt;vec4&gt;</code>
    * [.vertexNode](#NodeMaterial+vertexNode) : <code>Node.&lt;vec4&gt;</code>
    * [.customProgramCacheKey()](#NodeMaterial+customProgramCacheKey) ⇒ <code>string</code>
    * [.build(builder)](#NodeMaterial+build)
    * [.setupObserver(builder)](#NodeMaterial+setupObserver) ⇒ <code>NodeMaterialObserver</code>
    * [.setup(builder)](#NodeMaterial+setup)
    * [.setupClipping(builder)](#NodeMaterial+setupClipping) ⇒ <code>ClippingNode</code>
    * [.setupHardwareClipping(builder)](#NodeMaterial+setupHardwareClipping)
    * [.setupDepth(builder)](#NodeMaterial+setupDepth)
    * [.setupPositionView(builder)](#NodeMaterial+setupPositionView) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupModelViewProjection(builder)](#NodeMaterial+setupModelViewProjection) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setupVertex(builder)](#NodeMaterial+setupVertex) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setupPosition(builder)](#NodeMaterial+setupPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupDiffuseColor(builder, geometry)](#NodeMaterial+setupDiffuseColor)
    * *[.setupVariants(builder)](#NodeMaterial+setupVariants)*
    * [.setupOutgoingLight()](#NodeMaterial+setupOutgoingLight) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupNormal()](#NodeMaterial+setupNormal) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupEnvironment(builder)](#NodeMaterial+setupEnvironment) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setupLightMap(builder)](#NodeMaterial+setupLightMap) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupLights(builder)](#NodeMaterial+setupLights) ⇒ <code>LightsNode</code>
    * *[.setupLightingModel(builder)](#NodeMaterial+setupLightingModel) ⇒ <code>LightingModel</code>*
    * [.setupLighting(builder)](#NodeMaterial+setupLighting) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupFog(builder, outputNode)](#NodeMaterial+setupFog) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setupOutput(builder, outputNode)](#NodeMaterial+setupOutput) ⇒ <code>Node.&lt;vec4&gt;</code>
    * [.setDefaultValues(material)](#NodeMaterial+setDefaultValues)
    * [.toJSON(meta)](#NodeMaterial+toJSON) ⇒ <code>Object</code>
    * [.copy(source)](#NodeMaterial+copy) ⇒ [<code>NodeMaterial</code>](#NodeMaterial)

<a name="new_NodeMaterial_new"></a>

### new NodeMaterial()
Constructs a new node material.

<a name="NodeMaterial+type"></a>

### nodeMaterial.type : <code>string</code>
Represents the type of the node material.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
<a name="NodeMaterial+isNodeMaterial"></a>

### nodeMaterial.isNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="NodeMaterial+fog"></a>

### nodeMaterial.fog : <code>boolean</code>
Whether this material is affected by fog or not.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>true</code>  
<a name="NodeMaterial+lights"></a>

### nodeMaterial.lights : <code>boolean</code>
Whether this material is affected by lights or not.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>false</code>  
<a name="NodeMaterial+hardwareClipping"></a>

### nodeMaterial.hardwareClipping : <code>boolean</code>
Whether this material uses hardware clipping or not.
This property is managed by the engine and should not be
modified by apps.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>false</code>  
<a name="NodeMaterial+lightsNode"></a>

### nodeMaterial.lightsNode : <code>LightsNode</code>
Node materials which set their `lights` property to `true`
are affected by all lights of the scene. Sometimes selective
lighting is wanted which means only _some_ lights in the scene
affect a material. This can be achieved by creating an instance
of [LightsNode](LightsNode) with a list of selective
lights and assign the node to this property.

```js
const customLightsNode = lights( [ light1, light2 ] );
material.lightsNode = customLightsNode;
```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+envNode"></a>

### nodeMaterial.envNode : <code>Node.&lt;vec3&gt;</code>
The environment of node materials can be defined by an environment
map assigned to the `envMap` property or by `Scene.environment`
if the node material is a PBR material. This node property allows to overwrite
the default behavior and define the environment with a custom node.

```js
material.envNode = pmremTexture( renderTarget.texture );
```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+aoNode"></a>

### nodeMaterial.aoNode : <code>Node.&lt;float&gt;</code>
The lighting of node materials might be influenced by ambient occlusion.
The default AO is inferred from an ambient occlusion map assigned to `aoMap`
and the respective `aoMapIntensity`. This node property allows to overwrite
the default and define the ambient occlusion with a custom node instead.

If you don't want to overwrite the diffuse color but modify the existing
values instead, use [materialAO](materialAO).

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+colorNode"></a>

### nodeMaterial.colorNode : <code>Node.&lt;vec3&gt;</code>
The diffuse color of node materials is by default inferred from the
`color` and `map` properties. This node property allows to overwrite the default
and define the diffuse color with a node instead.

```js
material.colorNode = color( 0xff0000 ); // define red color
```

If you don't want to overwrite the diffuse color but modify the existing
values instead, use [materialColor](materialColor).

```js
material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint
```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+normalNode"></a>

### nodeMaterial.normalNode : <code>Node.&lt;vec3&gt;</code>
The normals of node materials are by default inferred from the `normalMap`/`normalScale`
or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default
and define the normals with a node instead.

If you don't want to overwrite the normals but modify the existing values instead,
use [materialNormal](materialNormal).

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+opacityNode"></a>

### nodeMaterial.opacityNode : <code>Node.&lt;float&gt;</code>
The opacity of node materials is by default inferred from the `opacity`
and `alphaMap` properties. This node property allows to overwrite the default
and define the opacity with a node instead.

If you don't want to overwrite the normals but modify the existing
value instead, use [materialOpacity](materialOpacity).

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+backdropNode"></a>

### nodeMaterial.backdropNode : <code>Node.&lt;vec3&gt;</code>
This node can be used to to implement a variety of filter-like effects. The idea is
to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it
to create an arbitrary effect and then assign the node composition to this property.
Everything behind the object using this material will now be affected by a filter.

```js
const material = new NodeMaterial()
material.transparent = true;

// everything behind the object will be monochromatic
material.backdropNode = saturation( viewportSharedTexture().rgb, 0 );
```

Backdrop computations are part of the lighting so only lit materials can use this property.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+backdropAlphaNode"></a>

### nodeMaterial.backdropAlphaNode : <code>Node.&lt;float&gt;</code>
This node allows to modulate the influence of `backdropNode` to the outgoing light.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+alphaTestNode"></a>

### nodeMaterial.alphaTestNode : <code>Node.&lt;float&gt;</code>
The alpha test of node materials is by default inferred from the `alphaTest`
property. This node property allows to overwrite the default and define the
alpha test with a node instead.

If you don't want to overwrite the alpha test but modify the existing
value instead, use [materialAlphaTest](materialAlphaTest).

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+positionNode"></a>

### nodeMaterial.positionNode : <code>Node.&lt;vec3&gt;</code>
The local vertex positions are computed based on multiple factors like the
attribute data, morphing or skinning. This node property allows to overwrite
the default and define local vertex positions with nodes instead.

If you don't want to overwrite the vertex positions but modify the existing
values instead, use [positionLocal](positionLocal).

```js
material.positionNode = positionLocal.add( displace );
```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+geometryNode"></a>

### nodeMaterial.geometryNode : <code>function</code>
This node property is intended for logic which modifies geometry data once or per animation step.
Apps usually place such logic randomly in initialization routines or in the animation loop.
`geometryNode` is intended as a dedicated API so there is an intended spot where geometry modifications
can be implemented.

The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example
would be a GPU based particle system that provides a node material for usage on app level. The particle
simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is
eventually assigned to `geometryNode`.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+depthNode"></a>

### nodeMaterial.depthNode : <code>Node.&lt;float&gt;</code>
Allows to overwrite depth values in the fragment shader.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+shadowPositionNode"></a>

### nodeMaterial.shadowPositionNode : <code>Node.&lt;float&gt;</code>
Allows to overwrite the position used for shadow map rendering which
is by default [positionWorld](positionWorld), the vertex position
in world space.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+receivedShadowNode"></a>

### nodeMaterial.receivedShadowNode : <code>function</code> \| <code>FunctionNode.&lt;vec4&gt;</code>
This node can be used to influence how an object using this node material
receive shadows.

```js
const totalShadows = float( 1 ).toVar();
material.receivedShadowNode = Fn( ( [ shadow ] ) => {
	totalShadows.mulAssign( shadow );
	//return float( 1 ); // bypass received shadows
	return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color
} );

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+castShadowNode"></a>

### nodeMaterial.castShadowNode : <code>Node.&lt;vec4&gt;</code>
This node can be used to influence how an object using this node material
casts shadows. To apply a color to shadows, you can simply do:

```js
material.castShadowNode = vec4( 1, 0, 0, 1 );
```

Which can be nice to fake colored shadows of semi-transparent objects. It
is also common to use the property with `Fn` function so checks are performed
per fragment.

```js
materialCustomShadow.castShadowNode = Fn( () => {
	hash( vertexIndex ).greaterThan( 0.5 ).discard();
	return materialColor;
} )();
 ```

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+outputNode"></a>

### nodeMaterial.outputNode : <code>Node.&lt;vec4&gt;</code>
This node can be used to define the final output of the material.

TODO: Explain the differences to `fragmentNode`.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+mrtNode"></a>

### nodeMaterial.mrtNode : <code>MRTNode</code>
MRT configuration is done on renderer or pass level. This node allows to
overwrite what values are written into MRT targets on material level. This
can be useful for implementing selective FX features that should only affect
specific objects.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+fragmentNode"></a>

### nodeMaterial.fragmentNode : <code>Node.&lt;vec4&gt;</code>
This node property can be used if you need complete freedom in implementing
the fragment shader. Assigning a node will replace the built-in material
logic used in the fragment stage.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+vertexNode"></a>

### nodeMaterial.vertexNode : <code>Node.&lt;vec4&gt;</code>
This node property can be used if you need complete freedom in implementing
the vertex shader. Assigning a node will replace the built-in material logic
used in the vertex stage.

**Kind**: instance property of [<code>NodeMaterial</code>](#NodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterial+customProgramCacheKey"></a>

### nodeMaterial.customProgramCacheKey() ⇒ <code>string</code>
Allows to define a custom cache key that influence the material key computation
for render objects.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>string</code> - The custom cache key.  
<a name="NodeMaterial+build"></a>

### nodeMaterial.build(builder)
Builds this material with the given node builder.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupObserver"></a>

### nodeMaterial.setupObserver(builder) ⇒ <code>NodeMaterialObserver</code>
Setups a node material observer with the given builder.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>NodeMaterialObserver</code> - The node material observer.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setup"></a>

### nodeMaterial.setup(builder)
Setups the vertex and fragment stage of this node material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupClipping"></a>

### nodeMaterial.setupClipping(builder) ⇒ <code>ClippingNode</code>
Setups the clipping node.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>ClippingNode</code> - The clipping node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupHardwareClipping"></a>

### nodeMaterial.setupHardwareClipping(builder)
Setups the hardware clipping if available on the current device.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupDepth"></a>

### nodeMaterial.setupDepth(builder)
Setups the depth of this material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupPositionView"></a>

### nodeMaterial.setupPositionView(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the position node in view space. This method exists
so derived node materials can modify the implementation e.g. sprite materials.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The position in view space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupModelViewProjection"></a>

### nodeMaterial.setupModelViewProjection(builder) ⇒ <code>Node.&lt;vec4&gt;</code>
Setups the position in clip space.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The position in view space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupVertex"></a>

### nodeMaterial.setupVertex(builder) ⇒ <code>Node.&lt;vec4&gt;</code>
Setups the logic for the vertex stage.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The position in clip space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupPosition"></a>

### nodeMaterial.setupPosition(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the computation of the position in local space.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The position in local space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupDiffuseColor"></a>

### nodeMaterial.setupDiffuseColor(builder, geometry)
Setups the computation of the material's diffuse color.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| geometry | <code>BufferGeometry</code> | The geometry. |

<a name="NodeMaterial+setupVariants"></a>

### *nodeMaterial.setupVariants(builder)*
Abstract interface method that can be implemented by derived materials
to setup material-specific node variables.

**Kind**: instance abstract method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupOutgoingLight"></a>

### nodeMaterial.setupOutgoingLight() ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the outgoing light node variable

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The outgoing light node.  
<a name="NodeMaterial+setupNormal"></a>

### nodeMaterial.setupNormal() ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the normal node from the material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The normal node.  
<a name="NodeMaterial+setupEnvironment"></a>

### nodeMaterial.setupEnvironment(builder) ⇒ <code>Node.&lt;vec4&gt;</code>
Setups the environment node from the material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The environment node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupLightMap"></a>

### nodeMaterial.setupLightMap(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the light map node from the material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The light map node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupLights"></a>

### nodeMaterial.setupLights(builder) ⇒ <code>LightsNode</code>
Setups the lights node based on the scene, environment and material.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>LightsNode</code> - The lights node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupLightingModel"></a>

### *nodeMaterial.setupLightingModel(builder) ⇒ <code>LightingModel</code>*
This method should be implemented by most derived materials
since it defines the material's lighting model.

**Kind**: instance abstract method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>LightingModel</code> - The lighting model.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupLighting"></a>

### nodeMaterial.setupLighting(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the outgoing light node.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The outgoing light node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterial+setupFog"></a>

### nodeMaterial.setupFog(builder, outputNode) ⇒ <code>Node.&lt;vec4&gt;</code>
Setup the fog.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| outputNode | <code>Node.&lt;vec4&gt;</code> | The existing output node. |

<a name="NodeMaterial+setupOutput"></a>

### nodeMaterial.setupOutput(builder, outputNode) ⇒ <code>Node.&lt;vec4&gt;</code>
Setups the output node.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| outputNode | <code>Node.&lt;vec4&gt;</code> | The existing output node. |

<a name="NodeMaterial+setDefaultValues"></a>

### nodeMaterial.setDefaultValues(material)
Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
there is `MeshBasicNodeMaterial`. This utility method is intended for
defining all material properties of the classic type in the node type.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  

| Param | Type | Description |
| --- | --- | --- |
| material | <code>Material</code> | The material to copy properties with their values to this node material. |

<a name="NodeMaterial+toJSON"></a>

### nodeMaterial.toJSON(meta) ⇒ <code>Object</code>
Serializes this material to JSON.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: <code>Object</code> - The serialized node.  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | The meta information for serialization. |

<a name="NodeMaterial+copy"></a>

### nodeMaterial.copy(source) ⇒ [<code>NodeMaterial</code>](#NodeMaterial)
Copies the properties of the given node material to this instance.

**Kind**: instance method of [<code>NodeMaterial</code>](#NodeMaterial)  
**Returns**: [<code>NodeMaterial</code>](#NodeMaterial) - A reference to this node material.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>NodeMaterial</code>](#NodeMaterial) | The material to copy. |

<a name="PointsNodeMaterial"></a>

## PointsNodeMaterial ⇐ <code>SpriteNodeMaterial</code>
Node material version of [PointsMaterial](PointsMaterial).

**Kind**: global class  
**Extends**: <code>SpriteNodeMaterial</code>  

* [PointsNodeMaterial](#PointsNodeMaterial) ⇐ <code>SpriteNodeMaterial</code>
    * [new PointsNodeMaterial([parameters])](#new_PointsNodeMaterial_new)
    * [.sizeNode](#PointsNodeMaterial+sizeNode) : <code>Node.&lt;vec2&gt;</code>
    * [.isPointsNodeMaterial](#PointsNodeMaterial+isPointsNodeMaterial) : <code>boolean</code>
    * [.alphaToCoverage](#PointsNodeMaterial+alphaToCoverage) : <code>boolean</code>

<a name="new_PointsNodeMaterial_new"></a>

### new PointsNodeMaterial([parameters])
Constructs a new points node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="PointsNodeMaterial+sizeNode"></a>

### pointsNodeMaterial.sizeNode : <code>Node.&lt;vec2&gt;</code>
This node property provides an additional way to set the point size.

**Kind**: instance property of [<code>PointsNodeMaterial</code>](#PointsNodeMaterial)  
**Default**: <code>null</code>  
<a name="PointsNodeMaterial+isPointsNodeMaterial"></a>

### pointsNodeMaterial.isPointsNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointsNodeMaterial</code>](#PointsNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PointsNodeMaterial+alphaToCoverage"></a>

### pointsNodeMaterial.alphaToCoverage : <code>boolean</code>
Whether alpha to coverage should be used or not.

**Kind**: instance property of [<code>PointsNodeMaterial</code>](#PointsNodeMaterial)  
**Default**: <code>true</code>  
<a name="ShadowNodeMaterial"></a>

## ShadowNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [ShadowMaterial](ShadowMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [ShadowNodeMaterial](#ShadowNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new ShadowNodeMaterial([parameters])](#new_ShadowNodeMaterial_new)
    * [.isShadowNodeMaterial](#ShadowNodeMaterial+isShadowNodeMaterial) : <code>boolean</code>
    * [.lights](#ShadowNodeMaterial+lights) : <code>boolean</code>
    * [.transparent](#ShadowNodeMaterial+transparent) : <code>boolean</code>
    * [.setupLightingModel()](#ShadowNodeMaterial+setupLightingModel) ⇒ <code>ShadowMaskModel</code>

<a name="new_ShadowNodeMaterial_new"></a>

### new ShadowNodeMaterial([parameters])
Constructs a new shadow node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="ShadowNodeMaterial+isShadowNodeMaterial"></a>

### shadowNodeMaterial.isShadowNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowNodeMaterial</code>](#ShadowNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowNodeMaterial+lights"></a>

### shadowNodeMaterial.lights : <code>boolean</code>
Set to `true` because so it's possible to implement
the shadow mask effect.

**Kind**: instance property of [<code>ShadowNodeMaterial</code>](#ShadowNodeMaterial)  
**Default**: <code>true</code>  
<a name="ShadowNodeMaterial+transparent"></a>

### shadowNodeMaterial.transparent : <code>boolean</code>
Overwritten since shadow materials are transparent
by default.

**Kind**: instance property of [<code>ShadowNodeMaterial</code>](#ShadowNodeMaterial)  
**Default**: <code>true</code>  
<a name="ShadowNodeMaterial+setupLightingModel"></a>

### shadowNodeMaterial.setupLightingModel() ⇒ <code>ShadowMaskModel</code>
Setups the lighting model.

**Kind**: instance method of [<code>ShadowNodeMaterial</code>](#ShadowNodeMaterial)  
**Returns**: <code>ShadowMaskModel</code> - The lighting model.  
<a name="SpriteNodeMaterial"></a>

## SpriteNodeMaterial ⇐ <code>NodeMaterial</code>
Node material version of [SpriteMaterial](SpriteMaterial).

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [SpriteNodeMaterial](#SpriteNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new SpriteNodeMaterial([parameters])](#new_SpriteNodeMaterial_new)
    * [.isSpriteNodeMaterial](#SpriteNodeMaterial+isSpriteNodeMaterial) : <code>boolean</code>
    * [.positionNode](#SpriteNodeMaterial+positionNode) : <code>Node.&lt;vec2&gt;</code>
    * [.rotationNode](#SpriteNodeMaterial+rotationNode) : <code>Node.&lt;float&gt;</code>
    * [.scaleNode](#SpriteNodeMaterial+scaleNode) : <code>Node.&lt;vec2&gt;</code>
    * [.transparent](#SpriteNodeMaterial+transparent) : <code>boolean</code>
    * [.sizeAttenuation](#SpriteNodeMaterial+sizeAttenuation) : <code>boolean</code>
    * [.setupPositionView(builder)](#SpriteNodeMaterial+setupPositionView) ⇒ <code>Node.&lt;vec3&gt;</code>

<a name="new_SpriteNodeMaterial_new"></a>

### new SpriteNodeMaterial([parameters])
Constructs a new sprite node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="SpriteNodeMaterial+isSpriteNodeMaterial"></a>

### spriteNodeMaterial.isSpriteNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SpriteNodeMaterial+positionNode"></a>

### spriteNodeMaterial.positionNode : <code>Node.&lt;vec2&gt;</code>
This property makes it possible to define the position of the sprite with a
node. That can be useful when the material is used with instanced rendering
and node data are defined with an instanced attribute node:
```js
const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );
material.positionNode = instancedBufferAttribute( positionAttribute );
```
Another possibility is to compute the instanced data with a compute shader:
```js
const positionBuffer = instancedArray( particleCount, 'vec3' );
particleMaterial.positionNode = positionBuffer.toAttribute();
```

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>null</code>  
<a name="SpriteNodeMaterial+rotationNode"></a>

### spriteNodeMaterial.rotationNode : <code>Node.&lt;float&gt;</code>
The rotation of sprite materials is by default inferred from the `rotation`,
property. This node property allows to overwrite the default and define
the rotation with a node instead.

If you don't want to overwrite the rotation but modify the existing
value instead, use [materialRotation](materialRotation).

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>null</code>  
<a name="SpriteNodeMaterial+scaleNode"></a>

### spriteNodeMaterial.scaleNode : <code>Node.&lt;vec2&gt;</code>
This node property provides an additional way to scale sprites next to
`Object3D.scale`. The scale transformation based in `Object3D.scale`
is multiplied with the scale value of this node in the vertex shader.

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>null</code>  
<a name="SpriteNodeMaterial+transparent"></a>

### spriteNodeMaterial.transparent : <code>boolean</code>
In Sprites, the transparent property is enabled by default.

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>true</code>  
<a name="SpriteNodeMaterial+sizeAttenuation"></a>

### spriteNodeMaterial.sizeAttenuation : <code>boolean</code>
Whether to use size attenuation or not.

**Kind**: instance property of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Default**: <code>true</code>  
<a name="SpriteNodeMaterial+setupPositionView"></a>

### spriteNodeMaterial.setupPositionView(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the position node in view space. This method implements
the sprite specific vertex shader.

**Kind**: instance method of [<code>SpriteNodeMaterial</code>](#SpriteNodeMaterial)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The position in view space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="VolumeNodeMaterial"></a>

## VolumeNodeMaterial ⇐ <code>NodeMaterial</code>
Volume node material.

**Kind**: global class  
**Extends**: <code>NodeMaterial</code>  

* [VolumeNodeMaterial](#VolumeNodeMaterial) ⇐ <code>NodeMaterial</code>
    * [new VolumeNodeMaterial([parameters])](#new_VolumeNodeMaterial_new)
    * [.isVolumeNodeMaterial](#VolumeNodeMaterial+isVolumeNodeMaterial) : <code>boolean</code>
    * [.steps](#VolumeNodeMaterial+steps) : <code>number</code>
    * [.offsetNode](#VolumeNodeMaterial+offsetNode) : <code>Node.&lt;float&gt;</code>
    * [.scatteringNode](#VolumeNodeMaterial+scatteringNode) : <code>function</code> \| <code>FunctionNode.&lt;vec4&gt;</code>

<a name="new_VolumeNodeMaterial_new"></a>

### new VolumeNodeMaterial([parameters])
Constructs a new volume node material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | The configuration parameter. |

<a name="VolumeNodeMaterial+isVolumeNodeMaterial"></a>

### volumeNodeMaterial.isVolumeNodeMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VolumeNodeMaterial</code>](#VolumeNodeMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VolumeNodeMaterial+steps"></a>

### volumeNodeMaterial.steps : <code>number</code>
Number of steps used for raymarching.

**Kind**: instance property of [<code>VolumeNodeMaterial</code>](#VolumeNodeMaterial)  
**Default**: <code>25</code>  
<a name="VolumeNodeMaterial+offsetNode"></a>

### volumeNodeMaterial.offsetNode : <code>Node.&lt;float&gt;</code>
Offsets the distance a ray has been traveled through a volume.
Can be used to implement dithering to reduce banding.

**Kind**: instance property of [<code>VolumeNodeMaterial</code>](#VolumeNodeMaterial)  
**Default**: <code>null</code>  
<a name="VolumeNodeMaterial+scatteringNode"></a>

### volumeNodeMaterial.scatteringNode : <code>function</code> \| <code>FunctionNode.&lt;vec4&gt;</code>
Node used for scattering calculations.

**Kind**: instance property of [<code>VolumeNodeMaterial</code>](#VolumeNodeMaterial)  
**Default**: <code>null</code>  
<a name="NodeMaterialObserver"></a>

## NodeMaterialObserver
This class is used by [WebGPURenderer](WebGPURenderer) as management component.
It's primary purpose is to determine whether render objects require a
refresh right before they are going to be rendered or not.

**Kind**: global class  

* [NodeMaterialObserver](#NodeMaterialObserver)
    * [new NodeMaterialObserver(builder)](#new_NodeMaterialObserver_new)
    * [.renderObjects](#NodeMaterialObserver+renderObjects) : <code>WeakMap.&lt;RenderObject, Object&gt;</code>
    * [.hasNode](#NodeMaterialObserver+hasNode) : <code>boolean</code>
    * [.hasAnimation](#NodeMaterialObserver+hasAnimation) : <code>boolean</code>
    * [.refreshUniforms](#NodeMaterialObserver+refreshUniforms) : <code>Array.&lt;string&gt;</code>
    * [.renderId](#NodeMaterialObserver+renderId) : <code>number</code>
    * [.firstInitialization(renderObject)](#NodeMaterialObserver+firstInitialization) ⇒ <code>boolean</code>
    * [.getRenderObjectData(renderObject)](#NodeMaterialObserver+getRenderObjectData) ⇒ <code>Object</code>
    * [.getAttributesData(attributes)](#NodeMaterialObserver+getAttributesData) ⇒ <code>Object</code>
    * [.containsNode(builder)](#NodeMaterialObserver+containsNode) ⇒ <code>boolean</code>
    * [.getMaterialData(material)](#NodeMaterialObserver+getMaterialData) ⇒ <code>Object</code>
    * [.equals(renderObject)](#NodeMaterialObserver+equals) ⇒ <code>boolean</code>
    * [.needsRefresh(renderObject, nodeFrame)](#NodeMaterialObserver+needsRefresh) ⇒ <code>boolean</code>

<a name="new_NodeMaterialObserver_new"></a>

### new NodeMaterialObserver(builder)
Constructs a new node material observer.


| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The node builder. |

<a name="NodeMaterialObserver+renderObjects"></a>

### nodeMaterialObserver.renderObjects : <code>WeakMap.&lt;RenderObject, Object&gt;</code>
A node material can be used by more than one render object so the
monitor must maintain a list of render objects.

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
<a name="NodeMaterialObserver+hasNode"></a>

### nodeMaterialObserver.hasNode : <code>boolean</code>
Whether the material uses node objects or not.

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
<a name="NodeMaterialObserver+hasAnimation"></a>

### nodeMaterialObserver.hasAnimation : <code>boolean</code>
Whether the node builder's 3D object is animated or not.

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
<a name="NodeMaterialObserver+refreshUniforms"></a>

### nodeMaterialObserver.refreshUniforms : <code>Array.&lt;string&gt;</code>
A list of all possible material uniforms

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
<a name="NodeMaterialObserver+renderId"></a>

### nodeMaterialObserver.renderId : <code>number</code>
Holds the current render ID from the node frame.

**Kind**: instance property of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Default**: <code>0</code>  
<a name="NodeMaterialObserver+firstInitialization"></a>

### nodeMaterialObserver.firstInitialization(renderObject) ⇒ <code>boolean</code>
Returns `true` if the given render object is verified for the first time of this observer.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>boolean</code> - Whether the given render object is verified for the first time of this observer.  

| Param | Type | Description |
| --- | --- | --- |
| renderObject | <code>RenderObject</code> | The render object. |

<a name="NodeMaterialObserver+getRenderObjectData"></a>

### nodeMaterialObserver.getRenderObjectData(renderObject) ⇒ <code>Object</code>
Returns monitoring data for the given render object.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>Object</code> - The monitoring data.  

| Param | Type | Description |
| --- | --- | --- |
| renderObject | <code>RenderObject</code> | The render object. |

<a name="NodeMaterialObserver+getAttributesData"></a>

### nodeMaterialObserver.getAttributesData(attributes) ⇒ <code>Object</code>
Returns an attribute data structure holding the attributes versions for
monitoring.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>Object</code> - An object for monitoring the versions of attributes.  

| Param | Type | Description |
| --- | --- | --- |
| attributes | <code>Object</code> | The geometry attributes. |

<a name="NodeMaterialObserver+containsNode"></a>

### nodeMaterialObserver.containsNode(builder) ⇒ <code>boolean</code>
Returns `true` if the node builder's material uses
node properties.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>boolean</code> - Whether the node builder's material uses node properties or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="NodeMaterialObserver+getMaterialData"></a>

### nodeMaterialObserver.getMaterialData(material) ⇒ <code>Object</code>
Returns a material data structure holding the material property values for
monitoring.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>Object</code> - An object for monitoring material properties.  

| Param | Type | Description |
| --- | --- | --- |
| material | <code>Material</code> | The material. |

<a name="NodeMaterialObserver+equals"></a>

### nodeMaterialObserver.equals(renderObject) ⇒ <code>boolean</code>
Returns `true` if the given render object has not changed its state.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>boolean</code> - Whether the given render object has changed its state or not.  

| Param | Type | Description |
| --- | --- | --- |
| renderObject | <code>RenderObject</code> | The render object. |

<a name="NodeMaterialObserver+needsRefresh"></a>

### nodeMaterialObserver.needsRefresh(renderObject, nodeFrame) ⇒ <code>boolean</code>
Checks if the given render object requires a refresh.

**Kind**: instance method of [<code>NodeMaterialObserver</code>](#NodeMaterialObserver)  
**Returns**: <code>boolean</code> - Whether the given render object requires a refresh or not.  

| Param | Type | Description |
| --- | --- | --- |
| renderObject | <code>RenderObject</code> | The render object. |
| nodeFrame | <code>NodeFrame</code> | The current node frame. |

<a name="Box2"></a>

## Box2
Represents an axis-aligned bounding box (AABB) in 2D space.

**Kind**: global class  

* [Box2](#Box2)
    * [new Box2([min], [max])](#new_Box2_new)
    * [.isBox2](#Box2+isBox2) : <code>boolean</code>
    * [.min](#Box2+min) : <code>Vector2</code>
    * [.max](#Box2+max) : <code>Vector2</code>
    * [.set(min, max)](#Box2+set) ⇒ [<code>Box2</code>](#Box2)
    * [.setFromPoints(points)](#Box2+setFromPoints) ⇒ [<code>Box2</code>](#Box2)
    * [.setFromCenterAndSize(center, size)](#Box2+setFromCenterAndSize) ⇒ [<code>Box2</code>](#Box2)
    * [.clone()](#Box2+clone) ⇒ [<code>Box2</code>](#Box2)
    * [.copy(box)](#Box2+copy) ⇒ [<code>Box2</code>](#Box2)
    * [.makeEmpty()](#Box2+makeEmpty) ⇒ [<code>Box2</code>](#Box2)
    * [.isEmpty()](#Box2+isEmpty) ⇒ <code>boolean</code>
    * [.getCenter(target)](#Box2+getCenter) ⇒ <code>Vector2</code>
    * [.getSize(target)](#Box2+getSize) ⇒ <code>Vector2</code>
    * [.expandByPoint(point)](#Box2+expandByPoint) ⇒ [<code>Box2</code>](#Box2)
    * [.expandByVector(vector)](#Box2+expandByVector) ⇒ [<code>Box2</code>](#Box2)
    * [.expandByScalar(scalar)](#Box2+expandByScalar) ⇒ [<code>Box2</code>](#Box2)
    * [.containsPoint(point)](#Box2+containsPoint) ⇒ <code>boolean</code>
    * [.containsBox(box)](#Box2+containsBox) ⇒ <code>boolean</code>
    * [.getParameter(point, target)](#Box2+getParameter) ⇒ <code>Vector2</code>
    * [.intersectsBox(box)](#Box2+intersectsBox) ⇒ <code>boolean</code>
    * [.clampPoint(point, target)](#Box2+clampPoint) ⇒ <code>Vector2</code>
    * [.distanceToPoint(point)](#Box2+distanceToPoint) ⇒ <code>number</code>
    * [.intersect(box)](#Box2+intersect) ⇒ [<code>Box2</code>](#Box2)
    * [.union(box)](#Box2+union) ⇒ [<code>Box2</code>](#Box2)
    * [.translate(offset)](#Box2+translate) ⇒ [<code>Box2</code>](#Box2)
    * [.equals(box)](#Box2+equals) ⇒ <code>boolean</code>

<a name="new_Box2_new"></a>

### new Box2([min], [max])
Constructs a new bounding box.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [min] | <code>Vector2</code> | <code>(Infinity,Infinity)</code> | A vector representing the lower boundary of the box. |
| [max] | <code>Vector2</code> | <code>(-Infinity,-Infinity)</code> | A vector representing the upper boundary of the box. |

<a name="Box2+isBox2"></a>

### box2.isBox2 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Box2</code>](#Box2)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Box2+min"></a>

### box2.min : <code>Vector2</code>
The lower boundary of the box.

**Kind**: instance property of [<code>Box2</code>](#Box2)  
<a name="Box2+max"></a>

### box2.max : <code>Vector2</code>
The upper boundary of the box.

**Kind**: instance property of [<code>Box2</code>](#Box2)  
<a name="Box2+set"></a>

### box2.set(min, max) ⇒ [<code>Box2</code>](#Box2)
Sets the lower and upper boundaries of this box.
Please note that this method only copies the values from the given objects.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>Vector2</code> | The lower boundary of the box. |
| max | <code>Vector2</code> | The upper boundary of the box. |

<a name="Box2+setFromPoints"></a>

### box2.setFromPoints(points) ⇒ [<code>Box2</code>](#Box2)
Sets the upper and lower bounds of this box so it encloses the position data
in the given array.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector2&gt;</code> | An array holding 2D position data as instances of [Vector2](Vector2). |

<a name="Box2+setFromCenterAndSize"></a>

### box2.setFromCenterAndSize(center, size) ⇒ [<code>Box2</code>](#Box2)
Centers this box on the given center vector and sets this box's width, height and
depth to the given size values.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| center | <code>Vector2</code> | The center of the box. |
| size | <code>Vector2</code> | The x and y dimensions of the box. |

<a name="Box2+clone"></a>

### box2.clone() ⇒ [<code>Box2</code>](#Box2)
Returns a new box with copied values from this instance.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A clone of this instance.  
<a name="Box2+copy"></a>

### box2.copy(box) ⇒ [<code>Box2</code>](#Box2)
Copies the values of the given box to this instance.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The box to copy. |

<a name="Box2+makeEmpty"></a>

### box2.makeEmpty() ⇒ [<code>Box2</code>](#Box2)
Makes this box empty which means in encloses a zero space in 2D.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  
<a name="Box2+isEmpty"></a>

### box2.isEmpty() ⇒ <code>boolean</code>
Returns true if this box includes zero points within its bounds.
Note that a box with equal lower and upper bounds still includes one
point, the one both bounds share.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether this box is empty or not.  
<a name="Box2+getCenter"></a>

### box2.getCenter(target) ⇒ <code>Vector2</code>
Returns the center point of this box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>Vector2</code> - The center point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The target vector that is used to store the method's result. |

<a name="Box2+getSize"></a>

### box2.getSize(target) ⇒ <code>Vector2</code>
Returns the dimensions of this box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>Vector2</code> - The size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The target vector that is used to store the method's result. |

<a name="Box2+expandByPoint"></a>

### box2.expandByPoint(point) ⇒ [<code>Box2</code>](#Box2)
Expands the boundaries of this box to include the given point.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | The point that should be included by the bounding box. |

<a name="Box2+expandByVector"></a>

### box2.expandByVector(vector) ⇒ [<code>Box2</code>](#Box2)
Expands this box equilaterally by the given vector. The width of this
box will be expanded by the x component of the vector in both
directions. The height of this box will be expanded by the y component of
the vector in both directions.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| vector | <code>Vector2</code> | The vector that should expand the bounding box. |

<a name="Box2+expandByScalar"></a>

### box2.expandByScalar(scalar) ⇒ [<code>Box2</code>](#Box2)
Expands each dimension of the box by the given scalar. If negative, the
dimensions of the box will be contracted.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar value that should expand the bounding box. |

<a name="Box2+containsPoint"></a>

### box2.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies within or on the boundaries of this box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether the bounding box contains the given point or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | The point to test. |

<a name="Box2+containsBox"></a>

### box2.containsBox(box) ⇒ <code>boolean</code>
Returns `true` if this bounding box includes the entirety of the given bounding box.
If this box and the given one are identical, this function also returns `true`.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether the bounding box contains the given bounding box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The bounding box to test. |

<a name="Box2+getParameter"></a>

### box2.getParameter(point, target) ⇒ <code>Vector2</code>
Returns a point as a proportion of this box's width and height.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>Vector2</code> - A point as a proportion of this box's width and height.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | A point in 2D space. |
| target | <code>Vector2</code> | The target vector that is used to store the method's result. |

<a name="Box2+intersectsBox"></a>

### box2.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box intersects with this bounding box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether the given bounding box intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The bounding box to test. |

<a name="Box2+clampPoint"></a>

### box2.clampPoint(point, target) ⇒ <code>Vector2</code>
Clamps the given point within the bounds of this box.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>Vector2</code> - The clamped point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | The point to clamp. |
| target | <code>Vector2</code> | The target vector that is used to store the method's result. |

<a name="Box2+distanceToPoint"></a>

### box2.distanceToPoint(point) ⇒ <code>number</code>
Returns the euclidean distance from any edge of this box to the specified point. If
the given point lies inside of this box, the distance will be `0`.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>number</code> - The euclidean distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector2</code> | The point to compute the distance to. |

<a name="Box2+intersect"></a>

### box2.intersect(box) ⇒ [<code>Box2</code>](#Box2)
Computes the intersection of this bounding box and the given one, setting the upper
bound of this box to the lesser of the two boxes' upper bounds and the
lower bound of this box to the greater of the two boxes' lower bounds. If
there's no overlap, makes this box empty.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The bounding box to intersect with. |

<a name="Box2+union"></a>

### box2.union(box) ⇒ [<code>Box2</code>](#Box2)
Computes the union of this box and another and the given one, setting the upper
bound of this box to the greater of the two boxes' upper bounds and the
lower bound of this box to the lesser of the two boxes' lower bounds.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The bounding box that will be unioned with this instance. |

<a name="Box2+translate"></a>

### box2.translate(offset) ⇒ [<code>Box2</code>](#Box2)
Adds the given offset to both the upper and lower bounds of this bounding box,
effectively moving it in 2D space.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: [<code>Box2</code>](#Box2) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| offset | <code>Vector2</code> | The offset that should be used to translate the bounding box. |

<a name="Box2+equals"></a>

### box2.equals(box) ⇒ <code>boolean</code>
Returns `true` if this bounding box is equal with the given one.

**Kind**: instance method of [<code>Box2</code>](#Box2)  
**Returns**: <code>boolean</code> - Whether this bounding box is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box2</code>](#Box2) | The box to test for equality. |

<a name="Box3"></a>

## Box3
Represents an axis-aligned bounding box (AABB) in 3D space.

**Kind**: global class  

* [Box3](#Box3)
    * [new Box3([min], [max])](#new_Box3_new)
    * [.isBox3](#Box3+isBox3) : <code>boolean</code>
    * [.min](#Box3+min) : <code>Vector3</code>
    * [.max](#Box3+max) : <code>Vector3</code>
    * [.set(min, max)](#Box3+set) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromArray(array)](#Box3+setFromArray) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromBufferAttribute(attribute)](#Box3+setFromBufferAttribute) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromPoints(points)](#Box3+setFromPoints) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromCenterAndSize(center, size)](#Box3+setFromCenterAndSize) ⇒ [<code>Box3</code>](#Box3)
    * [.setFromObject(object, [precise])](#Box3+setFromObject) ⇒ [<code>Box3</code>](#Box3)
    * [.clone()](#Box3+clone) ⇒ [<code>Box3</code>](#Box3)
    * [.copy(box)](#Box3+copy) ⇒ [<code>Box3</code>](#Box3)
    * [.makeEmpty()](#Box3+makeEmpty) ⇒ [<code>Box3</code>](#Box3)
    * [.isEmpty()](#Box3+isEmpty) ⇒ <code>boolean</code>
    * [.getCenter(target)](#Box3+getCenter) ⇒ <code>Vector3</code>
    * [.getSize(target)](#Box3+getSize) ⇒ <code>Vector3</code>
    * [.expandByPoint(point)](#Box3+expandByPoint) ⇒ [<code>Box3</code>](#Box3)
    * [.expandByVector(vector)](#Box3+expandByVector) ⇒ [<code>Box3</code>](#Box3)
    * [.expandByScalar(scalar)](#Box3+expandByScalar) ⇒ [<code>Box3</code>](#Box3)
    * [.expandByObject(object, precise)](#Box3+expandByObject) ⇒ [<code>Box3</code>](#Box3)
    * [.containsPoint(point)](#Box3+containsPoint) ⇒ <code>boolean</code>
    * [.containsBox(box)](#Box3+containsBox) ⇒ <code>boolean</code>
    * [.getParameter(point, target)](#Box3+getParameter) ⇒ <code>Vector3</code>
    * [.intersectsBox(box)](#Box3+intersectsBox) ⇒ <code>boolean</code>
    * [.intersectsSphere(sphere)](#Box3+intersectsSphere) ⇒ <code>boolean</code>
    * [.intersectsPlane(plane)](#Box3+intersectsPlane) ⇒ <code>boolean</code>
    * [.intersectsTriangle(triangle)](#Box3+intersectsTriangle) ⇒ <code>boolean</code>
    * [.clampPoint(point, target)](#Box3+clampPoint) ⇒ <code>Vector3</code>
    * [.distanceToPoint(point)](#Box3+distanceToPoint) ⇒ <code>number</code>
    * [.getBoundingSphere(target)](#Box3+getBoundingSphere) ⇒ <code>Sphere</code>
    * [.intersect(box)](#Box3+intersect) ⇒ [<code>Box3</code>](#Box3)
    * [.union(box)](#Box3+union) ⇒ [<code>Box3</code>](#Box3)
    * [.applyMatrix4(matrix)](#Box3+applyMatrix4) ⇒ [<code>Box3</code>](#Box3)
    * [.translate(offset)](#Box3+translate) ⇒ [<code>Box3</code>](#Box3)
    * [.equals(box)](#Box3+equals) ⇒ <code>boolean</code>

<a name="new_Box3_new"></a>

### new Box3([min], [max])
Constructs a new bounding box.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [min] | <code>Vector3</code> | <code>(Infinity,Infinity,Infinity)</code> | A vector representing the lower boundary of the box. |
| [max] | <code>Vector3</code> | <code>(-Infinity,-Infinity,-Infinity)</code> | A vector representing the upper boundary of the box. |

<a name="Box3+isBox3"></a>

### box3.isBox3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Box3</code>](#Box3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Box3+min"></a>

### box3.min : <code>Vector3</code>
The lower boundary of the box.

**Kind**: instance property of [<code>Box3</code>](#Box3)  
<a name="Box3+max"></a>

### box3.max : <code>Vector3</code>
The upper boundary of the box.

**Kind**: instance property of [<code>Box3</code>](#Box3)  
<a name="Box3+set"></a>

### box3.set(min, max) ⇒ [<code>Box3</code>](#Box3)
Sets the lower and upper boundaries of this box.
Please note that this method only copies the values from the given objects.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>Vector3</code> | The lower boundary of the box. |
| max | <code>Vector3</code> | The upper boundary of the box. |

<a name="Box3+setFromArray"></a>

### box3.setFromArray(array) ⇒ [<code>Box3</code>](#Box3)
Sets the upper and lower bounds of this box so it encloses the position data
in the given array.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> | An array holding 3D position data. |

<a name="Box3+setFromBufferAttribute"></a>

### box3.setFromBufferAttribute(attribute) ⇒ [<code>Box3</code>](#Box3)
Sets the upper and lower bounds of this box so it encloses the position data
in the given buffer attribute.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | A buffer attribute holding 3D position data. |

<a name="Box3+setFromPoints"></a>

### box3.setFromPoints(points) ⇒ [<code>Box3</code>](#Box3)
Sets the upper and lower bounds of this box so it encloses the position data
in the given array.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector3&gt;</code> | An array holding 3D position data as instances of [Vector3](Vector3). |

<a name="Box3+setFromCenterAndSize"></a>

### box3.setFromCenterAndSize(center, size) ⇒ [<code>Box3</code>](#Box3)
Centers this box on the given center vector and sets this box's width, height and
depth to the given size values.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| center | <code>Vector3</code> | The center of the box. |
| size | <code>Vector3</code> | The x, y and z dimensions of the box. |

<a name="Box3+setFromObject"></a>

### box3.setFromObject(object, [precise]) ⇒ [<code>Box3</code>](#Box3)
Computes the world-axis-aligned bounding box for the given 3D object
(including its children), accounting for the object's, and children's,
world transforms. The function may result in a larger box than strictly necessary.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object to compute the bounding box for. |
| [precise] | <code>boolean</code> | <code>false</code> | If set to `true`, the method computes the smallest world-axis-aligned bounding box at the expense of more computation. |

<a name="Box3+clone"></a>

### box3.clone() ⇒ [<code>Box3</code>](#Box3)
Returns a new box with copied values from this instance.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A clone of this instance.  
<a name="Box3+copy"></a>

### box3.copy(box) ⇒ [<code>Box3</code>](#Box3)
Copies the values of the given box to this instance.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The box to copy. |

<a name="Box3+makeEmpty"></a>

### box3.makeEmpty() ⇒ [<code>Box3</code>](#Box3)
Makes this box empty which means in encloses a zero space in 3D.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  
<a name="Box3+isEmpty"></a>

### box3.isEmpty() ⇒ <code>boolean</code>
Returns true if this box includes zero points within its bounds.
Note that a box with equal lower and upper bounds still includes one
point, the one both bounds share.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether this box is empty or not.  
<a name="Box3+getCenter"></a>

### box3.getCenter(target) ⇒ <code>Vector3</code>
Returns the center point of this box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Vector3</code> - The center point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Box3+getSize"></a>

### box3.getSize(target) ⇒ <code>Vector3</code>
Returns the dimensions of this box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Vector3</code> - The size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Box3+expandByPoint"></a>

### box3.expandByPoint(point) ⇒ [<code>Box3</code>](#Box3)
Expands the boundaries of this box to include the given point.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point that should be included by the bounding box. |

<a name="Box3+expandByVector"></a>

### box3.expandByVector(vector) ⇒ [<code>Box3</code>](#Box3)
Expands this box equilaterally by the given vector. The width of this
box will be expanded by the x component of the vector in both
directions. The height of this box will be expanded by the y component of
the vector in both directions. The depth of this box will be
expanded by the z component of the vector in both directions.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| vector | <code>Vector3</code> | The vector that should expand the bounding box. |

<a name="Box3+expandByScalar"></a>

### box3.expandByScalar(scalar) ⇒ [<code>Box3</code>](#Box3)
Expands each dimension of the box by the given scalar. If negative, the
dimensions of the box will be contracted.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar value that should expand the bounding box. |

<a name="Box3+expandByObject"></a>

### box3.expandByObject(object, precise) ⇒ [<code>Box3</code>](#Box3)
Expands the boundaries of this box to include the given 3D object and
its children, accounting for the object's, and children's, world
transforms. The function may result in a larger box than strictly
necessary (unless the precise parameter is set to true).

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object that should expand the bounding box. |
| precise | <code>boolean</code> | <code>false</code> | If set to `true`, the method expands the bounding box as little as necessary at the expense of more computation. |

<a name="Box3+containsPoint"></a>

### box3.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies within or on the boundaries of this box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the bounding box contains the given point or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to test. |

<a name="Box3+containsBox"></a>

### box3.containsBox(box) ⇒ <code>boolean</code>
Returns `true` if this bounding box includes the entirety of the given bounding box.
If this box and the given one are identical, this function also returns `true`.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the bounding box contains the given bounding box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The bounding box to test. |

<a name="Box3+getParameter"></a>

### box3.getParameter(point, target) ⇒ <code>Vector3</code>
Returns a point as a proportion of this box's width, height and depth.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Vector3</code> - A point as a proportion of this box's width, height and depth.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Box3+intersectsBox"></a>

### box3.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box intersects with this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the given bounding box intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The bounding box to test. |

<a name="Box3+intersectsSphere"></a>

### box3.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if the given bounding sphere intersects with this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the given bounding sphere intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="Box3+intersectsPlane"></a>

### box3.intersectsPlane(plane) ⇒ <code>boolean</code>
Returns `true` if the given plane intersects with this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the given plane intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to test. |

<a name="Box3+intersectsTriangle"></a>

### box3.intersectsTriangle(triangle) ⇒ <code>boolean</code>
Returns `true` if the given triangle intersects with this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether the given triangle intersects with this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| triangle | <code>Triangle</code> | The triangle to test. |

<a name="Box3+clampPoint"></a>

### box3.clampPoint(point, target) ⇒ <code>Vector3</code>
Clamps the given point within the bounds of this box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Vector3</code> - The clamped point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to clamp. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Box3+distanceToPoint"></a>

### box3.distanceToPoint(point) ⇒ <code>number</code>
Returns the euclidean distance from any edge of this box to the specified point. If
the given point lies inside of this box, the distance will be `0`.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>number</code> - The euclidean distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to compute the distance to. |

<a name="Box3+getBoundingSphere"></a>

### box3.getBoundingSphere(target) ⇒ <code>Sphere</code>
Returns a bounding sphere that encloses this bounding box.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>Sphere</code> - The bounding sphere that encloses this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Sphere</code> | The target sphere that is used to store the method's result. |

<a name="Box3+intersect"></a>

### box3.intersect(box) ⇒ [<code>Box3</code>](#Box3)
Computes the intersection of this bounding box and the given one, setting the upper
bound of this box to the lesser of the two boxes' upper bounds and the
lower bound of this box to the greater of the two boxes' lower bounds. If
there's no overlap, makes this box empty.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The bounding box to intersect with. |

<a name="Box3+union"></a>

### box3.union(box) ⇒ [<code>Box3</code>](#Box3)
Computes the union of this box and another and the given one, setting the upper
bound of this box to the greater of the two boxes' upper bounds and the
lower bound of this box to the lesser of the two boxes' lower bounds.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The bounding box that will be unioned with this instance. |

<a name="Box3+applyMatrix4"></a>

### box3.applyMatrix4(matrix) ⇒ [<code>Box3</code>](#Box3)
Transforms this bounding box by the given 4x4 transformation matrix.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The transformation matrix. |

<a name="Box3+translate"></a>

### box3.translate(offset) ⇒ [<code>Box3</code>](#Box3)
Adds the given offset to both the upper and lower bounds of this bounding box,
effectively moving it in 3D space.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: [<code>Box3</code>](#Box3) - A reference to this bounding box.  

| Param | Type | Description |
| --- | --- | --- |
| offset | <code>Vector3</code> | The offset that should be used to translate the bounding box. |

<a name="Box3+equals"></a>

### box3.equals(box) ⇒ <code>boolean</code>
Returns `true` if this bounding box is equal with the given one.

**Kind**: instance method of [<code>Box3</code>](#Box3)  
**Returns**: <code>boolean</code> - Whether this bounding box is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| box | [<code>Box3</code>](#Box3) | The box to test for equality. |

<a name="Color"></a>

## Color
A Color instance is represented by RGB components in the linear <i>working
color space</i>, which defaults to `LinearSRGBColorSpace`. Inputs
conventionally using `SRGBColorSpace` (such as hexadecimals and CSS
strings) are converted to the working color space automatically.

```js
// converted automatically from SRGBColorSpace to LinearSRGBColorSpace
const color = new THREE.Color().setHex( 0x112233 );
```
Source color spaces may be specified explicitly, to ensure correct conversions.
```js
// assumed already LinearSRGBColorSpace; no conversion
const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5 );

// converted explicitly from SRGBColorSpace to LinearSRGBColorSpace
const color = new THREE.Color().setRGB( 0.5, 0.5, 0.5, SRGBColorSpace );
```
If THREE.ColorManagement is disabled, no conversions occur. For details,
see <i>Color management</i>. Iterating through a Color instance will yield
its components (r, g, b) in the corresponding order. A Color can be initialised
in any of the following ways:
```js
//empty constructor - will default white
const color1 = new THREE.Color();

//Hexadecimal color (recommended)
const color2 = new THREE.Color( 0xff0000 );

//RGB string
const color3 = new THREE.Color("rgb(255, 0, 0)");
const color4 = new THREE.Color("rgb(100%, 0%, 0%)");

//X11 color name - all 140 color names are supported.
//Note the lack of CamelCase in the name
const color5 = new THREE.Color( 'skyblue' );
//HSL string
const color6 = new THREE.Color("hsl(0, 100%, 50%)");

//Separate RGB values between 0 and 1
const color7 = new THREE.Color( 1, 0, 0 );
```

**Kind**: global class  

* [Color](#Color)
    * [new Color([r], [g], [b])](#new_Color_new)
    * _instance_
        * [.isColor](#Color+isColor) : <code>boolean</code>
        * [.r](#Color+r) : <code>number</code>
        * [.g](#Color+g) : <code>number</code>
        * [.b](#Color+b) : <code>number</code>
        * [.set([r], [g], [b])](#Color+set) ⇒ [<code>Color</code>](#Color)
        * [.setScalar(scalar)](#Color+setScalar) ⇒ [<code>Color</code>](#Color)
        * [.setHex(hex, [colorSpace])](#Color+setHex) ⇒ [<code>Color</code>](#Color)
        * [.setRGB(r, g, b, [colorSpace])](#Color+setRGB) ⇒ [<code>Color</code>](#Color)
        * [.setHSL(h, s, l, [colorSpace])](#Color+setHSL) ⇒ [<code>Color</code>](#Color)
        * [.setStyle(style, [colorSpace])](#Color+setStyle) ⇒ [<code>Color</code>](#Color)
        * [.setColorName(style, [colorSpace])](#Color+setColorName) ⇒ [<code>Color</code>](#Color)
        * [.clone()](#Color+clone) ⇒ [<code>Color</code>](#Color)
        * [.copy(color)](#Color+copy) ⇒ [<code>Color</code>](#Color)
        * [.copySRGBToLinear(color)](#Color+copySRGBToLinear) ⇒ [<code>Color</code>](#Color)
        * [.copyLinearToSRGB(color)](#Color+copyLinearToSRGB) ⇒ [<code>Color</code>](#Color)
        * [.convertSRGBToLinear()](#Color+convertSRGBToLinear) ⇒ [<code>Color</code>](#Color)
        * [.convertLinearToSRGB()](#Color+convertLinearToSRGB) ⇒ [<code>Color</code>](#Color)
        * [.getHex([colorSpace])](#Color+getHex) ⇒ <code>number</code>
        * [.getHexString([colorSpace])](#Color+getHexString) ⇒ <code>string</code>
        * [.getHSL(target, [colorSpace])](#Color+getHSL) ⇒ <code>Object</code>
        * [.getRGB(target, [colorSpace])](#Color+getRGB) ⇒ [<code>Color</code>](#Color)
        * [.getStyle([colorSpace])](#Color+getStyle) ⇒ <code>string</code>
        * [.offsetHSL(h, s, l)](#Color+offsetHSL) ⇒ [<code>Color</code>](#Color)
        * [.add(color)](#Color+add) ⇒ [<code>Color</code>](#Color)
        * [.addColors(color1, color2)](#Color+addColors) ⇒ [<code>Color</code>](#Color)
        * [.addScalar(s)](#Color+addScalar) ⇒ [<code>Color</code>](#Color)
        * [.sub(color)](#Color+sub) ⇒ [<code>Color</code>](#Color)
        * [.multiply(color)](#Color+multiply) ⇒ [<code>Color</code>](#Color)
        * [.multiplyScalar(s)](#Color+multiplyScalar) ⇒ [<code>Color</code>](#Color)
        * [.lerp(color, alpha)](#Color+lerp) ⇒ [<code>Color</code>](#Color)
        * [.lerpColors(color1, color2, alpha)](#Color+lerpColors) ⇒ [<code>Color</code>](#Color)
        * [.lerpHSL(color, alpha)](#Color+lerpHSL) ⇒ [<code>Color</code>](#Color)
        * [.setFromVector3(v)](#Color+setFromVector3) ⇒ [<code>Color</code>](#Color)
        * [.applyMatrix3(m)](#Color+applyMatrix3) ⇒ [<code>Color</code>](#Color)
        * [.equals(c)](#Color+equals) ⇒ <code>boolean</code>
        * [.fromArray(array, [offset])](#Color+fromArray) ⇒ [<code>Color</code>](#Color)
        * [.toArray([array], [offset])](#Color+toArray) ⇒ <code>Array.&lt;number&gt;</code>
        * [.fromBufferAttribute(attribute, index)](#Color+fromBufferAttribute) ⇒ [<code>Color</code>](#Color)
        * [.toJSON()](#Color+toJSON) ⇒ <code>number</code>
    * _static_
        * [.NAMES](#Color.NAMES) : <code>Object</code>

<a name="new_Color_new"></a>

### new Color([r], [g], [b])
Constructs a new color.

Note that standard method of specifying color in three.js is with a hexadecimal triplet,
and that method is used throughout the rest of the documentation.


| Param | Type | Description |
| --- | --- | --- |
| [r] | <code>number</code> \| <code>string</code> \| [<code>Color</code>](#Color) | The red component of the color. If `g` and `b` are not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance. |
| [g] | <code>number</code> | The green component. |
| [b] | <code>number</code> | The blue component. |

<a name="Color+isColor"></a>

### color.isColor : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Color</code>](#Color)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Color+r"></a>

### color.r : <code>number</code>
The red component.

**Kind**: instance property of [<code>Color</code>](#Color)  
**Default**: <code>1</code>  
<a name="Color+g"></a>

### color.g : <code>number</code>
The green component.

**Kind**: instance property of [<code>Color</code>](#Color)  
**Default**: <code>1</code>  
<a name="Color+b"></a>

### color.b : <code>number</code>
The blue component.

**Kind**: instance property of [<code>Color</code>](#Color)  
**Default**: <code>1</code>  
<a name="Color+set"></a>

### color.set([r], [g], [b]) ⇒ [<code>Color</code>](#Color)
Sets the colors's components from the given values.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| [r] | <code>number</code> \| <code>string</code> \| [<code>Color</code>](#Color) | The red component of the color. If `g` and `b` are not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance. |
| [g] | <code>number</code> | The green component. |
| [b] | <code>number</code> | The blue component. |

<a name="Color+setScalar"></a>

### color.setScalar(scalar) ⇒ [<code>Color</code>](#Color)
Sets the colors's components to the given scalar value.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar value. |

<a name="Color+setHex"></a>

### color.setHex(hex, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from a hexadecimal value.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| hex | <code>number</code> |  | The hexadecimal value. |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+setRGB"></a>

### color.setRGB(r, g, b, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from RGB values.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| r | <code>number</code> |  | Red channel value between `0.0` and `1.0`. |
| g | <code>number</code> |  | Green channel value between `0.0` and `1.0`. |
| b | <code>number</code> |  | Blue channel value between `0.0` and `1.0`. |
| [colorSpace] | <code>string</code> | <code>&quot;ColorManagement.workingColorSpace&quot;</code> | The color space. |

<a name="Color+setHSL"></a>

### color.setHSL(h, s, l, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from RGB values.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| h | <code>number</code> |  | Hue value between `0.0` and `1.0`. |
| s | <code>number</code> |  | Saturation value between `0.0` and `1.0`. |
| l | <code>number</code> |  | Lightness value between `0.0` and `1.0`. |
| [colorSpace] | <code>string</code> | <code>&quot;ColorManagement.workingColorSpace&quot;</code> | The color space. |

<a name="Color+setStyle"></a>

### color.setStyle(style, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
`rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) -
all 140 color names are supported).

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| style | <code>string</code> |  | Color as a CSS-style string. |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+setColorName"></a>

### color.setColorName(style, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Sets this color from a color name. Faster than [setStyle](#Color+setStyle) if
you don't need the other CSS-style formats.

For convenience, the list of names is exposed in `Color.NAMES` as a hash.
```js
Color.NAMES.aliceblue // returns 0xF0F8FF
```

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| style | <code>string</code> |  | The color name. |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+clone"></a>

### color.clone() ⇒ [<code>Color</code>](#Color)
Returns a new color with copied values from this instance.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A clone of this instance.  
<a name="Color+copy"></a>

### color.copy(color) ⇒ [<code>Color</code>](#Color)
Copies the values of the given color to this instance.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to copy. |

<a name="Color+copySRGBToLinear"></a>

### color.copySRGBToLinear(color) ⇒ [<code>Color</code>](#Color)
Copies the given color into this color, and then converts this color from
`SRGBColorSpace` to `LinearSRGBColorSpace`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to copy/convert. |

<a name="Color+copyLinearToSRGB"></a>

### color.copyLinearToSRGB(color) ⇒ [<code>Color</code>](#Color)
Copies the given color into this color, and then converts this color from
`LinearSRGBColorSpace` to `SRGBColorSpace`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to copy/convert. |

<a name="Color+convertSRGBToLinear"></a>

### color.convertSRGBToLinear() ⇒ [<code>Color</code>](#Color)
Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  
<a name="Color+convertLinearToSRGB"></a>

### color.convertLinearToSRGB() ⇒ [<code>Color</code>](#Color)
Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  
<a name="Color+getHex"></a>

### color.getHex([colorSpace]) ⇒ <code>number</code>
Returns the hexadecimal value of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>number</code> - The hexadecimal value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+getHexString"></a>

### color.getHexString([colorSpace]) ⇒ <code>string</code>
Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>string</code> - The hexadecimal value as a string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+getHSL"></a>

### color.getHSL(target, [colorSpace]) ⇒ <code>Object</code>
Converts the colors RGB values into the HSL format and stores them into the
given target object.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>Object</code> - The HSL representation of this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| target | <code>Object</code> |  | The target object that is used to store the method's result. |
| [colorSpace] | <code>string</code> | <code>&quot;ColorManagement.workingColorSpace&quot;</code> | The color space. |

<a name="Color+getRGB"></a>

### color.getRGB(target, [colorSpace]) ⇒ [<code>Color</code>](#Color)
Returns the RGB values of this color and stores them into the given target object.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - The RGB representation of this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| target | [<code>Color</code>](#Color) |  | The target color that is used to store the method's result. |
| [colorSpace] | <code>string</code> | <code>&quot;ColorManagement.workingColorSpace&quot;</code> | The color space. |

<a name="Color+getStyle"></a>

### color.getStyle([colorSpace]) ⇒ <code>string</code>
Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>string</code> - The CSS representation of this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [colorSpace] | <code>string</code> | <code>&quot;SRGBColorSpace&quot;</code> | The color space. |

<a name="Color+offsetHSL"></a>

### color.offsetHSL(h, s, l) ⇒ [<code>Color</code>](#Color)
Adds the given HSL values to this color's values.
Internally, this converts the color's RGB values to HSL, adds HSL
and then converts the color back to RGB.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| h | <code>number</code> | Hue value between `0.0` and `1.0`. |
| s | <code>number</code> | Saturation value between `0.0` and `1.0`. |
| l | <code>number</code> | Lightness value between `0.0` and `1.0`. |

<a name="Color+add"></a>

### color.add(color) ⇒ [<code>Color</code>](#Color)
Adds the RGB values of the given color to the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to add. |

<a name="Color+addColors"></a>

### color.addColors(color1, color2) ⇒ [<code>Color</code>](#Color)
Adds the RGB values of the given colors and stores the result in this instance.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color1 | [<code>Color</code>](#Color) | The first color. |
| color2 | [<code>Color</code>](#Color) | The second color. |

<a name="Color+addScalar"></a>

### color.addScalar(s) ⇒ [<code>Color</code>](#Color)
Adds the given scalar value to the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to add. |

<a name="Color+sub"></a>

### color.sub(color) ⇒ [<code>Color</code>](#Color)
Subtracts the RGB values of the given color from the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to subtract. |

<a name="Color+multiply"></a>

### color.multiply(color) ⇒ [<code>Color</code>](#Color)
Multiplies the RGB values of the given color with the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to multiply. |

<a name="Color+multiplyScalar"></a>

### color.multiplyScalar(s) ⇒ [<code>Color</code>](#Color)
Multiplies the given scalar value with the RGB values of this color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to multiply. |

<a name="Color+lerp"></a>

### color.lerp(color, alpha) ⇒ [<code>Color</code>](#Color)
Linearly interpolates this color's RGB values toward the RGB values of the
given color. The alpha argument can be thought of as the ratio between
the two colors, where `0.0` is this color and `1.0` is the first argument.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to converge on. |
| alpha | <code>number</code> | The interpolation factor in the closed interval `[0,1]`. |

<a name="Color+lerpColors"></a>

### color.lerpColors(color1, color2, alpha) ⇒ [<code>Color</code>](#Color)
Linearly interpolates between the given colors and stores the result in this instance.
The alpha argument can be thought of as the ratio between the two colors, where `0.0`
is the first and `1.0` is the second color.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color1 | [<code>Color</code>](#Color) | The first color. |
| color2 | [<code>Color</code>](#Color) | The second color. |
| alpha | <code>number</code> | The interpolation factor in the closed interval `[0,1]`. |

<a name="Color+lerpHSL"></a>

### color.lerpHSL(color, alpha) ⇒ [<code>Color</code>](#Color)
Linearly interpolates this color's HSL values toward the HSL values of the
given color. It differs from [lerp](#Color+lerp) by not interpolating straight
from one color to the other, but instead going through all the hues in between
those two colors. The alpha argument can be thought of as the ratio between
the two colors, where 0.0 is this color and 1.0 is the first argument.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| color | [<code>Color</code>](#Color) | The color to converge on. |
| alpha | <code>number</code> | The interpolation factor in the closed interval `[0,1]`. |

<a name="Color+setFromVector3"></a>

### color.setFromVector3(v) ⇒ [<code>Color</code>](#Color)
Sets the color's RGB components from the given 3D vector.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The vector to set. |

<a name="Color+applyMatrix3"></a>

### color.applyMatrix3(m) ⇒ [<code>Color</code>](#Color)
Transforms this color with the given 3x3 matrix.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix. |

<a name="Color+equals"></a>

### color.equals(c) ⇒ <code>boolean</code>
Returns `true` if this color is equal with the given one.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>boolean</code> - Whether this bounding color is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| c | [<code>Color</code>](#Color) | The color to test for equality. |

<a name="Color+fromArray"></a>

### color.fromArray(array, [offset]) ⇒ [<code>Color</code>](#Color)
Sets this color's RGB components from the given array.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the RGB values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Color+toArray"></a>

### color.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the RGB components of this color to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>Array.&lt;number&gt;</code> - The color components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the color components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Color+fromBufferAttribute"></a>

### color.fromBufferAttribute(attribute, index) ⇒ [<code>Color</code>](#Color)
Sets the components of this color from the given buffer attribute.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: [<code>Color</code>](#Color) - A reference to this color.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding color data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Color+toJSON"></a>

### color.toJSON() ⇒ <code>number</code>
This methods defines the serialization result of this class. Returns the color
as a hexadecimal value.

**Kind**: instance method of [<code>Color</code>](#Color)  
**Returns**: <code>number</code> - The hexadecimal value.  
<a name="Color.NAMES"></a>

### Color.NAMES : <code>Object</code>
A dictionary with X11 color names.

Note that multiple words such as Dark Orange become the string 'darkorange'.

**Kind**: static property of [<code>Color</code>](#Color)  
<a name="Cylindrical"></a>

## Cylindrical
This class can be used to represent points in 3D space as
[Cylindrical coordinates](https://en.wikipedia.org/wiki/Cylindrical_coordinate_system).

**Kind**: global class  

* [Cylindrical](#Cylindrical)
    * [new Cylindrical([radius], [theta], [y])](#new_Cylindrical_new)
    * [.radius](#Cylindrical+radius) : <code>number</code>
    * [.theta](#Cylindrical+theta) : <code>number</code>
    * [.y](#Cylindrical+y) : <code>number</code>
    * [.set(radius, theta, y)](#Cylindrical+set) ⇒ [<code>Cylindrical</code>](#Cylindrical)
    * [.copy(other)](#Cylindrical+copy) ⇒ [<code>Cylindrical</code>](#Cylindrical)
    * [.setFromVector3(v)](#Cylindrical+setFromVector3) ⇒ [<code>Cylindrical</code>](#Cylindrical)
    * [.setFromCartesianCoords(x, y, z)](#Cylindrical+setFromCartesianCoords) ⇒ [<code>Cylindrical</code>](#Cylindrical)
    * [.clone()](#Cylindrical+clone) ⇒ [<code>Cylindrical</code>](#Cylindrical)

<a name="new_Cylindrical_new"></a>

### new Cylindrical([radius], [theta], [y])
Constructs a new cylindrical.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | The distance from the origin to a point in the x-z plane. |
| [theta] | <code>number</code> | <code>0</code> | A counterclockwise angle in the x-z plane measured in radians from the positive z-axis. |
| [y] | <code>number</code> | <code>0</code> | The height above the x-z plane. |

<a name="Cylindrical+radius"></a>

### cylindrical.radius : <code>number</code>
The distance from the origin to a point in the x-z plane.

**Kind**: instance property of [<code>Cylindrical</code>](#Cylindrical)  
**Default**: <code>1</code>  
<a name="Cylindrical+theta"></a>

### cylindrical.theta : <code>number</code>
A counterclockwise angle in the x-z plane measured in radians from the positive z-axis.

**Kind**: instance property of [<code>Cylindrical</code>](#Cylindrical)  
**Default**: <code>0</code>  
<a name="Cylindrical+y"></a>

### cylindrical.y : <code>number</code>
The height above the x-z plane.

**Kind**: instance property of [<code>Cylindrical</code>](#Cylindrical)  
**Default**: <code>0</code>  
<a name="Cylindrical+set"></a>

### cylindrical.set(radius, theta, y) ⇒ [<code>Cylindrical</code>](#Cylindrical)
Sets the cylindrical components by copying the given values.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A reference to this cylindrical.  

| Param | Type | Description |
| --- | --- | --- |
| radius | <code>number</code> | The radius. |
| theta | <code>number</code> | The theta angle. |
| y | <code>number</code> | The height value. |

<a name="Cylindrical+copy"></a>

### cylindrical.copy(other) ⇒ [<code>Cylindrical</code>](#Cylindrical)
Copies the values of the given cylindrical to this instance.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A reference to this cylindrical.  

| Param | Type | Description |
| --- | --- | --- |
| other | [<code>Cylindrical</code>](#Cylindrical) | The cylindrical to copy. |

<a name="Cylindrical+setFromVector3"></a>

### cylindrical.setFromVector3(v) ⇒ [<code>Cylindrical</code>](#Cylindrical)
Sets the cylindrical components from the given vector which is assumed to hold
Cartesian coordinates.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A reference to this cylindrical.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The vector to set. |

<a name="Cylindrical+setFromCartesianCoords"></a>

### cylindrical.setFromCartesianCoords(x, y, z) ⇒ [<code>Cylindrical</code>](#Cylindrical)
Sets the cylindrical components from the given Cartesian coordinates.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A reference to this cylindrical.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value. |
| y | <code>number</code> | The x value. |
| z | <code>number</code> | The x value. |

<a name="Cylindrical+clone"></a>

### cylindrical.clone() ⇒ [<code>Cylindrical</code>](#Cylindrical)
Returns a new cylindrical with copied values from this instance.

**Kind**: instance method of [<code>Cylindrical</code>](#Cylindrical)  
**Returns**: [<code>Cylindrical</code>](#Cylindrical) - A clone of this instance.  
<a name="Euler"></a>

## Euler
A class representing Euler angles.

Euler angles describe a rotational transformation by rotating an object on
its various axes in specified amounts per axis, and a specified axis
order.

Iterating through an instance will yield its components (x, y, z,
order) in the corresponding order.

```js
const a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
const b = new THREE.Vector3( 1, 0, 1 );
b.applyEuler(a);
```

**Kind**: global class  

* [Euler](#Euler)
    * [new Euler([x], [y], [z], [order])](#new_Euler_new)
    * _instance_
        * [.isEuler](#Euler+isEuler) : <code>boolean</code>
        * [.x](#Euler+x) : <code>number</code>
        * [.y](#Euler+y) : <code>number</code>
        * [.z](#Euler+z) : <code>number</code>
        * [.order](#Euler+order) : <code>string</code>
        * [.set(x, y, z, [order])](#Euler+set) ⇒ [<code>Euler</code>](#Euler)
        * [.clone()](#Euler+clone) ⇒ [<code>Euler</code>](#Euler)
        * [.copy(euler)](#Euler+copy) ⇒ [<code>Euler</code>](#Euler)
        * [.setFromRotationMatrix(m, [order], [update])](#Euler+setFromRotationMatrix) ⇒ [<code>Euler</code>](#Euler)
        * [.setFromQuaternion(q, [order], [update])](#Euler+setFromQuaternion) ⇒ [<code>Euler</code>](#Euler)
        * [.setFromVector3(v, [order])](#Euler+setFromVector3) ⇒ [<code>Euler</code>](#Euler)
        * [.reorder([newOrder])](#Euler+reorder) ⇒ [<code>Euler</code>](#Euler)
        * [.equals(euler)](#Euler+equals) ⇒ <code>boolean</code>
        * [.fromArray(array)](#Euler+fromArray) ⇒ [<code>Euler</code>](#Euler)
        * [.toArray([array], [offset])](#Euler+toArray) ⇒ <code>Array.&lt;number, number, number, string&gt;</code>
    * _static_
        * [.DEFAULT_ORDER](#Euler.DEFAULT_ORDER) : <code>string</code>

<a name="new_Euler_new"></a>

### new Euler([x], [y], [z], [order])
Constructs a new euler instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The angle of the x axis in radians. |
| [y] | <code>number</code> | <code>0</code> | The angle of the y axis in radians. |
| [z] | <code>number</code> | <code>0</code> | The angle of the z axis in radians. |
| [order] | <code>string</code> | <code>&quot;Euler.DEFAULT_ORDER&quot;</code> | A string representing the order that the rotations are applied. |

<a name="Euler+isEuler"></a>

### euler.isEuler : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Euler+x"></a>

### euler.x : <code>number</code>
The angle of the x axis in radians.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>0</code>  
<a name="Euler+y"></a>

### euler.y : <code>number</code>
The angle of the y axis in radians.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>0</code>  
<a name="Euler+z"></a>

### euler.z : <code>number</code>
The angle of the z axis in radians.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>0</code>  
<a name="Euler+order"></a>

### euler.order : <code>string</code>
A string representing the order that the rotations are applied.

**Kind**: instance property of [<code>Euler</code>](#Euler)  
**Default**: <code>&quot;&#x27;XYZ&#x27;&quot;</code>  
<a name="Euler+set"></a>

### euler.set(x, y, z, [order]) ⇒ [<code>Euler</code>](#Euler)
Sets the Euler components.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The angle of the x axis in radians. |
| y | <code>number</code> | The angle of the y axis in radians. |
| z | <code>number</code> | The angle of the z axis in radians. |
| [order] | <code>string</code> | A string representing the order that the rotations are applied. |

<a name="Euler+clone"></a>

### euler.clone() ⇒ [<code>Euler</code>](#Euler)
Returns a new Euler instance with copied values from this instance.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A clone of this instance.  
<a name="Euler+copy"></a>

### euler.copy(euler) ⇒ [<code>Euler</code>](#Euler)
Copies the values of the given Euler instance to this instance.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| euler | [<code>Euler</code>](#Euler) | The Euler instance to copy. |

<a name="Euler+setFromRotationMatrix"></a>

### euler.setFromRotationMatrix(m, [order], [update]) ⇒ [<code>Euler</code>](#Euler)
Sets the angles of this Euler instance from a pure rotation matrix.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| m | <code>Matrix4</code> |  | A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled). |
| [order] | <code>string</code> |  | A string representing the order that the rotations are applied. |
| [update] | <code>boolean</code> | <code>true</code> | Whether the internal `onChange` callback should be executed or not. |

<a name="Euler+setFromQuaternion"></a>

### euler.setFromQuaternion(q, [order], [update]) ⇒ [<code>Euler</code>](#Euler)
Sets the angles of this Euler instance from a normalized quaternion.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| q | <code>Quaternion</code> |  | A normalized Quaternion. |
| [order] | <code>string</code> |  | A string representing the order that the rotations are applied. |
| [update] | <code>boolean</code> | <code>true</code> | Whether the internal `onChange` callback should be executed or not. |

<a name="Euler+setFromVector3"></a>

### euler.setFromVector3(v, [order]) ⇒ [<code>Euler</code>](#Euler)
Sets the angles of this Euler instance from the given vector.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The vector. |
| [order] | <code>string</code> | A string representing the order that the rotations are applied. |

<a name="Euler+reorder"></a>

### euler.reorder([newOrder]) ⇒ [<code>Euler</code>](#Euler)
Resets the euler angle with a new order by creating a quaternion from this
euler angle and then setting this euler angle with the quaternion and the
new order.

Warning: This discards revolution information.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| [newOrder] | <code>string</code> | A string representing the new order that the rotations are applied. |

<a name="Euler+equals"></a>

### euler.equals(euler) ⇒ <code>boolean</code>
Returns `true` if this Euler instance is equal with the given one.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: <code>boolean</code> - Whether this Euler instance is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| euler | [<code>Euler</code>](#Euler) | The Euler instance to test for equality. |

<a name="Euler+fromArray"></a>

### euler.fromArray(array) ⇒ [<code>Euler</code>](#Euler)
Sets this Euler instance's components to values from the given array. The first three
entries of the array are assign to the x,y and z components. An optional fourth entry
defines the Euler order.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: [<code>Euler</code>](#Euler) - A reference to this Euler instance.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array.&lt;number, number, number, ?string&gt;</code> | An array holding the Euler component values. |

<a name="Euler+toArray"></a>

### euler.toArray([array], [offset]) ⇒ <code>Array.&lt;number, number, number, string&gt;</code>
Writes the components of this Euler instance to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Euler</code>](#Euler)  
**Returns**: <code>Array.&lt;number, number, number, string&gt;</code> - The Euler components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number, number, number, string&gt;</code> | <code>[]</code> | The target array holding the Euler components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Euler.DEFAULT_ORDER"></a>

### Euler.DEFAULT\_ORDER : <code>string</code>
The default Euler angle order.

**Kind**: static property of [<code>Euler</code>](#Euler)  
**Default**: <code>&quot;&#x27;XYZ&#x27;&quot;</code>  
<a name="Frustum"></a>

## Frustum
Frustums are used to determine what is inside the camera's field of view.
They help speed up the rendering process - objects which lie outside a camera's
frustum can safely be excluded from rendering.

This class is mainly intended for use internally by a renderer.

**Kind**: global class  

* [Frustum](#Frustum)
    * [new Frustum([p0], [p1], [p2], [p3], [p4], [p5])](#new_Frustum_new)
    * [.planes](#Frustum+planes) : <code>Array.&lt;Plane&gt;</code>
    * [.set([p0], [p1], [p2], [p3], [p4], [p5])](#Frustum+set) ⇒ [<code>Frustum</code>](#Frustum)
    * [.copy(frustum)](#Frustum+copy) ⇒ [<code>Frustum</code>](#Frustum)
    * [.setFromProjectionMatrix(m, coordinateSystem)](#Frustum+setFromProjectionMatrix) ⇒ [<code>Frustum</code>](#Frustum)
    * [.intersectsObject(object)](#Frustum+intersectsObject) ⇒ <code>boolean</code>
    * [.intersectsSprite(sprite)](#Frustum+intersectsSprite) ⇒ <code>boolean</code>
    * [.intersectsSphere(sphere)](#Frustum+intersectsSphere) ⇒ <code>boolean</code>
    * [.intersectsBox(box)](#Frustum+intersectsBox) ⇒ <code>boolean</code>
    * [.containsPoint(point)](#Frustum+containsPoint) ⇒ <code>boolean</code>
    * [.clone()](#Frustum+clone) ⇒ [<code>Frustum</code>](#Frustum)

<a name="new_Frustum_new"></a>

### new Frustum([p0], [p1], [p2], [p3], [p4], [p5])
Constructs a new frustum.


| Param | Type | Description |
| --- | --- | --- |
| [p0] | <code>Plane</code> | The first plane that encloses the frustum. |
| [p1] | <code>Plane</code> | The second plane that encloses the frustum. |
| [p2] | <code>Plane</code> | The third plane that encloses the frustum. |
| [p3] | <code>Plane</code> | The fourth plane that encloses the frustum. |
| [p4] | <code>Plane</code> | The fifth plane that encloses the frustum. |
| [p5] | <code>Plane</code> | The sixth plane that encloses the frustum. |

<a name="Frustum+planes"></a>

### frustum.planes : <code>Array.&lt;Plane&gt;</code>
This array holds the planes that enclose the frustum.

**Kind**: instance property of [<code>Frustum</code>](#Frustum)  
<a name="Frustum+set"></a>

### frustum.set([p0], [p1], [p2], [p3], [p4], [p5]) ⇒ [<code>Frustum</code>](#Frustum)
Sets the frustum planes by copying the given planes.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: [<code>Frustum</code>](#Frustum) - A reference to this frustum.  

| Param | Type | Description |
| --- | --- | --- |
| [p0] | <code>Plane</code> | The first plane that encloses the frustum. |
| [p1] | <code>Plane</code> | The second plane that encloses the frustum. |
| [p2] | <code>Plane</code> | The third plane that encloses the frustum. |
| [p3] | <code>Plane</code> | The fourth plane that encloses the frustum. |
| [p4] | <code>Plane</code> | The fifth plane that encloses the frustum. |
| [p5] | <code>Plane</code> | The sixth plane that encloses the frustum. |

<a name="Frustum+copy"></a>

### frustum.copy(frustum) ⇒ [<code>Frustum</code>](#Frustum)
Copies the values of the given frustum to this instance.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: [<code>Frustum</code>](#Frustum) - A reference to this frustum.  

| Param | Type | Description |
| --- | --- | --- |
| frustum | [<code>Frustum</code>](#Frustum) | The frustum to copy. |

<a name="Frustum+setFromProjectionMatrix"></a>

### frustum.setFromProjectionMatrix(m, coordinateSystem) ⇒ [<code>Frustum</code>](#Frustum)
Sets the frustum planes from the given projection matrix.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: [<code>Frustum</code>](#Frustum) - A reference to this frustum.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The projection matrix. |
| coordinateSystem | <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code> | The coordinate system. |

<a name="Frustum+intersectsObject"></a>

### frustum.intersectsObject(object) ⇒ <code>boolean</code>
Returns `true` if the 3D object's bounding sphere is intersecting this frustum.

Note that the 3D object must have a geometry so that the bounding sphere can be calculated.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the 3D object's bounding sphere is intersecting this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to test. |

<a name="Frustum+intersectsSprite"></a>

### frustum.intersectsSprite(sprite) ⇒ <code>boolean</code>
Returns `true` if the given sprite is intersecting this frustum.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the sprite is intersecting this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| sprite | <code>Sprite</code> | The sprite to test. |

<a name="Frustum+intersectsSphere"></a>

### frustum.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if the given bounding sphere is intersecting this frustum.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the bounding sphere is intersecting this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="Frustum+intersectsBox"></a>

### frustum.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box is intersecting this frustum.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the bounding box is intersecting this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The bounding box to test. |

<a name="Frustum+containsPoint"></a>

### frustum.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies within the frustum.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: <code>boolean</code> - Whether the point lies within this frustum or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to test. |

<a name="Frustum+clone"></a>

### frustum.clone() ⇒ [<code>Frustum</code>](#Frustum)
Returns a new frustum with copied values from this instance.

**Kind**: instance method of [<code>Frustum</code>](#Frustum)  
**Returns**: [<code>Frustum</code>](#Frustum) - A clone of this instance.  
<a name="Interpolant"></a>

## *Interpolant*
Abstract base class of interpolants over parametric samples.

The parameter domain is one dimensional, typically the time or a path
along a curve defined by the data.

The sample values can have any dimensionality and derived classes may
apply special interpretations to the data.

This class provides the interval seek in a Template Method, deferring
the actual interpolation to derived classes.

Time complexity is O(1) for linear access crossing at most two points
and O(log N) for random access, where N is the number of positions.

References: [http://www.oodesign.com/template-method-pattern.html](http://www.oodesign.com/template-method-pattern.html)

**Kind**: global abstract class  

* *[Interpolant](#Interpolant)*
    * *[new Interpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])](#new_Interpolant_new)*
    * *[.parameterPositions](#Interpolant+parameterPositions) : <code>TypedArray</code>*
    * *[.resultBuffer](#Interpolant+resultBuffer) : <code>TypedArray</code>*
    * *[.sampleValues](#Interpolant+sampleValues) : <code>TypedArray</code>*
    * *[.valueSize](#Interpolant+valueSize) : <code>TypedArray</code>*
    * *[.settings](#Interpolant+settings) : <code>Object</code>*
    * *[.DefaultSettings_](#Interpolant+DefaultSettings_) : <code>Object</code>*
    * *[.evaluate(t)](#Interpolant+evaluate) ⇒ <code>TypedArray</code>*
    * *[.getSettings_()](#Interpolant+getSettings_) ⇒ <code>Object</code>*
    * *[.copySampleValue_(index)](#Interpolant+copySampleValue_) ⇒ <code>TypedArray</code>*
    * **[.interpolate_(i1, t0, t, t1)](#Interpolant+interpolate_) ⇒ <code>TypedArray</code>**
    * *[.intervalChanged_(i1, t0, t)](#Interpolant+intervalChanged_)*

<a name="new_Interpolant_new"></a>

### *new Interpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])*
Constructs a new interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

<a name="Interpolant+parameterPositions"></a>

### *interpolant.parameterPositions : <code>TypedArray</code>*
The parameter positions.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+resultBuffer"></a>

### *interpolant.resultBuffer : <code>TypedArray</code>*
The result buffer.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+sampleValues"></a>

### *interpolant.sampleValues : <code>TypedArray</code>*
The sample values.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+valueSize"></a>

### *interpolant.valueSize : <code>TypedArray</code>*
The value size.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+settings"></a>

### *interpolant.settings : <code>Object</code>*
The interpolation settings.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
**Default**: <code>null</code>  
<a name="Interpolant+DefaultSettings_"></a>

### *interpolant.DefaultSettings\_ : <code>Object</code>*
The default settings object.

**Kind**: instance property of [<code>Interpolant</code>](#Interpolant)  
<a name="Interpolant+evaluate"></a>

### *interpolant.evaluate(t) ⇒ <code>TypedArray</code>*
Evaluate the interpolant at position `t`.

**Kind**: instance method of [<code>Interpolant</code>](#Interpolant)  
**Returns**: <code>TypedArray</code> - The result buffer.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The interpolation factor. |

<a name="Interpolant+getSettings_"></a>

### *interpolant.getSettings\_() ⇒ <code>Object</code>*
Returns the interpolation settings.

**Kind**: instance method of [<code>Interpolant</code>](#Interpolant)  
**Returns**: <code>Object</code> - The interpolation settings.  
<a name="Interpolant+copySampleValue_"></a>

### *interpolant.copySampleValue\_(index) ⇒ <code>TypedArray</code>*
Copies a sample value to the result buffer.

**Kind**: instance method of [<code>Interpolant</code>](#Interpolant)  
**Returns**: <code>TypedArray</code> - The result buffer.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | An index into the sample value buffer. |

<a name="Interpolant+interpolate_"></a>

### **interpolant.interpolate\_(i1, t0, t, t1) ⇒ <code>TypedArray</code>**
Copies a sample value to the result buffer.

**Kind**: instance abstract method of [<code>Interpolant</code>](#Interpolant)  
**Returns**: <code>TypedArray</code> - The result buffer.  

| Param | Type | Description |
| --- | --- | --- |
| i1 | <code>number</code> | An index into the sample value buffer. |
| t0 | <code>number</code> | The previous interpolation factor. |
| t | <code>number</code> | The current interpolation factor. |
| t1 | <code>number</code> | The next interpolation factor. |

<a name="Interpolant+intervalChanged_"></a>

### *interpolant.intervalChanged\_(i1, t0, t)*
Optional method that is executed when the interval has changed.

**Kind**: instance method of [<code>Interpolant</code>](#Interpolant)  

| Param | Type | Description |
| --- | --- | --- |
| i1 | <code>number</code> | An index into the sample value buffer. |
| t0 | <code>number</code> | The previous interpolation factor. |
| t | <code>number</code> | The current interpolation factor. |

<a name="Line3"></a>

## Line3
An analytical line segment in 3D space represented by a start and end point.

**Kind**: global class  

* [Line3](#Line3)
    * [new Line3([start], [end])](#new_Line3_new)
    * [.start](#Line3+start) : <code>Vector3</code>
    * [.end](#Line3+end) : <code>Vector3</code>
    * [.set(start, end)](#Line3+set) ⇒ [<code>Line3</code>](#Line3)
    * [.copy(line)](#Line3+copy) ⇒ [<code>Line3</code>](#Line3)
    * [.getCenter(target)](#Line3+getCenter) ⇒ <code>Vector3</code>
    * [.delta(target)](#Line3+delta) ⇒ <code>Vector3</code>
    * [.distanceSq()](#Line3+distanceSq) ⇒ <code>number</code>
    * [.distance()](#Line3+distance) ⇒ <code>number</code>
    * [.at(t, target)](#Line3+at) ⇒ <code>Vector3</code>
    * [.closestPointToPointParameter(point, clampToLine)](#Line3+closestPointToPointParameter) ⇒ <code>number</code>
    * [.closestPointToPoint(point, clampToLine, target)](#Line3+closestPointToPoint) ⇒ <code>Vector3</code>
    * [.applyMatrix4(matrix)](#Line3+applyMatrix4) ⇒ [<code>Line3</code>](#Line3)
    * [.equals(line)](#Line3+equals) ⇒ <code>boolean</code>
    * [.clone()](#Line3+clone) ⇒ [<code>Line3</code>](#Line3)

<a name="new_Line3_new"></a>

### new Line3([start], [end])
Constructs a new line segment.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [start] | <code>Vector3</code> | <code>(0,0,0)</code> | Start of the line segment. |
| [end] | <code>Vector3</code> | <code>(0,0,0)</code> | End of the line segment. |

<a name="Line3+start"></a>

### line3.start : <code>Vector3</code>
Start of the line segment.

**Kind**: instance property of [<code>Line3</code>](#Line3)  
<a name="Line3+end"></a>

### line3.end : <code>Vector3</code>
End of the line segment.

**Kind**: instance property of [<code>Line3</code>](#Line3)  
<a name="Line3+set"></a>

### line3.set(start, end) ⇒ [<code>Line3</code>](#Line3)
Sets the start and end values by copying the given vectors.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: [<code>Line3</code>](#Line3) - A reference to this line segment.  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>Vector3</code> | The start point. |
| end | <code>Vector3</code> | The end point. |

<a name="Line3+copy"></a>

### line3.copy(line) ⇒ [<code>Line3</code>](#Line3)
Copies the values of the given line segment to this instance.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: [<code>Line3</code>](#Line3) - A reference to this line segment.  

| Param | Type | Description |
| --- | --- | --- |
| line | [<code>Line3</code>](#Line3) | The line segment to copy. |

<a name="Line3+getCenter"></a>

### line3.getCenter(target) ⇒ <code>Vector3</code>
Returns the center of the line segment.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>Vector3</code> - The center point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Line3+delta"></a>

### line3.delta(target) ⇒ <code>Vector3</code>
Returns the delta vector of the line segment's start and end point.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>Vector3</code> - The delta vector.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Line3+distanceSq"></a>

### line3.distanceSq() ⇒ <code>number</code>
Returns the squared Euclidean distance between the line' start and end point.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>number</code> - The squared Euclidean distance.  
<a name="Line3+distance"></a>

### line3.distance() ⇒ <code>number</code>
Returns the Euclidean distance between the line' start and end point.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>number</code> - The Euclidean distance.  
<a name="Line3+at"></a>

### line3.at(t, target) ⇒ <code>Vector3</code>
Returns a vector at a certain position along the line segment.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>Vector3</code> - The delta vector.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | A value between `[0,1]` to represent a position along the line segment. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Line3+closestPointToPointParameter"></a>

### line3.closestPointToPointParameter(point, clampToLine) ⇒ <code>number</code>
Returns a point parameter based on the closest point as projected on the line segment.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>number</code> - The point parameter.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point for which to return a point parameter. |
| clampToLine | <code>boolean</code> | Whether to clamp the result to the range `[0,1]` or not. |

<a name="Line3+closestPointToPoint"></a>

### line3.closestPointToPoint(point, clampToLine, target) ⇒ <code>Vector3</code>
Returns the closets point on the line for a given point.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>Vector3</code> - The closest point on the line.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to compute the closest point on the line for. |
| clampToLine | <code>boolean</code> | Whether to clamp the result to the range `[0,1]` or not. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Line3+applyMatrix4"></a>

### line3.applyMatrix4(matrix) ⇒ [<code>Line3</code>](#Line3)
Applies a 4x4 transformation matrix to this line segment.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: [<code>Line3</code>](#Line3) - A reference to this line segment.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The transformation matrix. |

<a name="Line3+equals"></a>

### line3.equals(line) ⇒ <code>boolean</code>
Returns `true` if this line segment is equal with the given one.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: <code>boolean</code> - Whether this line segment is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| line | [<code>Line3</code>](#Line3) | The line segment to test for equality. |

<a name="Line3+clone"></a>

### line3.clone() ⇒ [<code>Line3</code>](#Line3)
Returns a new line segment with copied values from this instance.

**Kind**: instance method of [<code>Line3</code>](#Line3)  
**Returns**: [<code>Line3</code>](#Line3) - A clone of this instance.  
## Classes

<dl>
<dt><a href="#MathUtils">MathUtils</a></dt>
<dd><p>A collection of math utility functions.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#generateUUID">generateUUID()</a> ⇒ <code>string</code></dt>
<dd><p>Generate a <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>
(universally unique identifier).</p>
</dd>
<dt><a href="#clamp">clamp(value, min, max)</a> ⇒ <code>number</code></dt>
<dd><p>Clamps the given value between min and max.</p>
</dd>
<dt><a href="#euclideanModulo">euclideanModulo(n, m)</a> ⇒ <code>number</code></dt>
<dd><p>Computes the Euclidean modulo of the given parameters that
is <code>( ( n % m ) + m ) % m</code>.</p>
</dd>
<dt><a href="#mapLinear">mapLinear(x, a1, a2, b1, b2)</a> ⇒ <code>number</code></dt>
<dd><p>Performs a linear mapping from range <code>&lt;a1, a2&gt;</code> to range <code>&lt;b1, b2&gt;</code>
for the given value.</p>
</dd>
<dt><a href="#inverseLerp">inverseLerp(x, y, value)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the percentage in the closed interval <code>[0, 1]</code> of the given value
between the start and end point.</p>
</dd>
<dt><a href="#lerp">lerp(x, y, t)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a value linearly interpolated from two known points based on the given interval -
<code>t = 0</code> will return <code>x</code> and <code>t = 1</code> will return <code>y</code>.</p>
</dd>
<dt><a href="#damp">damp(x, y, lambda, dt)</a> ⇒ <code>number</code></dt>
<dd><p>Smoothly interpolate a number from <code>x</code> to <code>y</code> in  a spring-like manner using a delta
time to maintain frame rate independent movement. For details, see
<a href="http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/">Frame rate independent damping using lerp</a>.</p>
</dd>
<dt><a href="#pingpong">pingpong(x, [length])</a> ⇒ <code>number</code></dt>
<dd><p>Returns a value that alternates between <code>0</code> and the given <code>length</code> parameter.</p>
</dd>
<dt><a href="#smoothstep">smoothstep(x, min, max)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a value in the range <code>[0,1]</code> that represents the percentage that <code>x</code> has
moved between <code>min</code> and <code>max</code>, but smoothed or slowed down the closer <code>x</code> is to
the <code>min</code> and <code>max</code>.</p>
<p>See <a href="http://en.wikipedia.org/wiki/Smoothstep">Smoothstep</a> for more details.</p>
</dd>
<dt><a href="#smootherstep">smootherstep(x, min, max)</a> ⇒ <code>number</code></dt>
<dd><p>A <a href="https://en.wikipedia.org/wiki/Smoothstep#Variations">variation on smoothstep</a>
that has zero 1st and 2nd order derivatives at x=0 and x=1.</p>
</dd>
<dt><a href="#randInt">randInt(low, high)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a random integer from <code>&lt;low, high&gt;</code> interval.</p>
</dd>
<dt><a href="#randFloat">randFloat(low, high)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a random float from <code>&lt;low, high&gt;</code> interval.</p>
</dd>
<dt><a href="#randFloatSpread">randFloatSpread(range)</a> ⇒ <code>number</code></dt>
<dd><p>Returns a random integer from <code>&lt;-range/2, range/2&gt;</code> interval.</p>
</dd>
<dt><a href="#seededRandom">seededRandom([s])</a> ⇒ <code>number</code></dt>
<dd><p>Returns a deterministic pseudo-random float in the interval <code>[0, 1]</code>.</p>
</dd>
<dt><a href="#degToRad">degToRad(degrees)</a> ⇒ <code>number</code></dt>
<dd><p>Converts degrees to radians.</p>
</dd>
<dt><a href="#radToDeg">radToDeg(radians)</a> ⇒ <code>number</code></dt>
<dd><p>Converts radians to degrees.</p>
</dd>
<dt><a href="#isPowerOfTwo">isPowerOfTwo(value)</a> ⇒ <code>boolean</code></dt>
<dd><p>Returns <code>true</code> if the given number is a power of two.</p>
</dd>
<dt><a href="#ceilPowerOfTwo">ceilPowerOfTwo(value)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the smallest power of two that is greater than or equal to the given number.</p>
</dd>
<dt><a href="#floorPowerOfTwo">floorPowerOfTwo(value)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the largest power of two that is less than or equal to the given number.</p>
</dd>
<dt><a href="#setQuaternionFromProperEuler">setQuaternionFromProperEuler(q, a, b, c, order)</a></dt>
<dd><p>Sets the given quaternion from the <a href="https://en.wikipedia.org/wiki/Euler_angles">Intrinsic Proper Euler Angles</a>
defined by the given angles and order.</p>
<p>Rotations are applied to the axes in the order specified by order:
rotation by angle <code>a</code> is applied first, then by angle <code>b</code>, then by angle <code>c</code>.</p>
</dd>
<dt><a href="#denormalize">denormalize(value, array)</a> ⇒ <code>number</code></dt>
<dd><p>Denormalizes the given value according to the given typed array.</p>
</dd>
<dt><a href="#normalize">normalize(value, array)</a> ⇒ <code>number</code></dt>
<dd><p>Normalizes the given value according to the given typed array.</p>
</dd>
</dl>

<a name="MathUtils"></a>

## MathUtils
A collection of math utility functions.

**Kind**: global class  

* [MathUtils](#MathUtils)
    * [.generateUUID()](#MathUtils.generateUUID) ⇒ <code>string</code>
    * [.clamp(value, min, max)](#MathUtils.clamp) ⇒ <code>number</code>
    * [.euclideanModulo(n, m)](#MathUtils.euclideanModulo) ⇒ <code>number</code>
    * [.mapLinear(x, a1, a2, b1, b2)](#MathUtils.mapLinear) ⇒ <code>number</code>
    * [.inverseLerp(x, y, value)](#MathUtils.inverseLerp) ⇒ <code>number</code>
    * [.lerp(x, y, t)](#MathUtils.lerp) ⇒ <code>number</code>
    * [.damp(x, y, lambda, dt)](#MathUtils.damp) ⇒ <code>number</code>
    * [.pingpong(x, [length])](#MathUtils.pingpong) ⇒ <code>number</code>
    * [.smoothstep(x, min, max)](#MathUtils.smoothstep) ⇒ <code>number</code>
    * [.smootherstep(x, min, max)](#MathUtils.smootherstep) ⇒ <code>number</code>
    * [.randInt(low, high)](#MathUtils.randInt) ⇒ <code>number</code>
    * [.randFloat(low, high)](#MathUtils.randFloat) ⇒ <code>number</code>
    * [.randFloatSpread(range)](#MathUtils.randFloatSpread) ⇒ <code>number</code>
    * [.seededRandom([s])](#MathUtils.seededRandom) ⇒ <code>number</code>
    * [.degToRad(degrees)](#MathUtils.degToRad) ⇒ <code>number</code>
    * [.radToDeg(radians)](#MathUtils.radToDeg) ⇒ <code>number</code>
    * [.isPowerOfTwo(value)](#MathUtils.isPowerOfTwo) ⇒ <code>boolean</code>
    * [.ceilPowerOfTwo(value)](#MathUtils.ceilPowerOfTwo) ⇒ <code>number</code>
    * [.floorPowerOfTwo(value)](#MathUtils.floorPowerOfTwo) ⇒ <code>number</code>
    * [.setQuaternionFromProperEuler(q, a, b, c, order)](#MathUtils.setQuaternionFromProperEuler)
    * [.normalize(value, array)](#MathUtils.normalize) ⇒ <code>number</code>
    * [.denormalize(value, array)](#MathUtils.denormalize) ⇒ <code>number</code>

<a name="MathUtils.generateUUID"></a>

### MathUtils.generateUUID() ⇒ <code>string</code>
Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
(universally unique identifier).

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>string</code> - The UUID.  
<a name="MathUtils.clamp"></a>

### MathUtils.clamp(value, min, max) ⇒ <code>number</code>
Clamps the given value between min and max.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The clamped value.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to clamp. |
| min | <code>number</code> | The min value. |
| max | <code>number</code> | The max value. |

<a name="MathUtils.euclideanModulo"></a>

### MathUtils.euclideanModulo(n, m) ⇒ <code>number</code>
Computes the Euclidean modulo of the given parameters that
is `( ( n % m ) + m ) % m`.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The Euclidean modulo.  

| Param | Type | Description |
| --- | --- | --- |
| n | <code>number</code> | The first parameter. |
| m | <code>number</code> | The second parameter. |

<a name="MathUtils.mapLinear"></a>

### MathUtils.mapLinear(x, a1, a2, b1, b2) ⇒ <code>number</code>
Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
for the given value.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The mapped value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to be mapped. |
| a1 | <code>number</code> | Minimum value for range A. |
| a2 | <code>number</code> | Maximum value for range A. |
| b1 | <code>number</code> | Minimum value for range B. |
| b2 | <code>number</code> | Maximum value for range B. |

<a name="MathUtils.inverseLerp"></a>

### MathUtils.inverseLerp(x, y, value) ⇒ <code>number</code>
Returns the percentage in the closed interval `[0, 1]` of the given value
between the start and end point.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The interpolation factor.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The start point |
| y | <code>number</code> | The end point. |
| value | <code>number</code> | A value between start and end. |

<a name="MathUtils.lerp"></a>

### MathUtils.lerp(x, y, t) ⇒ <code>number</code>
Returns a value linearly interpolated from two known points based on the given interval -
`t = 0` will return `x` and `t = 1` will return `y`.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The start point |
| y | <code>number</code> | The end point. |
| t | <code>number</code> | The interpolation factor in the closed interval `[0, 1]`. |

<a name="MathUtils.damp"></a>

### MathUtils.damp(x, y, lambda, dt) ⇒ <code>number</code>
Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
time to maintain frame rate independent movement. For details, see
[Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The current point. |
| y | <code>number</code> | The target point. |
| lambda | <code>number</code> | A higher lambda value will make the movement more sudden, and a lower value will make the movement more gradual. |
| dt | <code>number</code> | Delta time in seconds. |

<a name="MathUtils.pingpong"></a>

### MathUtils.pingpong(x, [length]) ⇒ <code>number</code>
Returns a value that alternates between `0` and the given `length` parameter.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| x | <code>number</code> |  | The value to pingpong. |
| [length] | <code>number</code> | <code>1</code> | The positive value the function will pingpong to. |

<a name="MathUtils.smoothstep"></a>

### MathUtils.smoothstep(x, min, max) ⇒ <code>number</code>
Returns a value in the range `[0,1]` that represents the percentage that `x` has
moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
the `min` and `max`.

See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to evaluate based on its position between min and max. |
| min | <code>number</code> | The min value. Any x value below min will be `0`. |
| max | <code>number</code> | The max value. Any x value above max will be `1`. |

<a name="MathUtils.smootherstep"></a>

### MathUtils.smootherstep(x, min, max) ⇒ <code>number</code>
A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
that has zero 1st and 2nd order derivatives at x=0 and x=1.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to evaluate based on its position between min and max. |
| min | <code>number</code> | The min value. Any x value below min will be `0`. |
| max | <code>number</code> | The max value. Any x value above max will be `1`. |

<a name="MathUtils.randInt"></a>

### MathUtils.randInt(low, high) ⇒ <code>number</code>
Returns a random integer from `<low, high>` interval.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - A random integer.  

| Param | Type | Description |
| --- | --- | --- |
| low | <code>number</code> | The lower value boundary. |
| high | <code>number</code> | The upper value boundary |

<a name="MathUtils.randFloat"></a>

### MathUtils.randFloat(low, high) ⇒ <code>number</code>
Returns a random float from `<low, high>` interval.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| low | <code>number</code> | The lower value boundary. |
| high | <code>number</code> | The upper value boundary |

<a name="MathUtils.randFloatSpread"></a>

### MathUtils.randFloatSpread(range) ⇒ <code>number</code>
Returns a random integer from `<-range/2, range/2>` interval.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| range | <code>number</code> | Defines the value range. |

<a name="MathUtils.seededRandom"></a>

### MathUtils.seededRandom([s]) ⇒ <code>number</code>
Returns a deterministic pseudo-random float in the interval `[0, 1]`.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| [s] | <code>number</code> | The integer seed. |

<a name="MathUtils.degToRad"></a>

### MathUtils.degToRad(degrees) ⇒ <code>number</code>
Converts degrees to radians.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The converted value in radians.  

| Param | Type | Description |
| --- | --- | --- |
| degrees | <code>number</code> | A value in degrees. |

<a name="MathUtils.radToDeg"></a>

### MathUtils.radToDeg(radians) ⇒ <code>number</code>
Converts radians to degrees.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The converted value in degrees.  

| Param | Type | Description |
| --- | --- | --- |
| radians | <code>number</code> | A value in radians. |

<a name="MathUtils.isPowerOfTwo"></a>

### MathUtils.isPowerOfTwo(value) ⇒ <code>boolean</code>
Returns `true` if the given number is a power of two.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>boolean</code> - Whether the given number is a power of two or not.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to check. |

<a name="MathUtils.ceilPowerOfTwo"></a>

### MathUtils.ceilPowerOfTwo(value) ⇒ <code>number</code>
Returns the smallest power of two that is greater than or equal to the given number.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The smallest power of two that is greater than or equal to the given number.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to find a POT for. |

<a name="MathUtils.floorPowerOfTwo"></a>

### MathUtils.floorPowerOfTwo(value) ⇒ <code>number</code>
Returns the largest power of two that is less than or equal to the given number.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The largest power of two that is less than or equal to the given number.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to find a POT for. |

<a name="MathUtils.setQuaternionFromProperEuler"></a>

### MathUtils.setQuaternionFromProperEuler(q, a, b, c, order)
Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)
defined by the given angles and order.

Rotations are applied to the axes in the order specified by order:
rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The quaternion to set. |
| a | <code>number</code> | The rotation applied to the first axis, in radians. |
| b | <code>number</code> | The rotation applied to the second axis, in radians. |
| c | <code>number</code> | The rotation applied to the third axis, in radians. |
| order | <code>&#x27;XYX&#x27;</code> \| <code>&#x27;XZX&#x27;</code> \| <code>&#x27;YXY&#x27;</code> \| <code>&#x27;YZY&#x27;</code> \| <code>&#x27;ZXZ&#x27;</code> \| <code>&#x27;ZYZ&#x27;</code> | A string specifying the axes order. |

<a name="MathUtils.normalize"></a>

### MathUtils.normalize(value, array) ⇒ <code>number</code>
Normalizes the given value according to the given typed array.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The normalize value.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The float value in the range `[0,1]` to normalize. |
| array | <code>TypedArray</code> | The typed array that defines the data type of the value. |

<a name="MathUtils.denormalize"></a>

### MathUtils.denormalize(value, array) ⇒ <code>number</code>
Denormalizes the given value according to the given typed array.

**Kind**: static method of [<code>MathUtils</code>](#MathUtils)  
**Returns**: <code>number</code> - The denormalize (float) value in the range `[0,1]`.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to denormalize. |
| array | <code>TypedArray</code> | The typed array that defines the data type of the value. |

<a name="generateUUID"></a>

## generateUUID() ⇒ <code>string</code>
Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
(universally unique identifier).

**Kind**: global function  
**Returns**: <code>string</code> - The UUID.  
<a name="clamp"></a>

## clamp(value, min, max) ⇒ <code>number</code>
Clamps the given value between min and max.

**Kind**: global function  
**Returns**: <code>number</code> - The clamped value.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to clamp. |
| min | <code>number</code> | The min value. |
| max | <code>number</code> | The max value. |

<a name="euclideanModulo"></a>

## euclideanModulo(n, m) ⇒ <code>number</code>
Computes the Euclidean modulo of the given parameters that
is `( ( n % m ) + m ) % m`.

**Kind**: global function  
**Returns**: <code>number</code> - The Euclidean modulo.  

| Param | Type | Description |
| --- | --- | --- |
| n | <code>number</code> | The first parameter. |
| m | <code>number</code> | The second parameter. |

<a name="mapLinear"></a>

## mapLinear(x, a1, a2, b1, b2) ⇒ <code>number</code>
Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
for the given value.

**Kind**: global function  
**Returns**: <code>number</code> - The mapped value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to be mapped. |
| a1 | <code>number</code> | Minimum value for range A. |
| a2 | <code>number</code> | Maximum value for range A. |
| b1 | <code>number</code> | Minimum value for range B. |
| b2 | <code>number</code> | Maximum value for range B. |

<a name="inverseLerp"></a>

## inverseLerp(x, y, value) ⇒ <code>number</code>
Returns the percentage in the closed interval `[0, 1]` of the given value
between the start and end point.

**Kind**: global function  
**Returns**: <code>number</code> - The interpolation factor.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The start point |
| y | <code>number</code> | The end point. |
| value | <code>number</code> | A value between start and end. |

<a name="lerp"></a>

## lerp(x, y, t) ⇒ <code>number</code>
Returns a value linearly interpolated from two known points based on the given interval -
`t = 0` will return `x` and `t = 1` will return `y`.

**Kind**: global function  
**Returns**: <code>number</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The start point |
| y | <code>number</code> | The end point. |
| t | <code>number</code> | The interpolation factor in the closed interval `[0, 1]`. |

<a name="damp"></a>

## damp(x, y, lambda, dt) ⇒ <code>number</code>
Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
time to maintain frame rate independent movement. For details, see
[Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).

**Kind**: global function  
**Returns**: <code>number</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The current point. |
| y | <code>number</code> | The target point. |
| lambda | <code>number</code> | A higher lambda value will make the movement more sudden, and a lower value will make the movement more gradual. |
| dt | <code>number</code> | Delta time in seconds. |

<a name="pingpong"></a>

## pingpong(x, [length]) ⇒ <code>number</code>
Returns a value that alternates between `0` and the given `length` parameter.

**Kind**: global function  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| x | <code>number</code> |  | The value to pingpong. |
| [length] | <code>number</code> | <code>1</code> | The positive value the function will pingpong to. |

<a name="smoothstep"></a>

## smoothstep(x, min, max) ⇒ <code>number</code>
Returns a value in the range `[0,1]` that represents the percentage that `x` has
moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
the `min` and `max`.

See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.

**Kind**: global function  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to evaluate based on its position between min and max. |
| min | <code>number</code> | The min value. Any x value below min will be `0`. |
| max | <code>number</code> | The max value. Any x value above max will be `1`. |

<a name="smootherstep"></a>

## smootherstep(x, min, max) ⇒ <code>number</code>
A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
that has zero 1st and 2nd order derivatives at x=0 and x=1.

**Kind**: global function  
**Returns**: <code>number</code> - The alternated value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to evaluate based on its position between min and max. |
| min | <code>number</code> | The min value. Any x value below min will be `0`. |
| max | <code>number</code> | The max value. Any x value above max will be `1`. |

<a name="randInt"></a>

## randInt(low, high) ⇒ <code>number</code>
Returns a random integer from `<low, high>` interval.

**Kind**: global function  
**Returns**: <code>number</code> - A random integer.  

| Param | Type | Description |
| --- | --- | --- |
| low | <code>number</code> | The lower value boundary. |
| high | <code>number</code> | The upper value boundary |

<a name="randFloat"></a>

## randFloat(low, high) ⇒ <code>number</code>
Returns a random float from `<low, high>` interval.

**Kind**: global function  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| low | <code>number</code> | The lower value boundary. |
| high | <code>number</code> | The upper value boundary |

<a name="randFloatSpread"></a>

## randFloatSpread(range) ⇒ <code>number</code>
Returns a random integer from `<-range/2, range/2>` interval.

**Kind**: global function  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| range | <code>number</code> | Defines the value range. |

<a name="seededRandom"></a>

## seededRandom([s]) ⇒ <code>number</code>
Returns a deterministic pseudo-random float in the interval `[0, 1]`.

**Kind**: global function  
**Returns**: <code>number</code> - A random float.  

| Param | Type | Description |
| --- | --- | --- |
| [s] | <code>number</code> | The integer seed. |

<a name="degToRad"></a>

## degToRad(degrees) ⇒ <code>number</code>
Converts degrees to radians.

**Kind**: global function  
**Returns**: <code>number</code> - The converted value in radians.  

| Param | Type | Description |
| --- | --- | --- |
| degrees | <code>number</code> | A value in degrees. |

<a name="radToDeg"></a>

## radToDeg(radians) ⇒ <code>number</code>
Converts radians to degrees.

**Kind**: global function  
**Returns**: <code>number</code> - The converted value in degrees.  

| Param | Type | Description |
| --- | --- | --- |
| radians | <code>number</code> | A value in radians. |

<a name="isPowerOfTwo"></a>

## isPowerOfTwo(value) ⇒ <code>boolean</code>
Returns `true` if the given number is a power of two.

**Kind**: global function  
**Returns**: <code>boolean</code> - Whether the given number is a power of two or not.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to check. |

<a name="ceilPowerOfTwo"></a>

## ceilPowerOfTwo(value) ⇒ <code>number</code>
Returns the smallest power of two that is greater than or equal to the given number.

**Kind**: global function  
**Returns**: <code>number</code> - The smallest power of two that is greater than or equal to the given number.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to find a POT for. |

<a name="floorPowerOfTwo"></a>

## floorPowerOfTwo(value) ⇒ <code>number</code>
Returns the largest power of two that is less than or equal to the given number.

**Kind**: global function  
**Returns**: <code>number</code> - The largest power of two that is less than or equal to the given number.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to find a POT for. |

<a name="setQuaternionFromProperEuler"></a>

## setQuaternionFromProperEuler(q, a, b, c, order)
Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)
defined by the given angles and order.

Rotations are applied to the axes in the order specified by order:
rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The quaternion to set. |
| a | <code>number</code> | The rotation applied to the first axis, in radians. |
| b | <code>number</code> | The rotation applied to the second axis, in radians. |
| c | <code>number</code> | The rotation applied to the third axis, in radians. |
| order | <code>&#x27;XYX&#x27;</code> \| <code>&#x27;XZX&#x27;</code> \| <code>&#x27;YXY&#x27;</code> \| <code>&#x27;YZY&#x27;</code> \| <code>&#x27;ZXZ&#x27;</code> \| <code>&#x27;ZYZ&#x27;</code> | A string specifying the axes order. |

<a name="denormalize"></a>

## denormalize(value, array) ⇒ <code>number</code>
Denormalizes the given value according to the given typed array.

**Kind**: global function  
**Returns**: <code>number</code> - The denormalize (float) value in the range `[0,1]`.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The value to denormalize. |
| array | <code>TypedArray</code> | The typed array that defines the data type of the value. |

<a name="normalize"></a>

## normalize(value, array) ⇒ <code>number</code>
Normalizes the given value according to the given typed array.

**Kind**: global function  
**Returns**: <code>number</code> - The normalize value.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The float value in the range `[0,1]` to normalize. |
| array | <code>TypedArray</code> | The typed array that defines the data type of the value. |

<a name="Matrix3"></a>

## Matrix3
Represents a 3x3 matrix.

A Note on Row-Major and Column-Major Ordering:

The constructor and [set](#Matrix3+set) method take arguments in
[row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
order, while internally they are stored in the [elements](#Matrix3+elements) array in column-major order.
This means that calling:
```js
const m = new THREE.Matrix();
m.set( 11, 12, 13,
       21, 22, 23,
       31, 32, 33 );
```
will result in the elements array containing:
```js
m.elements = [ 11, 21, 31,
               12, 22, 32,
               13, 23, 33 ];
```
and internally all calculations are performed using column-major ordering.
However, as the actual ordering makes no difference mathematically and
most people are used to thinking about matrices in row-major order, the
three.js documentation shows matrices in row-major order. Just bear in
mind that if you are reading the source code, you'll have to take the
transpose of any matrices outlined here to make sense of the calculations.

**Kind**: global class  

* [Matrix3](#Matrix3)
    * [new Matrix3([n11], [n12], [n13], [n21], [n22], [n23], [n31], [n32], [n33])](#new_Matrix3_new)
    * [.isMatrix3](#Matrix3+isMatrix3) : <code>boolean</code>
    * [.elements](#Matrix3+elements) : <code>Array.&lt;number&gt;</code>
    * [.set([n11], [n12], [n13], [n21], [n22], [n23], [n31], [n32], [n33])](#Matrix3+set) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.identity()](#Matrix3+identity) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.copy(m)](#Matrix3+copy) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.extractBasis(xAxis, yAxis, zAxis)](#Matrix3+extractBasis) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.setFromMatrix4(m)](#Matrix3+setFromMatrix4) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.multiply(m)](#Matrix3+multiply) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.premultiply(m)](#Matrix3+premultiply) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.multiplyMatrices(a, b)](#Matrix3+multiplyMatrices) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.multiplyScalar(s)](#Matrix3+multiplyScalar) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.determinant()](#Matrix3+determinant) ⇒ <code>number</code>
    * [.invert()](#Matrix3+invert) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.transpose()](#Matrix3+transpose) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.getNormalMatrix(matrix4)](#Matrix3+getNormalMatrix) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.transposeIntoArray(r)](#Matrix3+transposeIntoArray) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.setUvTransform(tx, ty, sx, sy, rotation, cx, cy)](#Matrix3+setUvTransform) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.scale(sx, sy)](#Matrix3+scale) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.rotate(theta)](#Matrix3+rotate) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.translate(tx, ty)](#Matrix3+translate) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.makeTranslation(x, y)](#Matrix3+makeTranslation) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.makeRotation(theta)](#Matrix3+makeRotation) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.makeScale(x, y)](#Matrix3+makeScale) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.equals(matrix)](#Matrix3+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Matrix3+fromArray) ⇒ [<code>Matrix3</code>](#Matrix3)
    * [.toArray([array], [offset])](#Matrix3+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * [.clone()](#Matrix3+clone) ⇒ [<code>Matrix3</code>](#Matrix3)

<a name="new_Matrix3_new"></a>

### new Matrix3([n11], [n12], [n13], [n21], [n22], [n23], [n31], [n32], [n33])
Constructs a new 3x3 matrix. The arguments are supposed to be
in row-major order. If no arguments are provided, the constructor
initializes the matrix as an identity matrix.


| Param | Type | Description |
| --- | --- | --- |
| [n11] | <code>number</code> | 1-1 matrix element. |
| [n12] | <code>number</code> | 1-2 matrix element. |
| [n13] | <code>number</code> | 1-3 matrix element. |
| [n21] | <code>number</code> | 2-1 matrix element. |
| [n22] | <code>number</code> | 2-2 matrix element. |
| [n23] | <code>number</code> | 2-3 matrix element. |
| [n31] | <code>number</code> | 3-1 matrix element. |
| [n32] | <code>number</code> | 3-2 matrix element. |
| [n33] | <code>number</code> | 3-3 matrix element. |

<a name="Matrix3+isMatrix3"></a>

### matrix3.isMatrix3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Matrix3</code>](#Matrix3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Matrix3+elements"></a>

### matrix3.elements : <code>Array.&lt;number&gt;</code>
A column-major list of matrix values.

**Kind**: instance property of [<code>Matrix3</code>](#Matrix3)  
<a name="Matrix3+set"></a>

### matrix3.set([n11], [n12], [n13], [n21], [n22], [n23], [n31], [n32], [n33]) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets the elements of the matrix.The arguments are supposed to be
in row-major order.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| [n11] | <code>number</code> | 1-1 matrix element. |
| [n12] | <code>number</code> | 1-2 matrix element. |
| [n13] | <code>number</code> | 1-3 matrix element. |
| [n21] | <code>number</code> | 2-1 matrix element. |
| [n22] | <code>number</code> | 2-2 matrix element. |
| [n23] | <code>number</code> | 2-3 matrix element. |
| [n31] | <code>number</code> | 3-1 matrix element. |
| [n32] | <code>number</code> | 3-2 matrix element. |
| [n33] | <code>number</code> | 3-3 matrix element. |

<a name="Matrix3+identity"></a>

### matrix3.identity() ⇒ [<code>Matrix3</code>](#Matrix3)
Sets this matrix to the 3x3 identity matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  
<a name="Matrix3+copy"></a>

### matrix3.copy(m) ⇒ [<code>Matrix3</code>](#Matrix3)
Copies the values of the given matrix to this instance.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix3</code>](#Matrix3) | The matrix to copy. |

<a name="Matrix3+extractBasis"></a>

### matrix3.extractBasis(xAxis, yAxis, zAxis) ⇒ [<code>Matrix3</code>](#Matrix3)
Extracts the basis of this matrix into the three axis vectors provided.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| xAxis | <code>Vector3</code> | The basis's x axis. |
| yAxis | <code>Vector3</code> | The basis's y axis. |
| zAxis | <code>Vector3</code> | The basis's z axis. |

<a name="Matrix3+setFromMatrix4"></a>

### matrix3.setFromMatrix4(m) ⇒ [<code>Matrix3</code>](#Matrix3)
Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Matrix3+multiply"></a>

### matrix3.multiply(m) ⇒ [<code>Matrix3</code>](#Matrix3)
Post-multiplies this matrix by the given 3x3 matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix3</code>](#Matrix3) | The matrix to multiply with. |

<a name="Matrix3+premultiply"></a>

### matrix3.premultiply(m) ⇒ [<code>Matrix3</code>](#Matrix3)
Pre-multiplies this matrix by the given 3x3 matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix3</code>](#Matrix3) | The matrix to multiply with. |

<a name="Matrix3+multiplyMatrices"></a>

### matrix3.multiplyMatrices(a, b) ⇒ [<code>Matrix3</code>](#Matrix3)
Multiples the given 3x3 matrices and stores the result
in this matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Matrix3</code>](#Matrix3) | The first matrix. |
| b | [<code>Matrix3</code>](#Matrix3) | The second matrix. |

<a name="Matrix3+multiplyScalar"></a>

### matrix3.multiplyScalar(s) ⇒ [<code>Matrix3</code>](#Matrix3)
Multiplies every component of the matrix by the given scalar.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar. |

<a name="Matrix3+determinant"></a>

### matrix3.determinant() ⇒ <code>number</code>
Computes and returns the determinant of this matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: <code>number</code> - The determinant.  
<a name="Matrix3+invert"></a>

### matrix3.invert() ⇒ [<code>Matrix3</code>](#Matrix3)
Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
You can not invert with a determinant of zero. If you attempt this, the method produces
a zero matrix instead.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  
<a name="Matrix3+transpose"></a>

### matrix3.transpose() ⇒ [<code>Matrix3</code>](#Matrix3)
Transposes this matrix in place.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  
<a name="Matrix3+getNormalMatrix"></a>

### matrix3.getNormalMatrix(matrix4) ⇒ [<code>Matrix3</code>](#Matrix3)
Computes the normal matrix which is the inverse transpose of the upper
left 3x3 portion of the given 4x4 matrix.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| matrix4 | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Matrix3+transposeIntoArray"></a>

### matrix3.transposeIntoArray(r) ⇒ [<code>Matrix3</code>](#Matrix3)
Transposes this matrix into the supplied array, and returns itself unchanged.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| r | <code>Array.&lt;number&gt;</code> | An array to store the transposed matrix elements. |

<a name="Matrix3+setUvTransform"></a>

### matrix3.setUvTransform(tx, ty, sx, sy, rotation, cx, cy) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets the UV transform matrix from offset, repeat, rotation, and center.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| tx | <code>number</code> | Offset x. |
| ty | <code>number</code> | Offset y. |
| sx | <code>number</code> | Repeat x. |
| sy | <code>number</code> | Repeat y. |
| rotation | <code>number</code> | Rotation, in radians. Positive values rotate counterclockwise. |
| cx | <code>number</code> | Center x of rotation. |
| cy | <code>number</code> | Center y of rotation |

<a name="Matrix3+scale"></a>

### matrix3.scale(sx, sy) ⇒ [<code>Matrix3</code>](#Matrix3)
Scales this matrix with the given scalar values.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| sx | <code>number</code> | The amount to scale in the X axis. |
| sy | <code>number</code> | The amount to scale in the Y axis. |

<a name="Matrix3+rotate"></a>

### matrix3.rotate(theta) ⇒ [<code>Matrix3</code>](#Matrix3)
Rotates this matrix by the given angle.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix3+translate"></a>

### matrix3.translate(tx, ty) ⇒ [<code>Matrix3</code>](#Matrix3)
Translates this matrix by the given scalar values.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| tx | <code>number</code> | The amount to translate in the X axis. |
| ty | <code>number</code> | The amount to translate in the Y axis. |

<a name="Matrix3+makeTranslation"></a>

### matrix3.makeTranslation(x, y) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets this matrix as a 2D translation transform.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector2</code> | The amount to translate in the X axis or alternatively a translation vector. |
| y | <code>number</code> | The amount to translate in the Y axis. |

<a name="Matrix3+makeRotation"></a>

### matrix3.makeRotation(theta) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets this matrix as a 2D rotational transformation.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix3+makeScale"></a>

### matrix3.makeScale(x, y) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets this matrix as a 2D scale transform.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The amount to scale in the X axis. |
| y | <code>number</code> | The amount to scale in the Y axis. |

<a name="Matrix3+equals"></a>

### matrix3.equals(matrix) ⇒ <code>boolean</code>
Returns `true` if this matrix is equal with the given one.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: <code>boolean</code> - Whether this matrix is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | [<code>Matrix3</code>](#Matrix3) | The matrix to test for equality. |

<a name="Matrix3+fromArray"></a>

### matrix3.fromArray(array, [offset]) ⇒ [<code>Matrix3</code>](#Matrix3)
Sets the elements of the matrix from the given array.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A reference to this matrix.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | The matrix elements in column-major order. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Matrix3+toArray"></a>

### matrix3.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the elements of this matrix to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: <code>Array.&lt;number&gt;</code> - The matrix elements in column-major order.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the matrix elements in column-major order. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Matrix3+clone"></a>

### matrix3.clone() ⇒ [<code>Matrix3</code>](#Matrix3)
Returns a matrix with copied values from this instance.

**Kind**: instance method of [<code>Matrix3</code>](#Matrix3)  
**Returns**: [<code>Matrix3</code>](#Matrix3) - A clone of this instance.  
<a name="Matrix4"></a>

## Matrix4
Represents a 4x4 matrix.

The most common use of a 4x4 matrix in 3D computer graphics is as a transformation matrix.
For an introduction to transformation matrices as used in WebGL, check out [this tutorial](https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices)

This allows a 3D vector representing a point in 3D space to undergo
transformations such as translation, rotation, shear, scale, reflection,
orthogonal or perspective projection and so on, by being multiplied by the
matrix. This is known as `applying` the matrix to the vector.

A Note on Row-Major and Column-Major Ordering:

The constructor and [Matrix3#set](Matrix3#set) method take arguments in
[row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
order, while internally they are stored in the [Matrix3#elements](Matrix3#elements) array in column-major order.
This means that calling:
```js
const m = new THREE.Matrix4();
m.set( 11, 12, 13, 14,
       21, 22, 23, 24,
       31, 32, 33, 34,
       41, 42, 43, 44 );
```
will result in the elements array containing:
```js
m.elements = [ 11, 21, 31, 41,
               12, 22, 32, 42,
               13, 23, 33, 43,
               14, 24, 34, 44 ];
```
and internally all calculations are performed using column-major ordering.
However, as the actual ordering makes no difference mathematically and
most people are used to thinking about matrices in row-major order, the
three.js documentation shows matrices in row-major order. Just bear in
mind that if you are reading the source code, you'll have to take the
transpose of any matrices outlined here to make sense of the calculations.

**Kind**: global class  

* [Matrix4](#Matrix4)
    * [new Matrix4([n11], [n12], [n13], [n14], [n21], [n22], [n23], [n24], [n31], [n32], [n33], [n34], [n41], [n42], [n43], [n44])](#new_Matrix4_new)
    * [.isMatrix4](#Matrix4+isMatrix4) : <code>boolean</code>
    * [.elements](#Matrix4+elements) : <code>Array.&lt;number&gt;</code>
    * [.set([n11], [n12], [n13], [n14], [n21], [n22], [n23], [n24], [n31], [n32], [n33], [n34], [n41], [n42], [n43], [n44])](#Matrix4+set) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.identity()](#Matrix4+identity) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.clone()](#Matrix4+clone) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.copy(m)](#Matrix4+copy) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.copyPosition(m)](#Matrix4+copyPosition) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.setFromMatrix3(m)](#Matrix4+setFromMatrix3) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.extractBasis(xAxis, yAxis, zAxis)](#Matrix4+extractBasis) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeBasis(xAxis, yAxis, zAxis)](#Matrix4+makeBasis) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.extractRotation(m)](#Matrix4+extractRotation) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationFromEuler(euler)](#Matrix4+makeRotationFromEuler) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationFromQuaternion(q)](#Matrix4+makeRotationFromQuaternion) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.lookAt(eye, target, up)](#Matrix4+lookAt) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.multiply(m)](#Matrix4+multiply) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.premultiply(m)](#Matrix4+premultiply) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.multiplyMatrices(a, b)](#Matrix4+multiplyMatrices) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.multiplyScalar(s)](#Matrix4+multiplyScalar) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.determinant()](#Matrix4+determinant) ⇒ <code>number</code>
    * [.transpose()](#Matrix4+transpose) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.setPosition(x, y, z)](#Matrix4+setPosition) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.invert()](#Matrix4+invert) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.scale(v)](#Matrix4+scale) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.getMaxScaleOnAxis()](#Matrix4+getMaxScaleOnAxis) ⇒ <code>number</code>
    * [.makeTranslation(x, y, z)](#Matrix4+makeTranslation) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationX(theta)](#Matrix4+makeRotationX) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationY(theta)](#Matrix4+makeRotationY) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationZ(theta)](#Matrix4+makeRotationZ) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeRotationAxis(axis, angle)](#Matrix4+makeRotationAxis) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeScale(x, y, z)](#Matrix4+makeScale) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeShear(xy, xz, yx, yz, zx, zy)](#Matrix4+makeShear) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.compose(position, quaternion, scale)](#Matrix4+compose) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.decompose(position, quaternion, scale)](#Matrix4+decompose) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makePerspective(left, right, top, bottom, near, far, [coordinateSystem])](#Matrix4+makePerspective) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.makeOrthographic(left, right, top, bottom, near, far, [coordinateSystem])](#Matrix4+makeOrthographic) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.equals(matrix)](#Matrix4+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Matrix4+fromArray) ⇒ [<code>Matrix4</code>](#Matrix4)
    * [.toArray([array], [offset])](#Matrix4+toArray) ⇒ <code>Array.&lt;number&gt;</code>

<a name="new_Matrix4_new"></a>

### new Matrix4([n11], [n12], [n13], [n14], [n21], [n22], [n23], [n24], [n31], [n32], [n33], [n34], [n41], [n42], [n43], [n44])
Constructs a new 4x4 matrix. The arguments are supposed to be
in row-major order. If no arguments are provided, the constructor
initializes the matrix as an identity matrix.


| Param | Type | Description |
| --- | --- | --- |
| [n11] | <code>number</code> | 1-1 matrix element. |
| [n12] | <code>number</code> | 1-2 matrix element. |
| [n13] | <code>number</code> | 1-3 matrix element. |
| [n14] | <code>number</code> | 1-4 matrix element. |
| [n21] | <code>number</code> | 2-1 matrix element. |
| [n22] | <code>number</code> | 2-2 matrix element. |
| [n23] | <code>number</code> | 2-3 matrix element. |
| [n24] | <code>number</code> | 2-4 matrix element. |
| [n31] | <code>number</code> | 3-1 matrix element. |
| [n32] | <code>number</code> | 3-2 matrix element. |
| [n33] | <code>number</code> | 3-3 matrix element. |
| [n34] | <code>number</code> | 3-4 matrix element. |
| [n41] | <code>number</code> | 4-1 matrix element. |
| [n42] | <code>number</code> | 4-2 matrix element. |
| [n43] | <code>number</code> | 4-3 matrix element. |
| [n44] | <code>number</code> | 4-4 matrix element. |

<a name="Matrix4+isMatrix4"></a>

### matrix4.isMatrix4 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Matrix4</code>](#Matrix4)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Matrix4+elements"></a>

### matrix4.elements : <code>Array.&lt;number&gt;</code>
A column-major list of matrix values.

**Kind**: instance property of [<code>Matrix4</code>](#Matrix4)  
<a name="Matrix4+set"></a>

### matrix4.set([n11], [n12], [n13], [n14], [n21], [n22], [n23], [n24], [n31], [n32], [n33], [n34], [n41], [n42], [n43], [n44]) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the elements of the matrix.The arguments are supposed to be
in row-major order.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| [n11] | <code>number</code> | 1-1 matrix element. |
| [n12] | <code>number</code> | 1-2 matrix element. |
| [n13] | <code>number</code> | 1-3 matrix element. |
| [n14] | <code>number</code> | 1-4 matrix element. |
| [n21] | <code>number</code> | 2-1 matrix element. |
| [n22] | <code>number</code> | 2-2 matrix element. |
| [n23] | <code>number</code> | 2-3 matrix element. |
| [n24] | <code>number</code> | 2-4 matrix element. |
| [n31] | <code>number</code> | 3-1 matrix element. |
| [n32] | <code>number</code> | 3-2 matrix element. |
| [n33] | <code>number</code> | 3-3 matrix element. |
| [n34] | <code>number</code> | 3-4 matrix element. |
| [n41] | <code>number</code> | 4-1 matrix element. |
| [n42] | <code>number</code> | 4-2 matrix element. |
| [n43] | <code>number</code> | 4-3 matrix element. |
| [n44] | <code>number</code> | 4-4 matrix element. |

<a name="Matrix4+identity"></a>

### matrix4.identity() ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix to the 4x4 identity matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  
<a name="Matrix4+clone"></a>

### matrix4.clone() ⇒ [<code>Matrix4</code>](#Matrix4)
Returns a matrix with copied values from this instance.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A clone of this instance.  
<a name="Matrix4+copy"></a>

### matrix4.copy(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Copies the values of the given matrix to this instance.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix to copy. |

<a name="Matrix4+copyPosition"></a>

### matrix4.copyPosition(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Copies the translation component of the given matrix
into this matrix's translation component.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix to copy the translation component. |

<a name="Matrix4+setFromMatrix3"></a>

### matrix4.setFromMatrix3(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The 3x3 matrix. |

<a name="Matrix4+extractBasis"></a>

### matrix4.extractBasis(xAxis, yAxis, zAxis) ⇒ [<code>Matrix4</code>](#Matrix4)
Extracts the basis of this matrix into the three axis vectors provided.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| xAxis | <code>Vector3</code> | The basis's x axis. |
| yAxis | <code>Vector3</code> | The basis's y axis. |
| zAxis | <code>Vector3</code> | The basis's z axis. |

<a name="Matrix4+makeBasis"></a>

### matrix4.makeBasis(xAxis, yAxis, zAxis) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the given basis vectors to this matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| xAxis | <code>Vector3</code> | The basis's x axis. |
| yAxis | <code>Vector3</code> | The basis's y axis. |
| zAxis | <code>Vector3</code> | The basis's z axis. |

<a name="Matrix4+extractRotation"></a>

### matrix4.extractRotation(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Extracts the rotation component of the given matrix
into this matrix's rotation component.

Note: This method does not support reflection matrices.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix. |

<a name="Matrix4+makeRotationFromEuler"></a>

### matrix4.makeRotationFromEuler(euler) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the rotation component (the upper left 3x3 matrix) of this matrix to
the rotation specified by the given Euler angles. The rest of
the matrix is set to the identity. Depending on the [Euler#order](Euler#order),
there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
for a complete list.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| euler | <code>Euler</code> | The Euler angles. |

<a name="Matrix4+makeRotationFromQuaternion"></a>

### matrix4.makeRotationFromQuaternion(q) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the rotation component of this matrix to the rotation specified by
the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion)
The rest of the matrix is set to the identity.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The Quaternion. |

<a name="Matrix4+lookAt"></a>

### matrix4.lookAt(eye, target, up) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the rotation component of the transformation matrix, looking from `eye` towards
`target`, and oriented by the up-direction.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| eye | <code>Vector3</code> | The eye vector. |
| target | <code>Vector3</code> | The target vector. |
| up | <code>Vector3</code> | The up vector. |

<a name="Matrix4+multiply"></a>

### matrix4.multiply(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Post-multiplies this matrix by the given 4x4 matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix to multiply with. |

<a name="Matrix4+premultiply"></a>

### matrix4.premultiply(m) ⇒ [<code>Matrix4</code>](#Matrix4)
Pre-multiplies this matrix by the given 4x4 matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| m | [<code>Matrix4</code>](#Matrix4) | The matrix to multiply with. |

<a name="Matrix4+multiplyMatrices"></a>

### matrix4.multiplyMatrices(a, b) ⇒ [<code>Matrix4</code>](#Matrix4)
Multiples the given 4x4 matrices and stores the result
in this matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Matrix4</code>](#Matrix4) | The first matrix. |
| b | [<code>Matrix4</code>](#Matrix4) | The second matrix. |

<a name="Matrix4+multiplyScalar"></a>

### matrix4.multiplyScalar(s) ⇒ [<code>Matrix4</code>](#Matrix4)
Multiplies every component of the matrix by the given scalar.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar. |

<a name="Matrix4+determinant"></a>

### matrix4.determinant() ⇒ <code>number</code>
Computes and returns the determinant of this matrix.

Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html).

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: <code>number</code> - The determinant.  
<a name="Matrix4+transpose"></a>

### matrix4.transpose() ⇒ [<code>Matrix4</code>](#Matrix4)
Transposes this matrix in place.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  
<a name="Matrix4+setPosition"></a>

### matrix4.setPosition(x, y, z) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the position component for this matrix from the given vector,
without affecting the rest of the matrix.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector3</code> | The x component of the vector or alternatively the vector object. |
| y | <code>number</code> | The y component of the vector. |
| z | <code>number</code> | The z component of the vector. |

<a name="Matrix4+invert"></a>

### matrix4.invert() ⇒ [<code>Matrix4</code>](#Matrix4)
Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
You can not invert with a determinant of zero. If you attempt this, the method produces
a zero matrix instead.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  
<a name="Matrix4+scale"></a>

### matrix4.scale(v) ⇒ [<code>Matrix4</code>](#Matrix4)
Multiplies the columns of this matrix by the given vector.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The scale vector. |

<a name="Matrix4+getMaxScaleOnAxis"></a>

### matrix4.getMaxScaleOnAxis() ⇒ <code>number</code>
Gets the maximum scale value of the three axes.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: <code>number</code> - The maximum scale.  
<a name="Matrix4+makeTranslation"></a>

### matrix4.makeTranslation(x, y, z) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a translation transform from the given vector.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector3</code> | The amount to translate in the X axis or alternatively a translation vector. |
| y | <code>number</code> | The amount to translate in the Y axis. |
| z | <code>number</code> | The amount to translate in the z axis. |

<a name="Matrix4+makeRotationX"></a>

### matrix4.makeRotationX(theta) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a rotational transformation around the X axis by
the given angle.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix4+makeRotationY"></a>

### matrix4.makeRotationY(theta) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a rotational transformation around the Y axis by
the given angle.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix4+makeRotationZ"></a>

### matrix4.makeRotationZ(theta) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a rotational transformation around the Z axis by
the given angle.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| theta | <code>number</code> | The rotation in radians. |

<a name="Matrix4+makeRotationAxis"></a>

### matrix4.makeRotationAxis(axis, angle) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a rotational transformation around the given axis by
the given angle.

This is a somewhat controversial but mathematically sound alternative to
rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199).

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>Vector3</code> | The normalized rotation axis. |
| angle | <code>number</code> | The rotation in radians. |

<a name="Matrix4+makeScale"></a>

### matrix4.makeScale(x, y, z) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a scale transformation.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The amount to scale in the X axis. |
| y | <code>number</code> | The amount to scale in the Y axis. |
| z | <code>number</code> | The amount to scale in the Z axis. |

<a name="Matrix4+makeShear"></a>

### matrix4.makeShear(xy, xz, yx, yz, zx, zy) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix as a shear transformation.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| xy | <code>number</code> | The amount to shear X by Y. |
| xz | <code>number</code> | The amount to shear X by Z. |
| yx | <code>number</code> | The amount to shear Y by X. |
| yz | <code>number</code> | The amount to shear Y by Z. |
| zx | <code>number</code> | The amount to shear Z by X. |
| zy | <code>number</code> | The amount to shear Z by Y. |

<a name="Matrix4+compose"></a>

### matrix4.compose(position, quaternion, scale) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets this matrix to the transformation composed of the given position,
rotation (Quaternion) and scale.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Vector3</code> | The position vector. |
| quaternion | <code>Quaternion</code> | The rotation as a Quaternion. |
| scale | <code>Vector3</code> | The scale vector. |

<a name="Matrix4+decompose"></a>

### matrix4.decompose(position, quaternion, scale) ⇒ [<code>Matrix4</code>](#Matrix4)
Decomposes this matrix into its position, rotation and scale components
and provides the result in the given objects.

Note: Not all matrices are decomposable in this way. For example, if an
object has a non-uniformly scaled parent, then the object's world matrix
may not be decomposable, and this method may not be appropriate.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Vector3</code> | The position vector. |
| quaternion | <code>Quaternion</code> | The rotation as a Quaternion. |
| scale | <code>Vector3</code> | The scale vector. |

<a name="Matrix4+makePerspective"></a>

### matrix4.makePerspective(left, right, top, bottom, near, far, [coordinateSystem]) ⇒ [<code>Matrix4</code>](#Matrix4)
Creates a perspective projection matrix. This is used internally by
[PerspectiveCamera#updateProjectionMatrix](PerspectiveCamera#updateProjectionMatrix).

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| left | <code>number</code> |  | Left boundary of the viewing frustum at the near plane. |
| right | <code>number</code> |  | Right boundary of the viewing frustum at the near plane. |
| top | <code>number</code> |  | Top boundary of the viewing frustum at the near plane. |
| bottom | <code>number</code> |  | Bottom boundary of the viewing frustum at the near plane. |
| near | <code>number</code> |  | The distance from the camera to the near plane. |
| far | <code>number</code> |  | The distance from the camera to the far plane. |
| [coordinateSystem] | <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code> | <code>WebGLCoordinateSystem</code> | The coordinate system. |

<a name="Matrix4+makeOrthographic"></a>

### matrix4.makeOrthographic(left, right, top, bottom, near, far, [coordinateSystem]) ⇒ [<code>Matrix4</code>](#Matrix4)
Creates a orthographic projection matrix. This is used internally by
[OrthographicCamera#updateProjectionMatrix](OrthographicCamera#updateProjectionMatrix).

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| left | <code>number</code> |  | Left boundary of the viewing frustum at the near plane. |
| right | <code>number</code> |  | Right boundary of the viewing frustum at the near plane. |
| top | <code>number</code> |  | Top boundary of the viewing frustum at the near plane. |
| bottom | <code>number</code> |  | Bottom boundary of the viewing frustum at the near plane. |
| near | <code>number</code> |  | The distance from the camera to the near plane. |
| far | <code>number</code> |  | The distance from the camera to the far plane. |
| [coordinateSystem] | <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code> | <code>WebGLCoordinateSystem</code> | The coordinate system. |

<a name="Matrix4+equals"></a>

### matrix4.equals(matrix) ⇒ <code>boolean</code>
Returns `true` if this matrix is equal with the given one.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: <code>boolean</code> - Whether this matrix is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | [<code>Matrix4</code>](#Matrix4) | The matrix to test for equality. |

<a name="Matrix4+fromArray"></a>

### matrix4.fromArray(array, [offset]) ⇒ [<code>Matrix4</code>](#Matrix4)
Sets the elements of the matrix from the given array.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: [<code>Matrix4</code>](#Matrix4) - A reference to this matrix.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | The matrix elements in column-major order. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Matrix4+toArray"></a>

### matrix4.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the elements of this matrix to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Matrix4</code>](#Matrix4)  
**Returns**: <code>Array.&lt;number&gt;</code> - The matrix elements in column-major order.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the matrix elements in column-major order. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Plane"></a>

## Plane
A two dimensional surface that extends infinitely in 3D space, represented
in [Hessian normal form](http://mathworld.wolfram.com/HessianNormalForm.html)
by a unit length normal vector and a constant.

**Kind**: global class  

* [Plane](#Plane)
    * [new Plane([normal], [constant])](#new_Plane_new)
    * [.isPlane](#Plane+isPlane) : <code>boolean</code>
    * [.normal](#Plane+normal) : <code>Vector3</code>
    * [.constant](#Plane+constant) : <code>number</code>
    * [.set(normal, constant)](#Plane+set) ⇒ [<code>Plane</code>](#Plane)
    * [.setComponents(x, y, z, w)](#Plane+setComponents) ⇒ [<code>Plane</code>](#Plane)
    * [.setFromNormalAndCoplanarPoint(normal, point)](#Plane+setFromNormalAndCoplanarPoint) ⇒ [<code>Plane</code>](#Plane)
    * [.setFromCoplanarPoints(a, b, c)](#Plane+setFromCoplanarPoints) ⇒ [<code>Plane</code>](#Plane)
    * [.copy(plane)](#Plane+copy) ⇒ [<code>Plane</code>](#Plane)
    * [.normalize()](#Plane+normalize) ⇒ [<code>Plane</code>](#Plane)
    * [.negate()](#Plane+negate) ⇒ [<code>Plane</code>](#Plane)
    * [.distanceToPoint(point)](#Plane+distanceToPoint) ⇒ <code>number</code>
    * [.distanceToSphere(sphere)](#Plane+distanceToSphere) ⇒ <code>number</code>
    * [.projectPoint(point, target)](#Plane+projectPoint) ⇒ <code>Vector3</code>
    * [.intersectLine(line, target)](#Plane+intersectLine) ⇒ <code>Vector3</code>
    * [.intersectsLine(line)](#Plane+intersectsLine) ⇒ <code>boolean</code>
    * [.intersectsBox(box)](#Plane+intersectsBox) ⇒ <code>boolean</code>
    * [.intersectsSphere(sphere)](#Plane+intersectsSphere) ⇒ <code>boolean</code>
    * [.coplanarPoint(target)](#Plane+coplanarPoint) ⇒ <code>Vector3</code>
    * [.applyMatrix4(matrix, [optionalNormalMatrix])](#Plane+applyMatrix4) ⇒ [<code>Plane</code>](#Plane)
    * [.translate(offset)](#Plane+translate) ⇒ [<code>Plane</code>](#Plane)
    * [.equals(plane)](#Plane+equals) ⇒ <code>boolean</code>
    * [.clone()](#Plane+clone) ⇒ [<code>Plane</code>](#Plane)

<a name="new_Plane_new"></a>

### new Plane([normal], [constant])
Constructs a new plane.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [normal] | <code>Vector3</code> | <code>(1,0,0)</code> | A unit length vector defining the normal of the plane. |
| [constant] | <code>number</code> | <code>0</code> | The signed distance from the origin to the plane. |

<a name="Plane+isPlane"></a>

### plane.isPlane : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Plane</code>](#Plane)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Plane+normal"></a>

### plane.normal : <code>Vector3</code>
A unit length vector defining the normal of the plane.

**Kind**: instance property of [<code>Plane</code>](#Plane)  
<a name="Plane+constant"></a>

### plane.constant : <code>number</code>
The signed distance from the origin to the plane.

**Kind**: instance property of [<code>Plane</code>](#Plane)  
**Default**: <code>0</code>  
<a name="Plane+set"></a>

### plane.set(normal, constant) ⇒ [<code>Plane</code>](#Plane)
Sets the plane components by copying the given values.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal. |
| constant | <code>number</code> | The constant. |

<a name="Plane+setComponents"></a>

### plane.setComponents(x, y, z, w) ⇒ [<code>Plane</code>](#Plane)
Sets the plane components by defining `x`, `y`, `z` as the
plane normal and `w` as the constant.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value for the normal's x component. |
| y | <code>number</code> | The value for the normal's y component. |
| z | <code>number</code> | The value for the normal's z component. |
| w | <code>number</code> | The constant value. |

<a name="Plane+setFromNormalAndCoplanarPoint"></a>

### plane.setFromNormalAndCoplanarPoint(normal, point) ⇒ [<code>Plane</code>](#Plane)
Sets the plane from the given normal and coplanar point (that is a point
that lies onto the plane).

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal. |
| point | <code>Vector3</code> | A coplanar point. |

<a name="Plane+setFromCoplanarPoints"></a>

### plane.setFromCoplanarPoints(a, b, c) ⇒ [<code>Plane</code>](#Plane)
Sets the plane from three coplanar points. The winding order is
assumed to be counter-clockwise, and determines the direction of
the plane normal.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first coplanar point. |
| b | <code>Vector3</code> | The second coplanar point. |
| c | <code>Vector3</code> | The third coplanar point. |

<a name="Plane+copy"></a>

### plane.copy(plane) ⇒ [<code>Plane</code>](#Plane)
Copies the values of the given plane to this instance.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| plane | [<code>Plane</code>](#Plane) | The plane to copy. |

<a name="Plane+normalize"></a>

### plane.normalize() ⇒ [<code>Plane</code>](#Plane)
Normalizes the plane normal and adjusts the constant accordingly.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  
<a name="Plane+negate"></a>

### plane.negate() ⇒ [<code>Plane</code>](#Plane)
Negates both the plane normal and the constant.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  
<a name="Plane+distanceToPoint"></a>

### plane.distanceToPoint(point) ⇒ <code>number</code>
Returns the signed distance from the given point to this plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>number</code> - The signed distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to compute the distance for. |

<a name="Plane+distanceToSphere"></a>

### plane.distanceToSphere(sphere) ⇒ <code>number</code>
Returns the signed distance from the given sphere to this plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>number</code> - The signed distance.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to compute the distance for. |

<a name="Plane+projectPoint"></a>

### plane.projectPoint(point, target) ⇒ <code>Vector3</code>
Projects a the given point onto the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>Vector3</code> - The projected point on the plane.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to project. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Plane+intersectLine"></a>

### plane.intersectLine(line, target) ⇒ <code>Vector3</code>
Returns the intersection point of the passed line and the plane. Returns
`null` if the line does not intersect. Returns the line's starting point if
the line is coplanar with the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| line | <code>Line3</code> | The line to compute the intersection for. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Plane+intersectsLine"></a>

### plane.intersectsLine(line) ⇒ <code>boolean</code>
Returns `true` if the given line segment intersects with (passes through) the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>boolean</code> - Whether the given line segment intersects with the plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| line | <code>Line3</code> | The line to test. |

<a name="Plane+intersectsBox"></a>

### plane.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box intersects with the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>boolean</code> - Whether the given bounding box intersects with the plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The bounding box to test. |

<a name="Plane+intersectsSphere"></a>

### plane.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if the given bounding sphere intersects with the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>boolean</code> - Whether the given bounding sphere intersects with the plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="Plane+coplanarPoint"></a>

### plane.coplanarPoint(target) ⇒ <code>Vector3</code>
Returns a coplanar vector to the plane, by calculating the
projection of the normal at the origin onto the plane.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>Vector3</code> - The coplanar point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Plane+applyMatrix4"></a>

### plane.applyMatrix4(matrix, [optionalNormalMatrix]) ⇒ [<code>Plane</code>](#Plane)
Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.

The optional normal matrix can be pre-computed like so:
```js
const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
```

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The transformation matrix. |
| [optionalNormalMatrix] | <code>Matrix4</code> | A pre-computed normal matrix. |

<a name="Plane+translate"></a>

### plane.translate(offset) ⇒ [<code>Plane</code>](#Plane)
Translates the plane by the distance defined by the given offset vector.
Note that this only affects the plane constant and will not affect the normal vector.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A reference to this plane.  

| Param | Type | Description |
| --- | --- | --- |
| offset | <code>Vector3</code> | The offset vector. |

<a name="Plane+equals"></a>

### plane.equals(plane) ⇒ <code>boolean</code>
Returns `true` if this plane is equal with the given one.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: <code>boolean</code> - Whether this plane is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| plane | [<code>Plane</code>](#Plane) | The plane to test for equality. |

<a name="Plane+clone"></a>

### plane.clone() ⇒ [<code>Plane</code>](#Plane)
Returns a new plane with copied values from this instance.

**Kind**: instance method of [<code>Plane</code>](#Plane)  
**Returns**: [<code>Plane</code>](#Plane) - A clone of this instance.  
<a name="Quaternion"></a>

## Quaternion
Class for representing a Quaternion. Quaternions are used in three.js to represent rotations.

Iterating through a vector instance will yield its components `(x, y, z, w)` in
the corresponding order.

Note that three.js expects Quaternions to be normalized.
```js
const quaternion = new THREE.Quaternion();
quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );

const vector = new THREE.Vector3( 1, 0, 0 );
vector.applyQuaternion( quaternion );
```

**Kind**: global class  

* [Quaternion](#Quaternion)
    * [new Quaternion([x], [y], [z], [w])](#new_Quaternion_new)
    * _instance_
        * [.isQuaternion](#Quaternion+isQuaternion) : <code>boolean</code>
        * [.x](#Quaternion+x) : <code>number</code>
        * [.y](#Quaternion+y) : <code>number</code>
        * [.z](#Quaternion+z) : <code>number</code>
        * [.w](#Quaternion+w) : <code>number</code>
        * [.set(x, y, z, w)](#Quaternion+set) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.clone()](#Quaternion+clone) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.copy(quaternion)](#Quaternion+copy) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.setFromEuler(euler, [update])](#Quaternion+setFromEuler) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.setFromAxisAngle(axis, angle)](#Quaternion+setFromAxisAngle) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.setFromRotationMatrix(m)](#Quaternion+setFromRotationMatrix) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.setFromUnitVectors(vFrom, vTo)](#Quaternion+setFromUnitVectors) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.angleTo(q)](#Quaternion+angleTo) ⇒ <code>number</code>
        * [.rotateTowards(q, step)](#Quaternion+rotateTowards) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.identity()](#Quaternion+identity) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.invert()](#Quaternion+invert) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.conjugate()](#Quaternion+conjugate) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.dot(v)](#Quaternion+dot) ⇒ <code>number</code>
        * [.lengthSq()](#Quaternion+lengthSq) ⇒ <code>number</code>
        * [.length()](#Quaternion+length) ⇒ <code>number</code>
        * [.normalize()](#Quaternion+normalize) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.multiply(q)](#Quaternion+multiply) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.premultiply(q)](#Quaternion+premultiply) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.multiplyQuaternions(a, b)](#Quaternion+multiplyQuaternions) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.slerp(qb, t)](#Quaternion+slerp) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.slerpQuaternions(qa, qb, t)](#Quaternion+slerpQuaternions) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.random()](#Quaternion+random) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.equals(quaternion)](#Quaternion+equals) ⇒ <code>boolean</code>
        * [.fromArray(array, [offset])](#Quaternion+fromArray) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.toArray([array], [offset])](#Quaternion+toArray) ⇒ <code>Array.&lt;number&gt;</code>
        * [.fromBufferAttribute(attribute, index)](#Quaternion+fromBufferAttribute) ⇒ [<code>Quaternion</code>](#Quaternion)
        * [.toJSON()](#Quaternion+toJSON) ⇒ <code>Array.&lt;number&gt;</code>
    * _static_
        * [.slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t)](#Quaternion.slerpFlat)
        * [.multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1)](#Quaternion.multiplyQuaternionsFlat) ⇒ <code>Array.&lt;number&gt;</code>

<a name="new_Quaternion_new"></a>

### new Quaternion([x], [y], [z], [w])
Constructs a new quaternion.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The x value of this quaternion. |
| [y] | <code>number</code> | <code>0</code> | The y value of this quaternion. |
| [z] | <code>number</code> | <code>0</code> | The z value of this quaternion. |
| [w] | <code>number</code> | <code>1</code> | The w value of this quaternion. |

<a name="Quaternion+isQuaternion"></a>

### quaternion.isQuaternion : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Quaternion+x"></a>

### quaternion.x : <code>number</code>
The x value of this quaternion.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>0</code>  
<a name="Quaternion+y"></a>

### quaternion.y : <code>number</code>
The y value of this quaternion.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>0</code>  
<a name="Quaternion+z"></a>

### quaternion.z : <code>number</code>
The z value of this quaternion.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>0</code>  
<a name="Quaternion+w"></a>

### quaternion.w : <code>number</code>
The w value of this quaternion.

**Kind**: instance property of [<code>Quaternion</code>](#Quaternion)  
**Default**: <code>1</code>  
<a name="Quaternion+set"></a>

### quaternion.set(x, y, z, w) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets the quaternion components.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value of this quaternion. |
| y | <code>number</code> | The y value of this quaternion. |
| z | <code>number</code> | The z value of this quaternion. |
| w | <code>number</code> | The w value of this quaternion. |

<a name="Quaternion+clone"></a>

### quaternion.clone() ⇒ [<code>Quaternion</code>](#Quaternion)
Returns a new quaternion with copied values from this instance.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A clone of this instance.  
<a name="Quaternion+copy"></a>

### quaternion.copy(quaternion) ⇒ [<code>Quaternion</code>](#Quaternion)
Copies the values of the given quaternion to this instance.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| quaternion | [<code>Quaternion</code>](#Quaternion) | The quaternion to copy. |

<a name="Quaternion+setFromEuler"></a>

### quaternion.setFromEuler(euler, [update]) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion from the rotation specified by the given
Euler angles.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| euler | <code>Euler</code> |  | The Euler angles. |
| [update] | <code>boolean</code> | <code>true</code> | Whether the internal `onChange` callback should be executed or not. |

<a name="Quaternion+setFromAxisAngle"></a>

### quaternion.setFromAxisAngle(axis, angle) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion from the given axis and angle.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>Vector3</code> | The normalized axis. |
| angle | <code>number</code> | The angle in radians. |

<a name="Quaternion+setFromRotationMatrix"></a>

### quaternion.setFromRotationMatrix(m) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion from the given rotation matrix.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled). |

<a name="Quaternion+setFromUnitVectors"></a>

### quaternion.setFromUnitVectors(vFrom, vTo) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion to the rotation required to rotate the direction vector
`vFrom` to the direction vector `vTo`.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| vFrom | <code>Vector3</code> | The first (normalized) direction vector. |
| vTo | <code>Vector3</code> | The second (normalized) direction vector. |

<a name="Quaternion+angleTo"></a>

### quaternion.angleTo(q) ⇒ <code>number</code>
Returns the angle between this quaternion and the given one in radians.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>number</code> - The angle in radians.  

| Param | Type | Description |
| --- | --- | --- |
| q | [<code>Quaternion</code>](#Quaternion) | The quaternion to compute the angle with. |

<a name="Quaternion+rotateTowards"></a>

### quaternion.rotateTowards(q, step) ⇒ [<code>Quaternion</code>](#Quaternion)
Rotates this quaternion by a given angular step to the given quaternion.
The method ensures that the final quaternion will not overshoot `q`.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| q | [<code>Quaternion</code>](#Quaternion) | The target quaternion. |
| step | <code>number</code> | The angular step in radians. |

<a name="Quaternion+identity"></a>

### quaternion.identity() ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion to the identity quaternion; that is, to the
quaternion that represents "no rotation".

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+invert"></a>

### quaternion.invert() ⇒ [<code>Quaternion</code>](#Quaternion)
Inverts this quaternion via [conjugate](#Quaternion+conjugate). The
quaternion is assumed to have unit length.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+conjugate"></a>

### quaternion.conjugate() ⇒ [<code>Quaternion</code>](#Quaternion)
Returns the rotational conjugate of this quaternion. The conjugate of a
quaternion represents the same rotation in the opposite direction about
the rotational axis.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+dot"></a>

### quaternion.dot(v) ⇒ <code>number</code>
Calculates the dot product of this quaternion and the given one.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>number</code> - The result of the dot product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Quaternion</code>](#Quaternion) | The quaternion to compute the dot product with. |

<a name="Quaternion+lengthSq"></a>

### quaternion.lengthSq() ⇒ <code>number</code>
Computes the squared Euclidean length (straight-line length) of this quaternion,
considered as a 4 dimensional vector. This can be useful if you are comparing the
lengths of two quaternions, as this is a slightly more efficient calculation than
[length](#Quaternion+length).

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>number</code> - The squared Euclidean length.  
<a name="Quaternion+length"></a>

### quaternion.length() ⇒ <code>number</code>
Computes the Euclidean length (straight-line length) of this quaternion,
considered as a 4 dimensional vector.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>number</code> - The Euclidean length.  
<a name="Quaternion+normalize"></a>

### quaternion.normalize() ⇒ [<code>Quaternion</code>](#Quaternion)
Normalizes this quaternion - that is, calculated the quaternion that performs
the same rotation as this one, but has a length equal to `1`.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+multiply"></a>

### quaternion.multiply(q) ⇒ [<code>Quaternion</code>](#Quaternion)
Multiplies this quaternion by the given one.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| q | [<code>Quaternion</code>](#Quaternion) | The quaternion. |

<a name="Quaternion+premultiply"></a>

### quaternion.premultiply(q) ⇒ [<code>Quaternion</code>](#Quaternion)
Pre-multiplies this quaternion by the given one.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| q | [<code>Quaternion</code>](#Quaternion) | The quaternion. |

<a name="Quaternion+multiplyQuaternions"></a>

### quaternion.multiplyQuaternions(a, b) ⇒ [<code>Quaternion</code>](#Quaternion)
Multiplies the given quaternions and stores the result in this instance.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Quaternion</code>](#Quaternion) | The first quaternion. |
| b | [<code>Quaternion</code>](#Quaternion) | The second quaternion. |

<a name="Quaternion+slerp"></a>

### quaternion.slerp(qb, t) ⇒ [<code>Quaternion</code>](#Quaternion)
Performs a spherical linear interpolation between quaternions.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| qb | [<code>Quaternion</code>](#Quaternion) | The target quaternion. |
| t | <code>number</code> | The interpolation factor in the closed interval `[0, 1]`. |

<a name="Quaternion+slerpQuaternions"></a>

### quaternion.slerpQuaternions(qa, qb, t) ⇒ [<code>Quaternion</code>](#Quaternion)
Performs a spherical linear interpolation between the given quaternions
and stores the result in this quaternion.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| qa | [<code>Quaternion</code>](#Quaternion) | The source quaternion. |
| qb | [<code>Quaternion</code>](#Quaternion) | The target quaternion. |
| t | <code>number</code> | The interpolation factor in the closed interval `[0, 1]`. |

<a name="Quaternion+random"></a>

### quaternion.random() ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion to a uniformly random, normalized quaternion.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  
<a name="Quaternion+equals"></a>

### quaternion.equals(quaternion) ⇒ <code>boolean</code>
Returns `true` if this quaternion is equal with the given one.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>boolean</code> - Whether this quaternion is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| quaternion | [<code>Quaternion</code>](#Quaternion) | The quaternion to test for equality. |

<a name="Quaternion+fromArray"></a>

### quaternion.fromArray(array, [offset]) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets this quaternion's components from the given array.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the quaternion component values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Quaternion+toArray"></a>

### quaternion.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the components of this quaternion to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>Array.&lt;number&gt;</code> - The quaternion components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the quaternion components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Quaternion+fromBufferAttribute"></a>

### quaternion.fromBufferAttribute(attribute, index) ⇒ [<code>Quaternion</code>](#Quaternion)
Sets the components of this quaternion from the given buffer attribute.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: [<code>Quaternion</code>](#Quaternion) - A reference to this quaternion.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding quaternion data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Quaternion+toJSON"></a>

### quaternion.toJSON() ⇒ <code>Array.&lt;number&gt;</code>
This methods defines the serialization result of this class. Returns the
numerical elements of this quaternion in an array of format `[x, y, z, w]`.

**Kind**: instance method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>Array.&lt;number&gt;</code> - The serialized quaternion.  
<a name="Quaternion.slerpFlat"></a>

### Quaternion.slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t)
Interpolates between two quaternions via SLERP. This implementation assumes the
quaternion data are managed  in flat arrays.

**Kind**: static method of [<code>Quaternion</code>](#Quaternion)  
**See**: [slerp](#Quaternion+slerp)  

| Param | Type | Description |
| --- | --- | --- |
| dst | <code>Array.&lt;number&gt;</code> | The destination array. |
| dstOffset | <code>number</code> | An offset into the destination array. |
| src0 | <code>Array.&lt;number&gt;</code> | The source array of the first quaternion. |
| srcOffset0 | <code>number</code> | An offset into the first source array. |
| src1 | <code>Array.&lt;number&gt;</code> | The source array of the second quaternion. |
| srcOffset1 | <code>number</code> | An offset into the second source array. |
| t | <code>number</code> | The interpolation factor in the range `[0,1]`. |

<a name="Quaternion.multiplyQuaternionsFlat"></a>

### Quaternion.multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) ⇒ <code>Array.&lt;number&gt;</code>
Multiplies two quaternions. This implementation assumes the quaternion data are managed
in flat arrays.

**Kind**: static method of [<code>Quaternion</code>](#Quaternion)  
**Returns**: <code>Array.&lt;number&gt;</code> - The destination array.  
**See**: [multiplyQuaternions](#Quaternion+multiplyQuaternions).  

| Param | Type | Description |
| --- | --- | --- |
| dst | <code>Array.&lt;number&gt;</code> | The destination array. |
| dstOffset | <code>number</code> | An offset into the destination array. |
| src0 | <code>Array.&lt;number&gt;</code> | The source array of the first quaternion. |
| srcOffset0 | <code>number</code> | An offset into the first source array. |
| src1 | <code>Array.&lt;number&gt;</code> | The source array of the second quaternion. |
| srcOffset1 | <code>number</code> | An offset into the second source array. |

<a name="Ray"></a>

## Ray
A ray that emits from an origin in a certain direction. The class is used by
[Raycaster](Raycaster) to assist with raycasting. Raycasting is used for
mouse picking (working out what objects in the 3D space the mouse is over)
amongst other things.

**Kind**: global class  

* [Ray](#Ray)
    * [new Ray([origin], [direction])](#new_Ray_new)
    * [.origin](#Ray+origin) : <code>Vector3</code>
    * [.direction](#Ray+direction) : <code>Vector3</code>
    * [.set(origin, direction)](#Ray+set) ⇒ [<code>Ray</code>](#Ray)
    * [.copy(ray)](#Ray+copy) ⇒ [<code>Ray</code>](#Ray)
    * [.at(t, target)](#Ray+at) ⇒ <code>Vector3</code>
    * [.lookAt(v)](#Ray+lookAt) ⇒ [<code>Ray</code>](#Ray)
    * [.recast(t)](#Ray+recast) ⇒ [<code>Ray</code>](#Ray)
    * [.closestPointToPoint(point, target)](#Ray+closestPointToPoint) ⇒ <code>Vector3</code>
    * [.distanceToPoint(point)](#Ray+distanceToPoint) ⇒ <code>number</code>
    * [.distanceSqToPoint(point)](#Ray+distanceSqToPoint) ⇒ <code>number</code>
    * [.distanceSqToSegment(v0, v1, [optionalPointOnRay], [optionalPointOnSegment])](#Ray+distanceSqToSegment) ⇒ <code>number</code>
    * [.intersectSphere(sphere, target)](#Ray+intersectSphere) ⇒ <code>Vector3</code>
    * [.intersectsSphere(sphere)](#Ray+intersectsSphere) ⇒ <code>boolean</code>
    * [.distanceToPlane(plane)](#Ray+distanceToPlane) ⇒ <code>number</code>
    * [.intersectPlane(plane, target)](#Ray+intersectPlane) ⇒ <code>Vector3</code>
    * [.intersectsPlane(plane)](#Ray+intersectsPlane) ⇒ <code>boolean</code>
    * [.intersectBox(box, target)](#Ray+intersectBox) ⇒ <code>Vector3</code>
    * [.intersectsBox(box)](#Ray+intersectsBox) ⇒ <code>boolean</code>
    * [.intersectTriangle(a, b, c, backfaceCulling, target)](#Ray+intersectTriangle) ⇒ <code>Vector3</code>
    * [.applyMatrix4(matrix4)](#Ray+applyMatrix4) ⇒ [<code>Ray</code>](#Ray)
    * [.equals(ray)](#Ray+equals) ⇒ <code>boolean</code>
    * [.clone()](#Ray+clone) ⇒ [<code>Ray</code>](#Ray)

<a name="new_Ray_new"></a>

### new Ray([origin], [direction])
Constructs a new ray.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [origin] | <code>Vector3</code> | <code>(0,0,0)</code> | The origin of the ray. |
| [direction] | <code>Vector3</code> | <code>(0,0,-1)</code> | The (normalized) direction of the ray. |

<a name="Ray+origin"></a>

### ray.origin : <code>Vector3</code>
The origin of the ray.

**Kind**: instance property of [<code>Ray</code>](#Ray)  
<a name="Ray+direction"></a>

### ray.direction : <code>Vector3</code>
The (normalized) direction of the ray.

**Kind**: instance property of [<code>Ray</code>](#Ray)  
<a name="Ray+set"></a>

### ray.set(origin, direction) ⇒ [<code>Ray</code>](#Ray)
Sets the ray's components by copying the given values.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| origin | <code>Vector3</code> | The origin. |
| direction | <code>Vector3</code> | The direction. |

<a name="Ray+copy"></a>

### ray.copy(ray) ⇒ [<code>Ray</code>](#Ray)
Copies the values of the given ray to this instance.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| ray | [<code>Ray</code>](#Ray) | The ray to copy. |

<a name="Ray+at"></a>

### ray.at(t, target) ⇒ <code>Vector3</code>
Returns a vector that is located at a given distance along this ray.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - A position on the ray.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The distance along the ray to retrieve a position for. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+lookAt"></a>

### ray.lookAt(v) ⇒ [<code>Ray</code>](#Ray)
Adjusts the direction of the ray to point at the given vector in world space.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The target position. |

<a name="Ray+recast"></a>

### ray.recast(t) ⇒ [<code>Ray</code>](#Ray)
Shift the origin of this ray along its direction by the given distance.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| t | <code>number</code> | The distance along the ray to interpolate. |

<a name="Ray+closestPointToPoint"></a>

### ray.closestPointToPoint(point, target) ⇒ <code>Vector3</code>
Returns the point along this ray that is closest to the given point.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The closest point on this ray.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space to get the closet location on the ray for. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+distanceToPoint"></a>

### ray.distanceToPoint(point) ⇒ <code>number</code>
Returns the distance of the closest approach between this ray and the given point.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>number</code> - The distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space to compute the distance to. |

<a name="Ray+distanceSqToPoint"></a>

### ray.distanceSqToPoint(point) ⇒ <code>number</code>
Returns the squared distance of the closest approach between this ray and the given point.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>number</code> - The squared distance.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space to compute the distance to. |

<a name="Ray+distanceSqToSegment"></a>

### ray.distanceSqToSegment(v0, v1, [optionalPointOnRay], [optionalPointOnSegment]) ⇒ <code>number</code>
Returns the squared distance between this ray and the given line segment.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>number</code> - The squared distance.  

| Param | Type | Description |
| --- | --- | --- |
| v0 | <code>Vector3</code> | The start point of the line segment. |
| v1 | <code>Vector3</code> | The end point of the line segment. |
| [optionalPointOnRay] | <code>Vector3</code> | When provided, it receives the point on this ray that is closest to the segment. |
| [optionalPointOnSegment] | <code>Vector3</code> | When provided, it receives the point on the line segment that is closest to this ray. |

<a name="Ray+intersectSphere"></a>

### ray.intersectSphere(sphere, target) ⇒ <code>Vector3</code>
Intersects this ray with the given sphere, returning the intersection
point or `null` if there is no intersection.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to intersect. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+intersectsSphere"></a>

### ray.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if this ray intersects with the given sphere.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>boolean</code> - Whether this ray intersects with the given sphere or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to intersect. |

<a name="Ray+distanceToPlane"></a>

### ray.distanceToPlane(plane) ⇒ <code>number</code>
Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
does not intersect with the plane.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>number</code> - Whether this ray intersects with the given sphere or not.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to compute the distance to. |

<a name="Ray+intersectPlane"></a>

### ray.intersectPlane(plane, target) ⇒ <code>Vector3</code>
Intersects this ray with the given plane, returning the intersection
point or `null` if there is no intersection.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to intersect. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+intersectsPlane"></a>

### ray.intersectsPlane(plane) ⇒ <code>boolean</code>
Returns `true` if this ray intersects with the given plane.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>boolean</code> - Whether this ray intersects with the given plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to intersect. |

<a name="Ray+intersectBox"></a>

### ray.intersectBox(box, target) ⇒ <code>Vector3</code>
Intersects this ray with the given bounding box, returning the intersection
point or `null` if there is no intersection.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The box to intersect. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+intersectsBox"></a>

### ray.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if this ray intersects with the given box.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>boolean</code> - Whether this ray intersects with the given box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The box to intersect. |

<a name="Ray+intersectTriangle"></a>

### ray.intersectTriangle(a, b, c, backfaceCulling, target) ⇒ <code>Vector3</code>
Intersects this ray with the given triangle, returning the intersection
point or `null` if there is no intersection.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>Vector3</code> - The intersection point.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first vertex of the triangle. |
| b | <code>Vector3</code> | The second vertex of the triangle. |
| c | <code>Vector3</code> | The third vertex of the triangle. |
| backfaceCulling | <code>boolean</code> | Whether to use backface culling or not. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Ray+applyMatrix4"></a>

### ray.applyMatrix4(matrix4) ⇒ [<code>Ray</code>](#Ray)
Transforms this ray with the given 4x4 transformation matrix.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A reference to this ray.  

| Param | Type | Description |
| --- | --- | --- |
| matrix4 | <code>Matrix4</code> | The transformation matrix. |

<a name="Ray+equals"></a>

### ray.equals(ray) ⇒ <code>boolean</code>
Returns `true` if this ray is equal with the given one.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: <code>boolean</code> - Whether this ray is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| ray | [<code>Ray</code>](#Ray) | The ray to test for equality. |

<a name="Ray+clone"></a>

### ray.clone() ⇒ [<code>Ray</code>](#Ray)
Returns a new ray with copied values from this instance.

**Kind**: instance method of [<code>Ray</code>](#Ray)  
**Returns**: [<code>Ray</code>](#Ray) - A clone of this instance.  
<a name="Sphere"></a>

## Sphere
An analytical 3D sphere defined by a center and radius. This class is mainly
used as a Bounding Sphere for 3D objects.

**Kind**: global class  

* [Sphere](#Sphere)
    * [new Sphere([center], [radius])](#new_Sphere_new)
    * [.isSphere](#Sphere+isSphere) : <code>boolean</code>
    * [.center](#Sphere+center) : <code>Vector3</code>
    * [.radius](#Sphere+radius) : <code>number</code>
    * [.set(center, radius)](#Sphere+set) ⇒ [<code>Sphere</code>](#Sphere)
    * [.setFromPoints(points, [optionalCenter])](#Sphere+setFromPoints) ⇒ [<code>Sphere</code>](#Sphere)
    * [.copy(sphere)](#Sphere+copy) ⇒ [<code>Sphere</code>](#Sphere)
    * [.isEmpty()](#Sphere+isEmpty) ⇒ <code>boolean</code>
    * [.makeEmpty()](#Sphere+makeEmpty) ⇒ [<code>Sphere</code>](#Sphere)
    * [.containsPoint(point)](#Sphere+containsPoint) ⇒ <code>boolean</code>
    * [.distanceToPoint(point)](#Sphere+distanceToPoint) ⇒ <code>number</code>
    * [.intersectsSphere(sphere)](#Sphere+intersectsSphere) ⇒ <code>boolean</code>
    * [.intersectsBox(box)](#Sphere+intersectsBox) ⇒ <code>boolean</code>
    * [.intersectsPlane(plane)](#Sphere+intersectsPlane) ⇒ <code>boolean</code>
    * [.clampPoint(point, target)](#Sphere+clampPoint) ⇒ <code>Vector3</code>
    * [.getBoundingBox(target)](#Sphere+getBoundingBox) ⇒ <code>Box3</code>
    * [.applyMatrix4(matrix)](#Sphere+applyMatrix4) ⇒ [<code>Sphere</code>](#Sphere)
    * [.translate(offset)](#Sphere+translate) ⇒ [<code>Sphere</code>](#Sphere)
    * [.expandByPoint(point)](#Sphere+expandByPoint) ⇒ [<code>Sphere</code>](#Sphere)
    * [.union(sphere)](#Sphere+union) ⇒ [<code>Sphere</code>](#Sphere)
    * [.equals(sphere)](#Sphere+equals) ⇒ <code>boolean</code>
    * [.clone()](#Sphere+clone) ⇒ [<code>Sphere</code>](#Sphere)

<a name="new_Sphere_new"></a>

### new Sphere([center], [radius])
Constructs a new sphere.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [center] | <code>Vector3</code> | <code>(0,0,0)</code> | The center of the sphere |
| [radius] | <code>number</code> | <code>-1</code> | The radius of the sphere. |

<a name="Sphere+isSphere"></a>

### sphere.isSphere : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Sphere</code>](#Sphere)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Sphere+center"></a>

### sphere.center : <code>Vector3</code>
The center of the sphere

**Kind**: instance property of [<code>Sphere</code>](#Sphere)  
<a name="Sphere+radius"></a>

### sphere.radius : <code>number</code>
The radius of the sphere.

**Kind**: instance property of [<code>Sphere</code>](#Sphere)  
<a name="Sphere+set"></a>

### sphere.set(center, radius) ⇒ [<code>Sphere</code>](#Sphere)
Sets the sphere's components by copying the given values.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| center | <code>Vector3</code> | The center. |
| radius | <code>number</code> | The radius. |

<a name="Sphere+setFromPoints"></a>

### sphere.setFromPoints(points, [optionalCenter]) ⇒ [<code>Sphere</code>](#Sphere)
Computes the minimum bounding sphere for list of points.
If the optional center point is given, it is used as the sphere's
center. Otherwise, the center of the axis-aligned bounding box
encompassing the points is calculated.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector3&gt;</code> | A list of points in 3D space. |
| [optionalCenter] | <code>Vector3</code> | The center of the sphere. |

<a name="Sphere+copy"></a>

### sphere.copy(sphere) ⇒ [<code>Sphere</code>](#Sphere)
Copies the values of the given sphere to this instance.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | [<code>Sphere</code>](#Sphere) | The sphere to copy. |

<a name="Sphere+isEmpty"></a>

### sphere.isEmpty() ⇒ <code>boolean</code>
Returns `true` if the sphere is empty (the radius set to a negative number).

Spheres with a radius of `0` contain only their center point and are not
considered to be empty.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere is empty or not.  
<a name="Sphere+makeEmpty"></a>

### sphere.makeEmpty() ⇒ [<code>Sphere</code>](#Sphere)
Makes this sphere empty which means in encloses a zero space in 3D.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  
<a name="Sphere+containsPoint"></a>

### sphere.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if this sphere contains the given point inclusive of
the surface of the sphere.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere contains the given point or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to check. |

<a name="Sphere+distanceToPoint"></a>

### sphere.distanceToPoint(point) ⇒ <code>number</code>
Returns the closest distance from the boundary of the sphere to the
given point. If the sphere contains the point, the distance will
be negative.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>number</code> - The distance to the point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to compute the distance to. |

<a name="Sphere+intersectsSphere"></a>

### sphere.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if this sphere intersects with the given one.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere intersects with the given one or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | [<code>Sphere</code>](#Sphere) | The sphere to test. |

<a name="Sphere+intersectsBox"></a>

### sphere.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if this sphere intersects with the given box.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere intersects with the given box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The box to test. |

<a name="Sphere+intersectsPlane"></a>

### sphere.intersectsPlane(plane) ⇒ <code>boolean</code>
Returns `true` if this sphere intersects with the given plane.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this sphere intersects with the given plane or not.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to test. |

<a name="Sphere+clampPoint"></a>

### sphere.clampPoint(point, target) ⇒ <code>Vector3</code>
Clamps a point within the sphere. If the point is outside the sphere, it
will clamp it to the closest point on the edge of the sphere. Points
already inside the sphere will not be affected.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>Vector3</code> - The clamped point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The plane to clamp. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Sphere+getBoundingBox"></a>

### sphere.getBoundingBox(target) ⇒ <code>Box3</code>
Returns a bounding box that encloses this sphere.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>Box3</code> - The bounding box that encloses this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Box3</code> | The target box that is used to store the method's result. |

<a name="Sphere+applyMatrix4"></a>

### sphere.applyMatrix4(matrix) ⇒ [<code>Sphere</code>](#Sphere)
Transforms this sphere with the given 4x4 transformation matrix.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The transformation matrix. |

<a name="Sphere+translate"></a>

### sphere.translate(offset) ⇒ [<code>Sphere</code>](#Sphere)
Translates the sphere's center by the given offset.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| offset | <code>Vector3</code> | The offset. |

<a name="Sphere+expandByPoint"></a>

### sphere.expandByPoint(point) ⇒ [<code>Sphere</code>](#Sphere)
Expands the boundaries of this sphere to include the given point.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to include. |

<a name="Sphere+union"></a>

### sphere.union(sphere) ⇒ [<code>Sphere</code>](#Sphere)
Expands this sphere to enclose both the original sphere and the given sphere.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A reference to this sphere.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | [<code>Sphere</code>](#Sphere) | The sphere to include. |

<a name="Sphere+equals"></a>

### sphere.equals(sphere) ⇒ <code>boolean</code>
Returns `true` if this sphere is equal with the given one.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: <code>boolean</code> - Whether this bounding sphere is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | [<code>Sphere</code>](#Sphere) | The sphere to test for equality. |

<a name="Sphere+clone"></a>

### sphere.clone() ⇒ [<code>Sphere</code>](#Sphere)
Returns a new sphere with copied values from this instance.

**Kind**: instance method of [<code>Sphere</code>](#Sphere)  
**Returns**: [<code>Sphere</code>](#Sphere) - A clone of this instance.  
<a name="Spherical"></a>

## Spherical
This class can be used to represent points in 3D space as
[Spherical coordinates](https://en.wikipedia.org/wiki/Spherical_coordinate_system).

**Kind**: global class  

* [Spherical](#Spherical)
    * [new Spherical([radius], [phi], [theta])](#new_Spherical_new)
    * [.radius](#Spherical+radius) : <code>number</code>
    * [.phi](#Spherical+phi) : <code>number</code>
    * [.theta](#Spherical+theta) : <code>number</code>
    * [.set(radius, phi, theta)](#Spherical+set) ⇒ [<code>Spherical</code>](#Spherical)
    * [.copy(other)](#Spherical+copy) ⇒ [<code>Spherical</code>](#Spherical)
    * [.makeSafe()](#Spherical+makeSafe) ⇒ [<code>Spherical</code>](#Spherical)
    * [.setFromVector3(v)](#Spherical+setFromVector3) ⇒ [<code>Spherical</code>](#Spherical)
    * [.setFromCartesianCoords(x, y, z)](#Spherical+setFromCartesianCoords) ⇒ [<code>Spherical</code>](#Spherical)
    * [.clone()](#Spherical+clone) ⇒ [<code>Spherical</code>](#Spherical)

<a name="new_Spherical_new"></a>

### new Spherical([radius], [phi], [theta])
Constructs a new spherical.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [radius] | <code>number</code> | <code>1</code> | The radius, or the Euclidean distance (straight-line distance) from the point to the origin. |
| [phi] | <code>number</code> | <code>0</code> | The polar angle in radians from the y (up) axis. |
| [theta] | <code>number</code> | <code>0</code> | The equator/azimuthal angle in radians around the y (up) axis. |

<a name="Spherical+radius"></a>

### spherical.radius : <code>number</code>
The radius, or the Euclidean distance (straight-line distance) from the point to the origin.

**Kind**: instance property of [<code>Spherical</code>](#Spherical)  
**Default**: <code>1</code>  
<a name="Spherical+phi"></a>

### spherical.phi : <code>number</code>
The polar angle in radians from the y (up) axis.

**Kind**: instance property of [<code>Spherical</code>](#Spherical)  
**Default**: <code>0</code>  
<a name="Spherical+theta"></a>

### spherical.theta : <code>number</code>
The equator/azimuthal angle in radians around the y (up) axis.

**Kind**: instance property of [<code>Spherical</code>](#Spherical)  
**Default**: <code>0</code>  
<a name="Spherical+set"></a>

### spherical.set(radius, phi, theta) ⇒ [<code>Spherical</code>](#Spherical)
Sets the spherical components by copying the given values.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  

| Param | Type | Description |
| --- | --- | --- |
| radius | <code>number</code> | The radius. |
| phi | <code>number</code> | The polar angle. |
| theta | <code>number</code> | The azimuthal angle. |

<a name="Spherical+copy"></a>

### spherical.copy(other) ⇒ [<code>Spherical</code>](#Spherical)
Copies the values of the given spherical to this instance.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  

| Param | Type | Description |
| --- | --- | --- |
| other | [<code>Spherical</code>](#Spherical) | The spherical to copy. |

<a name="Spherical+makeSafe"></a>

### spherical.makeSafe() ⇒ [<code>Spherical</code>](#Spherical)
Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
`0.000001`.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  
<a name="Spherical+setFromVector3"></a>

### spherical.setFromVector3(v) ⇒ [<code>Spherical</code>](#Spherical)
Sets the spherical components from the given vector which is assumed to hold
Cartesian coordinates.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The vector to set. |

<a name="Spherical+setFromCartesianCoords"></a>

### spherical.setFromCartesianCoords(x, y, z) ⇒ [<code>Spherical</code>](#Spherical)
Sets the spherical components from the given Cartesian coordinates.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A reference to this spherical.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value. |
| y | <code>number</code> | The x value. |
| z | <code>number</code> | The x value. |

<a name="Spherical+clone"></a>

### spherical.clone() ⇒ [<code>Spherical</code>](#Spherical)
Returns a new spherical with copied values from this instance.

**Kind**: instance method of [<code>Spherical</code>](#Spherical)  
**Returns**: [<code>Spherical</code>](#Spherical) - A clone of this instance.  
<a name="SphericalHarmonics3"></a>

## SphericalHarmonics3
Represents a third-order spherical harmonics (SH). Light probes use this class
to encode lighting information.

- Primary reference: [https://graphics.stanford.edu/papers/envmap/envmap.pdf](https://graphics.stanford.edu/papers/envmap/envmap.pdf)
- Secondary reference: [https://www.ppsloan.org/publications/StupidSH36.pdf](https://www.ppsloan.org/publications/StupidSH36.pdf)

**Kind**: global class  

* [SphericalHarmonics3](#SphericalHarmonics3)
    * [new SphericalHarmonics3()](#new_SphericalHarmonics3_new)
    * _instance_
        * [.isSphericalHarmonics3](#SphericalHarmonics3+isSphericalHarmonics3) : <code>boolean</code>
        * [.coefficients](#SphericalHarmonics3+coefficients) : <code>Array.&lt;Vector3&gt;</code>
        * [.set(coefficients)](#SphericalHarmonics3+set) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.zero()](#SphericalHarmonics3+zero) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.getAt(normal, target)](#SphericalHarmonics3+getAt) ⇒ <code>Vector3</code>
        * [.getIrradianceAt(normal, target)](#SphericalHarmonics3+getIrradianceAt) ⇒ <code>Vector3</code>
        * [.add(sh)](#SphericalHarmonics3+add) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.addScaledSH(sh, s)](#SphericalHarmonics3+addScaledSH) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.scale(s)](#SphericalHarmonics3+scale) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.lerp(sh, alpha)](#SphericalHarmonics3+lerp) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.equals(sh)](#SphericalHarmonics3+equals) ⇒ <code>boolean</code>
        * [.copy(sh)](#SphericalHarmonics3+copy) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.clone()](#SphericalHarmonics3+clone) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.fromArray(array, [offset])](#SphericalHarmonics3+fromArray) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
        * [.toArray([array], [offset])](#SphericalHarmonics3+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * _static_
        * [.getBasisAt(normal, shBasis)](#SphericalHarmonics3.getBasisAt)

<a name="new_SphericalHarmonics3_new"></a>

### new SphericalHarmonics3()
Constructs a new spherical harmonics.

<a name="SphericalHarmonics3+isSphericalHarmonics3"></a>

### sphericalHarmonics3.isSphericalHarmonics3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SphericalHarmonics3+coefficients"></a>

### sphericalHarmonics3.coefficients : <code>Array.&lt;Vector3&gt;</code>
An array holding the (9) SH coefficients.

**Kind**: instance property of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
<a name="SphericalHarmonics3+set"></a>

### sphericalHarmonics3.set(coefficients) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Sets the given SH coefficients to this instance by copying
the values.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| coefficients | <code>Array.&lt;Vector3&gt;</code> | The SH coefficients. |

<a name="SphericalHarmonics3+zero"></a>

### sphericalHarmonics3.zero() ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Sets all SH coefficients to `0`.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  
<a name="SphericalHarmonics3+getAt"></a>

### sphericalHarmonics3.getAt(normal, target) ⇒ <code>Vector3</code>
Returns the radiance in the direction of the given normal.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: <code>Vector3</code> - The radiance.  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal vector (assumed to be unit length) |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="SphericalHarmonics3+getIrradianceAt"></a>

### sphericalHarmonics3.getIrradianceAt(normal, target) ⇒ <code>Vector3</code>
Returns the irradiance (radiance convolved with cosine lobe) in the
direction of the given normal.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: <code>Vector3</code> - The irradiance.  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal vector (assumed to be unit length) |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="SphericalHarmonics3+add"></a>

### sphericalHarmonics3.add(sh) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Adds the given SH to this instance.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The SH to add. |

<a name="SphericalHarmonics3+addScaledSH"></a>

### sphericalHarmonics3.addScaledSH(sh, s) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
A convenience method for performing [add](#SphericalHarmonics3+add) and
[scale](#SphericalHarmonics3+scale) at once.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The SH to add. |
| s | <code>number</code> | The scale factor. |

<a name="SphericalHarmonics3+scale"></a>

### sphericalHarmonics3.scale(s) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Scales this SH by the given scale factor.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scale factor. |

<a name="SphericalHarmonics3+lerp"></a>

### sphericalHarmonics3.lerp(sh, alpha) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Linear interpolates between the given SH and this instance by the given
alpha factor.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The SH to interpolate with. |
| alpha | <code>number</code> | The alpha factor. |

<a name="SphericalHarmonics3+equals"></a>

### sphericalHarmonics3.equals(sh) ⇒ <code>boolean</code>
Returns `true` if this spherical harmonics is equal with the given one.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: <code>boolean</code> - Whether this spherical harmonics is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The spherical harmonics to test for equality. |

<a name="SphericalHarmonics3+copy"></a>

### sphericalHarmonics3.copy(sh) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Copies the values of the given spherical harmonics to this instance.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A reference to this spherical harmonics.  

| Param | Type | Description |
| --- | --- | --- |
| sh | [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) | The spherical harmonics to copy. |

<a name="SphericalHarmonics3+clone"></a>

### sphericalHarmonics3.clone() ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Returns a new spherical harmonics with copied values from this instance.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A clone of this instance.  
<a name="SphericalHarmonics3+fromArray"></a>

### sphericalHarmonics3.fromArray(array, [offset]) ⇒ [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)
Sets the SH coefficients of this instance from the given array.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: [<code>SphericalHarmonics3</code>](#SphericalHarmonics3) - A clone of this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the SH coefficients. |
| [offset] | <code>number</code> | <code>0</code> | The array offset where to start copying. |

<a name="SphericalHarmonics3+toArray"></a>

### sphericalHarmonics3.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Returns an array with the SH coefficients, or copies them into the provided
array. The coefficients are represented as numbers.

**Kind**: instance method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  
**Returns**: <code>Array.&lt;number&gt;</code> - An array with flat SH coefficients.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array. |
| [offset] | <code>number</code> | <code>0</code> | The array offset where to start copying. |

<a name="SphericalHarmonics3.getBasisAt"></a>

### SphericalHarmonics3.getBasisAt(normal, shBasis)
Computes the SH basis for the given normal vector.

**Kind**: static method of [<code>SphericalHarmonics3</code>](#SphericalHarmonics3)  

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Vector3</code> | The normal. |
| shBasis | <code>Array.&lt;number&gt;</code> | The target array holding the SH basis. |

<a name="Triangle"></a>

## Triangle
A geometric triangle as defined by three vectors representing its three corners.

**Kind**: global class  

* [Triangle](#Triangle)
    * [new Triangle([a], [b], [c])](#new_Triangle_new)
    * _instance_
        * [.a](#Triangle+a) : <code>Vector3</code>
        * [.b](#Triangle+b) : <code>Vector3</code>
        * [.c](#Triangle+c) : <code>Vector3</code>
        * [.set(a, b, c)](#Triangle+set) ⇒ [<code>Triangle</code>](#Triangle)
        * [.setFromPointsAndIndices(points, i0, i1, i2)](#Triangle+setFromPointsAndIndices) ⇒ [<code>Triangle</code>](#Triangle)
        * [.setFromAttributeAndIndices(attribute, i0, i1, i2)](#Triangle+setFromAttributeAndIndices) ⇒ [<code>Triangle</code>](#Triangle)
        * [.clone()](#Triangle+clone) ⇒ [<code>Triangle</code>](#Triangle)
        * [.copy(triangle)](#Triangle+copy) ⇒ [<code>Triangle</code>](#Triangle)
        * [.getArea()](#Triangle+getArea) ⇒ <code>number</code>
        * [.getMidpoint(target)](#Triangle+getMidpoint) ⇒ <code>Vector3</code>
        * [.getNormal(target)](#Triangle+getNormal) ⇒ <code>Vector3</code>
        * [.getPlane(target)](#Triangle+getPlane) ⇒ <code>Plane</code>
        * [.getBarycoord(point, target)](#Triangle+getBarycoord) ⇒ <code>Vector3</code>
        * [.getInterpolation(point, v1, v2, v3, target)](#Triangle+getInterpolation) ⇒ <code>Vector3</code>
        * [.containsPoint(point)](#Triangle+containsPoint) ⇒ <code>boolean</code>
        * [.isFrontFacing(direction)](#Triangle+isFrontFacing) ⇒ <code>boolean</code>
        * [.intersectsBox(box)](#Triangle+intersectsBox) ⇒ <code>boolean</code>
        * [.closestPointToPoint(p, target)](#Triangle+closestPointToPoint) ⇒ <code>Vector3</code>
        * [.equals(triangle)](#Triangle+equals) ⇒ <code>boolean</code>
    * _static_
        * [.getNormal(a, b, c, target)](#Triangle.getNormal) ⇒ <code>Vector3</code>
        * [.getBarycoord(point, a, b, c, target)](#Triangle.getBarycoord) ⇒ <code>Vector3</code>
        * [.containsPoint(point, a, b, c)](#Triangle.containsPoint) ⇒ <code>boolean</code>
        * [.getInterpolation(point, p1, p2, p3, v1, v2, v3, target)](#Triangle.getInterpolation) ⇒ <code>Vector3</code>
        * [.getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target)](#Triangle.getInterpolatedAttribute) ⇒ <code>Vector3</code>
        * [.isFrontFacing(a, b, c, direction)](#Triangle.isFrontFacing) ⇒ <code>boolean</code>

<a name="new_Triangle_new"></a>

### new Triangle([a], [b], [c])
Constructs a new triangle.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [a] | <code>Vector3</code> | <code>(0,0,0)</code> | The first corner of the triangle. |
| [b] | <code>Vector3</code> | <code>(0,0,0)</code> | The second corner of the triangle. |
| [c] | <code>Vector3</code> | <code>(0,0,0)</code> | The third corner of the triangle. |

<a name="Triangle+a"></a>

### triangle.a : <code>Vector3</code>
The first corner of the triangle.

**Kind**: instance property of [<code>Triangle</code>](#Triangle)  
<a name="Triangle+b"></a>

### triangle.b : <code>Vector3</code>
The second corner of the triangle.

**Kind**: instance property of [<code>Triangle</code>](#Triangle)  
<a name="Triangle+c"></a>

### triangle.c : <code>Vector3</code>
The third corner of the triangle.

**Kind**: instance property of [<code>Triangle</code>](#Triangle)  
<a name="Triangle+set"></a>

### triangle.set(a, b, c) ⇒ [<code>Triangle</code>](#Triangle)
Sets the triangle's vertices by copying the given values.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A reference to this triangle.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |

<a name="Triangle+setFromPointsAndIndices"></a>

### triangle.setFromPointsAndIndices(points, i0, i1, i2) ⇒ [<code>Triangle</code>](#Triangle)
Sets the triangle's vertices by copying the given array values.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A reference to this triangle.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector3&gt;</code> | An array with 3D points. |
| i0 | <code>number</code> | The array index representing the first corner of the triangle. |
| i1 | <code>number</code> | The array index representing the second corner of the triangle. |
| i2 | <code>number</code> | The array index representing the third corner of the triangle. |

<a name="Triangle+setFromAttributeAndIndices"></a>

### triangle.setFromAttributeAndIndices(attribute, i0, i1, i2) ⇒ [<code>Triangle</code>](#Triangle)
Sets the triangle's vertices by copying the given attribute values.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A reference to this triangle.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | A buffer attribute with 3D points data. |
| i0 | <code>number</code> | The attribute index representing the first corner of the triangle. |
| i1 | <code>number</code> | The attribute index representing the second corner of the triangle. |
| i2 | <code>number</code> | The attribute index representing the third corner of the triangle. |

<a name="Triangle+clone"></a>

### triangle.clone() ⇒ [<code>Triangle</code>](#Triangle)
Returns a new triangle with copied values from this instance.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A clone of this instance.  
<a name="Triangle+copy"></a>

### triangle.copy(triangle) ⇒ [<code>Triangle</code>](#Triangle)
Copies the values of the given triangle to this instance.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: [<code>Triangle</code>](#Triangle) - A reference to this triangle.  

| Param | Type | Description |
| --- | --- | --- |
| triangle | [<code>Triangle</code>](#Triangle) | The triangle to copy. |

<a name="Triangle+getArea"></a>

### triangle.getArea() ⇒ <code>number</code>
Computes the area of the triangle.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>number</code> - The triangle's area.  
<a name="Triangle+getMidpoint"></a>

### triangle.getMidpoint(target) ⇒ <code>Vector3</code>
Computes the midpoint of the triangle.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The triangle's midpoint.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+getNormal"></a>

### triangle.getNormal(target) ⇒ <code>Vector3</code>
Computes the normal of the triangle.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The triangle's normal.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+getPlane"></a>

### triangle.getPlane(target) ⇒ <code>Plane</code>
Computes a plane the triangle lies within.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Plane</code> - The plane the triangle lies within.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Plane</code> | The target vector that is used to store the method's result. |

<a name="Triangle+getBarycoord"></a>

### triangle.getBarycoord(point, target) ⇒ <code>Vector3</code>
Computes a barycentric coordinates from the given vector.
Returns `null` if the triangle is degenerate.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The barycentric coordinates for the given point  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+getInterpolation"></a>

### triangle.getInterpolation(point, v1, v2, v3, target) ⇒ <code>Vector3</code>
Computes the value barycentrically interpolated for the given point on the
triangle. Returns `null` if the triangle is degenerate.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | Position of interpolated point. |
| v1 | <code>Vector3</code> | Value to interpolate of first vertex. |
| v2 | <code>Vector3</code> | Value to interpolate of second vertex. |
| v3 | <code>Vector3</code> | Value to interpolate of third vertex. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+containsPoint"></a>

### triangle.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point, when projected onto the plane of the
triangle, lies within the triangle.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether the given point, when projected onto the plane of the
triangle, lies within the triangle or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point in 3D space to test. |

<a name="Triangle+isFrontFacing"></a>

### triangle.isFrontFacing(direction) ⇒ <code>boolean</code>
Returns `true` if the triangle is oriented towards the given direction.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether the triangle is oriented towards the given direction or not.  

| Param | Type | Description |
| --- | --- | --- |
| direction | <code>Vector3</code> | The (normalized) direction vector. |

<a name="Triangle+intersectsBox"></a>

### triangle.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if this triangle intersects with the given box.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether this triangle intersects with the given box or not.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The box to intersect. |

<a name="Triangle+closestPointToPoint"></a>

### triangle.closestPointToPoint(p, target) ⇒ <code>Vector3</code>
Returns the closest point on the triangle to the given point.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The closest point on the triangle.  

| Param | Type | Description |
| --- | --- | --- |
| p | <code>Vector3</code> | The point to compute the closest point for. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle+equals"></a>

### triangle.equals(triangle) ⇒ <code>boolean</code>
Returns `true` if this triangle is equal with the given one.

**Kind**: instance method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether this triangle is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| triangle | [<code>Triangle</code>](#Triangle) | The triangle to test for equality. |

<a name="Triangle.getNormal"></a>

### Triangle.getNormal(a, b, c, target) ⇒ <code>Vector3</code>
Computes the normal vector of a triangle.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The triangle's normal.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle.getBarycoord"></a>

### Triangle.getBarycoord(point, a, b, c, target) ⇒ <code>Vector3</code>
Computes a barycentric coordinates from the given vector.
Returns `null` if the triangle is degenerate.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The barycentric coordinates for the given point  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | A point in 3D space. |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle.containsPoint"></a>

### Triangle.containsPoint(point, a, b, c) ⇒ <code>boolean</code>
Returns `true` if the given point, when projected onto the plane of the
triangle, lies within the triangle.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether the given point, when projected onto the plane of the
triangle, lies within the triangle or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point in 3D space to test. |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |

<a name="Triangle.getInterpolation"></a>

### Triangle.getInterpolation(point, p1, p2, p3, v1, v2, v3, target) ⇒ <code>Vector3</code>
Computes the value barycentrically interpolated for the given point on the
triangle. Returns `null` if the triangle is degenerate.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The interpolated value.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | Position of interpolated point. |
| p1 | <code>Vector3</code> | The first corner of the triangle. |
| p2 | <code>Vector3</code> | The second corner of the triangle. |
| p3 | <code>Vector3</code> | The third corner of the triangle. |
| v1 | <code>Vector3</code> | Value to interpolate of first vertex. |
| v2 | <code>Vector3</code> | Value to interpolate of second vertex. |
| v3 | <code>Vector3</code> | Value to interpolate of third vertex. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle.getInterpolatedAttribute"></a>

### Triangle.getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) ⇒ <code>Vector3</code>
Computes the value barycentrically interpolated for the given attribute and indices.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>Vector3</code> - The interpolated attribute value.  

| Param | Type | Description |
| --- | --- | --- |
| attr | <code>BufferAttribute</code> | The attribute to interpolate. |
| i1 | <code>number</code> | Index of first vertex. |
| i2 | <code>number</code> | Index of second vertex. |
| i3 | <code>number</code> | Index of third vertex. |
| barycoord | <code>Vector3</code> | The barycoordinate value to use to interpolate. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Triangle.isFrontFacing"></a>

### Triangle.isFrontFacing(a, b, c, direction) ⇒ <code>boolean</code>
Returns `true` if the triangle is oriented towards the given direction.

**Kind**: static method of [<code>Triangle</code>](#Triangle)  
**Returns**: <code>boolean</code> - Whether the triangle is oriented towards the given direction or not.  

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Vector3</code> | The first corner of the triangle. |
| b | <code>Vector3</code> | The second corner of the triangle. |
| c | <code>Vector3</code> | The third corner of the triangle. |
| direction | <code>Vector3</code> | The (normalized) direction vector. |

<a name="Vector2"></a>

## Vector2
Class representing a 2D vector. A 2D vector is an ordered pair of numbers
(labeled x and y), which can be used to represent a number of things, such as:

- A point in 2D space (i.e. a position on a plane).
- A direction and length across a plane. In three.js the length will
always be the Euclidean distance(straight-line distance) from `(0, 0)` to `(x, y)`
and the direction is also measured from `(0, 0)` towards `(x, y)`.
- Any arbitrary ordered pair of numbers.

There are other things a 2D vector can be used to represent, such as
momentum vectors, complex numbers and so on, however these are the most
common uses in three.js.

Iterating through a vector instance will yield its components `(x, y)` in
the corresponding order.
```js
const a = new THREE.Vector2( 0, 1 );

//no arguments; will be initialised to (0, 0)
const b = new THREE.Vector2( );

const d = a.distanceTo( b );
```

**Kind**: global class  

* [Vector2](#Vector2)
    * [new Vector2([x], [y])](#new_Vector2_new)
    * [.isVector2](#Vector2+isVector2) : <code>boolean</code>
    * [.x](#Vector2+x) : <code>number</code>
    * [.y](#Vector2+y) : <code>number</code>
    * [.width](#Vector2+width) : <code>number</code>
    * [.height](#Vector2+height) : <code>number</code>
    * [.set(x, y)](#Vector2+set) ⇒ [<code>Vector2</code>](#Vector2)
    * [.setScalar(scalar)](#Vector2+setScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.setX(x)](#Vector2+setX) ⇒ [<code>Vector2</code>](#Vector2)
    * [.setY(y)](#Vector2+setY) ⇒ [<code>Vector2</code>](#Vector2)
    * [.setComponent(index, value)](#Vector2+setComponent) ⇒ [<code>Vector2</code>](#Vector2)
    * [.getComponent(index)](#Vector2+getComponent) ⇒ <code>number</code>
    * [.clone()](#Vector2+clone) ⇒ [<code>Vector2</code>](#Vector2)
    * [.copy(v)](#Vector2+copy) ⇒ [<code>Vector2</code>](#Vector2)
    * [.add(v)](#Vector2+add) ⇒ [<code>Vector2</code>](#Vector2)
    * [.addScalar(s)](#Vector2+addScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.addVectors(a, b)](#Vector2+addVectors) ⇒ [<code>Vector2</code>](#Vector2)
    * [.addScaledVector(v, s)](#Vector2+addScaledVector) ⇒ [<code>Vector2</code>](#Vector2)
    * [.sub(v)](#Vector2+sub) ⇒ [<code>Vector2</code>](#Vector2)
    * [.subScalar(s)](#Vector2+subScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.subVectors(a, b)](#Vector2+subVectors) ⇒ [<code>Vector2</code>](#Vector2)
    * [.multiply(v)](#Vector2+multiply) ⇒ [<code>Vector2</code>](#Vector2)
    * [.multiplyScalar(scalar)](#Vector2+multiplyScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.divide(v)](#Vector2+divide) ⇒ [<code>Vector2</code>](#Vector2)
    * [.divideScalar(scalar)](#Vector2+divideScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.applyMatrix3(m)](#Vector2+applyMatrix3) ⇒ [<code>Vector2</code>](#Vector2)
    * [.min(v)](#Vector2+min) ⇒ [<code>Vector2</code>](#Vector2)
    * [.max(v)](#Vector2+max) ⇒ [<code>Vector2</code>](#Vector2)
    * [.clamp(min, max)](#Vector2+clamp) ⇒ [<code>Vector2</code>](#Vector2)
    * [.clampScalar(minVal, maxVal)](#Vector2+clampScalar) ⇒ [<code>Vector2</code>](#Vector2)
    * [.clampLength(min, max)](#Vector2+clampLength) ⇒ [<code>Vector2</code>](#Vector2)
    * [.floor()](#Vector2+floor) ⇒ [<code>Vector2</code>](#Vector2)
    * [.ceil()](#Vector2+ceil) ⇒ [<code>Vector2</code>](#Vector2)
    * [.round()](#Vector2+round) ⇒ [<code>Vector2</code>](#Vector2)
    * [.roundToZero()](#Vector2+roundToZero) ⇒ [<code>Vector2</code>](#Vector2)
    * [.negate()](#Vector2+negate) ⇒ [<code>Vector2</code>](#Vector2)
    * [.dot(v)](#Vector2+dot) ⇒ <code>number</code>
    * [.cross(v)](#Vector2+cross) ⇒ <code>number</code>
    * [.lengthSq()](#Vector2+lengthSq) ⇒ <code>number</code>
    * [.length()](#Vector2+length) ⇒ <code>number</code>
    * [.manhattanLength()](#Vector2+manhattanLength) ⇒ <code>number</code>
    * [.normalize()](#Vector2+normalize) ⇒ [<code>Vector2</code>](#Vector2)
    * [.angle()](#Vector2+angle) ⇒ <code>number</code>
    * [.angleTo(v)](#Vector2+angleTo) ⇒ <code>number</code>
    * [.distanceTo(v)](#Vector2+distanceTo) ⇒ <code>number</code>
    * [.distanceToSquared(v)](#Vector2+distanceToSquared) ⇒ <code>number</code>
    * [.manhattanDistanceTo(v)](#Vector2+manhattanDistanceTo) ⇒ <code>number</code>
    * [.setLength(length)](#Vector2+setLength) ⇒ [<code>Vector2</code>](#Vector2)
    * [.lerp(v, alpha)](#Vector2+lerp) ⇒ [<code>Vector2</code>](#Vector2)
    * [.lerpVectors(v1, v2, alpha)](#Vector2+lerpVectors) ⇒ [<code>Vector2</code>](#Vector2)
    * [.equals(v)](#Vector2+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Vector2+fromArray) ⇒ [<code>Vector2</code>](#Vector2)
    * [.toArray([array], [offset])](#Vector2+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * [.fromBufferAttribute(attribute, index)](#Vector2+fromBufferAttribute) ⇒ [<code>Vector2</code>](#Vector2)
    * [.rotateAround(center, angle)](#Vector2+rotateAround) ⇒ [<code>Vector2</code>](#Vector2)
    * [.random()](#Vector2+random) ⇒ [<code>Vector2</code>](#Vector2)

<a name="new_Vector2_new"></a>

### new Vector2([x], [y])
Constructs a new 2D vector.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The x value of this vector. |
| [y] | <code>number</code> | <code>0</code> | The y value of this vector. |

<a name="Vector2+isVector2"></a>

### vector2.isVector2 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Vector2+x"></a>

### vector2.x : <code>number</code>
The x value of this vector.

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
<a name="Vector2+y"></a>

### vector2.y : <code>number</code>
The y value of this vector.

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
<a name="Vector2+width"></a>

### vector2.width : <code>number</code>
Alias for [x](#Vector2+x).

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
<a name="Vector2+height"></a>

### vector2.height : <code>number</code>
Alias for [y](#Vector2+y).

**Kind**: instance property of [<code>Vector2</code>](#Vector2)  
<a name="Vector2+set"></a>

### vector2.set(x, y) ⇒ [<code>Vector2</code>](#Vector2)
Sets the vector components.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value of the x component. |
| y | <code>number</code> | The value of the y component. |

<a name="Vector2+setScalar"></a>

### vector2.setScalar(scalar) ⇒ [<code>Vector2</code>](#Vector2)
Sets the vector components to the same value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The value to set for all vector components. |

<a name="Vector2+setX"></a>

### vector2.setX(x) ⇒ [<code>Vector2</code>](#Vector2)
Sets the vector's x component to the given value

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to set. |

<a name="Vector2+setY"></a>

### vector2.setY(y) ⇒ [<code>Vector2</code>](#Vector2)
Sets the vector's y component to the given value

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| y | <code>number</code> | The value to set. |

<a name="Vector2+setComponent"></a>

### vector2.setComponent(index, value) ⇒ [<code>Vector2</code>](#Vector2)
Allows to set a vector component with an index.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y. |
| value | <code>number</code> | The value to set. |

<a name="Vector2+getComponent"></a>

### vector2.getComponent(index) ⇒ <code>number</code>
Returns the value of the vector component which matches the given index.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - A vector component value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y. |

<a name="Vector2+clone"></a>

### vector2.clone() ⇒ [<code>Vector2</code>](#Vector2)
Returns a new vector with copied values from this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A clone of this instance.  
<a name="Vector2+copy"></a>

### vector2.copy(v) ⇒ [<code>Vector2</code>](#Vector2)
Copies the values of the given vector to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to copy. |

<a name="Vector2+add"></a>

### vector2.add(v) ⇒ [<code>Vector2</code>](#Vector2)
Adds the given vector to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to add. |

<a name="Vector2+addScalar"></a>

### vector2.addScalar(s) ⇒ [<code>Vector2</code>](#Vector2)
Adds the given scalar value to all components of this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to add. |

<a name="Vector2+addVectors"></a>

### vector2.addVectors(a, b) ⇒ [<code>Vector2</code>](#Vector2)
Adds the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector2</code>](#Vector2) | The first vector. |
| b | [<code>Vector2</code>](#Vector2) | The second vector. |

<a name="Vector2+addScaledVector"></a>

### vector2.addScaledVector(v, s) ⇒ [<code>Vector2</code>](#Vector2)
Adds the given vector scaled by the given factor to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector. |
| s | <code>number</code> | The factor that scales `v`. |

<a name="Vector2+sub"></a>

### vector2.sub(v) ⇒ [<code>Vector2</code>](#Vector2)
Subtracts the given vector from this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to subtract. |

<a name="Vector2+subScalar"></a>

### vector2.subScalar(s) ⇒ [<code>Vector2</code>](#Vector2)
Subtracts the given scalar value from all components of this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to subtract. |

<a name="Vector2+subVectors"></a>

### vector2.subVectors(a, b) ⇒ [<code>Vector2</code>](#Vector2)
Subtracts the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector2</code>](#Vector2) | The first vector. |
| b | [<code>Vector2</code>](#Vector2) | The second vector. |

<a name="Vector2+multiply"></a>

### vector2.multiply(v) ⇒ [<code>Vector2</code>](#Vector2)
Multiplies the given vector with this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to multiply. |

<a name="Vector2+multiplyScalar"></a>

### vector2.multiplyScalar(scalar) ⇒ [<code>Vector2</code>](#Vector2)
Multiplies the given scalar value with all components of this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to multiply. |

<a name="Vector2+divide"></a>

### vector2.divide(v) ⇒ [<code>Vector2</code>](#Vector2)
Divides this instance by the given vector.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to divide. |

<a name="Vector2+divideScalar"></a>

### vector2.divideScalar(scalar) ⇒ [<code>Vector2</code>](#Vector2)
Divides this vector by the given scalar.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to divide. |

<a name="Vector2+applyMatrix3"></a>

### vector2.applyMatrix3(m) ⇒ [<code>Vector2</code>](#Vector2)
Multiplies this vector (with an implicit 1 as the 3rd component) by
the given 3x3 matrix.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The matrix to apply. |

<a name="Vector2+min"></a>

### vector2.min(v) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's x or y value is greater than the given vector's x or y
value, replace that value with the corresponding min value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector. |

<a name="Vector2+max"></a>

### vector2.max(v) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's x or y value is less than the given vector's x or y
value, replace that value with the corresponding max value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector. |

<a name="Vector2+clamp"></a>

### vector2.clamp(min, max) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's x or y value is greater than the max vector's x or y
value, it is replaced by the corresponding value.
If this vector's x or y value is less than the min vector's x or y value,
it is replaced by the corresponding value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | [<code>Vector2</code>](#Vector2) | The minimum x and y values. |
| max | [<code>Vector2</code>](#Vector2) | The maximum x and y values in the desired range. |

<a name="Vector2+clampScalar"></a>

### vector2.clampScalar(minVal, maxVal) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's x or y values are greater than the max value, they are
replaced by the max value.
If this vector's x or y values are less than the min value, they are
replaced by the min value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| minVal | <code>number</code> | The minimum value the components will be clamped to. |
| maxVal | <code>number</code> | The maximum value the components will be clamped to. |

<a name="Vector2+clampLength"></a>

### vector2.clampLength(min, max) ⇒ [<code>Vector2</code>](#Vector2)
If this vector's length is greater than the max value, it is replaced by
the max value.
If this vector's length is less than the min value, it is replaced by the
min value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>number</code> | The minimum value the vector length will be clamped to. |
| max | <code>number</code> | The maximum value the vector length will be clamped to. |

<a name="Vector2+floor"></a>

### vector2.floor() ⇒ [<code>Vector2</code>](#Vector2)
The components of this vector are rounded down to the nearest integer value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+ceil"></a>

### vector2.ceil() ⇒ [<code>Vector2</code>](#Vector2)
The components of this vector are rounded up to the nearest integer value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+round"></a>

### vector2.round() ⇒ [<code>Vector2</code>](#Vector2)
The components of this vector are rounded to the nearest integer value

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+roundToZero"></a>

### vector2.roundToZero() ⇒ [<code>Vector2</code>](#Vector2)
The components of this vector are rounded towards zero (up if negative,
down if positive) to an integer value.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+negate"></a>

### vector2.negate() ⇒ [<code>Vector2</code>](#Vector2)
Inverts this vector - i.e. sets x = -x and y = -y.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+dot"></a>

### vector2.dot(v) ⇒ <code>number</code>
Calculates the dot product of the given vector with this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The result of the dot product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the dot product with. |

<a name="Vector2+cross"></a>

### vector2.cross(v) ⇒ <code>number</code>
Calculates the cross product of the given vector with this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The result of the cross product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the cross product with. |

<a name="Vector2+lengthSq"></a>

### vector2.lengthSq() ⇒ <code>number</code>
Computes the square of the Euclidean length (straight-line length) from
(0, 0) to (x, y). If you are comparing the lengths of vectors, you should
compare the length squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The square length of this vector.  
<a name="Vector2+length"></a>

### vector2.length() ⇒ <code>number</code>
Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector2+manhattanLength"></a>

### vector2.manhattanLength() ⇒ <code>number</code>
Computes the Manhattan length of this vector.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector2+normalize"></a>

### vector2.normalize() ⇒ [<code>Vector2</code>](#Vector2)
Converts this vector to a unit vector - that is, sets it equal to a vector
with the same direction as this one, but with a vector length of `1`.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector2+angle"></a>

### vector2.angle() ⇒ <code>number</code>
Computes the angle in radians of this vector with respect to the positive x-axis.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The angle in radians.  
<a name="Vector2+angleTo"></a>

### vector2.angleTo(v) ⇒ <code>number</code>
Returns the angle between the given vector and this instance in radians.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The angle in radians.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the angle with. |

<a name="Vector2+distanceTo"></a>

### vector2.distanceTo(v) ⇒ <code>number</code>
Computes the distance from the given vector to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the distance to. |

<a name="Vector2+distanceToSquared"></a>

### vector2.distanceToSquared(v) ⇒ <code>number</code>
Computes the squared distance from the given vector to this instance.
If you are just comparing the distance with another distance, you should compare
the distance squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The squared distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the squared distance to. |

<a name="Vector2+manhattanDistanceTo"></a>

### vector2.manhattanDistanceTo(v) ⇒ <code>number</code>
Computes the Manhattan distance from the given vector to this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>number</code> - The Manhattan distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to compute the Manhattan distance to. |

<a name="Vector2+setLength"></a>

### vector2.setLength(length) ⇒ [<code>Vector2</code>](#Vector2)
Sets this vector to a vector with the same direction as this one, but
with the specified length.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| length | <code>number</code> | The new length of this vector. |

<a name="Vector2+lerp"></a>

### vector2.lerp(v, alpha) ⇒ [<code>Vector2</code>](#Vector2)
Linearly interpolates between the given vector and this instance, where
alpha is the percent distance along the line - alpha = 0 will be this
vector, and alpha = 1 will be the given one.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to interpolate towards. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector2+lerpVectors"></a>

### vector2.lerpVectors(v1, v2, alpha) ⇒ [<code>Vector2</code>](#Vector2)
Linearly interpolates between the given vectors, where alpha is the percent
distance along the line - alpha = 0 will be first vector, and alpha = 1 will
be the second one. The result is stored in this instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v1 | [<code>Vector2</code>](#Vector2) | The first vector. |
| v2 | [<code>Vector2</code>](#Vector2) | The second vector. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector2+equals"></a>

### vector2.equals(v) ⇒ <code>boolean</code>
Returns `true` if this vector is equal with the given one.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>boolean</code> - Whether this vector is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector2</code>](#Vector2) | The vector to test for equality. |

<a name="Vector2+fromArray"></a>

### vector2.fromArray(array, [offset]) ⇒ [<code>Vector2</code>](#Vector2)
Sets this vector's x value to be `array[ offset ]` and y
value to be `array[ offset + 1 ]`.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the vector component values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Vector2+toArray"></a>

### vector2.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the components of this vector to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: <code>Array.&lt;number&gt;</code> - The vector components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the vector components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Vector2+fromBufferAttribute"></a>

### vector2.fromBufferAttribute(attribute, index) ⇒ [<code>Vector2</code>](#Vector2)
Sets the components of this vector from the given buffer attribute.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding vector data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Vector2+rotateAround"></a>

### vector2.rotateAround(center, angle) ⇒ [<code>Vector2</code>](#Vector2)
Rotates this vector around the given center by the given angle.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| center | [<code>Vector2</code>](#Vector2) | The point around which to rotate. |
| angle | <code>number</code> | The angle to rotate, in radians. |

<a name="Vector2+random"></a>

### vector2.random() ⇒ [<code>Vector2</code>](#Vector2)
Sets each component of this vector to a pseudo-random value between `0` and
`1`, excluding `1`.

**Kind**: instance method of [<code>Vector2</code>](#Vector2)  
**Returns**: [<code>Vector2</code>](#Vector2) - A reference to this vector.  
<a name="Vector3"></a>

## Vector3
Class representing a 3D vector. A 3D vector is an ordered triplet of numbers
(labeled x, y and z), which can be used to represent a number of things, such as:

- A point in 3D space.
- A direction and length in 3D space. In three.js the length will
always be the Euclidean distance(straight-line distance) from `(0, 0, 0)` to `(x, y, z)`
and the direction is also measured from `(0, 0, 0)` towards `(x, y, z)`.
- Any arbitrary ordered triplet of numbers.

There are other things a 3D vector can be used to represent, such as
momentum vectors and so on, however these are the most
common uses in three.js.

Iterating through a vector instance will yield its components `(x, y, z)` in
the corresponding order.
```js
const a = new THREE.Vector3( 0, 1, 0 );

//no arguments; will be initialised to (0, 0, 0)
const b = new THREE.Vector3( );

const d = a.distanceTo( b );
```

**Kind**: global class  

* [Vector3](#Vector3)
    * [new Vector3([x], [y], [z])](#new_Vector3_new)
    * [.isVector3](#Vector3+isVector3) : <code>boolean</code>
    * [.x](#Vector3+x) : <code>number</code>
    * [.y](#Vector3+y) : <code>number</code>
    * [.z](#Vector3+z) : <code>number</code>
    * [.set(x, y, z)](#Vector3+set) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setScalar(scalar)](#Vector3+setScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setX(x)](#Vector3+setX) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setY(y)](#Vector3+setY) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setZ(z)](#Vector3+setZ) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setComponent(index, value)](#Vector3+setComponent) ⇒ [<code>Vector3</code>](#Vector3)
    * [.getComponent(index)](#Vector3+getComponent) ⇒ <code>number</code>
    * [.clone()](#Vector3+clone) ⇒ [<code>Vector3</code>](#Vector3)
    * [.copy(v)](#Vector3+copy) ⇒ [<code>Vector3</code>](#Vector3)
    * [.add(v)](#Vector3+add) ⇒ [<code>Vector3</code>](#Vector3)
    * [.addScalar(s)](#Vector3+addScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.addVectors(a, b)](#Vector3+addVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.addScaledVector(v, s)](#Vector3+addScaledVector) ⇒ [<code>Vector3</code>](#Vector3)
    * [.sub(v)](#Vector3+sub) ⇒ [<code>Vector3</code>](#Vector3)
    * [.subScalar(s)](#Vector3+subScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.subVectors(a, b)](#Vector3+subVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.multiply(v)](#Vector3+multiply) ⇒ [<code>Vector3</code>](#Vector3)
    * [.multiplyScalar(scalar)](#Vector3+multiplyScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.multiplyVectors(a, b)](#Vector3+multiplyVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyEuler(euler)](#Vector3+applyEuler) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyAxisAngle(axis, angle)](#Vector3+applyAxisAngle) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyMatrix3(m)](#Vector3+applyMatrix3) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyNormalMatrix(m)](#Vector3+applyNormalMatrix) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyMatrix4(m)](#Vector3+applyMatrix4) ⇒ [<code>Vector3</code>](#Vector3)
    * [.applyQuaternion(q)](#Vector3+applyQuaternion) ⇒ [<code>Vector3</code>](#Vector3)
    * [.project(camera)](#Vector3+project) ⇒ [<code>Vector3</code>](#Vector3)
    * [.unproject(camera)](#Vector3+unproject) ⇒ [<code>Vector3</code>](#Vector3)
    * [.transformDirection(m)](#Vector3+transformDirection) ⇒ [<code>Vector3</code>](#Vector3)
    * [.divide(v)](#Vector3+divide) ⇒ [<code>Vector3</code>](#Vector3)
    * [.divideScalar(scalar)](#Vector3+divideScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.min(v)](#Vector3+min) ⇒ [<code>Vector3</code>](#Vector3)
    * [.max(v)](#Vector3+max) ⇒ [<code>Vector3</code>](#Vector3)
    * [.clamp(min, max)](#Vector3+clamp) ⇒ [<code>Vector3</code>](#Vector3)
    * [.clampScalar(minVal, maxVal)](#Vector3+clampScalar) ⇒ [<code>Vector3</code>](#Vector3)
    * [.clampLength(min, max)](#Vector3+clampLength) ⇒ [<code>Vector3</code>](#Vector3)
    * [.floor()](#Vector3+floor) ⇒ [<code>Vector3</code>](#Vector3)
    * [.ceil()](#Vector3+ceil) ⇒ [<code>Vector3</code>](#Vector3)
    * [.round()](#Vector3+round) ⇒ [<code>Vector3</code>](#Vector3)
    * [.roundToZero()](#Vector3+roundToZero) ⇒ [<code>Vector3</code>](#Vector3)
    * [.negate()](#Vector3+negate) ⇒ [<code>Vector3</code>](#Vector3)
    * [.dot(v)](#Vector3+dot) ⇒ <code>number</code>
    * [.lengthSq()](#Vector3+lengthSq) ⇒ <code>number</code>
    * [.length()](#Vector3+length) ⇒ <code>number</code>
    * [.manhattanLength()](#Vector3+manhattanLength) ⇒ <code>number</code>
    * [.normalize()](#Vector3+normalize) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setLength(length)](#Vector3+setLength) ⇒ [<code>Vector3</code>](#Vector3)
    * [.lerp(v, alpha)](#Vector3+lerp) ⇒ [<code>Vector3</code>](#Vector3)
    * [.lerpVectors(v1, v2, alpha)](#Vector3+lerpVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.cross(v)](#Vector3+cross) ⇒ [<code>Vector3</code>](#Vector3)
    * [.crossVectors(a, b)](#Vector3+crossVectors) ⇒ [<code>Vector3</code>](#Vector3)
    * [.projectOnVector(v)](#Vector3+projectOnVector) ⇒ [<code>Vector3</code>](#Vector3)
    * [.projectOnPlane(planeNormal)](#Vector3+projectOnPlane) ⇒ [<code>Vector3</code>](#Vector3)
    * [.reflect(normal)](#Vector3+reflect) ⇒ [<code>Vector3</code>](#Vector3)
    * [.angleTo(v)](#Vector3+angleTo) ⇒ <code>number</code>
    * [.distanceTo(v)](#Vector3+distanceTo) ⇒ <code>number</code>
    * [.distanceToSquared(v)](#Vector3+distanceToSquared) ⇒ <code>number</code>
    * [.manhattanDistanceTo(v)](#Vector3+manhattanDistanceTo) ⇒ <code>number</code>
    * [.setFromSpherical(s)](#Vector3+setFromSpherical) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromSphericalCoords(radius, phi, theta)](#Vector3+setFromSphericalCoords) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromCylindrical(c)](#Vector3+setFromCylindrical) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromCylindricalCoords(radius, theta, y)](#Vector3+setFromCylindricalCoords) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromMatrixPosition(m)](#Vector3+setFromMatrixPosition) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromMatrixScale(m)](#Vector3+setFromMatrixScale) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromMatrixColumn(m, index)](#Vector3+setFromMatrixColumn) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromMatrix3Column(m, index)](#Vector3+setFromMatrix3Column) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromEuler(e)](#Vector3+setFromEuler) ⇒ [<code>Vector3</code>](#Vector3)
    * [.setFromColor(c)](#Vector3+setFromColor) ⇒ [<code>Vector3</code>](#Vector3)
    * [.equals(v)](#Vector3+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Vector3+fromArray) ⇒ [<code>Vector3</code>](#Vector3)
    * [.toArray([array], [offset])](#Vector3+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * [.fromBufferAttribute(attribute, index)](#Vector3+fromBufferAttribute) ⇒ [<code>Vector3</code>](#Vector3)
    * [.random()](#Vector3+random) ⇒ [<code>Vector3</code>](#Vector3)
    * [.randomDirection()](#Vector3+randomDirection) ⇒ [<code>Vector3</code>](#Vector3)

<a name="new_Vector3_new"></a>

### new Vector3([x], [y], [z])
Constructs a new 3D vector.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The x value of this vector. |
| [y] | <code>number</code> | <code>0</code> | The y value of this vector. |
| [z] | <code>number</code> | <code>0</code> | The z value of this vector. |

<a name="Vector3+isVector3"></a>

### vector3.isVector3 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Vector3</code>](#Vector3)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Vector3+x"></a>

### vector3.x : <code>number</code>
The x value of this vector.

**Kind**: instance property of [<code>Vector3</code>](#Vector3)  
<a name="Vector3+y"></a>

### vector3.y : <code>number</code>
The y value of this vector.

**Kind**: instance property of [<code>Vector3</code>](#Vector3)  
<a name="Vector3+z"></a>

### vector3.z : <code>number</code>
The z value of this vector.

**Kind**: instance property of [<code>Vector3</code>](#Vector3)  
<a name="Vector3+set"></a>

### vector3.set(x, y, z) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value of the x component. |
| y | <code>number</code> | The value of the y component. |
| z | <code>number</code> | The value of the z component. |

<a name="Vector3+setScalar"></a>

### vector3.setScalar(scalar) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components to the same value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The value to set for all vector components. |

<a name="Vector3+setX"></a>

### vector3.setX(x) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector's x component to the given value

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to set. |

<a name="Vector3+setY"></a>

### vector3.setY(y) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector's y component to the given value

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| y | <code>number</code> | The value to set. |

<a name="Vector3+setZ"></a>

### vector3.setZ(z) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector's z component to the given value

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| z | <code>number</code> | The value to set. |

<a name="Vector3+setComponent"></a>

### vector3.setComponent(index, value) ⇒ [<code>Vector3</code>](#Vector3)
Allows to set a vector component with an index.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y, `2` equals to z. |
| value | <code>number</code> | The value to set. |

<a name="Vector3+getComponent"></a>

### vector3.getComponent(index) ⇒ <code>number</code>
Returns the value of the vector component which matches the given index.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - A vector component value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y, `2` equals to z. |

<a name="Vector3+clone"></a>

### vector3.clone() ⇒ [<code>Vector3</code>](#Vector3)
Returns a new vector with copied values from this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A clone of this instance.  
<a name="Vector3+copy"></a>

### vector3.copy(v) ⇒ [<code>Vector3</code>](#Vector3)
Copies the values of the given vector to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to copy. |

<a name="Vector3+add"></a>

### vector3.add(v) ⇒ [<code>Vector3</code>](#Vector3)
Adds the given vector to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to add. |

<a name="Vector3+addScalar"></a>

### vector3.addScalar(s) ⇒ [<code>Vector3</code>](#Vector3)
Adds the given scalar value to all components of this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to add. |

<a name="Vector3+addVectors"></a>

### vector3.addVectors(a, b) ⇒ [<code>Vector3</code>](#Vector3)
Adds the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector3</code>](#Vector3) | The first vector. |
| b | [<code>Vector3</code>](#Vector3) | The second vector. |

<a name="Vector3+addScaledVector"></a>

### vector3.addScaledVector(v, s) ⇒ [<code>Vector3</code>](#Vector3)
Adds the given vector scaled by the given factor to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) \| <code>Vector4</code> | The vector. |
| s | <code>number</code> | The factor that scales `v`. |

<a name="Vector3+sub"></a>

### vector3.sub(v) ⇒ [<code>Vector3</code>](#Vector3)
Subtracts the given vector from this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to subtract. |

<a name="Vector3+subScalar"></a>

### vector3.subScalar(s) ⇒ [<code>Vector3</code>](#Vector3)
Subtracts the given scalar value from all components of this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to subtract. |

<a name="Vector3+subVectors"></a>

### vector3.subVectors(a, b) ⇒ [<code>Vector3</code>](#Vector3)
Subtracts the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector3</code>](#Vector3) | The first vector. |
| b | [<code>Vector3</code>](#Vector3) | The second vector. |

<a name="Vector3+multiply"></a>

### vector3.multiply(v) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies the given vector with this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to multiply. |

<a name="Vector3+multiplyScalar"></a>

### vector3.multiplyScalar(scalar) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies the given scalar value with all components of this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to multiply. |

<a name="Vector3+multiplyVectors"></a>

### vector3.multiplyVectors(a, b) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector3</code>](#Vector3) | The first vector. |
| b | [<code>Vector3</code>](#Vector3) | The second vector. |

<a name="Vector3+applyEuler"></a>

### vector3.applyEuler(euler) ⇒ [<code>Vector3</code>](#Vector3)
Applies the given Euler rotation to this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| euler | <code>Euler</code> | The Euler angles. |

<a name="Vector3+applyAxisAngle"></a>

### vector3.applyAxisAngle(axis, angle) ⇒ [<code>Vector3</code>](#Vector3)
Applies a rotation specified by an axis and an angle to this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| axis | [<code>Vector3</code>](#Vector3) | A normalized vector representing the rotation axis. |
| angle | <code>number</code> | The angle in radians. |

<a name="Vector3+applyMatrix3"></a>

### vector3.applyMatrix3(m) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies this vector with the given 3x3 matrix.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The 3x3 matrix. |

<a name="Vector3+applyNormalMatrix"></a>

### vector3.applyNormalMatrix(m) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies this vector by the given normal matrix and normalizes
the result.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The normal matrix. |

<a name="Vector3+applyMatrix4"></a>

### vector3.applyMatrix4(m) ⇒ [<code>Vector3</code>](#Vector3)
Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
divides by perspective.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix to apply. |

<a name="Vector3+applyQuaternion"></a>

### vector3.applyQuaternion(q) ⇒ [<code>Vector3</code>](#Vector3)
Applies the given Quaternion to this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The Quaternion. |

<a name="Vector3+project"></a>

### vector3.project(camera) ⇒ [<code>Vector3</code>](#Vector3)
Projects this vector from world space into the camera's normalized
device coordinate (NDC) space.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera. |

<a name="Vector3+unproject"></a>

### vector3.unproject(camera) ⇒ [<code>Vector3</code>](#Vector3)
Unprojects this vector from the camera's normalized device coordinate (NDC)
space into world space.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera. |

<a name="Vector3+transformDirection"></a>

### vector3.transformDirection(m) ⇒ [<code>Vector3</code>](#Vector3)
Transforms the direction of this vector by a matrix (the upper left 3 x 3
subset of the given 4x4 matrix and then normalizes the result.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The matrix. |

<a name="Vector3+divide"></a>

### vector3.divide(v) ⇒ [<code>Vector3</code>](#Vector3)
Divides this instance by the given vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to divide. |

<a name="Vector3+divideScalar"></a>

### vector3.divideScalar(scalar) ⇒ [<code>Vector3</code>](#Vector3)
Divides this vector by the given scalar.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to divide. |

<a name="Vector3+min"></a>

### vector3.min(v) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's x, y or z value is greater than the given vector's x, y or z
value, replace that value with the corresponding min value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector. |

<a name="Vector3+max"></a>

### vector3.max(v) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's x, y or z value is less than the given vector's x, y or z
value, replace that value with the corresponding max value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector. |

<a name="Vector3+clamp"></a>

### vector3.clamp(min, max) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's x, y or z value is greater than the max vector's x, y or z
value, it is replaced by the corresponding value.
If this vector's x, y or z value is less than the min vector's x, y or z value,
it is replaced by the corresponding value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | [<code>Vector3</code>](#Vector3) | The minimum x, y and z values. |
| max | [<code>Vector3</code>](#Vector3) | The maximum x, y and z values in the desired range. |

<a name="Vector3+clampScalar"></a>

### vector3.clampScalar(minVal, maxVal) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's x, y or z values are greater than the max value, they are
replaced by the max value.
If this vector's x, y or z values are less than the min value, they are
replaced by the min value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| minVal | <code>number</code> | The minimum value the components will be clamped to. |
| maxVal | <code>number</code> | The maximum value the components will be clamped to. |

<a name="Vector3+clampLength"></a>

### vector3.clampLength(min, max) ⇒ [<code>Vector3</code>](#Vector3)
If this vector's length is greater than the max value, it is replaced by
the max value.
If this vector's length is less than the min value, it is replaced by the
min value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>number</code> | The minimum value the vector length will be clamped to. |
| max | <code>number</code> | The maximum value the vector length will be clamped to. |

<a name="Vector3+floor"></a>

### vector3.floor() ⇒ [<code>Vector3</code>](#Vector3)
The components of this vector are rounded down to the nearest integer value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+ceil"></a>

### vector3.ceil() ⇒ [<code>Vector3</code>](#Vector3)
The components of this vector are rounded up to the nearest integer value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+round"></a>

### vector3.round() ⇒ [<code>Vector3</code>](#Vector3)
The components of this vector are rounded to the nearest integer value

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+roundToZero"></a>

### vector3.roundToZero() ⇒ [<code>Vector3</code>](#Vector3)
The components of this vector are rounded towards zero (up if negative,
down if positive) to an integer value.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+negate"></a>

### vector3.negate() ⇒ [<code>Vector3</code>](#Vector3)
Inverts this vector - i.e. sets x = -x, y = -y and z = -z.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+dot"></a>

### vector3.dot(v) ⇒ <code>number</code>
Calculates the dot product of the given vector with this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The result of the dot product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the dot product with. |

<a name="Vector3+lengthSq"></a>

### vector3.lengthSq() ⇒ <code>number</code>
Computes the square of the Euclidean length (straight-line length) from
(0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
compare the length squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The square length of this vector.  
<a name="Vector3+length"></a>

### vector3.length() ⇒ <code>number</code>
Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector3+manhattanLength"></a>

### vector3.manhattanLength() ⇒ <code>number</code>
Computes the Manhattan length of this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector3+normalize"></a>

### vector3.normalize() ⇒ [<code>Vector3</code>](#Vector3)
Converts this vector to a unit vector - that is, sets it equal to a vector
with the same direction as this one, but with a vector length of `1`.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+setLength"></a>

### vector3.setLength(length) ⇒ [<code>Vector3</code>](#Vector3)
Sets this vector to a vector with the same direction as this one, but
with the specified length.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| length | <code>number</code> | The new length of this vector. |

<a name="Vector3+lerp"></a>

### vector3.lerp(v, alpha) ⇒ [<code>Vector3</code>](#Vector3)
Linearly interpolates between the given vector and this instance, where
alpha is the percent distance along the line - alpha = 0 will be this
vector, and alpha = 1 will be the given one.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to interpolate towards. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector3+lerpVectors"></a>

### vector3.lerpVectors(v1, v2, alpha) ⇒ [<code>Vector3</code>](#Vector3)
Linearly interpolates between the given vectors, where alpha is the percent
distance along the line - alpha = 0 will be first vector, and alpha = 1 will
be the second one. The result is stored in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v1 | [<code>Vector3</code>](#Vector3) | The first vector. |
| v2 | [<code>Vector3</code>](#Vector3) | The second vector. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector3+cross"></a>

### vector3.cross(v) ⇒ [<code>Vector3</code>](#Vector3)
Calculates the cross product of the given vector with this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - The result of the cross product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the cross product with. |

<a name="Vector3+crossVectors"></a>

### vector3.crossVectors(a, b) ⇒ [<code>Vector3</code>](#Vector3)
Calculates the cross product of the given vectors and stores the result
in this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector3</code>](#Vector3) | The first vector. |
| b | [<code>Vector3</code>](#Vector3) | The second vector. |

<a name="Vector3+projectOnVector"></a>

### vector3.projectOnVector(v) ⇒ [<code>Vector3</code>](#Vector3)
Projects this vector onto the given one.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to project to. |

<a name="Vector3+projectOnPlane"></a>

### vector3.projectOnPlane(planeNormal) ⇒ [<code>Vector3</code>](#Vector3)
Projects this vector onto a plane by subtracting this
vector projected onto the plane's normal from this vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| planeNormal | [<code>Vector3</code>](#Vector3) | The plane normal. |

<a name="Vector3+reflect"></a>

### vector3.reflect(normal) ⇒ [<code>Vector3</code>](#Vector3)
Reflects this vector off a plane orthogonal to the given normal vector.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| normal | [<code>Vector3</code>](#Vector3) | The (normalized) normal vector. |

<a name="Vector3+angleTo"></a>

### vector3.angleTo(v) ⇒ <code>number</code>
Returns the angle between the given vector and this instance in radians.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The angle in radians.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the angle with. |

<a name="Vector3+distanceTo"></a>

### vector3.distanceTo(v) ⇒ <code>number</code>
Computes the distance from the given vector to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the distance to. |

<a name="Vector3+distanceToSquared"></a>

### vector3.distanceToSquared(v) ⇒ <code>number</code>
Computes the squared distance from the given vector to this instance.
If you are just comparing the distance with another distance, you should compare
the distance squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The squared distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the squared distance to. |

<a name="Vector3+manhattanDistanceTo"></a>

### vector3.manhattanDistanceTo(v) ⇒ <code>number</code>
Computes the Manhattan distance from the given vector to this instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>number</code> - The Manhattan distance.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to compute the Manhattan distance to. |

<a name="Vector3+setFromSpherical"></a>

### vector3.setFromSpherical(s) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given spherical coordinates.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>Spherical</code> | The spherical coordinates. |

<a name="Vector3+setFromSphericalCoords"></a>

### vector3.setFromSphericalCoords(radius, phi, theta) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given spherical coordinates.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| radius | <code>number</code> | The radius. |
| phi | <code>number</code> | The phi angle in radians. |
| theta | <code>number</code> | The theta angle in radians. |

<a name="Vector3+setFromCylindrical"></a>

### vector3.setFromCylindrical(c) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given cylindrical coordinates.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| c | <code>Cylindrical</code> | The cylindrical coordinates. |

<a name="Vector3+setFromCylindricalCoords"></a>

### vector3.setFromCylindricalCoords(radius, theta, y) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given cylindrical coordinates.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| radius | <code>number</code> | The radius. |
| theta | <code>number</code> | The theta angle in radians. |
| y | <code>number</code> | The y value. |

<a name="Vector3+setFromMatrixPosition"></a>

### vector3.setFromMatrixPosition(m) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components to the position elements of the
given transformation matrix.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Vector3+setFromMatrixScale"></a>

### vector3.setFromMatrixScale(m) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components to the scale elements of the
given transformation matrix.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Vector3+setFromMatrixColumn"></a>

### vector3.setFromMatrixColumn(m, index) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the specified matrix column.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |
| index | <code>number</code> | The column index. |

<a name="Vector3+setFromMatrix3Column"></a>

### vector3.setFromMatrix3Column(m, index) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the specified matrix column.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix3</code> | The 3x3 matrix. |
| index | <code>number</code> | The column index. |

<a name="Vector3+setFromEuler"></a>

### vector3.setFromEuler(e) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the given Euler angles.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| e | <code>Euler</code> | The Euler angles to set. |

<a name="Vector3+setFromColor"></a>

### vector3.setFromColor(c) ⇒ [<code>Vector3</code>](#Vector3)
Sets the vector components from the RGB components of the
given color.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| c | <code>Color</code> | The color to set. |

<a name="Vector3+equals"></a>

### vector3.equals(v) ⇒ <code>boolean</code>
Returns `true` if this vector is equal with the given one.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>boolean</code> - Whether this vector is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector3</code>](#Vector3) | The vector to test for equality. |

<a name="Vector3+fromArray"></a>

### vector3.fromArray(array, [offset]) ⇒ [<code>Vector3</code>](#Vector3)
Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
and z value to be `array[ offset + 2 ]`.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the vector component values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Vector3+toArray"></a>

### vector3.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the components of this vector to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: <code>Array.&lt;number&gt;</code> - The vector components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the vector components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Vector3+fromBufferAttribute"></a>

### vector3.fromBufferAttribute(attribute, index) ⇒ [<code>Vector3</code>](#Vector3)
Sets the components of this vector from the given buffer attribute.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding vector data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Vector3+random"></a>

### vector3.random() ⇒ [<code>Vector3</code>](#Vector3)
Sets each component of this vector to a pseudo-random value between `0` and
`1`, excluding `1`.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector3+randomDirection"></a>

### vector3.randomDirection() ⇒ [<code>Vector3</code>](#Vector3)
Sets this vector to a uniformly random point on a unit sphere.

**Kind**: instance method of [<code>Vector3</code>](#Vector3)  
**Returns**: [<code>Vector3</code>](#Vector3) - A reference to this vector.  
<a name="Vector4"></a>

## Vector4
Class representing a 4D vector. A 4D vector is an ordered quadruplet of numbers
(labeled x, y, z and w), which can be used to represent a number of things, such as:

- A point in 4D space.
- A direction and length in 4D space. In three.js the length will
always be the Euclidean distance(straight-line distance) from `(0, 0, 0, 0)` to `(x, y, z, w)`
and the direction is also measured from `(0, 0, 0, 0)` towards `(x, y, z, w)`.
- Any arbitrary ordered quadruplet of numbers.

There are other things a 4D vector can be used to represent, however these
are the most common uses in *three.js*.

Iterating through a vector instance will yield its components `(x, y, z, w)` in
the corresponding order.
```js
const a = new THREE.Vector4( 0, 1, 0, 0 );

//no arguments; will be initialised to (0, 0, 0, 1)
const b = new THREE.Vector4( );

const d = a.dot( b );
```

**Kind**: global class  

* [Vector4](#Vector4)
    * [new Vector4([x], [y], [z], [w])](#new_Vector4_new)
    * [.isVector4](#Vector4+isVector4) : <code>boolean</code>
    * [.x](#Vector4+x) : <code>number</code>
    * [.y](#Vector4+y) : <code>number</code>
    * [.z](#Vector4+z) : <code>number</code>
    * [.w](#Vector4+w) : <code>number</code>
    * [.width](#Vector4+width) : <code>number</code>
    * [.height](#Vector4+height) : <code>number</code>
    * [.set(x, y, z, w)](#Vector4+set) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setScalar(scalar)](#Vector4+setScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setX(x)](#Vector4+setX) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setY(y)](#Vector4+setY) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setZ(z)](#Vector4+setZ) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setW(w)](#Vector4+setW) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setComponent(index, value)](#Vector4+setComponent) ⇒ [<code>Vector4</code>](#Vector4)
    * [.getComponent(index)](#Vector4+getComponent) ⇒ <code>number</code>
    * [.clone()](#Vector4+clone) ⇒ [<code>Vector4</code>](#Vector4)
    * [.copy(v)](#Vector4+copy) ⇒ [<code>Vector4</code>](#Vector4)
    * [.add(v)](#Vector4+add) ⇒ [<code>Vector4</code>](#Vector4)
    * [.addScalar(s)](#Vector4+addScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.addVectors(a, b)](#Vector4+addVectors) ⇒ [<code>Vector4</code>](#Vector4)
    * [.addScaledVector(v, s)](#Vector4+addScaledVector) ⇒ [<code>Vector4</code>](#Vector4)
    * [.sub(v)](#Vector4+sub) ⇒ [<code>Vector4</code>](#Vector4)
    * [.subScalar(s)](#Vector4+subScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.subVectors(a, b)](#Vector4+subVectors) ⇒ [<code>Vector4</code>](#Vector4)
    * [.multiply(v)](#Vector4+multiply) ⇒ [<code>Vector4</code>](#Vector4)
    * [.multiplyScalar(scalar)](#Vector4+multiplyScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.applyMatrix4(m)](#Vector4+applyMatrix4) ⇒ [<code>Vector4</code>](#Vector4)
    * [.divide(v)](#Vector4+divide) ⇒ [<code>Vector4</code>](#Vector4)
    * [.divideScalar(scalar)](#Vector4+divideScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setAxisAngleFromQuaternion(q)](#Vector4+setAxisAngleFromQuaternion) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setAxisAngleFromRotationMatrix(m)](#Vector4+setAxisAngleFromRotationMatrix) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setFromMatrixPosition(m)](#Vector4+setFromMatrixPosition) ⇒ [<code>Vector4</code>](#Vector4)
    * [.min(v)](#Vector4+min) ⇒ [<code>Vector4</code>](#Vector4)
    * [.max(v)](#Vector4+max) ⇒ [<code>Vector4</code>](#Vector4)
    * [.clamp(min, max)](#Vector4+clamp) ⇒ [<code>Vector4</code>](#Vector4)
    * [.clampScalar(minVal, maxVal)](#Vector4+clampScalar) ⇒ [<code>Vector4</code>](#Vector4)
    * [.clampLength(min, max)](#Vector4+clampLength) ⇒ [<code>Vector4</code>](#Vector4)
    * [.floor()](#Vector4+floor) ⇒ [<code>Vector4</code>](#Vector4)
    * [.ceil()](#Vector4+ceil) ⇒ [<code>Vector4</code>](#Vector4)
    * [.round()](#Vector4+round) ⇒ [<code>Vector4</code>](#Vector4)
    * [.roundToZero()](#Vector4+roundToZero) ⇒ [<code>Vector4</code>](#Vector4)
    * [.negate()](#Vector4+negate) ⇒ [<code>Vector4</code>](#Vector4)
    * [.dot(v)](#Vector4+dot) ⇒ <code>number</code>
    * [.lengthSq()](#Vector4+lengthSq) ⇒ <code>number</code>
    * [.length()](#Vector4+length) ⇒ <code>number</code>
    * [.manhattanLength()](#Vector4+manhattanLength) ⇒ <code>number</code>
    * [.normalize()](#Vector4+normalize) ⇒ [<code>Vector4</code>](#Vector4)
    * [.setLength(length)](#Vector4+setLength) ⇒ [<code>Vector4</code>](#Vector4)
    * [.lerp(v, alpha)](#Vector4+lerp) ⇒ [<code>Vector4</code>](#Vector4)
    * [.lerpVectors(v1, v2, alpha)](#Vector4+lerpVectors) ⇒ [<code>Vector4</code>](#Vector4)
    * [.equals(v)](#Vector4+equals) ⇒ <code>boolean</code>
    * [.fromArray(array, [offset])](#Vector4+fromArray) ⇒ [<code>Vector4</code>](#Vector4)
    * [.toArray([array], [offset])](#Vector4+toArray) ⇒ <code>Array.&lt;number&gt;</code>
    * [.fromBufferAttribute(attribute, index)](#Vector4+fromBufferAttribute) ⇒ [<code>Vector4</code>](#Vector4)
    * [.random()](#Vector4+random) ⇒ [<code>Vector4</code>](#Vector4)

<a name="new_Vector4_new"></a>

### new Vector4([x], [y], [z], [w])
Constructs a new 4D vector.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [x] | <code>number</code> | <code>0</code> | The x value of this vector. |
| [y] | <code>number</code> | <code>0</code> | The y value of this vector. |
| [z] | <code>number</code> | <code>0</code> | The z value of this vector. |
| [w] | <code>number</code> | <code>1</code> | The w value of this vector. |

<a name="Vector4+isVector4"></a>

### vector4.isVector4 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Vector4+x"></a>

### vector4.x : <code>number</code>
The x value of this vector.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+y"></a>

### vector4.y : <code>number</code>
The y value of this vector.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+z"></a>

### vector4.z : <code>number</code>
The z value of this vector.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+w"></a>

### vector4.w : <code>number</code>
The w value of this vector.

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+width"></a>

### vector4.width : <code>number</code>
Alias for [z](#Vector4+z).

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+height"></a>

### vector4.height : <code>number</code>
Alias for [w](#Vector4+w).

**Kind**: instance property of [<code>Vector4</code>](#Vector4)  
<a name="Vector4+set"></a>

### vector4.set(x, y, z, w) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector components.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value of the x component. |
| y | <code>number</code> | The value of the y component. |
| z | <code>number</code> | The value of the z component. |
| w | <code>number</code> | The value of the w component. |

<a name="Vector4+setScalar"></a>

### vector4.setScalar(scalar) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector components to the same value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The value to set for all vector components. |

<a name="Vector4+setX"></a>

### vector4.setX(x) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector's x component to the given value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The value to set. |

<a name="Vector4+setY"></a>

### vector4.setY(y) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector's y component to the given value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| y | <code>number</code> | The value to set. |

<a name="Vector4+setZ"></a>

### vector4.setZ(z) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector's z component to the given value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| z | <code>number</code> | The value to set. |

<a name="Vector4+setW"></a>

### vector4.setW(w) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector's w component to the given value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| w | <code>number</code> | The value to set. |

<a name="Vector4+setComponent"></a>

### vector4.setComponent(index, value) ⇒ [<code>Vector4</code>](#Vector4)
Allows to set a vector component with an index.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y, `2` equals to z, `3` equals to w. |
| value | <code>number</code> | The value to set. |

<a name="Vector4+getComponent"></a>

### vector4.getComponent(index) ⇒ <code>number</code>
Returns the value of the vector component which matches the given index.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - A vector component value.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The component index. `0` equals to x, `1` equals to y, `2` equals to z, `3` equals to w. |

<a name="Vector4+clone"></a>

### vector4.clone() ⇒ [<code>Vector4</code>](#Vector4)
Returns a new vector with copied values from this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A clone of this instance.  
<a name="Vector4+copy"></a>

### vector4.copy(v) ⇒ [<code>Vector4</code>](#Vector4)
Copies the values of the given vector to this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> \| [<code>Vector4</code>](#Vector4) | The vector to copy. |

<a name="Vector4+add"></a>

### vector4.add(v) ⇒ [<code>Vector4</code>](#Vector4)
Adds the given vector to this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to add. |

<a name="Vector4+addScalar"></a>

### vector4.addScalar(s) ⇒ [<code>Vector4</code>](#Vector4)
Adds the given scalar value to all components of this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to add. |

<a name="Vector4+addVectors"></a>

### vector4.addVectors(a, b) ⇒ [<code>Vector4</code>](#Vector4)
Adds the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector4</code>](#Vector4) | The first vector. |
| b | [<code>Vector4</code>](#Vector4) | The second vector. |

<a name="Vector4+addScaledVector"></a>

### vector4.addScaledVector(v, s) ⇒ [<code>Vector4</code>](#Vector4)
Adds the given vector scaled by the given factor to this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector. |
| s | <code>number</code> | The factor that scales `v`. |

<a name="Vector4+sub"></a>

### vector4.sub(v) ⇒ [<code>Vector4</code>](#Vector4)
Subtracts the given vector from this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to subtract. |

<a name="Vector4+subScalar"></a>

### vector4.subScalar(s) ⇒ [<code>Vector4</code>](#Vector4)
Subtracts the given scalar value from all components of this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| s | <code>number</code> | The scalar to subtract. |

<a name="Vector4+subVectors"></a>

### vector4.subVectors(a, b) ⇒ [<code>Vector4</code>](#Vector4)
Subtracts the given vectors and stores the result in this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| a | [<code>Vector4</code>](#Vector4) | The first vector. |
| b | [<code>Vector4</code>](#Vector4) | The second vector. |

<a name="Vector4+multiply"></a>

### vector4.multiply(v) ⇒ [<code>Vector4</code>](#Vector4)
Multiplies the given vector with this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to multiply. |

<a name="Vector4+multiplyScalar"></a>
