# three.js 

> JavaScript 3D Library. 

<a name="AnimationClipCreator"></a>

| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="shiftLeft"></a>

## shiftLeft(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Shifts a node to the left.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The node to shift. |
| b | <code>Node</code> | The value to shift. |

<a name="shiftRight"></a>

## shiftRight(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Shifts a node to the right.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The node to shift. |
| b | <code>Node</code> | The value to shift. |

<a name="remainder"></a>

## ~~remainder(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)~~
***since r168. Use [mod](#mod) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="modInt"></a>

## ~~modInt(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)~~
***since r175. Use [mod](#mod) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="triNoise3D"></a>

## triNoise3D(position, speed, time) ⇒ <code>Node.&lt;float&gt;</code>
Generates a noise value from the given position, speed and time parameters.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The generated noise.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Node.&lt;vec3&gt;</code> | The position. |
| speed | <code>Node.&lt;float&gt;</code> | The speed. |
| time | <code>Node.&lt;float&gt;</code> | The time. |

<a name="GLSLNodeFunction"></a>

## GLSLNodeFunction ⇐ <code>NodeFunction</code>
This class represents a GLSL node function.

**Kind**: global class  
**Extends**: <code>NodeFunction</code>  

* [GLSLNodeFunction](#GLSLNodeFunction) ⇐ <code>NodeFunction</code>
    * [new GLSLNodeFunction(source)](#new_GLSLNodeFunction_new)
    * [.getCode([name])](#GLSLNodeFunction+getCode) ⇒ <code>string</code>

<a name="new_GLSLNodeFunction_new"></a>

### new GLSLNodeFunction(source)
Constructs a new GLSL node function.


| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The GLSL source. |

<a name="GLSLNodeFunction+getCode"></a>

### glslNodeFunction.getCode([name]) ⇒ <code>string</code>
This method returns the GLSL code of the node function.

**Kind**: instance method of [<code>GLSLNodeFunction</code>](#GLSLNodeFunction)  
**Returns**: <code>string</code> - The shader code.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;this.name&quot;</code> | The function's name. |

<a name="GLSLNodeParser"></a>

## GLSLNodeParser ⇐ <code>NodeParser</code>
A GLSL node parser.

**Kind**: global class  
**Extends**: <code>NodeParser</code>  
<a name="GLSLNodeParser+parseFunction"></a>

### glslNodeParser.parseFunction(source) ⇒ <code>GLSLNodeFunction</code>
The method parses the given GLSL code an returns a node function.

**Kind**: instance method of [<code>GLSLNodeParser</code>](#GLSLNodeParser)  
**Returns**: <code>GLSLNodeFunction</code> - A node function.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The GLSL code. |

## Classes

<dl>
<dt><a href="#PMREMNode">PMREMNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents a PMREM which is a special type of preprocessed
environment map intended for PBR materials.</p>
<pre><code class="language-js">const material = new MeshStandardNodeMaterial();
material.envNode = pmremTexture( envMap );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#pmremTexture">pmremTexture(value, [uvNode], [levelNode])</a> ⇒ <code><a href="#PMREMNode">PMREMNode</a></code></dt>
<dd><p>TSL function for creating a PMREM node.</p>
</dd>
</dl>

<a name="PMREMNode"></a>

## PMREMNode ⇐ <code>TempNode</code>
This node represents a PMREM which is a special type of preprocessed
environment map intended for PBR materials.

```js
const material = new MeshStandardNodeMaterial();
material.envNode = pmremTexture( envMap );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [PMREMNode](#PMREMNode) ⇐ <code>TempNode</code>
    * [new PMREMNode(value, [uvNode], [levelNode])](#new_PMREMNode_new)
    * [.uvNode](#PMREMNode+uvNode) : <code>Node.&lt;vec2&gt;</code>
    * [.levelNode](#PMREMNode+levelNode) : <code>Node.&lt;float&gt;</code>
    * [.updateBeforeType](#PMREMNode+updateBeforeType) : <code>string</code>
    * [.value](#PMREMNode+value) : <code>Texture</code>
    * [.updateFromTexture(texture)](#PMREMNode+updateFromTexture)

<a name="new_PMREMNode_new"></a>

### new PMREMNode(value, [uvNode], [levelNode])
Constructs a new function overloading node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The input texture. |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The level node. |

<a name="PMREMNode+uvNode"></a>

### pmremNode.uvNode : <code>Node.&lt;vec2&gt;</code>
The uv node.

**Kind**: instance property of [<code>PMREMNode</code>](#PMREMNode)  
<a name="PMREMNode+levelNode"></a>

### pmremNode.levelNode : <code>Node.&lt;float&gt;</code>
The level node.

**Kind**: instance property of [<code>PMREMNode</code>](#PMREMNode)  
<a name="PMREMNode+updateBeforeType"></a>

### pmremNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.RENDER`.

**Kind**: instance property of [<code>PMREMNode</code>](#PMREMNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="PMREMNode+value"></a>

### pmremNode.value : <code>Texture</code>
The node's texture value.

**Kind**: instance property of [<code>PMREMNode</code>](#PMREMNode)  
<a name="PMREMNode+updateFromTexture"></a>

### pmremNode.updateFromTexture(texture)
Uses the given PMREM texture to update internal values.

**Kind**: instance method of [<code>PMREMNode</code>](#PMREMNode)  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The PMREM texture. |

<a name="pmremTexture"></a>

## pmremTexture(value, [uvNode], [levelNode]) ⇒ [<code>PMREMNode</code>](#PMREMNode)
TSL function for creating a PMREM node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The input texture. |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The level node. |

<a name="checker"></a>

## checker(coord) ⇒ <code>Node.&lt;float&gt;</code>
Creates a 2x2 checkerboard pattern that can be used as procedural texture data.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The result data.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| coord | <code>Node.&lt;vec2&gt;</code> | The uv coordinates. |

<a name="shapeCircle"></a>

## shapeCircle(coord) ⇒ <code>Node.&lt;float&gt;</code>
Generates a circle based on the uv coordinates.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The circle shape.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| coord | <code>Node.&lt;vec2&gt;</code> | The uv to generate the circle. |

<a name="tslFn"></a>

## ~~tslFn(...params) ⇒ <code>function</code>~~
***since r168. Use [Fn](Fn) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="ArrayElementNode"></a>

## ArrayElementNode ⇐ <code>Node</code>
Base class for representing element access on an array-like
node data structures.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ArrayElementNode](#ArrayElementNode) ⇐ <code>Node</code>
    * [new ArrayElementNode(node, indexNode)](#new_ArrayElementNode_new)
    * [.node](#ArrayElementNode+node) : <code>Node</code>
    * [.indexNode](#ArrayElementNode+indexNode) : <code>Node</code>
    * [.isArrayElementNode](#ArrayElementNode+isArrayElementNode) : <code>boolean</code>
    * [.getNodeType(builder)](#ArrayElementNode+getNodeType) ⇒ <code>string</code>

<a name="new_ArrayElementNode_new"></a>

### new ArrayElementNode(node, indexNode)
Constructs an array element node.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The array-like node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="ArrayElementNode+node"></a>

### arrayElementNode.node : <code>Node</code>
The array-like node.

**Kind**: instance property of [<code>ArrayElementNode</code>](#ArrayElementNode)  
<a name="ArrayElementNode+indexNode"></a>

### arrayElementNode.indexNode : <code>Node</code>
The index node that defines the element access.

**Kind**: instance property of [<code>ArrayElementNode</code>](#ArrayElementNode)  
<a name="ArrayElementNode+isArrayElementNode"></a>

### arrayElementNode.isArrayElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ArrayElementNode</code>](#ArrayElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ArrayElementNode+getNodeType"></a>

### arrayElementNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the array-like node.

**Kind**: instance method of [<code>ArrayElementNode</code>](#ArrayElementNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ConvertNode"></a>

## ConvertNode ⇐ <code>Node</code>
This module is part of the TSL core and usually not used in app level code.
It represents a convert operation during the shader generation process
meaning it converts the data type of a node to a target data type.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ConvertNode](#ConvertNode) ⇐ <code>Node</code>
    * [new ConvertNode(node, convertTo)](#new_ConvertNode_new)
    * [.node](#ConvertNode+node) : <code>Node</code>
    * [.convertTo](#ConvertNode+convertTo) : <code>string</code>
    * [.getNodeType(builder)](#ConvertNode+getNodeType) ⇒ <code>string</code>

<a name="new_ConvertNode_new"></a>

### new ConvertNode(node, convertTo)
Constructs a new convert node.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node which type should be converted. |
| convertTo | <code>string</code> | The target node type. Multiple types can be defined by separating them with a `|` sign. |

<a name="ConvertNode+node"></a>

### convertNode.node : <code>Node</code>
The node which type should be converted.

**Kind**: instance property of [<code>ConvertNode</code>](#ConvertNode)  
<a name="ConvertNode+convertTo"></a>

### convertNode.convertTo : <code>string</code>
The target node type. Multiple types can be defined by separating them with a `|` sign.

**Kind**: instance property of [<code>ConvertNode</code>](#ConvertNode)  
<a name="ConvertNode+getNodeType"></a>

### convertNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the implementation tries to infer the best
matching type from the [convertTo](#ConvertNode+convertTo) property.

**Kind**: instance method of [<code>ConvertNode</code>](#ConvertNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#CubeMapNode">CubeMapNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node can be used to automatically convert environment maps in the
equirectangular format into the cube map format.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#cubeMapNode">cubeMapNode(envNode)</a> ⇒ <code><a href="#CubeMapNode">CubeMapNode</a></code></dt>
<dd><p>TSL function for creating a cube map node.</p>
</dd>
</dl>

<a name="CubeMapNode"></a>

## CubeMapNode ⇐ <code>TempNode</code>
This node can be used to automatically convert environment maps in the
equirectangular format into the cube map format.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [CubeMapNode](#CubeMapNode) ⇐ <code>TempNode</code>
    * [new CubeMapNode(envNode)](#new_CubeMapNode_new)
    * [.envNode](#CubeMapNode+envNode) : <code>Node</code>
    * [.updateBeforeType](#CubeMapNode+updateBeforeType) : <code>string</code>

<a name="new_CubeMapNode_new"></a>

### new CubeMapNode(envNode)
Constructs a new cube map node.


| Param | Type | Description |
| --- | --- | --- |
| envNode | <code>Node</code> | The node representing the environment map. |

<a name="CubeMapNode+envNode"></a>

### cubeMapNode.envNode : <code>Node</code>
The node representing the environment map.

**Kind**: instance property of [<code>CubeMapNode</code>](#CubeMapNode)  
<a name="CubeMapNode+updateBeforeType"></a>

### cubeMapNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
the texture once per render in its [CubeMapNode#updateBefore](CubeMapNode#updateBefore) method.

**Kind**: instance property of [<code>CubeMapNode</code>](#CubeMapNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="cubeMapNode"></a>

## cubeMapNode(envNode) ⇒ [<code>CubeMapNode</code>](#CubeMapNode)
TSL function for creating a cube map node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| envNode | <code>Node</code> | The node representing the environment map. |

## Functions

<dl>
<dt><a href="#Discard">Discard(conditional)</a> ⇒ <code>Node</code></dt>
<dd><p>Represents a <code>discard</code> shader operation in TSL.</p>
</dd>
<dt><a href="#Return">Return()</a> ⇒ <code>ExpressionNode</code></dt>
<dd><p>Represents a <code>return</code> shader operation in TSL.</p>
</dd>
</dl>

<a name="Discard"></a>

## Discard(conditional) ⇒ <code>Node</code>
Represents a `discard` shader operation in TSL.

**Kind**: global function  
**Returns**: <code>Node</code> - The `discard` expression.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| conditional | <code>ConditionalNode</code> | An optional conditional node. It allows to decide whether the discard should be executed or not. |

<a name="Return"></a>

## Return() ⇒ <code>ExpressionNode</code>
Represents a `return` shader operation in TSL.

**Kind**: global function  
**Returns**: <code>ExpressionNode</code> - The `return` expression.  
**Tsl**:   
## Classes

<dl>
<dt><a href="#EquirectUVNode">EquirectUVNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Can be used to compute texture coordinates for projecting an
equirectangular texture onto a mesh for using it as the scene&#39;s
background.</p>
<pre><code class="language-js">scene.backgroundNode = texture( equirectTexture, equirectUV() );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#equirectUV">equirectUV([dirNode])</a> ⇒ <code><a href="#EquirectUVNode">EquirectUVNode</a></code></dt>
<dd><p>TSL function for creating an equirect uv node.</p>
</dd>
</dl>

<a name="EquirectUVNode"></a>

## EquirectUVNode ⇐ <code>TempNode</code>
Can be used to compute texture coordinates for projecting an
equirectangular texture onto a mesh for using it as the scene's
background.

```js
scene.backgroundNode = texture( equirectTexture, equirectUV() );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [EquirectUVNode](#EquirectUVNode) ⇐ <code>TempNode</code>
    * [new EquirectUVNode([dirNode])](#new_EquirectUVNode_new)
    * [.dirNode](#EquirectUVNode+dirNode) : <code>Node.&lt;vec3&gt;</code>

<a name="new_EquirectUVNode_new"></a>

### new EquirectUVNode([dirNode])
Constructs a new equirect uv node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [dirNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionWorldDirection</code> | A direction vector for sampling which is by default `positionWorldDirection`. |

<a name="EquirectUVNode+dirNode"></a>

### equirectUVNode.dirNode : <code>Node.&lt;vec3&gt;</code>
A direction vector for sampling why is by default `positionWorldDirection`.

**Kind**: instance property of [<code>EquirectUVNode</code>](#EquirectUVNode)  
<a name="equirectUV"></a>

## equirectUV([dirNode]) ⇒ [<code>EquirectUVNode</code>](#EquirectUVNode)
TSL function for creating an equirect uv node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [dirNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionWorldDirection</code> | A direction vector for sampling which is by default `positionWorldDirection`. |

<a name="FlipNode"></a>

## FlipNode ⇐ <code>TempNode</code>
This module is part of the TSL core and usually not used in app level code.
It represents a flip operation during the shader generation process
meaning it flips normalized values with the following formula:
```
x = 1 - x;
```
`FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and
`flipSTPQ()` method invocations on node objects. For example:
```js
uvNode = uvNode.flipY();
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [FlipNode](#FlipNode) ⇐ <code>TempNode</code>
    * [new FlipNode(sourceNode, components)](#new_FlipNode_new)
    * [.sourceNode](#FlipNode+sourceNode) : <code>Node</code>
    * [.components](#FlipNode+components) : <code>string</code>
    * [.getNodeType(builder)](#FlipNode+getNodeType) ⇒ <code>string</code>

<a name="new_FlipNode_new"></a>

### new FlipNode(sourceNode, components)
Constructs a new flip node.


| Param | Type | Description |
| --- | --- | --- |
| sourceNode | <code>Node</code> | The node which component(s) should be flipped. |
| components | <code>string</code> | The components that should be flipped e.g. `'x'` or `'xy'`. |

<a name="FlipNode+sourceNode"></a>

### flipNode.sourceNode : <code>Node</code>
The node which component(s) should be flipped.

**Kind**: instance property of [<code>FlipNode</code>](#FlipNode)  
<a name="FlipNode+components"></a>

### flipNode.components : <code>string</code>
The components that should be flipped e.g. `'x'` or `'xy'`.

**Kind**: instance property of [<code>FlipNode</code>](#FlipNode)  
<a name="FlipNode+getNodeType"></a>

### flipNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the source node.

**Kind**: instance method of [<code>FlipNode</code>](#FlipNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#FunctionOverloadingNode">FunctionOverloadingNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class allows to define multiple overloaded versions
of the same function. Depending on the parameters of the function
call, the node picks the best-fit overloaded version.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#overloadingFn">overloadingFn(functionNodes)</a> ⇒ <code><a href="#FunctionOverloadingNode">FunctionOverloadingNode</a></code></dt>
<dd><p>TSL function for creating a function overloading node.</p>
</dd>
</dl>

<a name="FunctionOverloadingNode"></a>

## FunctionOverloadingNode ⇐ <code>Node</code>
This class allows to define multiple overloaded versions
of the same function. Depending on the parameters of the function
call, the node picks the best-fit overloaded version.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [FunctionOverloadingNode](#FunctionOverloadingNode) ⇐ <code>Node</code>
    * [new FunctionOverloadingNode(functionNodes, ...parametersNodes)](#new_FunctionOverloadingNode_new)
    * [.functionNodes](#FunctionOverloadingNode+functionNodes) : <code>Array.&lt;function()&gt;</code>
    * [.parametersNodes](#FunctionOverloadingNode+parametersNodes) : <code>Array.&lt;Node&gt;</code>
    * [.global](#FunctionOverloadingNode+global) : <code>boolean</code>
    * [.getNodeType(builder)](#FunctionOverloadingNode+getNodeType) ⇒ <code>string</code>

<a name="new_FunctionOverloadingNode_new"></a>

### new FunctionOverloadingNode(functionNodes, ...parametersNodes)
Constructs a new function overloading node.


| Param | Type | Description |
| --- | --- | --- |
| functionNodes | <code>Array.&lt;function()&gt;</code> | Array of `Fn` function definitions. |
| ...parametersNodes | <code>Node</code> | A list of parameter nodes. |

<a name="FunctionOverloadingNode+functionNodes"></a>

### functionOverloadingNode.functionNodes : <code>Array.&lt;function()&gt;</code>
Array of `Fn` function definitions.

**Kind**: instance property of [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)  
<a name="FunctionOverloadingNode+parametersNodes"></a>

### functionOverloadingNode.parametersNodes : <code>Array.&lt;Node&gt;</code>
A list of parameter nodes.

**Kind**: instance property of [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)  
<a name="FunctionOverloadingNode+global"></a>

### functionOverloadingNode.global : <code>boolean</code>
This node is marked as global.

**Kind**: instance property of [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)  
**Default**: <code>true</code>  
<a name="FunctionOverloadingNode+getNodeType"></a>

### functionOverloadingNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the function's return type.

**Kind**: instance method of [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="overloadingFn"></a>

## overloadingFn(functionNodes) ⇒ [<code>FunctionOverloadingNode</code>](#FunctionOverloadingNode)
TSL function for creating a function overloading node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| functionNodes | <code>Array.&lt;function()&gt;</code> | Array of `Fn` function definitions. |

<a name="JoinNode"></a>

## JoinNode ⇐ <code>TempNode</code>
This module is part of the TSL core and usually not used in app level code.
It represents a join operation during the shader generation process.
For example in can compose/join two single floats into a `vec2` type.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [JoinNode](#JoinNode) ⇐ <code>TempNode</code>
    * [new JoinNode(nodes, [nodeType])](#new_JoinNode_new)
    * [.nodes](#JoinNode+nodes) : <code>Array.&lt;Node&gt;</code>
    * [.getNodeType(builder)](#JoinNode+getNodeType) ⇒ <code>string</code>

<a name="new_JoinNode_new"></a>

### new JoinNode(nodes, [nodeType])
Constructs a new join node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodes | <code>Array.&lt;Node&gt;</code> |  | An array of nodes that should be joined. |
| [nodeType] | <code>string</code> | <code>null</code> | The node type. |

<a name="JoinNode+nodes"></a>

### joinNode.nodes : <code>Array.&lt;Node&gt;</code>
An array of nodes that should be joined.

**Kind**: instance property of [<code>JoinNode</code>](#JoinNode)  
<a name="JoinNode+getNodeType"></a>

### joinNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type must be inferred from the
joined data length if not explicitly defined.

**Kind**: instance method of [<code>JoinNode</code>](#JoinNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#LoopNode">LoopNode</a> ⇐ <code>Node</code></dt>
<dd><p>This module offers a variety of ways to implement loops in TSL. In it&#39;s basic form it&#39;s:</p>
<pre><code class="language-js">Loop( count, ( { i } ) =&gt; {

} );
</code></pre>
<p>However, it is also possible to define a start and end ranges, data types and loop conditions:</p>
<pre><code class="language-js">Loop( { start: int( 0 ), end: int( 10 ), type: &#39;int&#39;, condition: &#39;&lt;&#39; }, ( { i } ) =&gt; {

} );
</code></pre>
<p>Nested loops can be defined in a compacted form:</p>
<pre><code class="language-js">Loop( 10, 5, ( { i, j } ) =&gt; {

} );
</code></pre>
<p>Loops that should run backwards can be defined like so:</p>
<pre><code class="language-js">Loop( { start: 10 }, () =&gt; {} );
</code></pre>
<p>The module also provides <code>Break()</code> and <code>Continue()</code> TSL expression for loop control.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#Loop">Loop(...params)</a> ⇒ <code><a href="#LoopNode">LoopNode</a></code></dt>
<dd><p>TSL function for creating a loop node.</p>
</dd>
<dt><a href="#Continue">Continue()</a> ⇒ <code>ExpressionNode</code></dt>
<dd><p>TSL function for creating a <code>Continue()</code> expression.</p>
</dd>
<dt><a href="#Break">Break()</a> ⇒ <code>ExpressionNode</code></dt>
<dd><p>TSL function for creating a <code>Break()</code> expression.</p>
</dd>
<dt><del><a href="#loop">loop(...params)</a> ⇒ <code><a href="#LoopNode">LoopNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="LoopNode"></a>

## LoopNode ⇐ <code>Node</code>
This module offers a variety of ways to implement loops in TSL. In it's basic form it's:
```js
Loop( count, ( { i } ) => {

} );
```
However, it is also possible to define a start and end ranges, data types and loop conditions:
```js
Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {

} );
```
Nested loops can be defined in a compacted form:
```js
Loop( 10, 5, ( { i, j } ) => {

} );
```
Loops that should run backwards can be defined like so:
```js
Loop( { start: 10 }, () => {} );
```
The module also provides `Break()` and `Continue()` TSL expression for loop control.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [LoopNode](#LoopNode) ⇐ <code>Node</code>
    * [new LoopNode(params)](#new_LoopNode_new)
    * [.getVarName(index)](#LoopNode+getVarName) ⇒ <code>string</code>
    * [.getProperties(builder)](#LoopNode+getProperties) ⇒ <code>Object</code>
    * [.getNodeType(builder)](#LoopNode+getNodeType) ⇒ <code>string</code>

<a name="new_LoopNode_new"></a>

### new LoopNode(params)
Constructs a new loop node.


| Param | Type | Description |
| --- | --- | --- |
| params | <code>Array.&lt;any&gt;</code> | Depending on the loop type, array holds different parameterization values for the loop. |

<a name="LoopNode+getVarName"></a>

### loopNode.getVarName(index) ⇒ <code>string</code>
Returns a loop variable name based on an index. The pattern is
`0` = `i`, `1`= `j`, `2`= `k` and so on.

**Kind**: instance method of [<code>LoopNode</code>](#LoopNode)  
**Returns**: <code>string</code> - The loop variable name.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index. |

<a name="LoopNode+getProperties"></a>

### loopNode.getProperties(builder) ⇒ <code>Object</code>
Returns properties about this node.

**Kind**: instance method of [<code>LoopNode</code>](#LoopNode)  
**Returns**: <code>Object</code> - The node properties.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LoopNode+getNodeType"></a>

### loopNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred based on the loop configuration.

**Kind**: instance method of [<code>LoopNode</code>](#LoopNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Loop"></a>

## Loop(...params) ⇒ [<code>LoopNode</code>](#LoopNode)
TSL function for creating a loop node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...params | <code>any</code> | A list of parameters. |

<a name="Continue"></a>

## Continue() ⇒ <code>ExpressionNode</code>
TSL function for creating a `Continue()` expression.

**Kind**: global function  
**Tsl**:   
<a name="Break"></a>

## Break() ⇒ <code>ExpressionNode</code>
TSL function for creating a `Break()` expression.

**Kind**: global function  
**Tsl**:   
<a name="loop"></a>

## ~~loop(...params) ⇒ [<code>LoopNode</code>](#LoopNode)~~
***since r168. Use [Loop](#Loop) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

## Classes

<dl>
<dt><a href="#MatcapUVNode">MatcapUVNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Can be used to compute texture coordinates for projecting a
matcap onto a mesh. Used by <a href="MeshMatcapNodeMaterial">MeshMatcapNodeMaterial</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#matcapUV">matcapUV()</a> ⇒ <code><a href="#MatcapUVNode">MatcapUVNode</a></code></dt>
<dd><p>TSL function for creating a matcap uv node.</p>
</dd>
</dl>

<a name="MatcapUVNode"></a>

## MatcapUVNode ⇐ <code>TempNode</code>
Can be used to compute texture coordinates for projecting a
matcap onto a mesh. Used by [MeshMatcapNodeMaterial](MeshMatcapNodeMaterial).

**Kind**: global class  
**Extends**: <code>TempNode</code>  
<a name="new_MatcapUVNode_new"></a>

### new MatcapUVNode()
Constructs a new matcap uv node.

<a name="matcapUV"></a>

## matcapUV() ⇒ [<code>MatcapUVNode</code>](#MatcapUVNode)
TSL function for creating a matcap uv node.

**Kind**: global function  
**Tsl**:   
## Classes

<dl>
<dt><a href="#MaxMipLevelNode">MaxMipLevelNode</a> ⇐ <code>UniformNode</code></dt>
<dd><p>A special type of uniform node that computes the
maximum mipmap level for a given texture node.</p>
<pre><code class="language-js">const level = maxMipLevel( textureNode );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#maxMipLevel">maxMipLevel(textureNode)</a> ⇒ <code><a href="#MaxMipLevelNode">MaxMipLevelNode</a></code></dt>
<dd><p>TSL function for creating a max mip level node.</p>
</dd>
</dl>

<a name="MaxMipLevelNode"></a>

## MaxMipLevelNode ⇐ <code>UniformNode</code>
A special type of uniform node that computes the
maximum mipmap level for a given texture node.

```js
const level = maxMipLevel( textureNode );
```

**Kind**: global class  
**Extends**: <code>UniformNode</code>  

* [MaxMipLevelNode](#MaxMipLevelNode) ⇐ <code>UniformNode</code>
    * [new MaxMipLevelNode(textureNode)](#new_MaxMipLevelNode_new)
    * [.updateType](#MaxMipLevelNode+updateType) : <code>string</code>
    * [.textureNode](#MaxMipLevelNode+textureNode) : <code>TextureNode</code>
    * [.texture](#MaxMipLevelNode+texture) : <code>Texture</code>

<a name="new_MaxMipLevelNode_new"></a>

### new MaxMipLevelNode(textureNode)
Constructs a new max mip level node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node to compute the max mip level for. |

<a name="MaxMipLevelNode+updateType"></a>

### maxMipLevelNode.updateType : <code>string</code>
The `updateType` is set to `NodeUpdateType.FRAME` since the node updates
the texture once per frame in its [MaxMipLevelNode#update](MaxMipLevelNode#update) method.

**Kind**: instance property of [<code>MaxMipLevelNode</code>](#MaxMipLevelNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="MaxMipLevelNode+textureNode"></a>

### maxMipLevelNode.textureNode : <code>TextureNode</code>
The texture node to compute the max mip level for.

**Kind**: instance property of [<code>MaxMipLevelNode</code>](#MaxMipLevelNode)  
**Read only**: true  
<a name="MaxMipLevelNode+texture"></a>

### maxMipLevelNode.texture : <code>Texture</code>
The texture.

**Kind**: instance property of [<code>MaxMipLevelNode</code>](#MaxMipLevelNode)  
**Read only**: true  
<a name="maxMipLevel"></a>

## maxMipLevel(textureNode) ⇒ [<code>MaxMipLevelNode</code>](#MaxMipLevelNode)
TSL function for creating a max mip level node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node to compute the max mip level for. |

<a name="MemberNode"></a>

## MemberNode ⇐ <code>Node</code>
Base class for representing member access on an object-like
node data structures.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [MemberNode](#MemberNode) ⇐ <code>Node</code>
    * [new MemberNode(node, property)](#new_MemberNode_new)
    * [.node](#MemberNode+node) : <code>Node</code>
    * [.property](#MemberNode+property) : <code>Node</code>
    * [.isMemberNode](#MemberNode+isMemberNode) : <code>boolean</code>

<a name="new_MemberNode_new"></a>

### new MemberNode(node, property)
Constructs an array element node.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The array-like node. |
| property | <code>string</code> | The property name. |

<a name="MemberNode+node"></a>

### memberNode.node : <code>Node</code>
The array-like node.

**Kind**: instance property of [<code>MemberNode</code>](#MemberNode)  
<a name="MemberNode+property"></a>

### memberNode.property : <code>Node</code>
The property name.

**Kind**: instance property of [<code>MemberNode</code>](#MemberNode)  
<a name="MemberNode+isMemberNode"></a>

### memberNode.isMemberNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MemberNode</code>](#MemberNode)  
**Default**: <code>true</code>  
**Read only**: true  
## Functions

<dl>
<dt><a href="#oscSine">oscSine(t)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Generates a sine wave oscillation based on a timer.</p>
</dd>
<dt><a href="#oscSquare">oscSquare(t)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Generates a square wave oscillation based on a timer.</p>
</dd>
<dt><a href="#oscTriangle">oscTriangle(t)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Generates a triangle wave oscillation based on a timer.</p>
</dd>
<dt><a href="#oscSawtooth">oscSawtooth(t)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Generates a sawtooth wave oscillation based on a timer.</p>
</dd>
</dl>

<a name="oscSine"></a>

## oscSine(t) ⇒ <code>Node.&lt;float&gt;</code>
Generates a sine wave oscillation based on a timer.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The oscillation node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node.&lt;float&gt;</code> | The timer to generate the oscillation with. |

<a name="oscSquare"></a>

## oscSquare(t) ⇒ <code>Node.&lt;float&gt;</code>
Generates a square wave oscillation based on a timer.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The oscillation node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node.&lt;float&gt;</code> | The timer to generate the oscillation with. |

<a name="oscTriangle"></a>

## oscTriangle(t) ⇒ <code>Node.&lt;float&gt;</code>
Generates a triangle wave oscillation based on a timer.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The oscillation node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node.&lt;float&gt;</code> | The timer to generate the oscillation with. |

<a name="oscSawtooth"></a>

## oscSawtooth(t) ⇒ <code>Node.&lt;float&gt;</code>
Generates a sawtooth wave oscillation based on a timer.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The oscillation node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node.&lt;float&gt;</code> | The timer to generate the oscillation with. |

## Functions

<dl>
<dt><a href="#directionToColor">directionToColor(node)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Packs a direction vector into a color value.</p>
</dd>
<dt><a href="#colorToDirection">colorToDirection(node)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Unpacks a color value into a direction vector.</p>
</dd>
</dl>

<a name="directionToColor"></a>

## directionToColor(node) ⇒ <code>Node.&lt;vec3&gt;</code>
Packs a direction vector into a color value.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> | The direction to pack. |

<a name="colorToDirection"></a>

## colorToDirection(node) ⇒ <code>Node.&lt;vec3&gt;</code>
Unpacks a color value into a direction vector.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The direction.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> | The color to unpack. |

## Functions

<dl>
<dt><a href="#getViewPosition">getViewPosition(screenPosition, depth, projectionMatrixInverse)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Computes a position in view space based on a fragment&#39;s screen position expressed as uv coordinates, the fragments
depth value and the camera&#39;s inverse projection matrix.</p>
</dd>
<dt><a href="#getScreenPosition">getScreenPosition(viewPosition, projectionMatrix)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Computes a screen position expressed as uv coordinates based on a fragment&#39;s position in view space
and the camera&#39;s projection matrix</p>
</dd>
<dt><a href="#getNormalFromDepth">getNormalFromDepth(uv, depthTexture, projectionMatrixInverse)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Computes a normal vector based on depth data. Can be used as a fallback when no normal render
target is available or if flat surface normals are required.</p>
</dd>
</dl>

<a name="getViewPosition"></a>

## getViewPosition(screenPosition, depth, projectionMatrixInverse) ⇒ <code>Node.&lt;vec3&gt;</code>
Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments
depth value and the camera's inverse projection matrix.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The fragments position in view space.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| screenPosition | <code>Node.&lt;vec2&gt;</code> | The fragment's screen position expressed as uv coordinates. |
| depth | <code>Node.&lt;float&gt;</code> | The fragment's depth value. |
| projectionMatrixInverse | <code>Node.&lt;mat4&gt;</code> | The camera's inverse projection matrix. |

<a name="getScreenPosition"></a>

## getScreenPosition(viewPosition, projectionMatrix) ⇒ <code>Node.&lt;vec2&gt;</code>
Computes a screen position expressed as uv coordinates based on a fragment's position in view space
and the camera's projection matrix

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The fragment's screen position expressed as uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| viewPosition | <code>Node.&lt;vec3&gt;</code> | The fragments position in view space. |
| projectionMatrix | <code>Node.&lt;mat4&gt;</code> | The camera's projection matrix. |

<a name="getNormalFromDepth"></a>

## getNormalFromDepth(uv, depthTexture, projectionMatrixInverse) ⇒ <code>Node.&lt;vec3&gt;</code>
Computes a normal vector based on depth data. Can be used as a fallback when no normal render
target is available or if flat surface normals are required.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The computed normal vector.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The texture coordinate. |
| depthTexture | <code>DepthTexture</code> | The depth texture. |
| projectionMatrixInverse | <code>Node.&lt;mat4&gt;</code> | The camera's inverse projection matrix. |

## Classes

<dl>
<dt><a href="#RTTNode">RTTNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p><code>RTTNode</code> takes another node and uses it with a <code>QuadMesh</code> to render into a texture (RTT).
This module is especially relevant in context of post processing where certain nodes require
texture input for their effects. With the helper function <code>convertToTexture()</code> which is based
on this module, the node system can automatically ensure texture input if required.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#rtt">rtt(node, [width], [height], [options])</a> ⇒ <code><a href="#RTTNode">RTTNode</a></code></dt>
<dd><p>TSL function for creating a RTT node.</p>
</dd>
<dt><a href="#convertToTexture">convertToTexture(node, [width], [height], [options])</a> ⇒ <code><a href="#RTTNode">RTTNode</a></code></dt>
<dd><p>TSL function for converting nodes to textures nodes.</p>
</dd>
</dl>

<a name="RTTNode"></a>

## RTTNode ⇐ <code>TextureNode</code>
`RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).
This module is especially relevant in context of post processing where certain nodes require
texture input for their effects. With the helper function `convertToTexture()` which is based
on this module, the node system can automatically ensure texture input if required.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [RTTNode](#RTTNode) ⇐ <code>TextureNode</code>
    * [new RTTNode(node, [width], [height], [options])](#new_RTTNode_new)
    * [.node](#RTTNode+node) : <code>Node</code>
    * [.width](#RTTNode+width) : <code>number</code>
    * [.height](#RTTNode+height) : <code>number</code>
    * [.pixelRatio](#RTTNode+pixelRatio) : <code>number</code>
    * [.renderTarget](#RTTNode+renderTarget) : <code>RenderTarget</code>
    * [.textureNeedsUpdate](#RTTNode+textureNeedsUpdate) : <code>boolean</code>
    * [.autoUpdate](#RTTNode+autoUpdate) : <code>boolean</code>
    * [.updateBeforeType](#RTTNode+updateBeforeType) : <code>string</code>
    * [.autoSize](#RTTNode+autoSize) : <code>boolean</code>
    * [.setSize(width, height)](#RTTNode+setSize)
    * [.setPixelRatio(pixelRatio)](#RTTNode+setPixelRatio)

<a name="new_RTTNode_new"></a>

### new RTTNode(node, [width], [height], [options])
Constructs a new RTT node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to render a texture with. |
| [width] | <code>number</code> | <code></code> | The width of the internal render target. If not width is applied, the render target is automatically resized. |
| [height] | <code>number</code> | <code></code> | The height of the internal render target. |
| [options] | <code>Object</code> | <code>{type:HalfFloatType}</code> | The options for the internal render target. |

<a name="RTTNode+node"></a>

### rttNode.node : <code>Node</code>
The node to render a texture with.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
<a name="RTTNode+width"></a>

### rttNode.width : <code>number</code>
The width of the internal render target.
If not width is applied, the render target is automatically resized.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>null</code>  
<a name="RTTNode+height"></a>

### rttNode.height : <code>number</code>
The height of the internal render target.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>null</code>  
<a name="RTTNode+pixelRatio"></a>

### rttNode.pixelRatio : <code>number</code>
The pixel ratio

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>1</code>  
<a name="RTTNode+renderTarget"></a>

### rttNode.renderTarget : <code>RenderTarget</code>
The render target

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
<a name="RTTNode+textureNeedsUpdate"></a>

### rttNode.textureNeedsUpdate : <code>boolean</code>
Whether the texture requires an update or not.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>true</code>  
<a name="RTTNode+autoUpdate"></a>

### rttNode.autoUpdate : <code>boolean</code>
Whether the texture should automatically be updated or not.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>true</code>  
<a name="RTTNode+updateBeforeType"></a>

### rttNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
the texture once per render in its [RTTNode#updateBefore](RTTNode#updateBefore) method.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="RTTNode+autoSize"></a>

### rttNode.autoSize : <code>boolean</code>
Whether the internal render target should automatically be resized or not.

**Kind**: instance property of [<code>RTTNode</code>](#RTTNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="RTTNode+setSize"></a>

### rttNode.setSize(width, height)
Sets the size of the internal render target

**Kind**: instance method of [<code>RTTNode</code>](#RTTNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="RTTNode+setPixelRatio"></a>

### rttNode.setPixelRatio(pixelRatio)
Sets the pixel ratio. This will also resize the render target.

**Kind**: instance method of [<code>RTTNode</code>](#RTTNode)  

| Param | Type | Description |
| --- | --- | --- |
| pixelRatio | <code>number</code> | The pixel ratio to set. |

<a name="rtt"></a>

## rtt(node, [width], [height], [options]) ⇒ [<code>RTTNode</code>](#RTTNode)
TSL function for creating a RTT node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to render a texture with. |
| [width] | <code>number</code> | <code></code> | The width of the internal render target. If not width is applied, the render target is automatically resized. |
| [height] | <code>number</code> | <code></code> | The height of the internal render target. |
| [options] | <code>Object</code> | <code>{type:HalfFloatType}</code> | The options for the internal render target. |

<a name="convertToTexture"></a>

## convertToTexture(node, [width], [height], [options]) ⇒ [<code>RTTNode</code>](#RTTNode)
TSL function for converting nodes to textures nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to render a texture with. |
| [width] | <code>number</code> | <code></code> | The width of the internal render target. If not width is applied, the render target is automatically resized. |
| [height] | <code>number</code> | <code></code> | The height of the internal render target. |
| [options] | <code>Object</code> | <code>{type:HalfFloatType}</code> | The options for the internal render target. |

## Classes

<dl>
<dt><a href="#ReflectorNode">ReflectorNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>This node can be used to implement mirror-like flat reflective surfaces.</p>
<pre><code class="language-js">const groundReflector = reflector();
material.colorNode = groundReflector;

const plane = new Mesh( geometry, material );
plane.add( groundReflector.target );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#reflector">reflector([parameters])</a> ⇒ <code><a href="#ReflectorNode">ReflectorNode</a></code></dt>
<dd><p>TSL function for creating a reflector node.</p>
</dd>
</dl>

<a name="ReflectorNode"></a>

## ReflectorNode ⇐ <code>TextureNode</code>
This node can be used to implement mirror-like flat reflective surfaces.

```js
const groundReflector = reflector();
material.colorNode = groundReflector;

const plane = new Mesh( geometry, material );
plane.add( groundReflector.target );
```

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [ReflectorNode](#ReflectorNode) ⇐ <code>TextureNode</code>
    * [new ReflectorNode([parameters])](#new_ReflectorNode_new)
    * [.reflector](#ReflectorNode+reflector) : [<code>ReflectorBaseNode</code>](#new_ReflectorBaseNode_new)
    * [.target](#ReflectorNode+target) : <code>Object3D</code>
    * [.getDepthNode()](#ReflectorNode+getDepthNode) ⇒ <code>Node</code>

<a name="new_ReflectorNode_new"></a>

### new ReflectorNode([parameters])
Constructs a new reflector node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parameters] | <code>Object</code> | <code>{}</code> | An object holding configuration parameters. |
| [parameters.target] | <code>Object3D</code> | <code>new Object3D()</code> | The 3D object the reflector is linked to. |
| [parameters.resolution] | <code>number</code> | <code>1</code> | The resolution scale. |
| [parameters.generateMipmaps] | <code>boolean</code> | <code>false</code> | Whether mipmaps should be generated or not. |
| [parameters.bounces] | <code>boolean</code> | <code>true</code> | Whether reflectors can render other reflector nodes or not. |
| [parameters.depth] | <code>boolean</code> | <code>false</code> | Whether depth data should be generated or not. |
| [parameters.defaultTexture] | <code>TextureNode</code> |  | The default texture node. |
| [parameters.reflector] | [<code>ReflectorBaseNode</code>](#new_ReflectorBaseNode_new) |  | The reflector base node. |

<a name="ReflectorNode+reflector"></a>

### reflectorNode.reflector : [<code>ReflectorBaseNode</code>](#new_ReflectorBaseNode_new)
A reference to the internal reflector node.

**Kind**: instance property of [<code>ReflectorNode</code>](#ReflectorNode)  
<a name="ReflectorNode+target"></a>

### reflectorNode.target : <code>Object3D</code>
A reference to 3D object the reflector is linked to.

**Kind**: instance property of [<code>ReflectorNode</code>](#ReflectorNode)  
<a name="ReflectorNode+getDepthNode"></a>

### reflectorNode.getDepthNode() ⇒ <code>Node</code>
Returns a node representing the mirror's depth. That can be used
to implement more advanced reflection effects like distance attenuation.

**Kind**: instance method of [<code>ReflectorNode</code>](#ReflectorNode)  
**Returns**: <code>Node</code> - The depth node.  
<a name="reflector"></a>

## reflector([parameters]) ⇒ [<code>ReflectorNode</code>](#ReflectorNode)
TSL function for creating a reflector node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parameters] | <code>Object</code> | <code>{}</code> | An object holding configuration parameters. |
| [parameters.target] | <code>Object3D</code> | <code>new Object3D()</code> | The 3D object the reflector is linked to. |
| [parameters.resolution] | <code>number</code> | <code>1</code> | The resolution scale. |
| [parameters.generateMipmaps] | <code>boolean</code> | <code>false</code> | Whether mipmaps should be generated or not. |
| [parameters.bounces] | <code>boolean</code> | <code>true</code> | Whether reflectors can render other reflector nodes or not. |
| [parameters.depth] | <code>boolean</code> | <code>false</code> | Whether depth data should be generated or not. |
| [parameters.defaultTexture] | <code>TextureNode</code> |  | The default texture node. |
| [parameters.reflector] | [<code>ReflectorBaseNode</code>](#new_ReflectorBaseNode_new) |  | The reflector base node. |

## Classes

<dl>
<dt><a href="#RemapNode">RemapNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node allows to remap a node value from one range into another. E.g a value of
<code>0.4</code> in the range <code>[ 0.3, 0.5 ]</code> should be remapped into the normalized range <code>[ 0, 1 ]</code>.
<code>RemapNode</code> takes care of that and converts the original value of <code>0.4</code> to <code>0.5</code>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#remap">remap(node, inLowNode, inHighNode, [outLowNode], [outHighNode])</a> ⇒ <code><a href="#RemapNode">RemapNode</a></code></dt>
<dd><p>TSL function for creating a remap node.</p>
</dd>
<dt><a href="#remapClamp">remapClamp(node, inLowNode, inHighNode, [outLowNode], [outHighNode])</a> ⇒ <code><a href="#RemapNode">RemapNode</a></code></dt>
<dd><p>TSL function for creating a remap node, but with enabled clamping.</p>
</dd>
</dl>

<a name="RemapNode"></a>

## RemapNode ⇐ <code>Node</code>
This node allows to remap a node value from one range into another. E.g a value of
`0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.
`RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [RemapNode](#RemapNode) ⇐ <code>Node</code>
    * [new RemapNode(node, inLowNode, inHighNode, [outLowNode], [outHighNode])](#new_RemapNode_new)
    * [.node](#RemapNode+node) : <code>Node</code>
    * [.inLowNode](#RemapNode+inLowNode) : <code>Node</code>
    * [.inHighNode](#RemapNode+inHighNode) : <code>Node</code>
    * [.outLowNode](#RemapNode+outLowNode) : <code>Node</code>
    * [.outHighNode](#RemapNode+outHighNode) : <code>Node</code>
    * [.doClamp](#RemapNode+doClamp) : <code>boolean</code>

<a name="new_RemapNode_new"></a>

### new RemapNode(node, inLowNode, inHighNode, [outLowNode], [outHighNode])
Constructs a new remap node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be remapped. |
| inLowNode | <code>Node</code> |  | The source or current lower bound of the range. |
| inHighNode | <code>Node</code> |  | The source or current upper bound of the range. |
| [outLowNode] | <code>Node</code> | <code>float(0)</code> | The target lower bound of the range. |
| [outHighNode] | <code>Node</code> | <code>float(1)</code> | The target upper bound of the range. |

<a name="RemapNode+node"></a>

### remapNode.node : <code>Node</code>
The node that should be remapped.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
<a name="RemapNode+inLowNode"></a>

### remapNode.inLowNode : <code>Node</code>
The source or current lower bound of the range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
<a name="RemapNode+inHighNode"></a>

### remapNode.inHighNode : <code>Node</code>
The source or current upper bound of the range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
<a name="RemapNode+outLowNode"></a>

### remapNode.outLowNode : <code>Node</code>
The target lower bound of the range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
**Default**: <code>float(0)</code>  
<a name="RemapNode+outHighNode"></a>

### remapNode.outHighNode : <code>Node</code>
The target upper bound of the range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
**Default**: <code>float(1)</code>  
<a name="RemapNode+doClamp"></a>

### remapNode.doClamp : <code>boolean</code>
Whether the node value should be clamped before
remapping it to the target range.

**Kind**: instance property of [<code>RemapNode</code>](#RemapNode)  
**Default**: <code>true</code>  
<a name="remap"></a>

## remap(node, inLowNode, inHighNode, [outLowNode], [outHighNode]) ⇒ [<code>RemapNode</code>](#RemapNode)
TSL function for creating a remap node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be remapped. |
| inLowNode | <code>Node</code> |  | The source or current lower bound of the range. |
| inHighNode | <code>Node</code> |  | The source or current upper bound of the range. |
| [outLowNode] | <code>Node</code> | <code>float(0)</code> | The target lower bound of the range. |
| [outHighNode] | <code>Node</code> | <code>float(1)</code> | The target upper bound of the range. |

<a name="remapClamp"></a>

## remapClamp(node, inLowNode, inHighNode, [outLowNode], [outHighNode]) ⇒ [<code>RemapNode</code>](#RemapNode)
TSL function for creating a remap node, but with enabled clamping.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be remapped. |
| inLowNode | <code>Node</code> |  | The source or current lower bound of the range. |
| inHighNode | <code>Node</code> |  | The source or current upper bound of the range. |
| [outLowNode] | <code>Node</code> | <code>float(0)</code> | The target lower bound of the range. |
| [outHighNode] | <code>Node</code> | <code>float(1)</code> | The target upper bound of the range. |

## Classes

<dl>
<dt><a href="#RotateNode">RotateNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Applies a rotation to the given position node.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#rotate">rotate(positionNode, rotationNode)</a> ⇒ <code><a href="#RotateNode">RotateNode</a></code></dt>
<dd><p>TSL function for creating a rotate node.</p>
</dd>
</dl>

<a name="RotateNode"></a>

## RotateNode ⇐ <code>TempNode</code>
Applies a rotation to the given position node.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [RotateNode](#RotateNode) ⇐ <code>TempNode</code>
    * [new RotateNode(positionNode, rotationNode)](#new_RotateNode_new)
    * [.positionNode](#RotateNode+positionNode) : <code>Node</code>
    * [.rotationNode](#RotateNode+rotationNode) : <code>Node</code>
    * [.getNodeType(builder)](#RotateNode+getNodeType) ⇒ <code>string</code>

<a name="new_RotateNode_new"></a>

### new RotateNode(positionNode, rotationNode)
Constructs a new rotate node.


| Param | Type | Description |
| --- | --- | --- |
| positionNode | <code>Node</code> | The position node. |
| rotationNode | <code>Node</code> | Represents the rotation that is applied to the position node. Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value. |

<a name="RotateNode+positionNode"></a>

### rotateNode.positionNode : <code>Node</code>
The position node.

**Kind**: instance property of [<code>RotateNode</code>](#RotateNode)  
<a name="RotateNode+rotationNode"></a>

### rotateNode.rotationNode : <code>Node</code>
Represents the rotation that is applied to the position node.
 Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.

**Kind**: instance property of [<code>RotateNode</code>](#RotateNode)  
<a name="RotateNode+getNodeType"></a>

### rotateNode.getNodeType(builder) ⇒ <code>string</code>
The type of the [positionNode](#RotateNode+positionNode) defines the node's type.

**Kind**: instance method of [<code>RotateNode</code>](#RotateNode)  
**Returns**: <code>string</code> - The node's type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="rotate"></a>

## rotate(positionNode, rotationNode) ⇒ [<code>RotateNode</code>](#RotateNode)
TSL function for creating a rotate node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| positionNode | <code>Node</code> | The position node. |
| rotationNode | <code>Node</code> | Represents the rotation that is applied to the position node. Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value. |

<a name="SetNode"></a>

## SetNode ⇐ <code>TempNode</code>
This module is part of the TSL core and usually not used in app level code.
`SetNode` represents a set operation which means it is used to implement any
`setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.
For example:
```js
materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [SetNode](#SetNode) ⇐ <code>TempNode</code>
    * [new SetNode(sourceNode, components, targetNode)](#new_SetNode_new)
    * [.sourceNode](#SetNode+sourceNode) : <code>Node</code>
    * [.components](#SetNode+components) : <code>string</code>
    * [.targetNode](#SetNode+targetNode) : <code>Node</code>
    * [.getNodeType(builder)](#SetNode+getNodeType) ⇒ <code>string</code>

<a name="new_SetNode_new"></a>

### new SetNode(sourceNode, components, targetNode)
Constructs a new set node.


| Param | Type | Description |
| --- | --- | --- |
| sourceNode | <code>Node</code> | The node that should be updated. |
| components | <code>string</code> | The components that should be updated. |
| targetNode | <code>Node</code> | The value node. |

<a name="SetNode+sourceNode"></a>

### setNode.sourceNode : <code>Node</code>
The node that should be updated.

**Kind**: instance property of [<code>SetNode</code>](#SetNode)  
<a name="SetNode+components"></a>

### setNode.components : <code>string</code>
The components that should be updated.

**Kind**: instance property of [<code>SetNode</code>](#SetNode)  
<a name="SetNode+targetNode"></a>

### setNode.targetNode : <code>Node</code>
The value node.

**Kind**: instance property of [<code>SetNode</code>](#SetNode)  
<a name="SetNode+getNodeType"></a>

### setNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from [sourceNode](#SetNode+sourceNode).

**Kind**: instance method of [<code>SetNode</code>](#SetNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SplitNode"></a>

## SplitNode ⇐ <code>Node</code>
This module is part of the TSL core and usually not used in app level code.
`SplitNode` represents a property access operation which means it is
used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.
For example:
```js
const redValue = color.r;
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [SplitNode](#SplitNode) ⇐ <code>Node</code>
    * [new SplitNode(node, [components])](#new_SplitNode_new)
    * [.node](#SplitNode+node) : <code>Node</code>
    * [.components](#SplitNode+components) : <code>string</code>
    * [.isSplitNode](#SplitNode+isSplitNode) : <code>boolean</code>
    * [.getVectorLength()](#SplitNode+getVectorLength) ⇒ <code>number</code>
    * [.getComponentType(builder)](#SplitNode+getComponentType) ⇒ <code>string</code>
    * [.getNodeType(builder)](#SplitNode+getNodeType) ⇒ <code>string</code>

<a name="new_SplitNode_new"></a>

### new SplitNode(node, [components])
Constructs a new split node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be accessed. |
| [components] | <code>string</code> | <code>&quot;&#x27;x&#x27;&quot;</code> | The components that should be accessed. |

<a name="SplitNode+node"></a>

### splitNode.node : <code>Node</code>
The node that should be accessed.

**Kind**: instance property of [<code>SplitNode</code>](#SplitNode)  
<a name="SplitNode+components"></a>

### splitNode.components : <code>string</code>
The components that should be accessed.

**Kind**: instance property of [<code>SplitNode</code>](#SplitNode)  
<a name="SplitNode+isSplitNode"></a>

### splitNode.isSplitNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SplitNode</code>](#SplitNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SplitNode+getVectorLength"></a>

### splitNode.getVectorLength() ⇒ <code>number</code>
Returns the vector length which is computed based on the requested components.

**Kind**: instance method of [<code>SplitNode</code>](#SplitNode)  
**Returns**: <code>number</code> - The vector length.  
<a name="SplitNode+getComponentType"></a>

### splitNode.getComponentType(builder) ⇒ <code>string</code>
Returns the component type of the node's type.

**Kind**: instance method of [<code>SplitNode</code>](#SplitNode)  
**Returns**: <code>string</code> - The component type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SplitNode+getNodeType"></a>

### splitNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from requested components.

**Kind**: instance method of [<code>SplitNode</code>](#SplitNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#SpriteSheetUVNode">SpriteSheetUVNode</a> ⇐ <code>Node</code></dt>
<dd><p>Can be used to compute texture coordinates for animated sprite sheets.</p>
<pre><code class="language-js">const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );

material.colorNode = texture( spriteSheet, uvNode );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#spritesheetUV">spritesheetUV(countNode, [uvNode], [frameNode])</a> ⇒ <code><a href="#SpriteSheetUVNode">SpriteSheetUVNode</a></code></dt>
<dd><p>TSL function for creating a sprite sheet uv node.</p>
</dd>
</dl>

<a name="SpriteSheetUVNode"></a>

## SpriteSheetUVNode ⇐ <code>Node</code>
Can be used to compute texture coordinates for animated sprite sheets.

```js
const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );

material.colorNode = texture( spriteSheet, uvNode );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [SpriteSheetUVNode](#SpriteSheetUVNode) ⇐ <code>Node</code>
    * [new SpriteSheetUVNode(countNode, [uvNode], [frameNode])](#new_SpriteSheetUVNode_new)
    * [.countNode](#SpriteSheetUVNode+countNode) : <code>Node.&lt;vec2&gt;</code>
    * [.uvNode](#SpriteSheetUVNode+uvNode) : <code>Node.&lt;vec2&gt;</code>
    * [.frameNode](#SpriteSheetUVNode+frameNode) : <code>Node.&lt;float&gt;</code>

<a name="new_SpriteSheetUVNode_new"></a>

### new SpriteSheetUVNode(countNode, [uvNode], [frameNode])
Constructs a new sprite sheet uv node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| countNode | <code>Node.&lt;vec2&gt;</code> |  | The node that defines the number of sprites in the x and y direction (e.g 6x6). |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code>uv()</code> | The uv node. |
| [frameNode] | <code>Node.&lt;float&gt;</code> | <code>float()</code> | The node that defines the current frame/sprite. |

<a name="SpriteSheetUVNode+countNode"></a>

### spriteSheetUVNode.countNode : <code>Node.&lt;vec2&gt;</code>
The node that defines the number of sprites in the x and y direction (e.g 6x6).

**Kind**: instance property of [<code>SpriteSheetUVNode</code>](#SpriteSheetUVNode)  
<a name="SpriteSheetUVNode+uvNode"></a>

### spriteSheetUVNode.uvNode : <code>Node.&lt;vec2&gt;</code>
The uv node.

**Kind**: instance property of [<code>SpriteSheetUVNode</code>](#SpriteSheetUVNode)  
<a name="SpriteSheetUVNode+frameNode"></a>

### spriteSheetUVNode.frameNode : <code>Node.&lt;float&gt;</code>
The node that defines the current frame/sprite.

**Kind**: instance property of [<code>SpriteSheetUVNode</code>](#SpriteSheetUVNode)  
<a name="spritesheetUV"></a>

## spritesheetUV(countNode, [uvNode], [frameNode]) ⇒ [<code>SpriteSheetUVNode</code>](#SpriteSheetUVNode)
TSL function for creating a sprite sheet uv node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| countNode | <code>Node.&lt;vec2&gt;</code> |  | The node that defines the number of sprites in the x and y direction (e.g 6x6). |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code>uv()</code> | The uv node. |
| [frameNode] | <code>Node.&lt;float&gt;</code> | <code>float()</code> | The node that defines the current frame/sprite. |

<a name="billboarding"></a>

## billboarding(config) ⇒ <code>Node.&lt;vec3&gt;</code>
This can be used to achieve a billboarding behavior for flat meshes. That means they are
oriented always towards the camera.

```js
material.vertexNode = billboarding();
```

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The updated vertex position in clip space.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| config | <code>Object</code> |  | The configuration object. |
| [config.position] | <code>Node.&lt;vec3&gt;</code> | <code></code> | Can be used to define the vertex positions in world space. |
| [config.horizontal] | <code>boolean</code> | <code>true</code> | Whether to follow the camera rotation horizontally or not. |
| [config.vertical] | <code>boolean</code> | <code>false</code> | Whether to follow the camera rotation vertically or not. |

## Classes

<dl>
<dt><a href="#StorageArrayElementNode">StorageArrayElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>This class enables element access on instances of <a href="StorageBufferNode">StorageBufferNode</a>.
In most cases, it is indirectly used when accessing elements with the
<a href="StorageBufferNode#element">StorageBufferNode#element</a> method.</p>
<pre><code class="language-js">const position = positionStorage.element( instanceIndex );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#storageElement">storageElement(storageBufferNode, indexNode)</a> ⇒ <code><a href="#StorageArrayElementNode">StorageArrayElementNode</a></code></dt>
<dd><p>TSL function for creating a storage element node.</p>
</dd>
</dl>

<a name="StorageArrayElementNode"></a>

## StorageArrayElementNode ⇐ <code>ArrayElementNode</code>
This class enables element access on instances of [StorageBufferNode](StorageBufferNode).
In most cases, it is indirectly used when accessing elements with the
[StorageBufferNode#element](StorageBufferNode#element) method.

```js
const position = positionStorage.element( instanceIndex );
```

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [StorageArrayElementNode](#StorageArrayElementNode) ⇐ <code>ArrayElementNode</code>
    * [new StorageArrayElementNode(storageBufferNode, indexNode)](#new_StorageArrayElementNode_new)
    * [.isStorageArrayElementNode](#StorageArrayElementNode+isStorageArrayElementNode) : <code>boolean</code>
    * [.storageBufferNode](#StorageArrayElementNode+storageBufferNode) : <code>StorageBufferNode</code>

<a name="new_StorageArrayElementNode_new"></a>

### new StorageArrayElementNode(storageBufferNode, indexNode)
Constructs storage buffer element node.


| Param | Type | Description |
| --- | --- | --- |
| storageBufferNode | <code>StorageBufferNode</code> | The storage buffer node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="StorageArrayElementNode+isStorageArrayElementNode"></a>

### storageArrayElementNode.isStorageArrayElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageArrayElementNode</code>](#StorageArrayElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageArrayElementNode+storageBufferNode"></a>

### storageArrayElementNode.storageBufferNode : <code>StorageBufferNode</code>
The storage buffer node.

**Kind**: instance property of [<code>StorageArrayElementNode</code>](#StorageArrayElementNode)  

| Param | Type |
| --- | --- |
| value | <code>Node</code> | 

<a name="storageElement"></a>

## storageElement(storageBufferNode, indexNode) ⇒ [<code>StorageArrayElementNode</code>](#StorageArrayElementNode)
TSL function for creating a storage element node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| storageBufferNode | <code>StorageBufferNode</code> | The storage buffer node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

## Constants

<dl>
<dt><a href="#time">time</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>Represents the elapsed time in seconds.</p>
</dd>
<dt><a href="#deltaTime">deltaTime</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>Represents the delta time in seconds.</p>
</dd>
<dt><a href="#frameId">frameId</a> : <code>UniformNode.&lt;uint&gt;</code></dt>
<dd><p>Represents the current frame ID.</p>
</dd>
</dl>

## Functions

<dl>
<dt><del><a href="#timerLocal">timerLocal([timeScale])</a> ⇒ <code>UniformNode.&lt;float&gt;</code></del></dt>
<dd></dd>
<dt><del><a href="#timerGlobal">timerGlobal([timeScale])</a> ⇒ <code>UniformNode.&lt;float&gt;</code></del></dt>
<dd></dd>
<dt><del><a href="#timerDelta">timerDelta([timeScale])</a> ⇒ <code>UniformNode.&lt;float&gt;</code></del></dt>
<dd></dd>
</dl>

<a name="time"></a>

## time : <code>UniformNode.&lt;float&gt;</code>
Represents the elapsed time in seconds.

**Kind**: global constant  
**Tsl**:   
<a name="deltaTime"></a>

## deltaTime : <code>UniformNode.&lt;float&gt;</code>
Represents the delta time in seconds.

**Kind**: global constant  
**Tsl**:   
<a name="frameId"></a>

## frameId : <code>UniformNode.&lt;uint&gt;</code>
Represents the current frame ID.

**Kind**: global constant  
**Tsl**:   
<a name="timerLocal"></a>

## ~~timerLocal([timeScale]) ⇒ <code>UniformNode.&lt;float&gt;</code>~~
***since r170. Use [time](#time) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [timeScale] | <code>number</code> | <code>1</code> | The time scale. |

<a name="timerGlobal"></a>

## ~~timerGlobal([timeScale]) ⇒ <code>UniformNode.&lt;float&gt;</code>~~
***since r170. Use [time](#time) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [timeScale] | <code>number</code> | <code>1</code> | The time scale. |

<a name="timerDelta"></a>

## ~~timerDelta([timeScale]) ⇒ <code>UniformNode.&lt;float&gt;</code>~~
***since r170. Use [deltaTime](#deltaTime) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [timeScale] | <code>number</code> | <code>1</code> | The time scale. |

## Classes

<dl>
<dt><a href="#TriplanarTexturesNode">TriplanarTexturesNode</a> ⇐ <code>Node</code></dt>
<dd><p>Can be used for triplanar texture mapping.</p>
<pre><code class="language-js">material.colorNode = triplanarTexture( texture( diffuseMap ) );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#triplanarTextures">triplanarTextures(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode])</a> ⇒ <code><a href="#TriplanarTexturesNode">TriplanarTexturesNode</a></code></dt>
<dd><p>TSL function for creating a triplanar textures node.</p>
</dd>
<dt><a href="#triplanarTexture">triplanarTexture(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode])</a> ⇒ <code><a href="#TriplanarTexturesNode">TriplanarTexturesNode</a></code></dt>
<dd><p>TSL function for creating a triplanar textures node.</p>
</dd>
</dl>

<a name="TriplanarTexturesNode"></a>

## TriplanarTexturesNode ⇐ <code>Node</code>
Can be used for triplanar texture mapping.

```js
material.colorNode = triplanarTexture( texture( diffuseMap ) );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [TriplanarTexturesNode](#TriplanarTexturesNode) ⇐ <code>Node</code>
    * [new TriplanarTexturesNode(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode])](#new_TriplanarTexturesNode_new)
    * [.textureXNode](#TriplanarTexturesNode+textureXNode) : <code>Node</code>
    * [.textureYNode](#TriplanarTexturesNode+textureYNode) : <code>Node</code>
    * [.textureZNode](#TriplanarTexturesNode+textureZNode) : <code>Node</code>
    * [.scaleNode](#TriplanarTexturesNode+scaleNode) : <code>Node.&lt;float&gt;</code>
    * [.positionNode](#TriplanarTexturesNode+positionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.normalNode](#TriplanarTexturesNode+normalNode) : <code>Node.&lt;vec3&gt;</code>

<a name="new_TriplanarTexturesNode_new"></a>

### new TriplanarTexturesNode(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode])
Constructs a new triplanar textures node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureXNode | <code>Node</code> |  | First texture node. |
| [textureYNode] | <code>Node</code> | <code></code> | Second texture node. When not set, the shader will sample from `textureXNode` instead. |
| [textureZNode] | <code>Node</code> | <code></code> | Third texture node. When not set, the shader will sample from `textureXNode` instead. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The scale node. |
| [positionNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionLocal</code> | Vertex positions in local space. |
| [normalNode] | <code>Node.&lt;vec3&gt;</code> | <code>normalLocal</code> | Normals in local space. |

<a name="TriplanarTexturesNode+textureXNode"></a>

### triplanarTexturesNode.textureXNode : <code>Node</code>
First texture node.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
<a name="TriplanarTexturesNode+textureYNode"></a>

### triplanarTexturesNode.textureYNode : <code>Node</code>
Second texture node. When not set, the shader will sample from `textureXNode` instead.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>null</code>  
<a name="TriplanarTexturesNode+textureZNode"></a>

### triplanarTexturesNode.textureZNode : <code>Node</code>
Third texture node. When not set, the shader will sample from `textureXNode` instead.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>null</code>  
<a name="TriplanarTexturesNode+scaleNode"></a>

### triplanarTexturesNode.scaleNode : <code>Node.&lt;float&gt;</code>
The scale node.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>float(1)</code>  
<a name="TriplanarTexturesNode+positionNode"></a>

### triplanarTexturesNode.positionNode : <code>Node.&lt;vec3&gt;</code>
Vertex positions in local space.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>positionLocal</code>  
<a name="TriplanarTexturesNode+normalNode"></a>

### triplanarTexturesNode.normalNode : <code>Node.&lt;vec3&gt;</code>
Normals in local space.

**Kind**: instance property of [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)  
**Default**: <code>normalLocal</code>  
<a name="triplanarTextures"></a>

## triplanarTextures(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode]) ⇒ [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)
TSL function for creating a triplanar textures node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureXNode | <code>Node</code> |  | First texture node. |
| [textureYNode] | <code>Node</code> | <code></code> | Second texture node. When not set, the shader will sample from `textureXNode` instead. |
| [textureZNode] | <code>Node</code> | <code></code> | Third texture node. When not set, the shader will sample from `textureXNode` instead. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The scale node. |
| [positionNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionLocal</code> | Vertex positions in local space. |
| [normalNode] | <code>Node.&lt;vec3&gt;</code> | <code>normalLocal</code> | Normals in local space. |

<a name="triplanarTexture"></a>

## triplanarTexture(textureXNode, [textureYNode], [textureZNode], [scaleNode], [positionNode], [normalNode]) ⇒ [<code>TriplanarTexturesNode</code>](#TriplanarTexturesNode)
TSL function for creating a triplanar textures node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureXNode | <code>Node</code> |  | First texture node. |
| [textureYNode] | <code>Node</code> | <code></code> | Second texture node. When not set, the shader will sample from `textureXNode` instead. |
| [textureZNode] | <code>Node</code> | <code></code> | Third texture node. When not set, the shader will sample from `textureXNode` instead. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The scale node. |
| [positionNode] | <code>Node.&lt;vec3&gt;</code> | <code>positionLocal</code> | Vertex positions in local space. |
| [normalNode] | <code>Node.&lt;vec3&gt;</code> | <code>normalLocal</code> | Normals in local space. |

## Functions

<dl>
<dt><a href="#rotateUV">rotateUV(uv, rotation, center)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Rotates the given uv coordinates around a center point</p>
</dd>
<dt><a href="#spherizeUV">spherizeUV(uv, strength, center)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Applies a spherical warping effect to the given uv coordinates.</p>
</dd>
</dl>

<a name="rotateUV"></a>

## rotateUV(uv, rotation, center) ⇒ <code>Node.&lt;vec2&gt;</code>
Rotates the given uv coordinates around a center point

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The rotated uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The uv coordinates. |
| rotation | <code>Node.&lt;float&gt;</code> | The rotation defined in radians. |
| center | <code>Node.&lt;vec2&gt;</code> | The center of rotation |

<a name="spherizeUV"></a>

## spherizeUV(uv, strength, center) ⇒ <code>Node.&lt;vec2&gt;</code>
Applies a spherical warping effect to the given uv coordinates.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The updated uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The uv coordinates. |
| strength | <code>Node.&lt;float&gt;</code> | The strength of the effect. |
| center | <code>Node.&lt;vec2&gt;</code> | The center point |

<a name="viewportSafeUV"></a>

## viewportSafeUV(uv) ⇒ <code>Node.&lt;vec2&gt;</code>
A special version of a screen uv function that involves a depth comparison
when computing the final uvs. The function mitigates visual errors when
using viewport texture nodes for refraction purposes. Without this function
objects in front of a refractive surface might appear on the refractive surface
which is incorrect.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The update uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | Optional uv coordinates. By default `screenUV` is used. |

<a name="BatchedMesh"></a>

## BatchedMesh ⇐ <code>Mesh</code>
A special version of a mesh with multi draw batch rendering support. Use
this class if you have to render a large number of objects with the same
material but with different geometries or world transformations. The usage of
`BatchedMesh` will help you to reduce the number of draw calls and thus improve the overall
rendering performance in your application.

```js
const box = new THREE.BoxGeometry( 1, 1, 1 );
const sphere = new THREE.SphereGeometry( 1, 12, 12 );
const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );

// initialize and add geometries into the batched mesh
const batchedMesh = new BatchedMesh( 10, 5000, 10000, material );
const boxGeometryId = batchedMesh.addGeometry( box );
const sphereGeometryId = batchedMesh.addGeometry( sphere );

// create instances of those geometries
const boxInstancedId1 = batchedMesh.addInstance( boxGeometryId );
const boxInstancedId2 = batchedMesh.addInstance( boxGeometryId );

const sphereInstancedId1 = batchedMesh.addInstance( sphereGeometryId );
const sphereInstancedId2 = batchedMesh.addInstance( sphereGeometryId );

// position the geometries
batchedMesh.setMatrixAt( boxInstancedId1, boxMatrix1 );
batchedMesh.setMatrixAt( boxInstancedId2, boxMatrix2 );

batchedMesh.setMatrixAt( sphereInstancedId1, sphereMatrix1 );
batchedMesh.setMatrixAt( sphereInstancedId2, sphereMatrix2 );

scene.add( batchedMesh );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [BatchedMesh](#BatchedMesh) ⇐ <code>Mesh</code>
    * [new BatchedMesh(maxInstanceCount, maxVertexCount, [maxIndexCount], [material])](#new_BatchedMesh_new)
    * [.isBatchedMesh](#BatchedMesh+isBatchedMesh) : <code>boolean</code>
    * [.perObjectFrustumCulled](#BatchedMesh+perObjectFrustumCulled) : <code>boolean</code>
    * [.sortObjects](#BatchedMesh+sortObjects) : <code>boolean</code>
    * [.boundingBox](#BatchedMesh+boundingBox) : <code>Box3</code>
    * [.boundingSphere](#BatchedMesh+boundingSphere) : <code>Sphere</code>
    * [.customSort](#BatchedMesh+customSort) : <code>function</code>
    * [.maxInstanceCount](#BatchedMesh+maxInstanceCount) : <code>number</code>
    * [.instanceCount](#BatchedMesh+instanceCount) : <code>number</code>
    * [.unusedVertexCount](#BatchedMesh+unusedVertexCount) : <code>number</code>
    * [.unusedIndexCount](#BatchedMesh+unusedIndexCount) : <code>number</code>
    * [.validateInstanceId(instanceId)](#BatchedMesh+validateInstanceId)
    * [.validateGeometryId(geometryId)](#BatchedMesh+validateGeometryId)
    * [.setCustomSort(func)](#BatchedMesh+setCustomSort) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.computeBoundingBox()](#BatchedMesh+computeBoundingBox)
    * [.computeBoundingSphere()](#BatchedMesh+computeBoundingSphere)
    * [.addInstance(geometryId)](#BatchedMesh+addInstance) ⇒ <code>number</code>
    * [.addGeometry(geometry, [reservedVertexCount], [reservedIndexCount])](#BatchedMesh+addGeometry) ⇒ <code>number</code>
    * [.setGeometryAt(geometryId, geometry)](#BatchedMesh+setGeometryAt) ⇒ <code>number</code>
    * [.deleteGeometry(geometryId)](#BatchedMesh+deleteGeometry) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.deleteInstance(instanceId)](#BatchedMesh+deleteInstance) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.optimize(instanceId)](#BatchedMesh+optimize) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getBoundingBoxAt(geometryId, target)](#BatchedMesh+getBoundingBoxAt) ⇒ <code>Box3</code> \| <code>null</code>
    * [.getBoundingSphereAt(geometryId, target)](#BatchedMesh+getBoundingSphereAt) ⇒ <code>Sphere</code> \| <code>null</code>
    * [.setMatrixAt(instanceId, matrix)](#BatchedMesh+setMatrixAt) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getMatrixAt(instanceId, matrix)](#BatchedMesh+getMatrixAt) ⇒ <code>Matrix4</code>
    * [.setColorAt(instanceId, color)](#BatchedMesh+setColorAt) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getColorAt(instanceId, color)](#BatchedMesh+getColorAt) ⇒ <code>Color</code>
    * [.setVisibleAt(instanceId, visible)](#BatchedMesh+setVisibleAt) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getVisibleAt(instanceId)](#BatchedMesh+getVisibleAt) ⇒ <code>boolean</code>
    * [.setGeometryIdAt(instanceId, geometryId)](#BatchedMesh+setGeometryIdAt) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
    * [.getGeometryIdAt(instanceId)](#BatchedMesh+getGeometryIdAt) ⇒ <code>number</code>
    * [.getGeometryRangeAt(geometryId, [target])](#BatchedMesh+getGeometryRangeAt) ⇒ <code>Object</code>
    * [.setInstanceCount(maxInstanceCount)](#BatchedMesh+setInstanceCount)
    * [.setGeometrySize(maxVertexCount, maxIndexCount)](#BatchedMesh+setGeometrySize)
    * [.dispose()](#BatchedMesh+dispose)

<a name="new_BatchedMesh_new"></a>

### new BatchedMesh(maxInstanceCount, maxVertexCount, [maxIndexCount], [material])
Constructs a new batched mesh.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| maxInstanceCount | <code>number</code> |  | The maximum number of individual instances planned to be added and rendered. |
| maxVertexCount | <code>number</code> |  | The maximum number of vertices to be used by all unique geometries. |
| [maxIndexCount] | <code>number</code> | <code>maxVertexCount*2</code> | The maximum number of indices to be used by all unique geometries |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> |  | The mesh material. |

<a name="BatchedMesh+isBatchedMesh"></a>

### batchedMesh.isBatchedMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BatchedMesh+perObjectFrustumCulled"></a>

### batchedMesh.perObjectFrustumCulled : <code>boolean</code>
When set ot `true`, the individual objects of a batch are frustum culled.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>true</code>  
<a name="BatchedMesh+sortObjects"></a>

### batchedMesh.sortObjects : <code>boolean</code>
When set to `true`, the individual objects of a batch are sorted to improve overdraw-related artifacts.
If the material is marked as "transparent" objects are rendered back to front and if not then they are
rendered front to back.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>true</code>  
<a name="BatchedMesh+boundingBox"></a>

### batchedMesh.boundingBox : <code>Box3</code>
The bounding box of the batched mesh. Can be computed via [computeBoundingBox](#BatchedMesh+computeBoundingBox).

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>null</code>  
<a name="BatchedMesh+boundingSphere"></a>

### batchedMesh.boundingSphere : <code>Sphere</code>
The bounding sphere of the batched mesh. Can be computed via [computeBoundingSphere](#BatchedMesh+computeBoundingSphere).

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>null</code>  
<a name="BatchedMesh+customSort"></a>

### batchedMesh.customSort : <code>function</code>
Takes a sort a function that is run before render. The function takes a list of instances to
sort and a camera. The objects in the list include a "z" field to perform a depth-ordered
sort with.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Default**: <code>null</code>  
<a name="BatchedMesh+maxInstanceCount"></a>

### batchedMesh.maxInstanceCount : <code>number</code>
The maximum number of individual instances that can be stored in the batch.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Read only**: true  
<a name="BatchedMesh+instanceCount"></a>

### batchedMesh.instanceCount : <code>number</code>
The instance count.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Read only**: true  
<a name="BatchedMesh+unusedVertexCount"></a>

### batchedMesh.unusedVertexCount : <code>number</code>
The number of unused vertices.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Read only**: true  
<a name="BatchedMesh+unusedIndexCount"></a>

### batchedMesh.unusedIndexCount : <code>number</code>
The number of unused indices.

**Kind**: instance property of [<code>BatchedMesh</code>](#BatchedMesh)  
**Read only**: true  
<a name="BatchedMesh+validateInstanceId"></a>

### batchedMesh.validateInstanceId(instanceId)
Validates the instance defined by the given ID.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The instance to validate. |

<a name="BatchedMesh+validateGeometryId"></a>

### batchedMesh.validateGeometryId(geometryId)
Validates the geometry defined by the given ID.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The geometry to validate. |

<a name="BatchedMesh+setCustomSort"></a>

### batchedMesh.setCustomSort(func) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Takes a sort a function that is run before render. The function takes a list of instances to
sort and a camera. The objects in the list include a "z" field to perform a depth-ordered sort with.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| func | <code>function</code> | The custom sort function. |

<a name="BatchedMesh+computeBoundingBox"></a>

### batchedMesh.computeBoundingBox()
Computes the bounding box, updating [boundingBox](#BatchedMesh+boundingBox).
Bounding boxes aren't computed by default. They need to be explicitly computed,
otherwise they are `null`.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
<a name="BatchedMesh+computeBoundingSphere"></a>

### batchedMesh.computeBoundingSphere()
Computes the bounding sphere, updating [boundingSphere](#BatchedMesh+boundingSphere).
Bounding spheres aren't computed by default. They need to be explicitly computed,
otherwise they are `null`.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
<a name="BatchedMesh+addInstance"></a>

### batchedMesh.addInstance(geometryId) ⇒ <code>number</code>
Adds a new instance to the batch using the geometry of the given ID and returns
a new id referring to the new instance to be used by other functions.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>number</code> - The instance ID.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of a previously added geometry via [addGeometry](#BatchedMesh+addGeometry). |

<a name="BatchedMesh+addGeometry"></a>

### batchedMesh.addGeometry(geometry, [reservedVertexCount], [reservedIndexCount]) ⇒ <code>number</code>
Adds the given geometry to the batch and returns the associated
geometry id referring to it to be used in other functions.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>number</code> - The geometry ID.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to add. |
| [reservedVertexCount] | <code>number</code> | <code>-1</code> | Optional parameter specifying the amount of vertex buffer space to reserve for the added geometry. This is necessary if it is planned to set a new geometry at this index at a later time that is larger than the original geometry. Defaults to the length of the given geometry vertex buffer. |
| [reservedIndexCount] | <code>number</code> | <code>-1</code> | Optional parameter specifying the amount of index buffer space to reserve for the added geometry. This is necessary if it is planned to set a new geometry at this index at a later time that is larger than the original geometry. Defaults to the length of the given geometry index buffer. |

<a name="BatchedMesh+setGeometryAt"></a>

### batchedMesh.setGeometryAt(geometryId, geometry) ⇒ <code>number</code>
Replaces the geometry at the given ID with the provided geometry. Throws an error if there
is not enough space reserved for geometry. Calling this will change all instances that are
rendering that geometry.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>number</code> - The geometry ID.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of the geometry that should be replaced with the given geometry. |
| geometry | <code>BufferGeometry</code> | The new geometry. |

<a name="BatchedMesh+deleteGeometry"></a>

### batchedMesh.deleteGeometry(geometryId) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Deletes the geometry defined by the given ID from this batch. Any instances referencing
this geometry will also be removed as a side effect.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of the geometry to remove from the batch. |

<a name="BatchedMesh+deleteInstance"></a>

### batchedMesh.deleteInstance(instanceId) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Deletes an existing instance from the batch using the given ID.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of the instance to remove from the batch. |

<a name="BatchedMesh+optimize"></a>

### batchedMesh.optimize(instanceId) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Repacks the sub geometries in [name] to remove any unused space remaining from
previously deleted geometry, freeing up space to add new geometry.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of the instance to remove from the batch. |

<a name="BatchedMesh+getBoundingBoxAt"></a>

### batchedMesh.getBoundingBoxAt(geometryId, target) ⇒ <code>Box3</code> \| <code>null</code>
Returns the bounding box for the given geometry.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Box3</code> \| <code>null</code> - The geometry's bounding box. Returns `null` if no geometry has been found for the given ID.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of the geometry to return the bounding box for. |
| target | <code>Box3</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+getBoundingSphereAt"></a>

### batchedMesh.getBoundingSphereAt(geometryId, target) ⇒ <code>Sphere</code> \| <code>null</code>
Returns the bounding sphere for the given geometry.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Sphere</code> \| <code>null</code> - The geometry's bounding sphere. Returns `null` if no geometry has been found for the given ID.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The ID of the geometry to return the bounding sphere for. |
| target | <code>Sphere</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+setMatrixAt"></a>

### batchedMesh.setMatrixAt(instanceId, matrix) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Sets the given local transformation matrix to the defined instance.
Negatively scaled matrices are not supported.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to set the matrix of. |
| matrix | <code>Matrix4</code> | A 4x4 matrix representing the local transformation of a single instance. |

<a name="BatchedMesh+getMatrixAt"></a>

### batchedMesh.getMatrixAt(instanceId, matrix) ⇒ <code>Matrix4</code>
Returns the local transformation matrix of the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Matrix4</code> - The instance's local transformation matrix.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to get the matrix of. |
| matrix | <code>Matrix4</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+setColorAt"></a>

### batchedMesh.setColorAt(instanceId, color) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Sets the given color to the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to set the color of. |
| color | <code>Color</code> | The color to set the instance to. |

<a name="BatchedMesh+getColorAt"></a>

### batchedMesh.getColorAt(instanceId, color) ⇒ <code>Color</code>
Returns the color of the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Color</code> - The instance's color.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to get the color of. |
| color | <code>Color</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+setVisibleAt"></a>

### batchedMesh.setVisibleAt(instanceId, visible) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Sets the visibility of the instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The id of the instance to set the visibility of. |
| visible | <code>boolean</code> | Whether the instance is visible or not. |

<a name="BatchedMesh+getVisibleAt"></a>

### batchedMesh.getVisibleAt(instanceId) ⇒ <code>boolean</code>
Returns the visibility state of the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>boolean</code> - Whether the instance is visible or not.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to get the visibility state of. |

<a name="BatchedMesh+setGeometryIdAt"></a>

### batchedMesh.setGeometryIdAt(instanceId, geometryId) ⇒ [<code>BatchedMesh</code>](#BatchedMesh)
Sets the geometry ID of the instance at the given index.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: [<code>BatchedMesh</code>](#BatchedMesh) - A reference to this batched mesh.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of the instance to set the geometry ID of. |
| geometryId | <code>number</code> | The geometry ID to be use by the instance. |

<a name="BatchedMesh+getGeometryIdAt"></a>

### batchedMesh.getGeometryIdAt(instanceId) ⇒ <code>number</code>
Returns the geometry ID of the defined instance.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>number</code> - The instance's geometry ID.  

| Param | Type | Description |
| --- | --- | --- |
| instanceId | <code>number</code> | The ID of an instance to get the geometry ID of. |

<a name="BatchedMesh+getGeometryRangeAt"></a>

### batchedMesh.getGeometryRangeAt(geometryId, [target]) ⇒ <code>Object</code>
Get the range representing the subset of triangles related to the attached geometry,
indicating the starting offset and count, or `null` if invalid.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
**Returns**: <code>Object</code> - The result object with range data.  

| Param | Type | Description |
| --- | --- | --- |
| geometryId | <code>number</code> | The id of the geometry to get the range of. |
| [target] | <code>Object</code> | The target object that is used to store the method's result. |

<a name="BatchedMesh+setInstanceCount"></a>

### batchedMesh.setInstanceCount(maxInstanceCount)
Resizes the necessary buffers to support the provided number of instances.
If the provided arguments shrink the number of instances but there are not enough
unused Ids at the end of the list then an error is thrown.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| maxInstanceCount | <code>number</code> | The max number of individual instances that can be added and rendered by the batch. |

<a name="BatchedMesh+setGeometrySize"></a>

### batchedMesh.setGeometrySize(maxVertexCount, maxIndexCount)
Resizes the available space in the batch's vertex and index buffer attributes to the provided sizes.
If the provided arguments shrink the geometry buffers but there is not enough unused space at the
end of the geometry attributes then an error is thrown.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| maxVertexCount | <code>number</code> | The maximum number of vertices to be used by all unique geometries to resize to. |
| maxIndexCount | <code>number</code> | The maximum number of indices to be used by all unique geometries to resize to. |

<a name="BatchedMesh+dispose"></a>

### batchedMesh.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>BatchedMesh</code>](#BatchedMesh)  
<a name="Bone"></a>

## Bone ⇐ <code>Object3D</code>
A bone which is part of a [Skeleton](Skeleton). The skeleton in turn is used by
the [SkinnedMesh](SkinnedMesh).

```js
const root = new THREE.Bone();
const child = new THREE.Bone();

root.add( child );
child.position.y = 5;
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Bone](#Bone) ⇐ <code>Object3D</code>
    * [new Bone()](#new_Bone_new)
    * [.isBone](#Bone+isBone) : <code>boolean</code>

<a name="new_Bone_new"></a>

### new Bone()
Constructs a new bone.

<a name="Bone+isBone"></a>

### bone.isBone : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Bone</code>](#Bone)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ClippingGroup"></a>

## ClippingGroup ⇐ <code>Group</code>
In earlier three.js versions, clipping was defined globally
on the renderer or on material level. This special version of
`THREE.Group` allows to encode the clipping state into the scene
graph. Meaning if you create an instance of this group, all
descendant 3D objects will be affected by the respective clipping
planes.

Note: `ClippingGroup` can only be used with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>Group</code>  

* [ClippingGroup](#ClippingGroup) ⇐ <code>Group</code>
    * [new ClippingGroup()](#new_ClippingGroup_new)
    * [.isClippingGroup](#ClippingGroup+isClippingGroup) : <code>boolean</code>
    * [.clippingPlanes](#ClippingGroup+clippingPlanes) : <code>Array.&lt;Plane&gt;</code>
    * [.enabled](#ClippingGroup+enabled) : <code>boolean</code>
    * [.clipIntersection](#ClippingGroup+clipIntersection) : <code>boolean</code>
    * [.clipShadows](#ClippingGroup+clipShadows) : <code>boolean</code>

<a name="new_ClippingGroup_new"></a>

### new ClippingGroup()
Constructs a new clipping group.

<a name="ClippingGroup+isClippingGroup"></a>

### clippingGroup.isClippingGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ClippingGroup+clippingPlanes"></a>

### clippingGroup.clippingPlanes : <code>Array.&lt;Plane&gt;</code>
An array with clipping planes.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
<a name="ClippingGroup+enabled"></a>

### clippingGroup.enabled : <code>boolean</code>
Whether clipping should be enabled or not.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
**Default**: <code>true</code>  
<a name="ClippingGroup+clipIntersection"></a>

### clippingGroup.clipIntersection : <code>boolean</code>
Whether the intersection of the clipping planes is used to clip objects, rather than their union.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
**Default**: <code>false</code>  
<a name="ClippingGroup+clipShadows"></a>

### clippingGroup.clipShadows : <code>boolean</code>
Whether shadows should be clipped or not.

**Kind**: instance property of [<code>ClippingGroup</code>](#ClippingGroup)  
**Default**: <code>false</code>  
<a name="Group"></a>

## Group ⇐ <code>Object3D</code>
This is almost identical to an [Object3D](Object3D). Its purpose is to
make working with groups of objects syntactically clearer.

```js
// Create a group and add the two cubes.
// These cubes can now be rotated / scaled etc as a group.
const group = new THREE.Group();

group.add( meshA );
group.add( meshB );

scene.add( group );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  
<a name="Group+isGroup"></a>

### group.isGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Group</code>](#Group)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InstancedMesh"></a>

## InstancedMesh ⇐ <code>Mesh</code>
A special version of a mesh with instanced rendering support. Use
this class if you have to render a large number of objects with the same
geometry and material(s) but with different world transformations. The usage
of 'InstancedMesh' will help you to reduce the number of draw calls and thus
improve the overall rendering performance in your application.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [InstancedMesh](#InstancedMesh) ⇐ <code>Mesh</code>
    * [new InstancedMesh([geometry], [material], count)](#new_InstancedMesh_new)
    * [.isInstancedMesh](#InstancedMesh+isInstancedMesh) : <code>boolean</code>
    * [.instanceMatrix](#InstancedMesh+instanceMatrix) : <code>InstancedBufferAttribute</code>
    * [.instanceColor](#InstancedMesh+instanceColor) : <code>InstancedBufferAttribute</code>
    * [.morphTexture](#InstancedMesh+morphTexture) : <code>DataTexture</code>
    * [.count](#InstancedMesh+count) : <code>number</code>
    * [.boundingBox](#InstancedMesh+boundingBox) : <code>Box3</code>
    * [.boundingSphere](#InstancedMesh+boundingSphere) : <code>Sphere</code>
    * [.computeBoundingBox()](#InstancedMesh+computeBoundingBox)
    * [.computeBoundingSphere()](#InstancedMesh+computeBoundingSphere)
    * [.getColorAt(index, color)](#InstancedMesh+getColorAt)
    * [.getMatrixAt(index, matrix)](#InstancedMesh+getMatrixAt)
    * [.getMorphAt(index, object)](#InstancedMesh+getMorphAt)
    * [.setColorAt(index, color)](#InstancedMesh+setColorAt)
    * [.setMatrixAt(index, matrix)](#InstancedMesh+setMatrixAt)
    * [.setMorphAt(index, object)](#InstancedMesh+setMorphAt)
    * [.dispose()](#InstancedMesh+dispose)

<a name="new_InstancedMesh_new"></a>

### new InstancedMesh([geometry], [material], count)
Constructs a new instanced mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |
| count | <code>number</code> | The number of instances. |

<a name="InstancedMesh+isInstancedMesh"></a>

### instancedMesh.isInstancedMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InstancedMesh+instanceMatrix"></a>

### instancedMesh.instanceMatrix : <code>InstancedBufferAttribute</code>
Represents the local transformation of all instances. You have to set its
[BufferAttribute#needsUpdate](BufferAttribute#needsUpdate) flag to true if you modify instanced data
via [setMatrixAt](#InstancedMesh+setMatrixAt).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="InstancedMesh+instanceColor"></a>

### instancedMesh.instanceColor : <code>InstancedBufferAttribute</code>
Represents the color of all instances. You have to set its
[BufferAttribute#needsUpdate](BufferAttribute#needsUpdate) flag to true if you modify instanced data
via [setColorAt](#InstancedMesh+setColorAt).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>null</code>  
<a name="InstancedMesh+morphTexture"></a>

### instancedMesh.morphTexture : <code>DataTexture</code>
Represents the morph target weights of all instances. You have to set its
[Texture#needsUpdate](Texture#needsUpdate) flag to true if you modify instanced data
via [setMorphAt](#InstancedMesh+setMorphAt).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>null</code>  
<a name="InstancedMesh+count"></a>

### instancedMesh.count : <code>number</code>
The number of instances.

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="InstancedMesh+boundingBox"></a>

### instancedMesh.boundingBox : <code>Box3</code>
The bounding box of the instanced mesh. Can be computed via [computeBoundingBox](#InstancedMesh+computeBoundingBox).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>null</code>  
<a name="InstancedMesh+boundingSphere"></a>

### instancedMesh.boundingSphere : <code>Sphere</code>
The bounding sphere of the instanced mesh. Can be computed via [computeBoundingSphere](#InstancedMesh+computeBoundingSphere).

**Kind**: instance property of [<code>InstancedMesh</code>](#InstancedMesh)  
**Default**: <code>null</code>  
<a name="InstancedMesh+computeBoundingBox"></a>

### instancedMesh.computeBoundingBox()
Computes the bounding box of the instanced mesh, and updates [boundingBox](#InstancedMesh+boundingBox).
The bounding box is not automatically computed by the engine; this method must be called by your app.
You may need to recompute the bounding box if an instance is transformed via [setMatrixAt](#InstancedMesh+setMatrixAt).

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="InstancedMesh+computeBoundingSphere"></a>

### instancedMesh.computeBoundingSphere()
Computes the bounding sphere of the instanced mesh, and updates [boundingSphere](#InstancedMesh+boundingSphere)
The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
You may need to recompute the bounding sphere if an instance is transformed via [setMatrixAt](#InstancedMesh+setMatrixAt).

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="InstancedMesh+getColorAt"></a>

### instancedMesh.getColorAt(index, color)
Gets the color of the defined instance.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| color | <code>Color</code> | The target object that is used to store the method's result. |

<a name="InstancedMesh+getMatrixAt"></a>

### instancedMesh.getMatrixAt(index, matrix)
Gets the local transformation matrix of the defined instance.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| matrix | <code>Matrix4</code> | The target object that is used to store the method's result. |

<a name="InstancedMesh+getMorphAt"></a>

### instancedMesh.getMorphAt(index, object)
Gets the morph target weights of the defined instance.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| object | <code>Mesh</code> | The target object that is used to store the method's result. |

<a name="InstancedMesh+setColorAt"></a>

### instancedMesh.setColorAt(index, color)
Sets the given color to the defined instance. Make sure you set the `needsUpdate` flag of
[instanceColor](#InstancedMesh+instanceColor) to `true` after updating all the colors.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| color | <code>Color</code> | The instance color. |

<a name="InstancedMesh+setMatrixAt"></a>

### instancedMesh.setMatrixAt(index, matrix)
Sets the given local transformation matrix to the defined instance. Make sure you set the `needsUpdate` flag of
[instanceMatrix](#InstancedMesh+instanceMatrix) to `true` after updating all the colors.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| matrix | <code>Matrix4</code> | The local transformation. |

<a name="InstancedMesh+setMorphAt"></a>

### instancedMesh.setMorphAt(index, object)
Sets the morph target weights to the defined instance. Make sure you set the `needsUpdate` flag of
[morphTexture](#InstancedMesh+morphTexture) to `true` after updating all the influences.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The instance index. |
| object | <code>Mesh</code> | A mesh which `morphTargetInfluences` property containing the morph target weights of a single instance. |

<a name="InstancedMesh+dispose"></a>

### instancedMesh.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>InstancedMesh</code>](#InstancedMesh)  
<a name="LOD"></a>

## LOD ⇐ <code>Object3D</code>
A component for providing a basic Level of Detail (LOD) mechanism.

Every LOD level is associated with an object, and rendering can be switched
between them at the distances specified. Typically you would create, say,
three meshes, one for far away (low detail), one for mid range (medium
detail) and one for close up (high detail).

```js
const lod = new THREE.LOD();
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );

//Create spheres with 3 levels of detail and create new LOD levels for them
for( let i = 0; i < 3; i++ ) {

	const geometry = new THREE.IcosahedronGeometry( 10, 3 - i );
	const mesh = new THREE.Mesh( geometry, material );
	lod.addLevel( mesh, i * 75 );

}

scene.add( lod );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [LOD](#LOD) ⇐ <code>Object3D</code>
    * [new LOD()](#new_LOD_new)
    * [.isLOD](#LOD+isLOD) : <code>boolean</code>
    * [.levels](#LOD+levels) : <code>Array.&lt;{object:Object3D, distance:number, hysteresis:number}&gt;</code>
    * [.autoUpdate](#LOD+autoUpdate) : <code>boolean</code>
    * [.addLevel(object, [distance], [hysteresis])](#LOD+addLevel) ⇒ [<code>LOD</code>](#LOD)
    * [.removeLevel(distance)](#LOD+removeLevel) ⇒ <code>boolean</code>
    * [.getCurrentLevel()](#LOD+getCurrentLevel) ⇒ <code>number</code>
    * [.getObjectForDistance(distance)](#LOD+getObjectForDistance) ⇒ <code>Object3D</code> \| <code>null</code>
    * [.raycast(raycaster, intersects)](#LOD+raycast)
    * [.update(camera)](#LOD+update)

<a name="new_LOD_new"></a>

### new LOD()
Constructs a new LOD.

<a name="LOD+isLOD"></a>

### loD.isLOD : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LOD</code>](#LOD)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LOD+levels"></a>

### loD.levels : <code>Array.&lt;{object:Object3D, distance:number, hysteresis:number}&gt;</code>
This array holds the LOD levels.

**Kind**: instance property of [<code>LOD</code>](#LOD)  
<a name="LOD+autoUpdate"></a>

### loD.autoUpdate : <code>boolean</code>
Whether the LOD object is updated automatically by the renderer per frame
or not. If set to `false`, you have to call [update](#LOD+update) in the
render loop by yourself.

**Kind**: instance property of [<code>LOD</code>](#LOD)  
**Default**: <code>true</code>  
<a name="LOD+addLevel"></a>

### loD.addLevel(object, [distance], [hysteresis]) ⇒ [<code>LOD</code>](#LOD)
Adds a mesh that will display at a certain distance and greater. Typically
the further away the distance, the lower the detail on the mesh.

**Kind**: instance method of [<code>LOD</code>](#LOD)  
**Returns**: [<code>LOD</code>](#LOD) - A reference to this instance.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object to display at this level. |
| [distance] | <code>number</code> | <code>0</code> | The distance at which to display this level of detail. |
| [hysteresis] | <code>number</code> | <code>0</code> | Threshold used to avoid flickering at LOD boundaries, as a fraction of distance. |

<a name="LOD+removeLevel"></a>

### loD.removeLevel(distance) ⇒ <code>boolean</code>
Removes an existing level, based on the distance from the camera.
Returns `true` when the level has been removed. Otherwise `false`.

**Kind**: instance method of [<code>LOD</code>](#LOD)  
**Returns**: <code>boolean</code> - Whether the level has been removed or not.  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | Distance of the level to remove. |

<a name="LOD+getCurrentLevel"></a>

### loD.getCurrentLevel() ⇒ <code>number</code>
Returns the currently active LOD level index.

**Kind**: instance method of [<code>LOD</code>](#LOD)  
**Returns**: <code>number</code> - The current active LOD level index.  
<a name="LOD+getObjectForDistance"></a>

### loD.getObjectForDistance(distance) ⇒ <code>Object3D</code> \| <code>null</code>
Returns a reference to the first 3D object that is greater than
the given distance.

**Kind**: instance method of [<code>LOD</code>](#LOD)  
**Returns**: <code>Object3D</code> \| <code>null</code> - The found 3D object. `null` if no 3D object has been found.  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The LOD distance. |

<a name="LOD+raycast"></a>

### loD.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this LOD.

**Kind**: instance method of [<code>LOD</code>](#LOD)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="LOD+update"></a>

### loD.update(camera)
Updates the LOD by computing which LOD level should be visible according
to the current distance of the given camera.

**Kind**: instance method of [<code>LOD</code>](#LOD)  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="Line"></a>

## Line ⇐ <code>Object3D</code>
A continuous line. The line are rendered by connecting consecutive
vertices with straight lines.

```js
const material = new THREE.LineBasicMaterial( { color: 0x0000ff } );

const points = [];
points.push( new THREE.Vector3( - 10, 0, 0 ) );
points.push( new THREE.Vector3( 0, 10, 0 ) );
points.push( new THREE.Vector3( 10, 0, 0 ) );

const geometry = new THREE.BufferGeometry().setFromPoints( points );

const line = new THREE.Line( geometry, material );
scene.add( line );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Line](#Line) ⇐ <code>Object3D</code>
    * [new Line([geometry], [material])](#new_Line_new)
    * [.isLine](#Line+isLine) : <code>boolean</code>
    * [.geometry](#Line+geometry) : <code>BufferGeometry</code>
    * [.material](#Line+material) : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
    * [.morphTargetDictionary](#Line+morphTargetDictionary) : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
    * [.morphTargetInfluences](#Line+morphTargetInfluences) : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
    * [.computeLineDistances()](#Line+computeLineDistances) ⇒ [<code>Line</code>](#Line)
    * [.raycast(raycaster, intersects)](#Line+raycast)
    * [.updateMorphTargets()](#Line+updateMorphTargets)

<a name="new_Line_new"></a>

### new Line([geometry], [material])
Constructs a new line.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The line geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The line material. |

<a name="Line+isLine"></a>

### line.isLine : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Line</code>](#Line)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Line+geometry"></a>

### line.geometry : <code>BufferGeometry</code>
The line geometry.

**Kind**: instance property of [<code>Line</code>](#Line)  
<a name="Line+material"></a>

### line.material : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
The line material.

**Kind**: instance property of [<code>Line</code>](#Line)  
**Default**: <code>LineBasicMaterial</code>  
<a name="Line+morphTargetDictionary"></a>

### line.morphTargetDictionary : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
A dictionary representing the morph targets in the geometry. The key is the
morph targets name, the value its attribute index. This member is `undefined`
by default and only set when morph targets are detected in the geometry.

**Kind**: instance property of [<code>Line</code>](#Line)  
**Default**: <code>undefined</code>  
<a name="Line+morphTargetInfluences"></a>

### line.morphTargetInfluences : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
An array of weights typically in the range `[0,1]` that specify how much of the morph
is applied. This member is `undefined` by default and only set when morph targets are
detected in the geometry.

**Kind**: instance property of [<code>Line</code>](#Line)  
**Default**: <code>undefined</code>  
<a name="Line+computeLineDistances"></a>

### line.computeLineDistances() ⇒ [<code>Line</code>](#Line)
Computes an array of distance values which are necessary for rendering dashed lines.
For each vertex in the geometry, the method calculates the cumulative length from the
current point to the very beginning of the line.

**Kind**: instance method of [<code>Line</code>](#Line)  
**Returns**: [<code>Line</code>](#Line) - A reference to this line.  
<a name="Line+raycast"></a>

### line.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this line.

**Kind**: instance method of [<code>Line</code>](#Line)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="Line+updateMorphTargets"></a>

### line.updateMorphTargets()
Sets the values of [morphTargetDictionary](#Line+morphTargetDictionary) and [morphTargetInfluences](#Line+morphTargetInfluences)
to make sure existing morph targets can influence this 3D object.

**Kind**: instance method of [<code>Line</code>](#Line)  
<a name="LineLoop"></a>

## LineLoop ⇐ <code>Line</code>
A continuous line. This is nearly the same as [Line](Line) the only difference
is that the last vertex is connected with the first vertex in order to close
the line to form a loop.

**Kind**: global class  
**Extends**: <code>Line</code>  

* [LineLoop](#LineLoop) ⇐ <code>Line</code>
    * [new LineLoop([geometry], [material])](#new_LineLoop_new)
    * [.isLineLoop](#LineLoop+isLineLoop) : <code>boolean</code>

<a name="new_LineLoop_new"></a>

### new LineLoop([geometry], [material])
Constructs a new line loop.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The line geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The line material. |

<a name="LineLoop+isLineLoop"></a>

### lineLoop.isLineLoop : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineLoop</code>](#LineLoop)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LineSegments"></a>

## LineSegments ⇐ <code>Line</code>
A series of lines drawn between pairs of vertices.

**Kind**: global class  
**Extends**: <code>Line</code>  

* [LineSegments](#LineSegments) ⇐ <code>Line</code>
    * [new LineSegments([geometry], [material])](#new_LineSegments_new)
    * [.isLineSegments](#LineSegments+isLineSegments) : <code>boolean</code>

<a name="new_LineSegments_new"></a>

### new LineSegments([geometry], [material])
Constructs a new line segments.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The line geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The line material. |

<a name="LineSegments+isLineSegments"></a>

### lineSegments.isLineSegments : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LineSegments</code>](#LineSegments)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Mesh"></a>

## Mesh ⇐ <code>Object3D</code>
Class representing triangular polygon mesh based objects.

```js
const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Mesh](#Mesh) ⇐ <code>Object3D</code>
    * [new Mesh([geometry], [material])](#new_Mesh_new)
    * [.isMesh](#Mesh+isMesh) : <code>boolean</code>
    * [.geometry](#Mesh+geometry) : <code>BufferGeometry</code>
    * [.material](#Mesh+material) : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
    * [.morphTargetDictionary](#Mesh+morphTargetDictionary) : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
    * [.morphTargetInfluences](#Mesh+morphTargetInfluences) : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
    * [.updateMorphTargets()](#Mesh+updateMorphTargets)
    * [.getVertexPosition(index, target)](#Mesh+getVertexPosition) ⇒ <code>Vector3</code>
    * [.raycast(raycaster, intersects)](#Mesh+raycast)

<a name="new_Mesh_new"></a>

### new Mesh([geometry], [material])
Constructs a new mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |

<a name="Mesh+isMesh"></a>

### mesh.isMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Mesh+geometry"></a>

### mesh.geometry : <code>BufferGeometry</code>
The mesh geometry.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
<a name="Mesh+material"></a>

### mesh.material : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
The mesh material.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
**Default**: <code>MeshBasicMaterial</code>  
<a name="Mesh+morphTargetDictionary"></a>

### mesh.morphTargetDictionary : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
A dictionary representing the morph targets in the geometry. The key is the
morph targets name, the value its attribute index. This member is `undefined`
by default and only set when morph targets are detected in the geometry.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
**Default**: <code>undefined</code>  
<a name="Mesh+morphTargetInfluences"></a>

### mesh.morphTargetInfluences : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
An array of weights typically in the range `[0,1]` that specify how much of the morph
is applied. This member is `undefined` by default and only set when morph targets are
detected in the geometry.

**Kind**: instance property of [<code>Mesh</code>](#Mesh)  
**Default**: <code>undefined</code>  
<a name="Mesh+updateMorphTargets"></a>

### mesh.updateMorphTargets()
Sets the values of [morphTargetDictionary](#Mesh+morphTargetDictionary) and [morphTargetInfluences](#Mesh+morphTargetInfluences)
to make sure existing morph targets can influence this 3D object.

**Kind**: instance method of [<code>Mesh</code>](#Mesh)  
<a name="Mesh+getVertexPosition"></a>

### mesh.getVertexPosition(index, target) ⇒ <code>Vector3</code>
Returns the local-space position of the vertex at the given index, taking into
account the current animation state of both morph targets and skinning.

**Kind**: instance method of [<code>Mesh</code>](#Mesh)  
**Returns**: <code>Vector3</code> - The vertex position in local space.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The vertex index. |
| target | <code>Vector3</code> | The target object that is used to store the method's result. |

<a name="Mesh+raycast"></a>

### mesh.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this line.

**Kind**: instance method of [<code>Mesh</code>](#Mesh)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="Points"></a>

## Points ⇐ <code>Object3D</code>
A class for displaying points or point clouds.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Points](#Points) ⇐ <code>Object3D</code>
    * [new Points([geometry], [material])](#new_Points_new)
    * [.isPoints](#Points+isPoints) : <code>boolean</code>
    * [.geometry](#Points+geometry) : <code>BufferGeometry</code>
    * [.material](#Points+material) : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
    * [.morphTargetDictionary](#Points+morphTargetDictionary) : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
    * [.morphTargetInfluences](#Points+morphTargetInfluences) : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
    * [.raycast(raycaster, intersects)](#Points+raycast)
    * [.updateMorphTargets()](#Points+updateMorphTargets)

<a name="new_Points_new"></a>

### new Points([geometry], [material])
Constructs a new point cloud.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The points geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The points material. |

<a name="Points+isPoints"></a>

### points.isPoints : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Points</code>](#Points)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Points+geometry"></a>

### points.geometry : <code>BufferGeometry</code>
The points geometry.

**Kind**: instance property of [<code>Points</code>](#Points)  
<a name="Points+material"></a>

### points.material : <code>Material</code> \| <code>Array.&lt;Material&gt;</code>
The line material.

**Kind**: instance property of [<code>Points</code>](#Points)  
**Default**: <code>PointsMaterial</code>  
<a name="Points+morphTargetDictionary"></a>

### points.morphTargetDictionary : <code>Object.&lt;String, number&gt;</code> \| <code>undefined</code>
A dictionary representing the morph targets in the geometry. The key is the
morph targets name, the value its attribute index. This member is `undefined`
by default and only set when morph targets are detected in the geometry.

**Kind**: instance property of [<code>Points</code>](#Points)  
**Default**: <code>undefined</code>  
<a name="Points+morphTargetInfluences"></a>

### points.morphTargetInfluences : <code>Array.&lt;number&gt;</code> \| <code>undefined</code>
An array of weights typically in the range `[0,1]` that specify how much of the morph
is applied. This member is `undefined` by default and only set when morph targets are
detected in the geometry.

**Kind**: instance property of [<code>Points</code>](#Points)  
**Default**: <code>undefined</code>  
<a name="Points+raycast"></a>

### points.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this point cloud.

**Kind**: instance method of [<code>Points</code>](#Points)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="Points+updateMorphTargets"></a>

### points.updateMorphTargets()
Sets the values of [morphTargetDictionary](#Points+morphTargetDictionary) and [morphTargetInfluences](#Points+morphTargetInfluences)
to make sure existing morph targets can influence this 3D object.

**Kind**: instance method of [<code>Points</code>](#Points)  
<a name="Skeleton"></a>

## Skeleton
Class for representing the armatures in `three.js`. The skeleton
is defined by a hierarchy of bones.

```js
const bones = [];

const shoulder = new THREE.Bone();
const elbow = new THREE.Bone();
const hand = new THREE.Bone();

shoulder.add( elbow );
elbow.add( hand );

bones.push( shoulder , elbow, hand);

shoulder.position.y = -5;
elbow.position.y = 0;
hand.position.y = 5;

const armSkeleton = new THREE.Skeleton( bones );
```

**Kind**: global class  

* [Skeleton](#Skeleton)
    * [new Skeleton([bones], [boneInverses])](#new_Skeleton_new)
    * [.bones](#Skeleton+bones) : <code>Array.&lt;Bone&gt;</code>
    * [.boneInverses](#Skeleton+boneInverses) : <code>Array.&lt;Matrix4&gt;</code>
    * [.boneMatrices](#Skeleton+boneMatrices) : <code>Float32Array</code>
    * [.boneTexture](#Skeleton+boneTexture) : <code>DataTexture</code>
    * [.init()](#Skeleton+init)
    * [.calculateInverses()](#Skeleton+calculateInverses)
    * [.pose()](#Skeleton+pose)
    * [.update()](#Skeleton+update)
    * [.clone()](#Skeleton+clone) ⇒ [<code>Skeleton</code>](#Skeleton)
    * [.computeBoneTexture()](#Skeleton+computeBoneTexture) ⇒ [<code>Skeleton</code>](#Skeleton)
    * [.getBoneByName(name)](#Skeleton+getBoneByName) ⇒ <code>Bone</code> \| <code>undefined</code>
    * [.dispose()](#Skeleton+dispose)
    * [.fromJSON(json, bones)](#Skeleton+fromJSON) ⇒ [<code>Skeleton</code>](#Skeleton)
    * [.toJSON()](#Skeleton+toJSON) ⇒ <code>Object</code>

<a name="new_Skeleton_new"></a>

### new Skeleton([bones], [boneInverses])
Constructs a new skeleton.


| Param | Type | Description |
| --- | --- | --- |
| [bones] | <code>Array.&lt;Bone&gt;</code> | An array of bones. |
| [boneInverses] | <code>Array.&lt;Matrix4&gt;</code> | An array of bone inverse matrices. If not provided, these matrices will be computed automatically via [calculateInverses](#Skeleton+calculateInverses). |

<a name="Skeleton+bones"></a>

### skeleton.bones : <code>Array.&lt;Bone&gt;</code>
An array of bones defining the skeleton.

**Kind**: instance property of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+boneInverses"></a>

### skeleton.boneInverses : <code>Array.&lt;Matrix4&gt;</code>
An array of bone inverse matrices.

**Kind**: instance property of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+boneMatrices"></a>

### skeleton.boneMatrices : <code>Float32Array</code>
An array buffer holding the bone data.
Input data for [boneTexture](#Skeleton+boneTexture).

**Kind**: instance property of [<code>Skeleton</code>](#Skeleton)  
**Default**: <code>null</code>  
<a name="Skeleton+boneTexture"></a>

### skeleton.boneTexture : <code>DataTexture</code>
A texture holding the bone data for use
in the vertex shader.

**Kind**: instance property of [<code>Skeleton</code>](#Skeleton)  
**Default**: <code>null</code>  
<a name="Skeleton+init"></a>

### skeleton.init()
Initializes the skeleton. This method gets automatically called by the constructor
but depending on how the skeleton is created it might be necessary to call this method
manually.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+calculateInverses"></a>

### skeleton.calculateInverses()
Computes the bone inverse matrices. This method resets [boneInverses](#Skeleton+boneInverses)
and fills it with new matrices.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+pose"></a>

### skeleton.pose()
Resets the skeleton to the base pose.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+update"></a>

### skeleton.update()
Resets the skeleton to the base pose.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+clone"></a>

### skeleton.clone() ⇒ [<code>Skeleton</code>](#Skeleton)
Returns a new skeleton with copied values from this instance.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: [<code>Skeleton</code>](#Skeleton) - A clone of this instance.  
<a name="Skeleton+computeBoneTexture"></a>

### skeleton.computeBoneTexture() ⇒ [<code>Skeleton</code>](#Skeleton)
Computes a data texture for passing bone data to the vertex shader.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: [<code>Skeleton</code>](#Skeleton) - A reference of this instance.  
<a name="Skeleton+getBoneByName"></a>

### skeleton.getBoneByName(name) ⇒ <code>Bone</code> \| <code>undefined</code>
Searches through the skeleton's bone array and returns the first with a
matching name.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: <code>Bone</code> \| <code>undefined</code> - The found bone. `undefined` if no bone has been found.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the bone. |

<a name="Skeleton+dispose"></a>

### skeleton.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
<a name="Skeleton+fromJSON"></a>

### skeleton.fromJSON(json, bones) ⇒ [<code>Skeleton</code>](#Skeleton)
Setups the skeleton by the given JSON and bones.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: [<code>Skeleton</code>](#Skeleton) - A reference of this instance.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The skeleton as serialized JSON. |
| bones | <code>Object.&lt;string, Bone&gt;</code> | An array of bones. |

<a name="Skeleton+toJSON"></a>

### skeleton.toJSON() ⇒ <code>Object</code>
Serializes the skeleton into JSON.

**Kind**: instance method of [<code>Skeleton</code>](#Skeleton)  
**Returns**: <code>Object</code> - A JSON object representing the serialized skeleton.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  
<a name="SkinnedMesh"></a>

## SkinnedMesh ⇐ <code>Mesh</code>
A mesh that has a [Skeleton](Skeleton) that can then be used to animate the
vertices of the geometry with skinning/skeleton animation.

Next to a valid skeleton, the skinned mesh requires skin indices and weights
as buffer attributes in its geometry. These attribute define which bones affect a single
vertex to a certain extend.

Typically skinned meshes are not created manually but loaders like [GLTFLoader](GLTFLoader)
or [FBXLoader](FBXLoader) import respective models.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [SkinnedMesh](#SkinnedMesh) ⇐ <code>Mesh</code>
    * [new SkinnedMesh([geometry], [material])](#new_SkinnedMesh_new)
    * [.isSkinnedMesh](#SkinnedMesh+isSkinnedMesh) : <code>boolean</code>
    * [.bindMode](#SkinnedMesh+bindMode) : <code>AttachedBindMode</code> \| <code>DetachedBindMode</code>
    * [.bindMatrix](#SkinnedMesh+bindMatrix) : <code>Matrix4</code>
    * [.bindMatrixInverse](#SkinnedMesh+bindMatrixInverse) : <code>Matrix4</code>
    * [.boundingBox](#SkinnedMesh+boundingBox) : <code>Box3</code>
    * [.boundingSphere](#SkinnedMesh+boundingSphere) : <code>Sphere</code>
    * [.computeBoundingBox()](#SkinnedMesh+computeBoundingBox)
    * [.computeBoundingSphere()](#SkinnedMesh+computeBoundingSphere)
    * [.bind(skeleton, [bindMatrix])](#SkinnedMesh+bind)
    * [.pose()](#SkinnedMesh+pose)
    * [.normalizeSkinWeights()](#SkinnedMesh+normalizeSkinWeights)
    * [.applyBoneTransform(index, target)](#SkinnedMesh+applyBoneTransform) ⇒ <code>Vector3</code>

<a name="new_SkinnedMesh_new"></a>

### new SkinnedMesh([geometry], [material])
Constructs a new skinned mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |

<a name="SkinnedMesh+isSkinnedMesh"></a>

### skinnedMesh.isSkinnedMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SkinnedMesh+bindMode"></a>

### skinnedMesh.bindMode : <code>AttachedBindMode</code> \| <code>DetachedBindMode</code>
`AttachedBindMode` means the skinned mesh shares the same world space as the skeleton.
This is not true when using `DetachedBindMode` which is useful when sharing a skeleton
across multiple skinned meshes.

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Default**: <code>AttachedBindMode</code>  
<a name="SkinnedMesh+bindMatrix"></a>

### skinnedMesh.bindMatrix : <code>Matrix4</code>
The base matrix that is used for the bound bone transforms.

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+bindMatrixInverse"></a>

### skinnedMesh.bindMatrixInverse : <code>Matrix4</code>
The base matrix that is used for resetting the bound bone transforms.

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+boundingBox"></a>

### skinnedMesh.boundingBox : <code>Box3</code>
The bounding box of the skinned mesh. Can be computed via [computeBoundingBox](#SkinnedMesh+computeBoundingBox).

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Default**: <code>null</code>  
<a name="SkinnedMesh+boundingSphere"></a>

### skinnedMesh.boundingSphere : <code>Sphere</code>
The bounding sphere of the skinned mesh. Can be computed via [computeBoundingSphere](#SkinnedMesh+computeBoundingSphere).

**Kind**: instance property of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Default**: <code>null</code>  
<a name="SkinnedMesh+computeBoundingBox"></a>

### skinnedMesh.computeBoundingBox()
Computes the bounding box of the skinned mesh, and updates [boundingBox](#SkinnedMesh+boundingBox).
The bounding box is not automatically computed by the engine; this method must be called by your app.
If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect
the current animation state.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+computeBoundingSphere"></a>

### skinnedMesh.computeBoundingSphere()
Computes the bounding sphere of the skinned mesh, and updates [boundingSphere](#SkinnedMesh+boundingSphere).
The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting
and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed
per frame in order to reflect the current animation state.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+bind"></a>

### skinnedMesh.bind(skeleton, [bindMatrix])
Binds the given skeleton to the skinned mesh.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  

| Param | Type | Description |
| --- | --- | --- |
| skeleton | <code>Skeleton</code> | The skeleton to bind. |
| [bindMatrix] | <code>Matrix4</code> | The bind matrix. If no bind matrix is provided, the skinned mesh's world matrix will be used instead. |

<a name="SkinnedMesh+pose"></a>

### skinnedMesh.pose()
This method sets the skinned mesh in the rest pose).

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+normalizeSkinWeights"></a>

### skinnedMesh.normalizeSkinWeights()
Normalizes the skin weights which are defined as a buffer attribute
in the skinned mesh's geometry.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
<a name="SkinnedMesh+applyBoneTransform"></a>

### skinnedMesh.applyBoneTransform(index, target) ⇒ <code>Vector3</code>
Applies the bone transform associated with the given index to the given
vertex position. Returns the updated vector.

**Kind**: instance method of [<code>SkinnedMesh</code>](#SkinnedMesh)  
**Returns**: <code>Vector3</code> - The updated vertex position.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The vertex index. |
| target | <code>Vector3</code> | The target object that is used to store the method's result. the skinned mesh's world matrix will be used instead. |

<a name="Sprite"></a>

## Sprite ⇐ <code>Object3D</code>
A sprite is a plane that always faces towards the camera, generally with a
partially transparent texture applied.

Sprites do not cast shadows, setting [Object3D#castShadow](Object3D#castShadow) to `true` will
have no effect.

```js
const map = new THREE.TextureLoader().load( 'sprite.png' );
const material = new THREE.SpriteMaterial( { map: map } );

const sprite = new THREE.Sprite( material );
scene.add( sprite );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Sprite](#Sprite) ⇐ <code>Object3D</code>
    * [new Sprite([material])](#new_Sprite_new)
    * [.isSprite](#Sprite+isSprite) : <code>boolean</code>
    * [.geometry](#Sprite+geometry) : <code>BufferGeometry</code>
    * [.material](#Sprite+material) : <code>SpriteMaterial</code>
    * [.center](#Sprite+center) : <code>Vector2</code>
    * [.raycast(raycaster, intersects)](#Sprite+raycast)

<a name="new_Sprite_new"></a>

### new Sprite([material])
Constructs a new sprite.


| Param | Type | Description |
| --- | --- | --- |
| [material] | <code>SpriteMaterial</code> | The sprite material. |

<a name="Sprite+isSprite"></a>

### sprite.isSprite : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Sprite</code>](#Sprite)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Sprite+geometry"></a>

### sprite.geometry : <code>BufferGeometry</code>
The sprite geometry.

**Kind**: instance property of [<code>Sprite</code>](#Sprite)  
<a name="Sprite+material"></a>

### sprite.material : <code>SpriteMaterial</code>
The sprite material.

**Kind**: instance property of [<code>Sprite</code>](#Sprite)  
<a name="Sprite+center"></a>

### sprite.center : <code>Vector2</code>
The sprite's anchor point, and the point around which the sprite rotates.
A value of `(0.5, 0.5)` corresponds to the midpoint of the sprite. A value
of `(0, 0)` corresponds to the lower left corner of the sprite.

**Kind**: instance property of [<code>Sprite</code>](#Sprite)  
**Default**: <code>(0.5,0.5)</code>  
<a name="Sprite+raycast"></a>

### sprite.raycast(raycaster, intersects)
Computes intersection points between a casted ray and this sprite.

**Kind**: instance method of [<code>Sprite</code>](#Sprite)  

| Param | Type | Description |
| --- | --- | --- |
| raycaster | <code>Raycaster</code> | The raycaster. |
| intersects | <code>Array.&lt;Object&gt;</code> | The target array that holds the intersection points. |

<a name="WebGL3DRenderTarget"></a>

## WebGL3DRenderTarget ⇐ <code>WebGLRenderTarget</code>
A 3D render target used in context of [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>WebGLRenderTarget</code>  

* [WebGL3DRenderTarget](#WebGL3DRenderTarget) ⇐ <code>WebGLRenderTarget</code>
    * [new WebGL3DRenderTarget([width], [height], [depth], [options])](#new_WebGL3DRenderTarget_new)
    * [.isWebGL3DRenderTarget](#WebGL3DRenderTarget+isWebGL3DRenderTarget) : <code>boolean</code>
    * [.texture](#WebGL3DRenderTarget+texture) : <code>Data3DTexture</code>

<a name="new_WebGL3DRenderTarget_new"></a>

### new WebGL3DRenderTarget([width], [height], [depth], [options])
Constructs a new 3D render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width of the render target. |
| [height] | <code>number</code> | <code>1</code> | The height of the render target. |
| [depth] | <code>number</code> | <code>1</code> | The height of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="WebGL3DRenderTarget+isWebGL3DRenderTarget"></a>

### webGL3DRenderTarget.isWebGL3DRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGL3DRenderTarget</code>](#WebGL3DRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGL3DRenderTarget+texture"></a>

### webGL3DRenderTarget.texture : <code>Data3DTexture</code>
Overwritten with a different texture type.

**Kind**: instance property of [<code>WebGL3DRenderTarget</code>](#WebGL3DRenderTarget)  
<a name="WebGLArrayRenderTarget"></a>

## WebGLArrayRenderTarget ⇐ <code>WebGLRenderTarget</code>
An array render target used in context of [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>WebGLRenderTarget</code>  

* [WebGLArrayRenderTarget](#WebGLArrayRenderTarget) ⇐ <code>WebGLRenderTarget</code>
    * [new WebGLArrayRenderTarget([width], [height], [depth], [options])](#new_WebGLArrayRenderTarget_new)
    * [.isWebGLArrayRenderTarget](#WebGLArrayRenderTarget+isWebGLArrayRenderTarget) : <code>boolean</code>
    * [.texture](#WebGLArrayRenderTarget+texture) : <code>DataArrayTexture</code>

<a name="new_WebGLArrayRenderTarget_new"></a>

### new WebGLArrayRenderTarget([width], [height], [depth], [options])
Constructs a new array render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width of the render target. |
| [height] | <code>number</code> | <code>1</code> | The height of the render target. |
| [depth] | <code>number</code> | <code>1</code> | The height of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="WebGLArrayRenderTarget+isWebGLArrayRenderTarget"></a>

### webGLArrayRenderTarget.isWebGLArrayRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGLArrayRenderTarget</code>](#WebGLArrayRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGLArrayRenderTarget+texture"></a>

### webGLArrayRenderTarget.texture : <code>DataArrayTexture</code>
Overwritten with a different texture type.

**Kind**: instance property of [<code>WebGLArrayRenderTarget</code>](#WebGLArrayRenderTarget)  
<a name="WebGLCubeRenderTarget"></a>

## WebGLCubeRenderTarget ⇐ <code>WebGLRenderTarget</code>
A cube render target used in context of [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>WebGLRenderTarget</code>  

* [WebGLCubeRenderTarget](#WebGLCubeRenderTarget) ⇐ <code>WebGLRenderTarget</code>
    * [new WebGLCubeRenderTarget([size], [options])](#new_WebGLCubeRenderTarget_new)
    * [.isWebGLCubeRenderTarget](#WebGLCubeRenderTarget+isWebGLCubeRenderTarget) : <code>boolean</code>
    * [.texture](#WebGLCubeRenderTarget+texture) : <code>DataArrayTexture</code>
    * [.fromEquirectangularTexture(renderer, texture)](#WebGLCubeRenderTarget+fromEquirectangularTexture) ⇒ [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)
    * [.clear(renderer, [color], [depth], [stencil])](#WebGLCubeRenderTarget+clear)

<a name="new_WebGLCubeRenderTarget_new"></a>

### new WebGLCubeRenderTarget([size], [options])
Constructs a new cube render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>1</code> | The size of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="WebGLCubeRenderTarget+isWebGLCubeRenderTarget"></a>

### webGLCubeRenderTarget.isWebGLCubeRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGLCubeRenderTarget+texture"></a>

### webGLCubeRenderTarget.texture : <code>DataArrayTexture</code>
Overwritten with a different texture type.

**Kind**: instance property of [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)  
<a name="WebGLCubeRenderTarget+fromEquirectangularTexture"></a>

### webGLCubeRenderTarget.fromEquirectangularTexture(renderer, texture) ⇒ [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)
Converts the given equirectangular texture to a cube map.

**Kind**: instance method of [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)  
**Returns**: [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget) - A reference to this cube render target.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| texture | <code>Texture</code> | The equirectangular texture. |

<a name="WebGLCubeRenderTarget+clear"></a>

### webGLCubeRenderTarget.clear(renderer, [color], [depth], [stencil])
Clears this cube render target.

**Kind**: instance method of [<code>WebGLCubeRenderTarget</code>](#WebGLCubeRenderTarget)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>WebGLRenderer</code> |  | The renderer. |
| [color] | <code>boolean</code> | <code>true</code> | Whether the color buffer should be cleared or not. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the depth buffer should be cleared or not. |
| [stencil] | <code>boolean</code> | <code>true</code> | Whether the stencil buffer should be cleared or not. |

<a name="WebGLRenderTarget"></a>

## WebGLRenderTarget ⇐ <code>RenderTarget</code>
A render target used in context of [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>RenderTarget</code>  

* [WebGLRenderTarget](#WebGLRenderTarget) ⇐ <code>RenderTarget</code>
    * [new WebGLRenderTarget([width], [height], [options])](#new_WebGLRenderTarget_new)
    * [.isWebGLRenderTarget](#WebGLRenderTarget+isWebGLRenderTarget) : <code>boolean</code>

<a name="new_WebGLRenderTarget_new"></a>

### new WebGLRenderTarget([width], [height], [options])
Constructs a new 3D render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The width of the render target. |
| [height] | <code>number</code> | <code>1</code> | The height of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="WebGLRenderTarget+isWebGLRenderTarget"></a>

### webGLRenderTarget.isWebGLRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGLRenderTarget</code>](#WebGLRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGLRenderer"></a>

## WebGLRenderer
This renderer uses WebGL 2 to display scenes.

WebGL 1 is not supported since `r163`.

**Kind**: global class  

* [WebGLRenderer](#WebGLRenderer)
    * [new WebGLRenderer([parameters])](#new_WebGLRenderer_new)
    * _instance_
        * [.isWebGLRenderer](#WebGLRenderer+isWebGLRenderer) : <code>boolean</code>
        * [.domElement](#WebGLRenderer+domElement) : <code>DOMElement</code>
        * [.debug](#WebGLRenderer+debug) : <code>Object</code>
            * [.checkShaderErrors](#WebGLRenderer+debug.checkShaderErrors) : <code>boolean</code>
            * [.onShaderError](#WebGLRenderer+debug.onShaderError) : <code>function</code>
        * [.autoClear](#WebGLRenderer+autoClear) : <code>boolean</code>
        * [.autoClearColor](#WebGLRenderer+autoClearColor) : <code>boolean</code>
        * [.autoClearDepth](#WebGLRenderer+autoClearDepth) : <code>boolean</code>
        * [.autoClearStencil](#WebGLRenderer+autoClearStencil) : <code>boolean</code>
        * [.sortObjects](#WebGLRenderer+sortObjects) : <code>boolean</code>
        * [.clippingPlanes](#WebGLRenderer+clippingPlanes) : <code>Array.&lt;Plane&gt;</code>
        * [.localClippingEnabled](#WebGLRenderer+localClippingEnabled) : <code>boolean</code>
        * [.toneMapping](#WebGLRenderer+toneMapping) : <code>NoToneMapping</code> \| <code>LinearToneMapping</code> \| <code>ReinhardToneMapping</code> \| <code>CineonToneMapping</code> \| <code>ACESFilmicToneMapping</code> \| <code>CustomToneMapping</code> \| <code>AgXToneMapping</code> \| <code>NeutralToneMapping</code>
        * [.toneMappingExposure](#WebGLRenderer+toneMappingExposure) : <code>number</code>
        * [.transmissionResolutionScale](#WebGLRenderer+transmissionResolutionScale) : <code>number</code>
        * [.capabilities](#WebGLRenderer+capabilities) : [<code>Capabilities</code>](#WebGLRenderer..Capabilities)
        * [.extensions](#WebGLRenderer+extensions) : <code>Object</code>
        * [.properties](#WebGLRenderer+properties) : <code>Object</code>
        * [.renderLists](#WebGLRenderer+renderLists) : <code>Object</code>
        * [.shadowMap](#WebGLRenderer+shadowMap) : [<code>ShadowMap</code>](#WebGLRenderer..ShadowMap)
        * [.state](#WebGLRenderer+state) : <code>Object</code>
        * [.info](#WebGLRenderer+info) : [<code>Info</code>](#WebGLRenderer..Info)
        * [.xr](#WebGLRenderer+xr) : <code>WebXRManager</code>
        * [.coordinateSystem](#WebGLRenderer+coordinateSystem) : <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code>
        * [.outputColorSpace](#WebGLRenderer+outputColorSpace) : <code>SRGBColorSpace</code> \| <code>LinearSRGBColorSpace</code>
        * [.getContext()](#WebGLRenderer+getContext) ⇒ <code>WebGL2RenderingContext</code>
        * [.getContextAttributes()](#WebGLRenderer+getContextAttributes) ⇒ <code>WebGLContextAttributes</code>
        * [.forceContextLoss()](#WebGLRenderer+forceContextLoss)
        * [.forceContextRestore()](#WebGLRenderer+forceContextRestore)
        * [.getPixelRatio()](#WebGLRenderer+getPixelRatio) ⇒ <code>number</code>
        * [.setPixelRatio(value)](#WebGLRenderer+setPixelRatio)
        * [.getSize(target)](#WebGLRenderer+getSize) ⇒ <code>Vector2</code>
        * [.setSize(width, height, [updateStyle])](#WebGLRenderer+setSize)
        * [.getDrawingBufferSize(target)](#WebGLRenderer+getDrawingBufferSize) ⇒ <code>Vector2</code>
        * [.setDrawingBufferSize(width, height, pixelRatio)](#WebGLRenderer+setDrawingBufferSize)
        * [.getCurrentViewport(target)](#WebGLRenderer+getCurrentViewport) ⇒ <code>Vector2</code>
        * [.getViewport(target)](#WebGLRenderer+getViewport) ⇒ <code>Vector4</code>
        * [.setViewport(x, y, width, height)](#WebGLRenderer+setViewport)
        * [.getScissor(target)](#WebGLRenderer+getScissor) ⇒ <code>Vector4</code>
        * [.setScissor(x, y, width, height)](#WebGLRenderer+setScissor)
        * [.getScissorTest()](#WebGLRenderer+getScissorTest) ⇒ <code>boolean</code>
        * [.setScissorTest(boolean)](#WebGLRenderer+setScissorTest)
        * [.setOpaqueSort(method)](#WebGLRenderer+setOpaqueSort)
        * [.setTransparentSort(method)](#WebGLRenderer+setTransparentSort)
        * [.getClearColor(target)](#WebGLRenderer+getClearColor) ⇒ <code>Color</code>
        * [.setClearColor(color, [alpha])](#WebGLRenderer+setClearColor)
        * [.getClearAlpha()](#WebGLRenderer+getClearAlpha) ⇒ <code>number</code>
        * [.setClearAlpha(alpha)](#WebGLRenderer+setClearAlpha)
        * [.clear([color], [depth], [stencil])](#WebGLRenderer+clear)
        * [.clearColor()](#WebGLRenderer+clearColor)
        * [.clearDepth()](#WebGLRenderer+clearDepth)
        * [.clearStencil()](#WebGLRenderer+clearStencil)
        * [.dispose()](#WebGLRenderer+dispose)
        * [.compile(scene, camera, [targetScene])](#WebGLRenderer+compile) ⇒ <code>Set</code>
        * [.compileAsync(scene, camera, [targetScene])](#WebGLRenderer+compileAsync) ⇒ <code>Promise</code>
        * [.render(scene, camera)](#WebGLRenderer+render)
        * [.getActiveCubeFace()](#WebGLRenderer+getActiveCubeFace) ⇒ <code>number</code>
        * [.getActiveMipmapLevel()](#WebGLRenderer+getActiveMipmapLevel) ⇒ <code>number</code>
        * [.getRenderTarget()](#WebGLRenderer+getRenderTarget) ⇒ <code>WebGLRenderTarget</code>
        * [.setRenderTarget(renderTarget, [activeCubeFace], [activeMipmapLevel])](#WebGLRenderer+setRenderTarget)
        * [.readRenderTargetPixels(renderTarget, x, y, width, height, buffer, [activeCubeFaceIndex])](#WebGLRenderer+readRenderTargetPixels)
        * [.readRenderTargetPixelsAsync(renderTarget, x, y, width, height, buffer, [activeCubeFaceIndex])](#WebGLRenderer+readRenderTargetPixelsAsync) ⇒ <code>Promise.&lt;TypedArray&gt;</code>
        * [.copyFramebufferToTexture(texture, position, [level])](#WebGLRenderer+copyFramebufferToTexture)
        * [.copyTextureToTexture(srcTexture, dstTexture, [srcRegion], [dstPosition], srcLevel, dstLevel)](#WebGLRenderer+copyTextureToTexture)
        * [.initRenderTarget(target)](#WebGLRenderer+initRenderTarget)
        * [.initTexture(texture)](#WebGLRenderer+initTexture)
        * [.resetState()](#WebGLRenderer+resetState)
    * _inner_
        * [~Options](#WebGLRenderer..Options) : <code>Object</code>
        * [~Capabilities](#WebGLRenderer..Capabilities) : <code>Object</code>
        * [~InfoMemory](#WebGLRenderer..InfoMemory) : <code>Object</code>
        * [~InfoRender](#WebGLRenderer..InfoRender) : <code>Object</code>
        * [~Info](#WebGLRenderer..Info) : <code>Object</code>
        * [~ShadowMap](#WebGLRenderer..ShadowMap) : <code>Object</code>

<a name="new_WebGLRenderer_new"></a>

### new WebGLRenderer([parameters])
Constructs a new WebGL renderer.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | [<code>Options</code>](#WebGLRenderer..Options) | The configuration parameter. |

<a name="WebGLRenderer+isWebGLRenderer"></a>

### webGLRenderer.isWebGLRenderer : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGLRenderer+domElement"></a>

### webGLRenderer.domElement : <code>DOMElement</code>
A canvas where the renderer draws its output.This is automatically created by the renderer
in the constructor (if not provided already); you just need to add it to your page like so:
```js
document.body.appendChild( renderer.domElement );
```

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+debug"></a>

### webGLRenderer.debug : <code>Object</code>
A object with debug configuration settings.

- `checkShaderErrors`: If it is `true`, defines whether material shader programs are
checked for errors during compilation and linkage process. It may be useful to disable
this check in production for performance gain. It is strongly recommended to keep these
checks enabled during development. If the shader does not compile and link - it will not
work and associated material will not render.
- `onShaderError(gl, program, glVertexShader,glFragmentShader)`: A callback function that
can be used for custom error reporting. The callback receives the WebGL context, an instance
of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader.
Assigning a custom function disables the default error reporting.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  

* [.debug](#WebGLRenderer+debug) : <code>Object</code>
    * [.checkShaderErrors](#WebGLRenderer+debug.checkShaderErrors) : <code>boolean</code>
    * [.onShaderError](#WebGLRenderer+debug.onShaderError) : <code>function</code>

<a name="WebGLRenderer+debug.checkShaderErrors"></a>

#### debug.checkShaderErrors : <code>boolean</code>
Enables error checking and reporting when shader programs are being compiled.

**Kind**: static property of [<code>debug</code>](#WebGLRenderer+debug)  
<a name="WebGLRenderer+debug.onShaderError"></a>

#### debug.onShaderError : <code>function</code>
Callback for custom error reporting.

**Kind**: static property of [<code>debug</code>](#WebGLRenderer+debug)  
<a name="WebGLRenderer+autoClear"></a>

### webGLRenderer.autoClear : <code>boolean</code>
Whether the renderer should automatically clear its output before rendering a frame or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+autoClearColor"></a>

### webGLRenderer.autoClearColor : <code>boolean</code>
If [autoClear](#WebGLRenderer+autoClear) set to `true`, whether the renderer should clear
the color buffer or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+autoClearDepth"></a>

### webGLRenderer.autoClearDepth : <code>boolean</code>
If [autoClear](#WebGLRenderer+autoClear) set to `true`, whether the renderer should clear
the depth buffer or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+autoClearStencil"></a>

### webGLRenderer.autoClearStencil : <code>boolean</code>
If [autoClear](#WebGLRenderer+autoClear) set to `true`, whether the renderer should clear
the stencil buffer or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+sortObjects"></a>

### webGLRenderer.sortObjects : <code>boolean</code>
Whether the renderer should sort objects or not.

Note: Sorting is used to attempt to properly render objects that have some
degree of transparency. By definition, sorting objects may not work in all
cases. Depending on the needs of application, it may be necessary to turn
off sorting and use other methods to deal with transparency rendering e.g.
manually determining each object's rendering order.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>true</code>  
<a name="WebGLRenderer+clippingPlanes"></a>

### webGLRenderer.clippingPlanes : <code>Array.&lt;Plane&gt;</code>
User-defined clipping planes specified in world space. These planes apply globally.
Points in space whose dot product with the plane is negative are cut away.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+localClippingEnabled"></a>

### webGLRenderer.localClippingEnabled : <code>boolean</code>
Whether the renderer respects object-level clipping planes or not.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>false</code>  
<a name="WebGLRenderer+toneMapping"></a>

### webGLRenderer.toneMapping : <code>NoToneMapping</code> \| <code>LinearToneMapping</code> \| <code>ReinhardToneMapping</code> \| <code>CineonToneMapping</code> \| <code>ACESFilmicToneMapping</code> \| <code>CustomToneMapping</code> \| <code>AgXToneMapping</code> \| <code>NeutralToneMapping</code>
The tone mapping technique of the renderer.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>NoToneMapping</code>  
<a name="WebGLRenderer+toneMappingExposure"></a>

### webGLRenderer.toneMappingExposure : <code>number</code>
Exposure level of tone mapping.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>1</code>  
<a name="WebGLRenderer+transmissionResolutionScale"></a>

### webGLRenderer.transmissionResolutionScale : <code>number</code>
The normalized resolution scale for the transmission render target, measured in percentage
of viewport dimensions. Lowering this value can result in significant performance improvements
when using [MeshPhysicalMaterial#transmission](MeshPhysicalMaterial#transmission).

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>1</code>  
<a name="WebGLRenderer+capabilities"></a>

### webGLRenderer.capabilities : [<code>Capabilities</code>](#WebGLRenderer..Capabilities)
Holds details about the capabilities of the current rendering context.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+extensions"></a>

### webGLRenderer.extensions : <code>Object</code>
Provides methods for retrieving and testing WebGL extensions.

- `get(extensionName:string)`: Used to check whether a WebGL extension is supported
and return the extension object if available.
- `has(extensionName:string)`: returns `true` if the extension is supported.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+properties"></a>

### webGLRenderer.properties : <code>Object</code>
Used to track properties of other objects like native WebGL objects.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+renderLists"></a>

### webGLRenderer.renderLists : <code>Object</code>
Manages the render lists of the renderer.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+shadowMap"></a>

### webGLRenderer.shadowMap : [<code>ShadowMap</code>](#WebGLRenderer..ShadowMap)
Interface for managing shadows.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+state"></a>

### webGLRenderer.state : <code>Object</code>
Interface for managing the WebGL state.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+info"></a>

### webGLRenderer.info : [<code>Info</code>](#WebGLRenderer..Info)
Holds a series of statistical information about the GPU memory
and the rendering process. Useful for debugging and monitoring.

By default these data are reset at each render call but when having
multiple render passes per frame (e.g. when using post processing) it can
be preferred to reset with a custom pattern. First, set `autoReset` to
`false`.
```js
renderer.info.autoReset = false;
```
Call `reset()` whenever you have finished to render a single frame.
```js
renderer.info.reset();
```

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+xr"></a>

### webGLRenderer.xr : <code>WebXRManager</code>
A reference to the XR manager.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+coordinateSystem"></a>

### webGLRenderer.coordinateSystem : <code>WebGLCoordinateSystem</code> \| <code>WebGPUCoordinateSystem</code>
Defines the coordinate system of the renderer.

In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>WebGLCoordinateSystem</code>  
**Read only**: true  
<a name="WebGLRenderer+outputColorSpace"></a>

### webGLRenderer.outputColorSpace : <code>SRGBColorSpace</code> \| <code>LinearSRGBColorSpace</code>
Defines the output color space of the renderer.

**Kind**: instance property of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Default**: <code>SRGBColorSpace</code>  
<a name="WebGLRenderer+getContext"></a>

### webGLRenderer.getContext() ⇒ <code>WebGL2RenderingContext</code>
Returns the rendering context.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>WebGL2RenderingContext</code> - The rendering context.  
<a name="WebGLRenderer+getContextAttributes"></a>

### webGLRenderer.getContextAttributes() ⇒ <code>WebGLContextAttributes</code>
Returns the rendering context attributes.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>WebGLContextAttributes</code> - The rendering context attributes.  
<a name="WebGLRenderer+forceContextLoss"></a>

### webGLRenderer.forceContextLoss()
Simulates a loss of the WebGL context. This requires support for the `WEBGL_lose_context` extension.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+forceContextRestore"></a>

### webGLRenderer.forceContextRestore()
Simulates a restore of the WebGL context. This requires support for the `WEBGL_lose_context` extension.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+getPixelRatio"></a>

### webGLRenderer.getPixelRatio() ⇒ <code>number</code>
Returns the pixel ratio.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>number</code> - The pixel ratio.  
<a name="WebGLRenderer+setPixelRatio"></a>

### webGLRenderer.setPixelRatio(value)
Sets the given pixel ratio and resizes the canvas if necessary.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The pixel ratio. |

<a name="WebGLRenderer+getSize"></a>

### webGLRenderer.getSize(target) ⇒ <code>Vector2</code>
Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector2</code> - The renderer's size in logical pixels.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setSize"></a>

### webGLRenderer.setSize(width, height, [updateStyle])
Resizes the output canvas to (width, height) with device pixel ratio taken
into account, and also sets the viewport to fit that size, starting in (0,
0). Setting `updateStyle` to false prevents any style changes to the output canvas.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| width | <code>number</code> |  | The width in logical pixels. |
| height | <code>number</code> |  | The height in logical pixels. |
| [updateStyle] | <code>boolean</code> | <code>true</code> | Whether to update the `style` attribute of the canvas or not. |

<a name="WebGLRenderer+getDrawingBufferSize"></a>

### webGLRenderer.getDrawingBufferSize(target) ⇒ <code>Vector2</code>
Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector2</code> - The drawing buffer size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setDrawingBufferSize"></a>

### webGLRenderer.setDrawingBufferSize(width, height, pixelRatio)
This method allows to define the drawing buffer size by specifying
width, height and pixel ratio all at once. The size of the drawing
buffer is computed with this formula:
```js
size.x = width * pixelRatio;
size.y = height * pixelRatio;
```

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width in logical pixels. |
| height | <code>number</code> | The height in logical pixels. |
| pixelRatio | <code>number</code> | The pixel ratio. |

<a name="WebGLRenderer+getCurrentViewport"></a>

### webGLRenderer.getCurrentViewport(target) ⇒ <code>Vector2</code>
Returns the current viewport definition.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector2</code> - The current viewport definition.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+getViewport"></a>

### webGLRenderer.getViewport(target) ⇒ <code>Vector4</code>
Returns the viewport definition.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector4</code> - The viewport definition.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector4</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setViewport"></a>

### webGLRenderer.setViewport(x, y, width, height)
Sets the viewport to render from `(x, y)` to `(x + width, y + height)`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector4</code> | The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit. Or alternatively a four-component vector specifying all the parameters of the viewport. |
| y | <code>number</code> | The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit. |
| width | <code>number</code> | The width of the viewport in logical pixel unit. |
| height | <code>number</code> | The height of the viewport in logical pixel unit. |

<a name="WebGLRenderer+getScissor"></a>

### webGLRenderer.getScissor(target) ⇒ <code>Vector4</code>
Returns the scissor region.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Vector4</code> - The scissor region.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector4</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setScissor"></a>

### webGLRenderer.setScissor(x, y, width, height)
Sets the scissor region to render from `(x, y)` to `(x + width, y + height)`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector4</code> | The horizontal coordinate for the lower left corner of the scissor region origin in logical pixel unit. Or alternatively a four-component vector specifying all the parameters of the scissor region. |
| y | <code>number</code> | The vertical coordinate for the lower left corner of the scissor region origin  in logical pixel unit. |
| width | <code>number</code> | The width of the scissor region in logical pixel unit. |
| height | <code>number</code> | The height of the scissor region in logical pixel unit. |

<a name="WebGLRenderer+getScissorTest"></a>

### webGLRenderer.getScissorTest() ⇒ <code>boolean</code>
Returns `true` if the scissor test is enabled.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>boolean</code> - Whether the scissor test is enabled or not.  
<a name="WebGLRenderer+setScissorTest"></a>

### webGLRenderer.setScissorTest(boolean)
Enable or disable the scissor test. When this is enabled, only the pixels
within the defined scissor area will be affected by further renderer
actions.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| boolean | <code>boolean</code> | Whether the scissor test is enabled or not. |

<a name="WebGLRenderer+setOpaqueSort"></a>

### webGLRenderer.setOpaqueSort(method)
Sets a custom opaque sort function for the render lists. Pass `null`
to use the default `painterSortStable` function.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | The opaque sort function. |

<a name="WebGLRenderer+setTransparentSort"></a>

### webGLRenderer.setTransparentSort(method)
Sets a custom transparent sort function for the render lists. Pass `null`
to use the default `reversePainterSortStable` function.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | The opaque sort function. |

<a name="WebGLRenderer+getClearColor"></a>

### webGLRenderer.getClearColor(target) ⇒ <code>Color</code>
Returns the clear color.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Color</code> - The clear color.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Color</code> | The method writes the result in this target object. |

<a name="WebGLRenderer+setClearColor"></a>

### webGLRenderer.setClearColor(color, [alpha])
Sets the clear color and alpha.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Color</code> |  | The clear color. |
| [alpha] | <code>number</code> | <code>1</code> | The clear alpha. |

<a name="WebGLRenderer+getClearAlpha"></a>

### webGLRenderer.getClearAlpha() ⇒ <code>number</code>
Returns the clear alpha. Ranges within `[0,1]`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>number</code> - The clear alpha.  
<a name="WebGLRenderer+setClearAlpha"></a>

### webGLRenderer.setClearAlpha(alpha)
Sets the clear alpha.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| alpha | <code>number</code> | The clear alpha. |

<a name="WebGLRenderer+clear"></a>

### webGLRenderer.clear([color], [depth], [stencil])
Tells the renderer to clear its color, depth or stencil drawing buffer(s).
This method initializes the buffers to the current clear color values.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>boolean</code> | <code>true</code> | Whether the color buffer should be cleared or not. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the depth buffer should be cleared or not. |
| [stencil] | <code>boolean</code> | <code>true</code> | Whether the stencil buffer should be cleared or not. |

<a name="WebGLRenderer+clearColor"></a>

### webGLRenderer.clearColor()
Clears the color buffer. Equivalent to calling `renderer.clear( true, false, false )`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+clearDepth"></a>

### webGLRenderer.clearDepth()
Clears the depth buffer. Equivalent to calling `renderer.clear( false, true, false )`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+clearStencil"></a>

### webGLRenderer.clearStencil()
Clears the stencil buffer. Equivalent to calling `renderer.clear( false, false, true )`.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+dispose"></a>

### webGLRenderer.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer+compile"></a>

### webGLRenderer.compile(scene, camera, [targetScene]) ⇒ <code>Set</code>
Compiles all materials in the scene with the camera. This is useful to precompile shaders
before the first rendering. If you want to add a 3D object to an existing scene, use the third
optional parameter for applying the target scene.

Note that the (target) scene's lighting and environment must be configured before calling this method.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Set</code> - The precompiled materials.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Object3D</code> |  | The scene or another type of 3D object to precompile. |
| camera | <code>Camera</code> |  | The camera. |
| [targetScene] | <code>Scene</code> | <code></code> | The target scene. |

<a name="WebGLRenderer+compileAsync"></a>

### webGLRenderer.compileAsync(scene, camera, [targetScene]) ⇒ <code>Promise</code>
Asynchronous version of [compile](#WebGLRenderer+compile).

This method makes use of the `KHR_parallel_shader_compile` WebGL extension. Hence,
it is recommended to use this version of `compile()` whenever possible.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Object3D</code> |  | The scene or another type of 3D object to precompile. |
| camera | <code>Camera</code> |  | The camera. |
| [targetScene] | <code>Scene</code> | <code></code> | The target scene. |

<a name="WebGLRenderer+render"></a>

### webGLRenderer.render(scene, camera)
Renders the given scene (or other type of 3D object) using the given camera.

The render is done to a previously specified render target set by calling [setRenderTarget](#WebGLRenderer+setRenderTarget)
or to the canvas as usual.

By default render buffers are cleared before rendering but you can prevent
this by setting the property `autoClear` to `false`. If you want to prevent
only certain buffers being cleared you can `autoClearColor`, `autoClearDepth`
or `autoClearStencil` to `false`. To force a clear, use [clear](#WebGLRenderer+clear).

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |

<a name="WebGLRenderer+getActiveCubeFace"></a>

### webGLRenderer.getActiveCubeFace() ⇒ <code>number</code>
Returns the active cube face.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>number</code> - The active cube face.  
<a name="WebGLRenderer+getActiveMipmapLevel"></a>

### webGLRenderer.getActiveMipmapLevel() ⇒ <code>number</code>
Returns the active mipmap level.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>number</code> - The active mipmap level.  
<a name="WebGLRenderer+getRenderTarget"></a>

### webGLRenderer.getRenderTarget() ⇒ <code>WebGLRenderTarget</code>
Returns the active render target.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>WebGLRenderTarget</code> - The active render target. Returns `null` if no render target
is currently set.  
<a name="WebGLRenderer+setRenderTarget"></a>

### webGLRenderer.setRenderTarget(renderTarget, [activeCubeFace], [activeMipmapLevel])
Sets the active rendertarget.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderTarget | <code>WebGLRenderTarget</code> |  | The render target to set. When `null` is given, the canvas is set as the active render target instead. |
| [activeCubeFace] | <code>number</code> | <code>0</code> | The active cube face when using a cube render target. Indicates the z layer to render in to when using 3D or array render targets. |
| [activeMipmapLevel] | <code>number</code> | <code>0</code> | The active mipmap level. |

<a name="WebGLRenderer+readRenderTargetPixels"></a>

### webGLRenderer.readRenderTargetPixels(renderTarget, x, y, width, height, buffer, [activeCubeFaceIndex])
Reads the pixel data from the given render target into the given buffer.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| renderTarget | <code>WebGLRenderTarget</code> | The render target to read from. |
| x | <code>number</code> | The `x` coordinate of the copy region's origin. |
| y | <code>number</code> | The `y` coordinate of the copy region's origin. |
| width | <code>number</code> | The width of the copy region. |
| height | <code>number</code> | The height of the copy region. |
| buffer | <code>TypedArray</code> | The result buffer. |
| [activeCubeFaceIndex] | <code>number</code> | The active cube face index. |

<a name="WebGLRenderer+readRenderTargetPixelsAsync"></a>

### webGLRenderer.readRenderTargetPixelsAsync(renderTarget, x, y, width, height, buffer, [activeCubeFaceIndex]) ⇒ <code>Promise.&lt;TypedArray&gt;</code>
Asynchronous, non-blocking version of [readRenderTargetPixels](#WebGLRenderer+readRenderTargetPixels).

It is recommended to use this version of `readRenderTargetPixels()` whenever possible.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Returns**: <code>Promise.&lt;TypedArray&gt;</code> - A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.  

| Param | Type | Description |
| --- | --- | --- |
| renderTarget | <code>WebGLRenderTarget</code> | The render target to read from. |
| x | <code>number</code> | The `x` coordinate of the copy region's origin. |
| y | <code>number</code> | The `y` coordinate of the copy region's origin. |
| width | <code>number</code> | The width of the copy region. |
| height | <code>number</code> | The height of the copy region. |
| buffer | <code>TypedArray</code> | The result buffer. |
| [activeCubeFaceIndex] | <code>number</code> | The active cube face index. |

<a name="WebGLRenderer+copyFramebufferToTexture"></a>

### webGLRenderer.copyFramebufferToTexture(texture, position, [level])
Copies pixels from the current bound framebuffer into the given texture.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>FramebufferTexture</code> |  | The texture. |
| position | <code>Vector2</code> |  | The start position of the copy operation. |
| [level] | <code>number</code> | <code>0</code> | The mip level. The default represents the base mip. |

<a name="WebGLRenderer+copyTextureToTexture"></a>

### webGLRenderer.copyTextureToTexture(srcTexture, dstTexture, [srcRegion], [dstPosition], srcLevel, dstLevel)
Copies data of the given source texture into a destination texture.

When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized
[initRenderTarget](#WebGLRenderer+initRenderTarget).

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| srcTexture | <code>Texture</code> |  | The source texture. |
| dstTexture | <code>Texture</code> |  | The destination texture. |
| [srcRegion] | <code>Box2</code> \| <code>Box3</code> | <code></code> | A bounding box which describes the source region. Can be two or three-dimensional. |
| [dstPosition] | <code>Vector2</code> \| <code>Vector3</code> | <code></code> | A vector that represents the origin of the destination region. Can be two or three-dimensional. |
| srcLevel | <code>number</code> |  | The source mipmap level to copy. |
| dstLevel | <code>number</code> |  | The destination mipmap level. |

<a name="WebGLRenderer+initRenderTarget"></a>

### webGLRenderer.initRenderTarget(target)
Initializes the given WebGLRenderTarget memory. Useful for initializing a render target so data
can be copied into it using [copyTextureToTexture](#WebGLRenderer+copyTextureToTexture) before it has been
rendered to.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>WebGLRenderTarget</code> | The render target. |

<a name="WebGLRenderer+initTexture"></a>

### webGLRenderer.initTexture(texture)
Initializes the given texture. Useful for preloading a texture rather than waiting until first
render (which can cause noticeable lags due to decode and GPU upload overhead).

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="WebGLRenderer+resetState"></a>

### webGLRenderer.resetState()
Can be used to reset the internal WebGL state. This method is mostly
relevant for applications which share a single WebGL context across
multiple WebGL libraries.

**Kind**: instance method of [<code>WebGLRenderer</code>](#WebGLRenderer)  
<a name="WebGLRenderer..Options"></a>

### WebGLRenderer~Options : <code>Object</code>
WebGLRenderer options.

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [canvas] | <code>DOMElement</code> | <code></code> | A canvas element where the renderer draws its output. If not passed in here, a new canvas element will be created by the renderer. |
| [context] | <code>WebGL2RenderingContext</code> | <code></code> | Can be used to attach an existing rendering context to this renderer. |
| [precision] | <code>&#x27;highp&#x27;</code> \| <code>&#x27;mediump&#x27;</code> \| <code>&#x27;lowp&#x27;</code> | <code>&#x27;highp&#x27;</code> | The default shader precision. Uses `highp` if supported by the device. |
| [alpha] | <code>boolean</code> | <code>false</code> | Controls the default clear alpha value. When set to`true`, the value is `0`. Otherwise it's `1`. |
| [premultipliedAlpha] | <code>boolean</code> | <code>true</code> | Whether the renderer will assume colors have premultiplied alpha or not. |
| [antialias] | <code>boolean</code> | <code>false</code> | Whether to use the default MSAA or not. |
| [stencil] | <code>boolean</code> | <code>false</code> | Whether the drawing buffer has a stencil buffer of at least 8 bits or not. |
| [preserveDrawingBuffer] | <code>boolean</code> | <code>false</code> | Whether to preserve the buffer until manually cleared or overwritten. |
| [powerPreference] | <code>&#x27;default&#x27;</code> \| <code>&#x27;low-power&#x27;</code> \| <code>&#x27;high-performance&#x27;</code> | <code>&#x27;default&#x27;</code> | Provides a hint to the user agent indicating what configuration of GPU is suitable for this WebGL context. |
| [failIfMajorPerformanceCaveat] | <code>boolean</code> | <code>false</code> | Whether the renderer creation will fail upon low performance is detected. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the drawing buffer has a depth buffer of at least 16 bits. |
| [logarithmicDepthBuffer] | <code>boolean</code> | <code>false</code> | Whether to use a logarithmic depth buffer. It may be necessary to use this if dealing with huge differences in scale in a single scene. Note that this setting uses `gl_FragDepth` if available which disables the Early Fragment Test optimization and can cause a decrease in performance. |
| [reverseDepthBuffer] | <code>boolean</code> | <code>false</code> | Whether to use a reverse depth buffer. Requires the `EXT_clip_control` extension. This is a more faster and accurate version than logarithmic depth buffer. |

<a name="WebGLRenderer..Capabilities"></a>

### WebGLRenderer~Capabilities : <code>Object</code>
WebGLRenderer Capabilities.

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| getMaxAnisotropy | <code>function</code> | Returns the maximum available anisotropy. |
| getMaxPrecision | <code>function</code> | Returns the maximum available precision for vertex and fragment shaders. |
| logarithmicDepthBuffer | <code>boolean</code> | `true` if `logarithmicDepthBuffer` was set to `true` in the constructor. |
| maxAttributes | <code>number</code> | The number of shader attributes that can be used by the vertex shader. |
| maxCubemapSize | <code>number</code> | Maximum height * width of cube map textures that a shader can use. |
| maxFragmentUniforms | <code>number</code> | The number of uniforms that can be used by a fragment shader. |
| maxSamples | <code>number</code> | Maximum number of samples in context of Multisample anti-aliasing (MSAA). |
| maxTextures | <code>number</code> | The maximum number of textures that can be used by a shader. |
| maxTextureSize | <code>number</code> | Maximum height * width of a texture that a shader use. |
| maxVaryings | <code>number</code> | The number of varying vectors that can used by shaders. |
| maxVertexTextures | <code>number</code> | The number of textures that can be used in a vertex shader. |
| maxVertexUniforms | <code>number</code> | The maximum number of uniforms that can be used in a vertex shader. |
| precision | <code>string</code> | The shader precision currently being used by the renderer. |
| reverseDepthBuffer | <code>boolean</code> | `true` if `reverseDepthBuffer` was set to `true` in the constructor and the rendering context supports `EXT_clip_control`. |
| vertexTextures | <code>boolean</code> | `true` if vertex textures can be used. |

<a name="WebGLRenderer..InfoMemory"></a>

### WebGLRenderer~InfoMemory : <code>Object</code>
WebGLRenderer Info Memory

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| geometries | <code>number</code> | The number of active geometries. |
| textures | <code>number</code> | The number of active textures. |

<a name="WebGLRenderer..InfoRender"></a>

### WebGLRenderer~InfoRender : <code>Object</code>
WebGLRenderer Info Render

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| frame | <code>number</code> | The frame ID. |
| calls | <code>number</code> | The number of draw calls per frame. |
| triangles | <code>number</code> | The number of rendered triangles primitives per frame. |
| points | <code>number</code> | The number of rendered points primitives per frame. |
| lines | <code>number</code> | The number of rendered lines primitives per frame. |

<a name="WebGLRenderer..Info"></a>

### WebGLRenderer~Info : <code>Object</code>
WebGLRenderer Info

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [autoReset] | <code>boolean</code> | <code>true</code> | Whether to automatically reset the info by the renderer or not. |
| memory | [<code>InfoMemory</code>](#WebGLRenderer..InfoMemory) |  | Information about allocated objects. |
| render | [<code>InfoRender</code>](#WebGLRenderer..InfoRender) |  | Information about rendered objects. |
| programs | <code>Array.&lt;WebGLProgram&gt;</code> |  | An array `WebGLProgram`s used for rendering. |
| reset | <code>function</code> |  | Resets the info object for the next frame. |

<a name="WebGLRenderer..ShadowMap"></a>

### WebGLRenderer~ShadowMap : <code>Object</code>
WebGLRenderer Shadow Map.

**Kind**: inner typedef of [<code>WebGLRenderer</code>](#WebGLRenderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [enabled] | <code>boolean</code> | <code>false</code> | If set to `true`, use shadow maps in the scene. |
| [autoUpdate] | <code>boolean</code> | <code>true</code> | Enables automatic updates to the shadows in the scene. If you do not require dynamic lighting / shadows, you may set this to `false`. |
| [needsUpdate] | <code>boolean</code> | <code>false</code> | When set to `true`, shadow maps in the scene will be updated in the next `render` call. |
| [type] | <code>BasicShadowMap</code> \| <code>PCFShadowMap</code> \| <code>PCFSoftShadowMap</code> \| <code>VSMShadowMap</code> | <code>PCFShadowMap</code> | Defines the shadow map type. |

## Functions

<dl>
<dt><a href="#getFloatLength">getFloatLength(floatLength)</a> ⇒ <code>number</code></dt>
<dd><p>This function is usually called with the length in bytes of an array buffer.
It returns an padded value which ensure chunk size alignment according to STD140 layout.</p>
</dd>
<dt><a href="#getVectorLength">getVectorLength(count, [vectorLength])</a> ⇒ <code>number</code></dt>
<dd><p>Given the count of vectors and their vector length, this function computes
a total length in bytes with buffer alignment according to STD140 layout.</p>
</dd>
<dt><a href="#getStrideLength">getStrideLength(vectorLength)</a> ⇒ <code>number</code></dt>
<dd><p>This function is called with a vector length and ensure the computed length
matches a predefined stride (in this case <code>4</code>).</p>
</dd>
</dl>

<a name="getFloatLength"></a>

## getFloatLength(floatLength) ⇒ <code>number</code>
This function is usually called with the length in bytes of an array buffer.
It returns an padded value which ensure chunk size alignment according to STD140 layout.

**Kind**: global function  
**Returns**: <code>number</code> - The padded length.  

| Param | Type | Description |
| --- | --- | --- |
| floatLength | <code>number</code> | The buffer length. |

<a name="getVectorLength"></a>

## getVectorLength(count, [vectorLength]) ⇒ <code>number</code>
Given the count of vectors and their vector length, this function computes
a total length in bytes with buffer alignment according to STD140 layout.

**Kind**: global function  
**Returns**: <code>number</code> - The padded length.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> |  | The number of vectors. |
| [vectorLength] | <code>number</code> | <code>4</code> | The vector length. |

<a name="getStrideLength"></a>

## getStrideLength(vectorLength) ⇒ <code>number</code>
This function is called with a vector length and ensure the computed length
matches a predefined stride (in this case `4`).

**Kind**: global function  
**Returns**: <code>number</code> - The padded length.  

| Param | Type | Description |
| --- | --- | --- |
| vectorLength | <code>number</code> | The vector length. |

<a name="BundleGroup"></a>

## BundleGroup ⇐ <code>Group</code>
A specialized group which enables applications access to the
Render Bundle API of WebGPU. The group with all its descendant nodes
are considered as one render bundle and processed as such by
the renderer.

This module is only fully supported by `WebGPURenderer` with a WebGPU backend.
With a WebGL backend, the group can technically be rendered but without
any performance improvements.

**Kind**: global class  
**Extends**: <code>Group</code>  

* [BundleGroup](#BundleGroup) ⇐ <code>Group</code>
    * [new BundleGroup()](#new_BundleGroup_new)
    * [.isBundleGroup](#BundleGroup+isBundleGroup) : <code>boolean</code>
    * [.type](#BundleGroup+type) : <code>string</code>
    * [.static](#BundleGroup+static) : <code>boolean</code>
    * [.version](#BundleGroup+version) : <code>number</code>
    * [.needsUpdate](#BundleGroup+needsUpdate) : <code>boolean</code>

<a name="new_BundleGroup_new"></a>

### new BundleGroup()
Constructs a new bundle group.

<a name="BundleGroup+isBundleGroup"></a>

### bundleGroup.isBundleGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BundleGroup+type"></a>

### bundleGroup.type : <code>string</code>
This property is only relevant for detecting types
during serialization/deserialization. It should always
match the class name.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>&quot;&#x27;BundleGroup&#x27;&quot;</code>  
**Read only**: true  
<a name="BundleGroup+static"></a>

### bundleGroup.static : <code>boolean</code>
Whether the bundle is static or not. When set to `true`, the structure
is assumed to be static and does not change. E.g. no new objects are
added to the group

If a change is required, an update can still be forced by setting the
`needsUpdate` flag to `true`.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>true</code>  
<a name="BundleGroup+version"></a>

### bundleGroup.version : <code>number</code>
The bundle group's version.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="BundleGroup+needsUpdate"></a>

### bundleGroup.needsUpdate : <code>boolean</code>
Set this property to `true` when the bundle group has changed.

**Kind**: instance property of [<code>BundleGroup</code>](#BundleGroup)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="CubeRenderTarget"></a>

## CubeRenderTarget ⇐ <code>WebGLCubeRenderTarget</code>
This class represents a cube render target. It is a special version
of `WebGLCubeRenderTarget` which is compatible with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>WebGLCubeRenderTarget</code>  

* [CubeRenderTarget](#CubeRenderTarget) ⇐ <code>WebGLCubeRenderTarget</code>
    * [new CubeRenderTarget([size], [options])](#new_CubeRenderTarget_new)
    * [.isCubeRenderTarget](#CubeRenderTarget+isCubeRenderTarget) : <code>boolean</code>
    * [.fromEquirectangularTexture(renderer, texture)](#CubeRenderTarget+fromEquirectangularTexture) ⇒ [<code>CubeRenderTarget</code>](#CubeRenderTarget)

<a name="new_CubeRenderTarget_new"></a>

### new CubeRenderTarget([size], [options])
Constructs a new cube render target.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>1</code> | The size of the render target. |
| [options] | <code>RenderTarget~Options</code> |  | The configuration object. |

<a name="CubeRenderTarget+isCubeRenderTarget"></a>

### cubeRenderTarget.isCubeRenderTarget : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubeRenderTarget</code>](#CubeRenderTarget)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubeRenderTarget+fromEquirectangularTexture"></a>

### cubeRenderTarget.fromEquirectangularTexture(renderer, texture) ⇒ [<code>CubeRenderTarget</code>](#CubeRenderTarget)
Converts the given equirectangular texture to a cube map.

**Kind**: instance method of [<code>CubeRenderTarget</code>](#CubeRenderTarget)  
**Returns**: [<code>CubeRenderTarget</code>](#CubeRenderTarget) - A reference to this cube render target.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |
| texture | <code>Texture</code> | The equirectangular texture. |

<a name="IndirectStorageBufferAttribute"></a>

## IndirectStorageBufferAttribute ⇐ <code>StorageBufferAttribute</code>
This special type of buffer attribute is intended for compute shaders.
It can be used to encode draw parameters for indirect draw calls.

Note: This type of buffer attribute can only be used with `WebGPURenderer`
and a WebGPU backend.

**Kind**: global class  
**Extends**: <code>StorageBufferAttribute</code>  

* [IndirectStorageBufferAttribute](#IndirectStorageBufferAttribute) ⇐ <code>StorageBufferAttribute</code>
    * [new IndirectStorageBufferAttribute(count, itemSize)](#new_IndirectStorageBufferAttribute_new)
    * [.isIndirectStorageBufferAttribute](#IndirectStorageBufferAttribute+isIndirectStorageBufferAttribute) : <code>boolean</code>

<a name="new_IndirectStorageBufferAttribute_new"></a>

### new IndirectStorageBufferAttribute(count, itemSize)
Constructs a new storage buffer attribute.


| Param | Type | Description |
| --- | --- | --- |
| count | <code>number</code> \| <code>Uint32Array</code> | The item count. It is also valid to pass a `Uint32Array` as an argument. The subsequent parameter is then obsolete. |
| itemSize | <code>number</code> | The item size. |

<a name="IndirectStorageBufferAttribute+isIndirectStorageBufferAttribute"></a>

### indirectStorageBufferAttribute.isIndirectStorageBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>IndirectStorageBufferAttribute</code>](#IndirectStorageBufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Info"></a>

## Info
This renderer module provides a series of statistical information
about the GPU memory and the rendering process. Useful for debugging
and monitoring.

**Kind**: global class  

* [Info](#Info)
    * [new Info()](#new_Info_new)
    * [.autoReset](#Info+autoReset) : <code>boolean</code>
    * [.frame](#Info+frame) : <code>number</code>
    * [.calls](#Info+calls) : <code>number</code>
    * [.render](#Info+render) : <code>Object</code>
    * [.compute](#Info+compute) : <code>Object</code>
    * [.memory](#Info+memory) : <code>Object</code>
    * [.update(object, count, instanceCount)](#Info+update)
    * [.reset()](#Info+reset)
    * [.dispose()](#Info+dispose)

<a name="new_Info_new"></a>

### new Info()
Constructs a new info component.

<a name="Info+autoReset"></a>

### info.autoReset : <code>boolean</code>
Whether frame related metrics should automatically
be resetted or not. This property should be set to `false`
by apps which manage their own animation loop. They must
then call `renderer.info.reset()` once per frame manually.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Default**: <code>true</code>  
<a name="Info+frame"></a>

### info.frame : <code>number</code>
The current frame ID. This ID is managed
by `NodeFrame`.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Info+calls"></a>

### info.calls : <code>number</code>
The number of render calls since the
app has been started.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Info+render"></a>

### info.render : <code>Object</code>
Render related metrics.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Read only**: true  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| calls | <code>number</code> | The number of render calls since the app has been started. |
| frameCalls | <code>number</code> | The number of render calls of the current frame. |
| drawCalls | <code>number</code> | The number of draw calls of the current frame. |
| triangles | <code>number</code> | The number of rendered triangle primitives of the current frame. |
| points | <code>number</code> | The number of rendered point primitives of the current frame. |
| lines | <code>number</code> | The number of rendered line primitives of the current frame. |
| timestamp | <code>number</code> | The timestamp of the frame when using `renderer.renderAsync()`. |

<a name="Info+compute"></a>

### info.compute : <code>Object</code>
Compute related metrics.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Read only**: true  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| calls | <code>number</code> | The number of compute calls since the app has been started. |
| frameCalls | <code>number</code> | The number of compute calls of the current frame. |
| timestamp | <code>number</code> | The timestamp of the frame when using `renderer.computeAsync()`. |

<a name="Info+memory"></a>

### info.memory : <code>Object</code>
Memory related metrics.

**Kind**: instance property of [<code>Info</code>](#Info)  
**Read only**: true  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| geometries | <code>number</code> | The number of active geometries. |
| frameCalls | <code>number</code> | The number of active textures. |

<a name="Info+update"></a>

### info.update(object, count, instanceCount)
This method should be executed per draw call and updates the corresponding metrics.

**Kind**: instance method of [<code>Info</code>](#Info)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object that is going to be rendered. |
| count | <code>number</code> | The vertex or index count. |
| instanceCount | <code>number</code> | The instance count. |

<a name="Info+reset"></a>

### info.reset()
Resets frame related metrics.

**Kind**: instance method of [<code>Info</code>](#Info)  
<a name="Info+dispose"></a>

### info.dispose()
Performs a complete reset of the object.

**Kind**: instance method of [<code>Info</code>](#Info)  
<a name="PostProcessing"></a>

## PostProcessing
This module is responsible to manage the post processing setups in apps.
You usually create a single instance of this class and use it to define
the output of your post processing effect chain.
```js
const postProcessing = new PostProcessing( renderer );

const scenePass = pass( scene, camera );

postProcessing.outputNode = scenePass;
```

Note: This module can only be used with `WebGPURenderer`.

**Kind**: global class  

* [PostProcessing](#PostProcessing)
    * [new PostProcessing(renderer, outputNode)](#new_PostProcessing_new)
    * [.renderer](#PostProcessing+renderer) : <code>Renderer</code>
    * [.outputNode](#PostProcessing+outputNode) : <code>Node.&lt;vec4&gt;</code>
    * [.outputColorTransform](#PostProcessing+outputColorTransform) : <code>boolean</code>
    * [.needsUpdate](#PostProcessing+needsUpdate) : <code>Node.&lt;vec4&gt;</code>
    * [.render()](#PostProcessing+render)
    * [.dispose()](#PostProcessing+dispose)
    * [.renderAsync()](#PostProcessing+renderAsync) ⇒ <code>Promise</code>

<a name="new_PostProcessing_new"></a>

### new PostProcessing(renderer, outputNode)
Constructs a new post processing management module.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | A reference to the renderer. |
| outputNode | <code>Node.&lt;vec4&gt;</code> | An optional output node. |

<a name="PostProcessing+renderer"></a>

### postProcessing.renderer : <code>Renderer</code>
A reference to the renderer.

**Kind**: instance property of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+outputNode"></a>

### postProcessing.outputNode : <code>Node.&lt;vec4&gt;</code>
A node which defines the final output of the post
processing. This is usually the last node in a chain
of effect nodes.

**Kind**: instance property of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+outputColorTransform"></a>

### postProcessing.outputColorTransform : <code>boolean</code>
Whether the default output tone mapping and color
space transformation should be enabled or not.

It is enabled by default by it must be disabled when
effects must be executed after tone mapping and color
space conversion. A typical example is FXAA which
requires sRGB input.

When set to `false`, the app must control the output
transformation with `RenderOutputNode`.

```js
const outputPass = renderOutput( scenePass );
```

**Kind**: instance property of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+needsUpdate"></a>

### postProcessing.needsUpdate : <code>Node.&lt;vec4&gt;</code>
Must be set to `true` when the output node changes.

**Kind**: instance property of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+render"></a>

### postProcessing.render()
When `PostProcessing` is used to apply post processing effects,
the application must use this version of `render()` inside
its animation loop (not the one from the renderer).

**Kind**: instance method of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+dispose"></a>

### postProcessing.dispose()
Frees internal resources.

**Kind**: instance method of [<code>PostProcessing</code>](#PostProcessing)  
<a name="PostProcessing+renderAsync"></a>

### postProcessing.renderAsync() ⇒ <code>Promise</code>
When `PostProcessing` is used to apply post processing effects,
the application must use this version of `renderAsync()` inside
its animation loop (not the one from the renderer).

**Kind**: instance method of [<code>PostProcessing</code>](#PostProcessing)  
**Returns**: <code>Promise</code> - A Promise that resolves when the render has been finished.  
<a name="QuadMesh"></a>

## QuadMesh ⇐ <code>Mesh</code>
This module is a helper for passes which need to render a full
screen effect which is quite common in context of post processing.

The intended usage is to reuse a single quad mesh for rendering
subsequent passes by just reassigning the `material` reference.

Note: This module can only be used with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [QuadMesh](#QuadMesh) ⇐ <code>Mesh</code>
    * [new QuadMesh([material])](#new_QuadMesh_new)
    * [.camera](#QuadMesh+camera) : <code>OrthographicCamera</code>
    * [.isQuadMesh](#QuadMesh+isQuadMesh) : <code>boolean</code>
    * [.renderAsync(renderer)](#QuadMesh+renderAsync) ⇒ <code>Promise</code>
    * [.render(renderer)](#QuadMesh+render)

<a name="new_QuadMesh_new"></a>

### new QuadMesh([material])
Constructs a new quad mesh.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [material] | <code>Material</code> | <code></code> | The material to render the quad mesh with. |

<a name="QuadMesh+camera"></a>

### quadMesh.camera : <code>OrthographicCamera</code>
The camera to render the quad mesh with.

**Kind**: instance property of [<code>QuadMesh</code>](#QuadMesh)  
**Read only**: true  
<a name="QuadMesh+isQuadMesh"></a>

### quadMesh.isQuadMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>QuadMesh</code>](#QuadMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="QuadMesh+renderAsync"></a>

### quadMesh.renderAsync(renderer) ⇒ <code>Promise</code>
Async version of `render()`.

**Kind**: instance method of [<code>QuadMesh</code>](#QuadMesh)  
**Returns**: <code>Promise</code> - A Promise that resolves when the render has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |

<a name="QuadMesh+render"></a>

### quadMesh.render(renderer)
Renders the quad mesh

**Kind**: instance method of [<code>QuadMesh</code>](#QuadMesh)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |

<a name="getCacheKey"></a>

## getCacheKey(renderContext) ⇒ <code>number</code>
Computes a cache key for the given render context. This key
should identify the render target state so it is possible to
configure the correct attachments in the respective backend.

**Kind**: global function  
**Returns**: <code>number</code> - The cache key.  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | [<code>RenderContext</code>](#new_RenderContext_new) | The render context. |

## Classes

<dl>
<dt><a href="#Renderer">Renderer</a></dt>
<dd><p>Base class for renderers.</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#ShadowMapConfig">ShadowMapConfig</a> : <code>Object</code></dt>
<dd><p>Shadow map configuration</p>
</dd>
<dt><a href="#XRConfig">XRConfig</a> : <code>Object</code></dt>
<dd><p>XR configuration.</p>
</dd>
<dt><a href="#DebugConfig">DebugConfig</a> : <code>Object</code></dt>
<dd><p>Debug configuration.</p>
</dd>
<dt><a href="#renderObjectFunction">renderObjectFunction</a> : <code>function</code></dt>
<dd><p>Callback for <a href="#Renderer+setRenderObjectFunction">setRenderObjectFunction</a>.</p>
</dd>
</dl>

<a name="Renderer"></a>

## Renderer
Base class for renderers.

**Kind**: global class  

* [Renderer](#Renderer)
    * [new Renderer(backend, [parameters])](#new_Renderer_new)
    * _instance_
        * [.isRenderer](#Renderer+isRenderer) : <code>boolean</code>
        * [.domElement](#Renderer+domElement) : <code>HTMLCanvasElement</code> \| <code>OffscreenCanvas</code>
        * [.backend](#Renderer+backend) : <code>Backend</code>
        * [.samples](#Renderer+samples) : <code>number</code>
        * [.autoClear](#Renderer+autoClear) : <code>boolean</code>
        * [.autoClearColor](#Renderer+autoClearColor) : <code>boolean</code>
        * [.autoClearDepth](#Renderer+autoClearDepth) : <code>boolean</code>
        * [.autoClearStencil](#Renderer+autoClearStencil) : <code>boolean</code>
        * [.alpha](#Renderer+alpha) : <code>boolean</code>
        * [.logarithmicDepthBuffer](#Renderer+logarithmicDepthBuffer) : <code>boolean</code>
        * [.outputColorSpace](#Renderer+outputColorSpace) : <code>string</code>
        * [.toneMapping](#Renderer+toneMapping) : <code>number</code>
        * [.toneMappingExposure](#Renderer+toneMappingExposure) : <code>number</code>
        * [.sortObjects](#Renderer+sortObjects) : <code>boolean</code>
        * [.depth](#Renderer+depth) : <code>boolean</code>
        * [.stencil](#Renderer+stencil) : <code>boolean</code>
        * [.info](#Renderer+info) : <code>Info</code>
        * [.library](#Renderer+library) : <code>NodeLibrary</code>
        * [.lighting](#Renderer+lighting) : <code>Lighting</code>
        * [.onDeviceLost](#Renderer+onDeviceLost) : <code>function</code>
        * [.transparent](#Renderer+transparent) : <code>boolean</code>
        * [.opaque](#Renderer+opaque) : <code>boolean</code>
        * [.shadowMap](#Renderer+shadowMap) : [<code>ShadowMapConfig</code>](#ShadowMapConfig)
        * [.xr](#Renderer+xr) : <code>XRManager</code>
        * [.debug](#Renderer+debug) : [<code>DebugConfig</code>](#DebugConfig)
        * [.coordinateSystem](#Renderer+coordinateSystem) : <code>number</code>
        * [.currentToneMapping](#Renderer+currentToneMapping) : <code>number</code>
        * [.currentColorSpace](#Renderer+currentColorSpace) : <code>string</code>
        * [.isOutputTarget](#Renderer+isOutputTarget) ⇒ <code>boolean</code>
        * [.init()](#Renderer+init) ⇒ <code>Promise.&lt;this&gt;</code>
        * [.compileAsync(scene, camera, targetScene)](#Renderer+compileAsync) ⇒ <code>Promise.&lt;(Array\|undefined)&gt;</code>
        * [.renderAsync(scene, camera)](#Renderer+renderAsync) ⇒ <code>Promise</code>
        * [.waitForGPU()](#Renderer+waitForGPU) ⇒ <code>Promise</code>
        * [.setMRT(mrt)](#Renderer+setMRT) ⇒ [<code>Renderer</code>](#Renderer)
        * [.getMRT()](#Renderer+getMRT) ⇒ <code>MRTNode</code>
        * [.getColorBufferType()](#Renderer+getColorBufferType) ⇒ <code>number</code>
        * [.render(scene, camera)](#Renderer+render) ⇒ <code>Promise</code>
        * [.getMaxAnisotropy()](#Renderer+getMaxAnisotropy) ⇒ <code>number</code>
        * [.getActiveCubeFace()](#Renderer+getActiveCubeFace) ⇒ <code>number</code>
        * [.getActiveMipmapLevel()](#Renderer+getActiveMipmapLevel) ⇒ <code>number</code>
        * [.setAnimationLoop(callback)](#Renderer+setAnimationLoop) ⇒ <code>Promise</code>
        * [.getArrayBufferAsync(attribute)](#Renderer+getArrayBufferAsync) ⇒ <code>Promise.&lt;ArrayBuffer&gt;</code>
        * [.getContext()](#Renderer+getContext) ⇒ <code>GPUCanvasContext</code> \| <code>WebGL2RenderingContext</code>
        * [.getPixelRatio()](#Renderer+getPixelRatio) ⇒ <code>number</code>
        * [.getDrawingBufferSize(target)](#Renderer+getDrawingBufferSize) ⇒ <code>Vector2</code>
        * [.getSize(target)](#Renderer+getSize) ⇒ <code>Vector2</code>
        * [.setPixelRatio([value])](#Renderer+setPixelRatio)
        * [.setDrawingBufferSize(width, height, pixelRatio)](#Renderer+setDrawingBufferSize)
        * [.setSize(width, height, [updateStyle])](#Renderer+setSize)
        * [.setOpaqueSort(method)](#Renderer+setOpaqueSort)
        * [.setTransparentSort(method)](#Renderer+setTransparentSort)
        * [.getScissor(target)](#Renderer+getScissor) ⇒ <code>Vector4</code>
        * [.setScissor(x, y, width, height)](#Renderer+setScissor)
        * [.getScissorTest()](#Renderer+getScissorTest) ⇒ <code>boolean</code>
        * [.setScissorTest(boolean)](#Renderer+setScissorTest)
        * [.getViewport(target)](#Renderer+getViewport) ⇒ <code>Vector4</code>
        * [.setViewport(x, y, width, height, minDepth, maxDepth)](#Renderer+setViewport)
        * [.getClearColor(target)](#Renderer+getClearColor) ⇒ <code>Color</code>
        * [.setClearColor(color, [alpha])](#Renderer+setClearColor)
        * [.getClearAlpha()](#Renderer+getClearAlpha) ⇒ <code>number</code>
        * [.setClearAlpha(alpha)](#Renderer+setClearAlpha)
        * [.getClearDepth()](#Renderer+getClearDepth) ⇒ <code>number</code>
        * [.setClearDepth(depth)](#Renderer+setClearDepth)
        * [.getClearStencil()](#Renderer+getClearStencil) ⇒ <code>number</code>
        * [.setClearStencil(stencil)](#Renderer+setClearStencil)
        * [.isOccluded(object)](#Renderer+isOccluded) ⇒ <code>boolean</code>
        * [.clear([color], [depth], [stencil])](#Renderer+clear) ⇒ <code>Promise</code>
        * [.clearColor()](#Renderer+clearColor) ⇒ <code>Promise</code>
        * [.clearDepth()](#Renderer+clearDepth) ⇒ <code>Promise</code>
        * [.clearStencil()](#Renderer+clearStencil) ⇒ <code>Promise</code>
        * [.clearAsync([color], [depth], [stencil])](#Renderer+clearAsync) ⇒ <code>Promise</code>
        * [.clearColorAsync()](#Renderer+clearColorAsync) ⇒ <code>Promise</code>
        * [.clearDepthAsync()](#Renderer+clearDepthAsync) ⇒ <code>Promise</code>
        * [.clearStencilAsync()](#Renderer+clearStencilAsync) ⇒ <code>Promise</code>
        * [.dispose()](#Renderer+dispose)
        * [.setRenderTarget(renderTarget, [activeCubeFace], [activeMipmapLevel])](#Renderer+setRenderTarget)
        * [.getRenderTarget()](#Renderer+getRenderTarget) ⇒ <code>RenderTarget</code>
        * [.setOutputRenderTarget(renderTarget)](#Renderer+setOutputRenderTarget)
        * [.getOutputRenderTarget()](#Renderer+getOutputRenderTarget) ⇒ <code>RenderTarget</code>
        * [.setRenderObjectFunction(renderObjectFunction)](#Renderer+setRenderObjectFunction)
        * [.getRenderObjectFunction()](#Renderer+getRenderObjectFunction) ⇒ <code>function</code>
        * [.compute(computeNodes)](#Renderer+compute) ⇒ <code>Promise</code> \| <code>undefined</code>
        * [.computeAsync(computeNodes)](#Renderer+computeAsync) ⇒ <code>Promise</code>
        * [.hasFeatureAsync(name)](#Renderer+hasFeatureAsync) ⇒ <code>Promise.&lt;boolean&gt;</code>
        * [.hasFeature(name)](#Renderer+hasFeature) ⇒ <code>boolean</code>
        * [.hasInitialized()](#Renderer+hasInitialized) ⇒ <code>boolean</code>
        * [.initTextureAsync(texture)](#Renderer+initTextureAsync) ⇒ <code>Promise</code>
        * [.initTexture(texture)](#Renderer+initTexture)
        * [.copyFramebufferToTexture(framebufferTexture, [rectangle])](#Renderer+copyFramebufferToTexture)
        * [.copyTextureToTexture(srcTexture, dstTexture, [srcRegion], [dstPosition], [srcLevel], [dstLevel])](#Renderer+copyTextureToTexture)
        * [.readRenderTargetPixelsAsync(renderTarget, x, y, width, height, [textureIndex], [faceIndex])](#Renderer+readRenderTargetPixelsAsync) ⇒ <code>Promise.&lt;TypedArray&gt;</code>
        * [._projectObject(object, camera, groupOrder, renderList, clippingContext)](#Renderer+_projectObject)
        * [.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext, [passId])](#Renderer+renderObject)
        * [.compile(scene, camera, targetScene)](#Renderer+compile) ⇒ <code>function</code>
    * _inner_
        * [~Options](#Renderer..Options) : <code>Object</code>

<a name="new_Renderer_new"></a>

### new Renderer(backend, [parameters])
Constructs a new renderer.


| Param | Type | Description |
| --- | --- | --- |
| backend | <code>Backend</code> | The backend the renderer is targeting (e.g. WebGPU or WebGL 2). |
| [parameters] | [<code>Options</code>](#Renderer..Options) | The configuration parameter. |

<a name="Renderer+isRenderer"></a>

### renderer.isRenderer : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Renderer+domElement"></a>

### renderer.domElement : <code>HTMLCanvasElement</code> \| <code>OffscreenCanvas</code>
A reference to the canvas element the renderer is drawing to.
This value of this property will automatically be created by
the renderer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+backend"></a>

### renderer.backend : <code>Backend</code>
A reference to the current backend.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+samples"></a>

### renderer.samples : <code>number</code>
The number of MSAA samples.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>0</code>  
<a name="Renderer+autoClear"></a>

### renderer.autoClear : <code>boolean</code>
Whether the renderer should automatically clear the current rendering target
before execute a `render()` call. The target can be the canvas (default framebuffer)
or the current bound render target (custom framebuffer).

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+autoClearColor"></a>

### renderer.autoClearColor : <code>boolean</code>
When `autoClear` is set to `true`, this property defines whether the renderer
should clear the color buffer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+autoClearDepth"></a>

### renderer.autoClearDepth : <code>boolean</code>
When `autoClear` is set to `true`, this property defines whether the renderer
should clear the depth buffer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+autoClearStencil"></a>

### renderer.autoClearStencil : <code>boolean</code>
When `autoClear` is set to `true`, this property defines whether the renderer
should clear the stencil buffer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+alpha"></a>

### renderer.alpha : <code>boolean</code>
Whether the default framebuffer should be transparent or opaque.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+logarithmicDepthBuffer"></a>

### renderer.logarithmicDepthBuffer : <code>boolean</code>
Whether logarithmic depth buffer is enabled or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>false</code>  
<a name="Renderer+outputColorSpace"></a>

### renderer.outputColorSpace : <code>string</code>
Defines the output color space of the renderer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>&quot;SRGBColorSpace&quot;</code>  
<a name="Renderer+toneMapping"></a>

### renderer.toneMapping : <code>number</code>
Defines the tone mapping of the renderer.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>NoToneMapping</code>  
<a name="Renderer+toneMappingExposure"></a>

### renderer.toneMappingExposure : <code>number</code>
Defines the tone mapping exposure.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>1</code>  
<a name="Renderer+sortObjects"></a>

### renderer.sortObjects : <code>boolean</code>
Whether the renderer should sort its render lists or not.

Note: Sorting is used to attempt to properly render objects that have some degree of transparency.
By definition, sorting objects may not work in all cases. Depending on the needs of application,
it may be necessary to turn off sorting and use other methods to deal with transparency rendering
e.g. manually determining each object's rendering order.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+depth"></a>

### renderer.depth : <code>boolean</code>
Whether the default framebuffer should have a depth buffer or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+stencil"></a>

### renderer.stencil : <code>boolean</code>
Whether the default framebuffer should have a stencil buffer or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>false</code>  
<a name="Renderer+info"></a>

### renderer.info : <code>Info</code>
Holds a series of statistical information about the GPU memory
and the rendering process. Useful for debugging and monitoring.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+library"></a>

### renderer.library : <code>NodeLibrary</code>
The node library defines how certain library objects like materials, lights
or tone mapping functions are mapped to node types. This is required since
although instances of classes like `MeshBasicMaterial` or `PointLight` can
be part of the scene graph, they are internally represented as nodes for
further processing.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+lighting"></a>

### renderer.lighting : <code>Lighting</code>
A map-like data structure for managing lights.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+onDeviceLost"></a>

### renderer.onDeviceLost : <code>function</code>
A callback function that defines what should happen when a device/context lost occurs.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+transparent"></a>

### renderer.transparent : <code>boolean</code>
Whether the renderer should render transparent render objects or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+opaque"></a>

### renderer.opaque : <code>boolean</code>
Whether the renderer should render opaque render objects or not.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Default**: <code>true</code>  
<a name="Renderer+shadowMap"></a>

### renderer.shadowMap : [<code>ShadowMapConfig</code>](#ShadowMapConfig)
The renderer's shadow configuration.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+xr"></a>

### renderer.xr : <code>XRManager</code>
The renderer's XR manager.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+debug"></a>

### renderer.debug : [<code>DebugConfig</code>](#DebugConfig)
The renderer's debug configuration.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+coordinateSystem"></a>

### renderer.coordinateSystem : <code>number</code>
The coordinate system of the renderer. The value of this property
depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
`THREE.WebGPUCoordinateSystem`.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Read only**: true  
<a name="Renderer+currentToneMapping"></a>

### renderer.currentToneMapping : <code>number</code>
The current output tone mapping of the renderer. When a render target is set,
the output tone mapping is always `NoToneMapping`.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+currentColorSpace"></a>

### renderer.currentColorSpace : <code>string</code>
The current output color space of the renderer. When a render target is set,
the output color space is always `LinearSRGBColorSpace`.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+isOutputTarget"></a>

### renderer.isOutputTarget ⇒ <code>boolean</code>
Returns `true` if the rendering settings are set to screen output.

**Kind**: instance property of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - True if the current render target is the same of output render target or `null`, otherwise false.  
<a name="Renderer+init"></a>

### renderer.init() ⇒ <code>Promise.&lt;this&gt;</code>
Initializes the renderer so it is ready for usage.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;this&gt;</code> - A Promise that resolves when the renderer has been initialized.  
<a name="Renderer+compileAsync"></a>

### renderer.compileAsync(scene, camera, targetScene) ⇒ <code>Promise.&lt;(Array\|undefined)&gt;</code>
Compiles all materials in the given scene. This can be useful to avoid a
phenomenon which is called "shader compilation stutter", which occurs when
rendering an object with a new shader for the first time.

If you want to add a 3D object to an existing scene, use the third optional
parameter for applying the target scene. Note that the (target) scene's lighting
and environment must be configured before calling this method.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;(Array\|undefined)&gt;</code> - A Promise that resolves when the compile has been finished.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Object3D</code> |  | The scene or 3D object to precompile. |
| camera | <code>Camera</code> |  | The camera that is used to render the scene. |
| targetScene | <code>Scene</code> | <code></code> | If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added. |

<a name="Renderer+renderAsync"></a>

### renderer.renderAsync(scene, camera) ⇒ <code>Promise</code>
Renders the scene in an async fashion.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the render has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or 3D object to render. |
| camera | <code>Camera</code> | The camera. |

<a name="Renderer+waitForGPU"></a>

### renderer.waitForGPU() ⇒ <code>Promise</code>
Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
the CPU waits for the GPU to complete its operation (e.g. a compute task).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when synchronization has been finished.  
<a name="Renderer+setMRT"></a>

### renderer.setMRT(mrt) ⇒ [<code>Renderer</code>](#Renderer)
Sets the given MRT configuration.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: [<code>Renderer</code>](#Renderer) - A reference to this renderer.  

| Param | Type | Description |
| --- | --- | --- |
| mrt | <code>MRTNode</code> | The MRT node to set. |

<a name="Renderer+getMRT"></a>

### renderer.getMRT() ⇒ <code>MRTNode</code>
Returns the MRT configuration.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>MRTNode</code> - The MRT configuration.  
<a name="Renderer+getColorBufferType"></a>

### renderer.getColorBufferType() ⇒ <code>number</code>
Returns the color buffer type.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The color buffer type.  
<a name="Renderer+render"></a>

### renderer.render(scene, camera) ⇒ <code>Promise</code>
Renders the scene or 3D object with the given camera. This method can only be called
if the renderer has been initialized.

The target of the method is the default framebuffer (meaning the canvas)
or alternatively a render target when specified via `setRenderTarget()`.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolve when the scene has been rendered.
Only returned when the renderer has not been initialized.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or 3D object to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="Renderer+getMaxAnisotropy"></a>

### renderer.getMaxAnisotropy() ⇒ <code>number</code>
Returns the maximum available anisotropy for texture filtering.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The maximum available anisotropy.  
<a name="Renderer+getActiveCubeFace"></a>

### renderer.getActiveCubeFace() ⇒ <code>number</code>
Returns the active cube face.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The active cube face.  
<a name="Renderer+getActiveMipmapLevel"></a>

### renderer.getActiveMipmapLevel() ⇒ <code>number</code>
Returns the active mipmap level.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The active mipmap level.  
<a name="Renderer+setAnimationLoop"></a>

### renderer.setAnimationLoop(callback) ⇒ <code>Promise</code>
Applications are advised to always define the animation loop
with this method and not manually with `requestAnimationFrame()`
for best compatibility.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the set has been executed.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The application's animation loop. |

<a name="Renderer+getArrayBufferAsync"></a>

### renderer.getArrayBufferAsync(attribute) ⇒ <code>Promise.&lt;ArrayBuffer&gt;</code>
Can be used to transfer buffer data from a storage buffer attribute
from the GPU to the CPU in context of compute shaders.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;ArrayBuffer&gt;</code> - A promise that resolves with the buffer data when the data are ready.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>StorageBufferAttribute</code> | The storage buffer attribute. |

<a name="Renderer+getContext"></a>

### renderer.getContext() ⇒ <code>GPUCanvasContext</code> \| <code>WebGL2RenderingContext</code>
Returns the rendering context.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>GPUCanvasContext</code> \| <code>WebGL2RenderingContext</code> - The rendering context.  
<a name="Renderer+getPixelRatio"></a>

### renderer.getPixelRatio() ⇒ <code>number</code>
Returns the pixel ratio.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The pixel ratio.  
<a name="Renderer+getDrawingBufferSize"></a>

### renderer.getDrawingBufferSize(target) ⇒ <code>Vector2</code>
Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Vector2</code> - The drawing buffer size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="Renderer+getSize"></a>

### renderer.getSize(target) ⇒ <code>Vector2</code>
Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Vector2</code> - The renderer's size in logical pixels.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector2</code> | The method writes the result in this target object. |

<a name="Renderer+setPixelRatio"></a>

### renderer.setPixelRatio([value])
Sets the given pixel ratio and resizes the canvas if necessary.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [value] | <code>number</code> | <code>1</code> | The pixel ratio. |

<a name="Renderer+setDrawingBufferSize"></a>

### renderer.setDrawingBufferSize(width, height, pixelRatio)
This method allows to define the drawing buffer size by specifying
width, height and pixel ratio all at once. The size of the drawing
buffer is computed with this formula:
```js
size.x = width * pixelRatio;
size.y = height * pixelRatio;
```

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width in logical pixels. |
| height | <code>number</code> | The height in logical pixels. |
| pixelRatio | <code>number</code> | The pixel ratio. |

<a name="Renderer+setSize"></a>

### renderer.setSize(width, height, [updateStyle])
Sets the size of the renderer.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| width | <code>number</code> |  | The width in logical pixels. |
| height | <code>number</code> |  | The height in logical pixels. |
| [updateStyle] | <code>boolean</code> | <code>true</code> | Whether to update the `style` attribute of the canvas or not. |

<a name="Renderer+setOpaqueSort"></a>

### renderer.setOpaqueSort(method)
Defines a manual sort function for the opaque render list.
Pass `null` to use the default sort.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | The sort function. |

<a name="Renderer+setTransparentSort"></a>

### renderer.setTransparentSort(method)
Defines a manual sort function for the transparent render list.
Pass `null` to use the default sort.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | The sort function. |

<a name="Renderer+getScissor"></a>

### renderer.getScissor(target) ⇒ <code>Vector4</code>
Returns the scissor rectangle.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Vector4</code> - The scissor rectangle.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector4</code> | The method writes the result in this target object. |

<a name="Renderer+setScissor"></a>

### renderer.setScissor(x, y, width, height)
Defines the scissor rectangle.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> \| <code>Vector4</code> | The horizontal coordinate for the lower left corner of the box in logical pixel unit. Instead of passing four arguments, the method also works with a single four-dimensional vector. |
| y | <code>number</code> | The vertical coordinate for the lower left corner of the box in logical pixel unit. |
| width | <code>number</code> | The width of the scissor box in logical pixel unit. |
| height | <code>number</code> | The height of the scissor box in logical pixel unit. |

<a name="Renderer+getScissorTest"></a>

### renderer.getScissorTest() ⇒ <code>boolean</code>
Returns the scissor test value.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - Whether the scissor test should be enabled or not.  
<a name="Renderer+setScissorTest"></a>

### renderer.setScissorTest(boolean)
Defines the scissor test.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| boolean | <code>boolean</code> | Whether the scissor test should be enabled or not. |

<a name="Renderer+getViewport"></a>

### renderer.getViewport(target) ⇒ <code>Vector4</code>
Returns the viewport definition.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Vector4</code> - The viewport definition.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector4</code> | The method writes the result in this target object. |

<a name="Renderer+setViewport"></a>

### renderer.setViewport(x, y, width, height, minDepth, maxDepth)
Defines the viewport.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| x | <code>number</code> \| <code>Vector4</code> |  | The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit. |
| y | <code>number</code> |  | The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit. |
| width | <code>number</code> |  | The width of the viewport in logical pixel unit. |
| height | <code>number</code> |  | The height of the viewport in logical pixel unit. |
| minDepth | <code>number</code> | <code>0</code> | The minimum depth value of the viewport. WebGPU only. |
| maxDepth | <code>number</code> | <code>1</code> | The maximum depth value of the viewport. WebGPU only. |

<a name="Renderer+getClearColor"></a>

### renderer.getClearColor(target) ⇒ <code>Color</code>
Returns the clear color.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Color</code> - The clear color.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Color</code> | The method writes the result in this target object. |

<a name="Renderer+setClearColor"></a>

### renderer.setClearColor(color, [alpha])
Defines the clear color and optionally the clear alpha.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Color</code> |  | The clear color. |
| [alpha] | <code>number</code> | <code>1</code> | The clear alpha. |

<a name="Renderer+getClearAlpha"></a>

### renderer.getClearAlpha() ⇒ <code>number</code>
Returns the clear alpha.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The clear alpha.  
<a name="Renderer+setClearAlpha"></a>

### renderer.setClearAlpha(alpha)
Defines the clear alpha.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| alpha | <code>number</code> | The clear alpha. |

<a name="Renderer+getClearDepth"></a>

### renderer.getClearDepth() ⇒ <code>number</code>
Returns the clear depth.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The clear depth.  
<a name="Renderer+setClearDepth"></a>

### renderer.setClearDepth(depth)
Defines the clear depth.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| depth | <code>number</code> | The clear depth. |

<a name="Renderer+getClearStencil"></a>

### renderer.getClearStencil() ⇒ <code>number</code>
Returns the clear stencil.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>number</code> - The clear stencil.  
<a name="Renderer+setClearStencil"></a>

### renderer.setClearStencil(stencil)
Defines the clear stencil.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| stencil | <code>number</code> | The clear stencil. |

<a name="Renderer+isOccluded"></a>

### renderer.isOccluded(object) ⇒ <code>boolean</code>
This method performs an occlusion query for the given 3D object.
It returns `true` if the given 3D object is fully occluded by other
3D objects in the scene.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - Whether the 3D object is fully occluded or not.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to test. |

<a name="Renderer+clear"></a>

### renderer.clear([color], [depth], [stencil]) ⇒ <code>Promise</code>
Performs a manual clear operation. This method ignores `autoClear` properties.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.
Only returned when the renderer has not been initialized.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>boolean</code> | <code>true</code> | Whether the color buffer should be cleared or not. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the depth buffer should be cleared or not. |
| [stencil] | <code>boolean</code> | <code>true</code> | Whether the stencil buffer should be cleared or not. |

<a name="Renderer+clearColor"></a>

### renderer.clearColor() ⇒ <code>Promise</code>
Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.
Only returned when the renderer has not been initialized.  
<a name="Renderer+clearDepth"></a>

### renderer.clearDepth() ⇒ <code>Promise</code>
Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.
Only returned when the renderer has not been initialized.  
<a name="Renderer+clearStencil"></a>

### renderer.clearStencil() ⇒ <code>Promise</code>
Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.
Only returned when the renderer has not been initialized.  
<a name="Renderer+clearAsync"></a>

### renderer.clearAsync([color], [depth], [stencil]) ⇒ <code>Promise</code>
Async version of [clear](#Renderer+clear).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>boolean</code> | <code>true</code> | Whether the color buffer should be cleared or not. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the depth buffer should be cleared or not. |
| [stencil] | <code>boolean</code> | <code>true</code> | Whether the stencil buffer should be cleared or not. |

<a name="Renderer+clearColorAsync"></a>

### renderer.clearColorAsync() ⇒ <code>Promise</code>
Async version of [clearColor](#Renderer+clearColor).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.  
<a name="Renderer+clearDepthAsync"></a>

### renderer.clearDepthAsync() ⇒ <code>Promise</code>
Async version of [clearDepth](#Renderer+clearDepth).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.  
<a name="Renderer+clearStencilAsync"></a>

### renderer.clearStencilAsync() ⇒ <code>Promise</code>
Async version of [clearStencil](#Renderer+clearStencil).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the clear operation has been executed.  
<a name="Renderer+dispose"></a>

### renderer.dispose()
Frees all internal resources of the renderer. Call this method if the renderer
is no longer in use by your app.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
<a name="Renderer+setRenderTarget"></a>

### renderer.setRenderTarget(renderTarget, [activeCubeFace], [activeMipmapLevel])
Sets the given render target. Calling this method means the renderer does not
target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
Use `null` as the first argument to reset the state.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderTarget | <code>RenderTarget</code> |  | The render target to set. |
| [activeCubeFace] | <code>number</code> | <code>0</code> | The active cube face. |
| [activeMipmapLevel] | <code>number</code> | <code>0</code> | The active mipmap level. |

<a name="Renderer+getRenderTarget"></a>

### renderer.getRenderTarget() ⇒ <code>RenderTarget</code>
Returns the current render target.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>RenderTarget</code> - The render target. Returns `null` if no render target is set.  
<a name="Renderer+setOutputRenderTarget"></a>

### renderer.setOutputRenderTarget(renderTarget)
Sets the output render target for the renderer.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| renderTarget | <code>Object</code> | The render target to set as the output target. |

<a name="Renderer+getOutputRenderTarget"></a>

### renderer.getOutputRenderTarget() ⇒ <code>RenderTarget</code>
Returns the current output target.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>RenderTarget</code> - The current output render target. Returns `null` if no output target is set.  
<a name="Renderer+setRenderObjectFunction"></a>

### renderer.setRenderObjectFunction(renderObjectFunction)
Sets the given render object function. Calling this method overwrites the default implementation
which is [renderObject](#Renderer+renderObject). Defining a custom function can be useful
if you want to modify the way objects are rendered. For example you can define things like "every
object that has material of a certain type should perform a pre-pass with a special overwrite material".
The custom function must always call `renderObject()` in its implementation.

Use `null` as the first argument to reset the state.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| renderObjectFunction | [<code>renderObjectFunction</code>](#renderObjectFunction) | The render object function. |

<a name="Renderer+getRenderObjectFunction"></a>

### renderer.getRenderObjectFunction() ⇒ <code>function</code>
Returns the current render object function.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>function</code> - The current render object function. Returns `null` if no function is set.  
<a name="Renderer+compute"></a>

### renderer.compute(computeNodes) ⇒ <code>Promise</code> \| <code>undefined</code>
Execute a single or an array of compute nodes. This method can only be called
if the renderer has been initialized.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> \| <code>undefined</code> - A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.  

| Param | Type | Description |
| --- | --- | --- |
| computeNodes | <code>Node</code> \| <code>Array.&lt;Node&gt;</code> | The compute node(s). |

<a name="Renderer+computeAsync"></a>

### renderer.computeAsync(computeNodes) ⇒ <code>Promise</code>
Execute a single or an array of compute nodes.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolve when the compute has finished.  

| Param | Type | Description |
| --- | --- | --- |
| computeNodes | <code>Node</code> \| <code>Array.&lt;Node&gt;</code> | The compute node(s). |

<a name="Renderer+hasFeatureAsync"></a>

### renderer.hasFeatureAsync(name) ⇒ <code>Promise.&lt;boolean&gt;</code>
Checks if the given feature is supported by the selected backend.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;boolean&gt;</code> - A Promise that resolves with a bool that indicates whether the feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The feature's name. |

<a name="Renderer+hasFeature"></a>

### renderer.hasFeature(name) ⇒ <code>boolean</code>
Checks if the given feature is supported by the selected backend. If the
renderer has not been initialized, this method always returns `false`.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - Whether the feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The feature's name. |

<a name="Renderer+hasInitialized"></a>

### renderer.hasInitialized() ⇒ <code>boolean</code>
Returns `true` when the renderer has been initialized.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>boolean</code> - Whether the renderer has been initialized or not.  
<a name="Renderer+initTextureAsync"></a>

### renderer.initTextureAsync(texture) ⇒ <code>Promise</code>
Initializes the given textures. Useful for preloading a texture rather than waiting until first render
(which can cause noticeable lags due to decode and GPU upload overhead).

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise</code> - A Promise that resolves when the texture has been initialized.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="Renderer+initTexture"></a>

### renderer.initTexture(texture)
Initializes the given texture. Useful for preloading a texture rather than waiting until first render
(which can cause noticeable lags due to decode and GPU upload overhead).

This method can only be used if the renderer has been initialized.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="Renderer+copyFramebufferToTexture"></a>

### renderer.copyFramebufferToTexture(framebufferTexture, [rectangle])
Copies the current bound framebuffer into the given texture.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| framebufferTexture | <code>FramebufferTexture</code> |  | The texture. |
| [rectangle] | <code>Vector2</code> \| <code>Vector4</code> | <code></code> | A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied. |

<a name="Renderer+copyTextureToTexture"></a>

### renderer.copyTextureToTexture(srcTexture, dstTexture, [srcRegion], [dstPosition], [srcLevel], [dstLevel])
Copies data of the given source texture into a destination texture.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| srcTexture | <code>Texture</code> |  | The source texture. |
| dstTexture | <code>Texture</code> |  | The destination texture. |
| [srcRegion] | <code>Box2</code> \| <code>Box3</code> | <code></code> | A bounding box which describes the source region. Can be two or three-dimensional. |
| [dstPosition] | <code>Vector2</code> \| <code>Vector3</code> | <code></code> | A vector that represents the origin of the destination region. Can be two or three-dimensional. |
| [srcLevel] | <code>number</code> | <code>0</code> | The source mip level to copy from. |
| [dstLevel] | <code>number</code> | <code>0</code> | The destination mip level to copy to. |

<a name="Renderer+readRenderTargetPixelsAsync"></a>

### renderer.readRenderTargetPixelsAsync(renderTarget, x, y, width, height, [textureIndex], [faceIndex]) ⇒ <code>Promise.&lt;TypedArray&gt;</code>
Reads pixel data from the given render target.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>Promise.&lt;TypedArray&gt;</code> - A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderTarget | <code>RenderTarget</code> |  | The render target to read from. |
| x | <code>number</code> |  | The `x` coordinate of the copy region's origin. |
| y | <code>number</code> |  | The `y` coordinate of the copy region's origin. |
| width | <code>number</code> |  | The width of the copy region. |
| height | <code>number</code> |  | The height of the copy region. |
| [textureIndex] | <code>number</code> | <code>0</code> | The texture index of a MRT render target. |
| [faceIndex] | <code>number</code> | <code>0</code> | The active cube face index. |

<a name="Renderer+_projectObject"></a>

### renderer.\_projectObject(object, camera, groupOrder, renderList, clippingContext)
Analyzes the given 3D object's hierarchy and builds render lists from the
processed hierarchy.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to process (usually a scene). |
| camera | <code>Camera</code> | The camera the object is rendered with. |
| groupOrder | <code>number</code> | The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups. |
| renderList | <code>RenderList</code> | The current render list. |
| clippingContext | <code>ClippingContext</code> | The current clipping context. |

<a name="Renderer+renderObject"></a>

### renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext, [passId])
This method represents the default render object function that manages the render lifecycle
of the object.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object. |
| scene | <code>Scene</code> |  | The scene the 3D object belongs to. |
| camera | <code>Camera</code> |  | The camera the object should be rendered with. |
| geometry | <code>BufferGeometry</code> |  | The object's geometry. |
| material | <code>Material</code> |  | The object's material. |
| group | <code>Object</code> |  | Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`. |
| lightsNode | <code>LightsNode</code> |  | The current lights node. |
| clippingContext | <code>ClippingContext</code> | <code></code> | The clipping context. |
| [passId] | <code>string</code> | <code>null</code> | An optional ID for identifying the pass. |

<a name="Renderer+compile"></a>

### renderer.compile(scene, camera, targetScene) ⇒ <code>function</code>
Alias for `compileAsync()`.

**Kind**: instance method of [<code>Renderer</code>](#Renderer)  
**Returns**: <code>function</code> - A Promise that resolves when the compile has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or 3D object to precompile. |
| camera | <code>Camera</code> | The camera that is used to render the scene. |
| targetScene | <code>Scene</code> | If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added. |

<a name="Renderer..Options"></a>

### Renderer~Options : <code>Object</code>
Renderer options.

**Kind**: inner typedef of [<code>Renderer</code>](#Renderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [logarithmicDepthBuffer] | <code>boolean</code> | <code>false</code> | Whether logarithmic depth buffer is enabled or not. |
| [alpha] | <code>boolean</code> | <code>true</code> | Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the default framebuffer should have a depth buffer or not. |
| [stencil] | <code>boolean</code> | <code>false</code> | Whether the default framebuffer should have a stencil buffer or not. |
| [antialias] | <code>boolean</code> | <code>false</code> | Whether MSAA as the default anti-aliasing should be enabled or not. |
| [samples] | <code>number</code> | <code>0</code> | When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0 to overwrite the default. |
| [getFallback] | <code>function</code> | <code></code> | This callback function can be used to provide a fallback backend, if the primary backend can't be targeted. |
| [colorBufferType] | <code>number</code> | <code>HalfFloatType</code> | Defines the type of color buffers. The default `HalfFloatType` is recommend for best quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though. |

<a name="ShadowMapConfig"></a>

## ShadowMapConfig : <code>Object</code>
Shadow map configuration

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| enabled | <code>boolean</code> | Whether to globally enable shadows or not. |
| type | <code>number</code> | The shadow map type. |

<a name="XRConfig"></a>

## XRConfig : <code>Object</code>
XR configuration.

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| enabled | <code>boolean</code> | Whether to globally enable XR or not. |

<a name="DebugConfig"></a>

## DebugConfig : <code>Object</code>
Debug configuration.

**Kind**: global typedef  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| checkShaderErrors | <code>boolean</code> | Whether shader errors should be checked or not. |
| onShaderError | <code>function</code> | A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now. |
| getShaderAsync | <code>function</code> | Allows the get the raw shader code for the given scene, camera and 3D object. |

<a name="renderObjectFunction"></a>

## renderObjectFunction : <code>function</code>
Callback for [setRenderObjectFunction](#Renderer+setRenderObjectFunction).

**Kind**: global typedef  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object. |
| scene | <code>Scene</code> |  | The scene the 3D object belongs to. |
| camera | <code>Camera</code> |  | The camera the object should be rendered with. |
| geometry | <code>BufferGeometry</code> |  | The object's geometry. |
| material | <code>Material</code> |  | The object's material. |
| group | <code>Object</code> |  | Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`. |
| lightsNode | <code>LightsNode</code> |  | The current lights node. |
| clippingContext | <code>ClippingContext</code> |  | The clipping context. |
| [passId] | <code>string</code> | <code>null</code> | An optional ID for identifying the pass. |

## Functions

<dl>
<dt><a href="#saveRendererState">saveRendererState(renderer, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given renderer and stores it into the given state object.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#resetRendererState">resetRendererState(renderer, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given renderer and stores it into the given state object.
Besides, the function also resets the state of the renderer to its default values.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#restoreRendererState">restoreRendererState(renderer, state)</a></dt>
<dd><p>Restores the state of the given renderer from the given state object.</p>
</dd>
<dt><a href="#saveSceneState">saveSceneState(scene, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given scene and stores it into the given state object.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#resetSceneState">resetSceneState(scene, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given scene and stores it into the given state object.
Besides, the function also resets the state of the scene to its default values.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#restoreSceneState">restoreSceneState(scene, state)</a></dt>
<dd><p>Restores the state of the given scene from the given state object.</p>
</dd>
<dt><a href="#saveRendererAndSceneState">saveRendererAndSceneState(renderer, scene, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given renderer and scene and stores it into the given state object.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#resetRendererAndSceneState">resetRendererAndSceneState(renderer, scene, [state])</a> ⇒ <code>Object</code></dt>
<dd><p>Saves the state of the given renderer and scene and stores it into the given state object.
Besides, the function also resets the state of the renderer and scene to its default values.</p>
<p>If not state object is provided, the function creates one.</p>
</dd>
<dt><a href="#restoreRendererAndSceneState">restoreRendererAndSceneState(renderer, scene, state)</a></dt>
<dd><p>Restores the state of the given renderer and scene from the given state object.</p>
</dd>
</dl>

<a name="saveRendererState"></a>

## saveRendererState(renderer, [state]) ⇒ <code>Object</code>
Saves the state of the given renderer and stores it into the given state object.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>Renderer</code> |  | The renderer. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="resetRendererState"></a>

## resetRendererState(renderer, [state]) ⇒ <code>Object</code>
Saves the state of the given renderer and stores it into the given state object.
Besides, the function also resets the state of the renderer to its default values.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>Renderer</code> |  | The renderer. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="restoreRendererState"></a>

## restoreRendererState(renderer, state)
Restores the state of the given renderer from the given state object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |
| state | <code>Object</code> | The state to restore. |

<a name="saveSceneState"></a>

## saveSceneState(scene, [state]) ⇒ <code>Object</code>
Saves the state of the given scene and stores it into the given state object.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="resetSceneState"></a>

## resetSceneState(scene, [state]) ⇒ <code>Object</code>
Saves the state of the given scene and stores it into the given state object.
Besides, the function also resets the state of the scene to its default values.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="restoreSceneState"></a>

## restoreSceneState(scene, state)
Restores the state of the given scene from the given state object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene. |
| state | <code>Object</code> | The state to restore. |

<a name="saveRendererAndSceneState"></a>

## saveRendererAndSceneState(renderer, scene, [state]) ⇒ <code>Object</code>
Saves the state of the given renderer and scene and stores it into the given state object.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>Renderer</code> |  | The renderer. |
| scene | <code>Scene</code> |  | The scene. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="resetRendererAndSceneState"></a>

## resetRendererAndSceneState(renderer, scene, [state]) ⇒ <code>Object</code>
Saves the state of the given renderer and scene and stores it into the given state object.
Besides, the function also resets the state of the renderer and scene to its default values.

If not state object is provided, the function creates one.

**Kind**: global function  
**Returns**: <code>Object</code> - The state.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>Renderer</code> |  | The renderer. |
| scene | <code>Scene</code> |  | The scene. |
| [state] | <code>Object</code> | <code>{}</code> | The state. |

<a name="restoreRendererAndSceneState"></a>

## restoreRendererAndSceneState(renderer, scene, state)
Restores the state of the given renderer and scene from the given state object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |
| scene | <code>Scene</code> | The scene. |
| state | <code>Object</code> | The state to restore. |

<a name="StorageBufferAttribute"></a>

## StorageBufferAttribute ⇐ <code>BufferAttribute</code>
This special type of buffer attribute is intended for compute shaders.
In earlier three.js versions it was only possible to update attribute data
on the CPU via JavaScript and then upload the data to the GPU. With the
new material system and renderer it is now possible to use compute shaders
to compute the data for an attribute more efficiently on the GPU.

The idea is to create an instance of this class and provide it as an input
to [StorageBufferNode](StorageBufferNode).

Note: This type of buffer attribute can only be used with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>BufferAttribute</code>  

* [StorageBufferAttribute](#StorageBufferAttribute) ⇐ <code>BufferAttribute</code>
    * [new StorageBufferAttribute(count, itemSize, [typeClass])](#new_StorageBufferAttribute_new)
    * [.isStorageBufferAttribute](#StorageBufferAttribute+isStorageBufferAttribute) : <code>boolean</code>

<a name="new_StorageBufferAttribute_new"></a>

### new StorageBufferAttribute(count, itemSize, [typeClass])
Constructs a new storage buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> \| <code>TypedArray</code> |  | The item count. It is also valid to pass a typed array as an argument. The subsequent parameters are then obsolete. |
| itemSize | <code>number</code> |  | The item size. |
| [typeClass] | <code>TypedArray.constructor</code> | <code>Float32Array</code> | A typed array constructor. |

<a name="StorageBufferAttribute+isStorageBufferAttribute"></a>

### storageBufferAttribute.isStorageBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageBufferAttribute</code>](#StorageBufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageInstancedBufferAttribute"></a>

## StorageInstancedBufferAttribute ⇐ <code>InstancedBufferAttribute</code>
This special type of instanced buffer attribute is intended for compute shaders.
In earlier three.js versions it was only possible to update attribute data
on the CPU via JavaScript and then upload the data to the GPU. With the
new material system and renderer it is now possible to use compute shaders
to compute the data for an attribute more efficiently on the GPU.

The idea is to create an instance of this class and provide it as an input
to [StorageBufferNode](StorageBufferNode).

Note: This type of buffer attribute can only be used with `WebGPURenderer`.

**Kind**: global class  
**Extends**: <code>InstancedBufferAttribute</code>  

* [StorageInstancedBufferAttribute](#StorageInstancedBufferAttribute) ⇐ <code>InstancedBufferAttribute</code>
    * [new StorageInstancedBufferAttribute(count, itemSize, [typeClass])](#new_StorageInstancedBufferAttribute_new)
    * [.isStorageInstancedBufferAttribute](#StorageInstancedBufferAttribute+isStorageInstancedBufferAttribute) : <code>boolean</code>

<a name="new_StorageInstancedBufferAttribute_new"></a>

### new StorageInstancedBufferAttribute(count, itemSize, [typeClass])
Constructs a new storage instanced buffer attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> \| <code>TypedArray</code> |  | The item count. It is also valid to pass a typed array as an argument. The subsequent parameters are then obsolete. |
| itemSize | <code>number</code> |  | The item size. |
| [typeClass] | <code>TypedArray.constructor</code> | <code>Float32Array</code> | A typed array constructor. |

<a name="StorageInstancedBufferAttribute+isStorageInstancedBufferAttribute"></a>

### storageInstancedBufferAttribute.isStorageInstancedBufferAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageInstancedBufferAttribute</code>](#StorageInstancedBufferAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageTexture"></a>

## StorageTexture ⇐ <code>Texture</code>
This special type of texture is intended for compute shaders.
It can be used to compute the data of a texture with a compute shader.

Note: This type of texture can only be used with `WebGPURenderer`
and a WebGPU backend.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [StorageTexture](#StorageTexture) ⇐ <code>Texture</code>
    * [new StorageTexture([width], [height])](#new_StorageTexture_new)
    * [.image](#StorageTexture+image) : <code>Object</code>
    * [.magFilter](#StorageTexture+magFilter) : <code>number</code>
    * [.minFilter](#StorageTexture+minFilter) : <code>number</code>
    * [.isStorageTexture](#StorageTexture+isStorageTexture) : <code>boolean</code>

<a name="new_StorageTexture_new"></a>

### new StorageTexture([width], [height])
Constructs a new storage texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The storage texture's width. |
| [height] | <code>number</code> | <code>1</code> | The storage texture's height. |

<a name="StorageTexture+image"></a>

### storageTexture.image : <code>Object</code>
The image object which just represents the texture's dimension.

**Kind**: instance property of [<code>StorageTexture</code>](#StorageTexture)  
<a name="StorageTexture+magFilter"></a>

### storageTexture.magFilter : <code>number</code>
The default `magFilter` for storage textures is `THREE.LinearFilter`.

**Kind**: instance property of [<code>StorageTexture</code>](#StorageTexture)  
<a name="StorageTexture+minFilter"></a>

### storageTexture.minFilter : <code>number</code>
The default `minFilter` for storage textures is `THREE.LinearFilter`.

**Kind**: instance property of [<code>StorageTexture</code>](#StorageTexture)  
<a name="StorageTexture+isStorageTexture"></a>

### storageTexture.isStorageTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageTexture</code>](#StorageTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TimestampQueryPool"></a>

## *TimestampQueryPool*
Abstract base class of a timestamp query pool.

**Kind**: global abstract class  

* *[TimestampQueryPool](#TimestampQueryPool)*
    * *[new TimestampQueryPool([maxQueries])](#new_TimestampQueryPool_new)*
    * *[.trackTimestamp](#TimestampQueryPool+trackTimestamp) : <code>boolean</code>*
    * *[.maxQueries](#TimestampQueryPool+maxQueries) : <code>number</code>*
    * *[.currentQueryIndex](#TimestampQueryPool+currentQueryIndex) : <code>number</code>*
    * *[.queryOffsets](#TimestampQueryPool+queryOffsets) : <code>Map.&lt;string, number&gt;</code>*
    * *[.isDisposed](#TimestampQueryPool+isDisposed) : <code>boolean</code>*
    * *[.lastValue](#TimestampQueryPool+lastValue) : <code>number</code>*
    * *[.pendingResolve](#TimestampQueryPool+pendingResolve) : <code>boolean</code>*
    * **[.allocateQueriesForContext(renderContext)](#TimestampQueryPool+allocateQueriesForContext)**
    * **[.resolveQueriesAsync()](#TimestampQueryPool+resolveQueriesAsync) ⇒ <code>Promise.&lt;number&gt;</code> \| <code>number</code>**
    * **[.dispose()](#TimestampQueryPool+dispose)**

<a name="new_TimestampQueryPool_new"></a>

### *new TimestampQueryPool([maxQueries])*
Creates a new timestamp query pool.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [maxQueries] | <code>number</code> | <code>256</code> | Maximum number of queries this pool can hold. |

<a name="TimestampQueryPool+trackTimestamp"></a>

### *timestampQueryPool.trackTimestamp : <code>boolean</code>*
Whether to track timestamps or not.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>true</code>  
<a name="TimestampQueryPool+maxQueries"></a>

### *timestampQueryPool.maxQueries : <code>number</code>*
Maximum number of queries this pool can hold.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>256</code>  
<a name="TimestampQueryPool+currentQueryIndex"></a>

### *timestampQueryPool.currentQueryIndex : <code>number</code>*
How many queries allocated so far.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>0</code>  
<a name="TimestampQueryPool+queryOffsets"></a>

### *timestampQueryPool.queryOffsets : <code>Map.&lt;string, number&gt;</code>*
Tracks offsets for different contexts.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
<a name="TimestampQueryPool+isDisposed"></a>

### *timestampQueryPool.isDisposed : <code>boolean</code>*
Whether the pool has been disposed or not.

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>false</code>  
<a name="TimestampQueryPool+lastValue"></a>

### *timestampQueryPool.lastValue : <code>number</code>*
TODO

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>0</code>  
<a name="TimestampQueryPool+pendingResolve"></a>

### *timestampQueryPool.pendingResolve : <code>boolean</code>*
TODO

**Kind**: instance property of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Default**: <code>false</code>  
<a name="TimestampQueryPool+allocateQueriesForContext"></a>

### **timestampQueryPool.allocateQueriesForContext(renderContext)**
Allocate queries for a specific renderContext.

**Kind**: instance abstract method of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to allocate queries for. |

<a name="TimestampQueryPool+resolveQueriesAsync"></a>

### **timestampQueryPool.resolveQueriesAsync() ⇒ <code>Promise.&lt;number&gt;</code> \| <code>number</code>**
Resolve all timestamps and return data (or process them).

**Kind**: instance abstract method of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
**Returns**: <code>Promise.&lt;number&gt;</code> \| <code>number</code> - The resolved timestamp value.  
<a name="TimestampQueryPool+dispose"></a>

### **timestampQueryPool.dispose()**
Dispose of the query pool.

**Kind**: instance abstract method of [<code>TimestampQueryPool</code>](#TimestampQueryPool)  
## Classes

<dl>
<dt><a href="#XRManager">XRManager</a> ⇐ <code>EventDispatcher</code></dt>
<dd><p>The XR manager is built on top of the WebXR Device API to
manage XR sessions with <code>WebGPURenderer</code>.</p>
<p>XR is currently only supported with a WebGL 2 backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#setProjectionFromUnion">setProjectionFromUnion(camera, cameraL, cameraR)</a></dt>
<dd><p>Assumes 2 cameras that are parallel and share an X-axis, and that
the cameras&#39; projection and world matrices have already been set.
And that near and far planes are identical for both cameras.
Visualization of this technique: <a href="https://computergraphics.stackexchange.com/a/4765">https://computergraphics.stackexchange.com/a/4765</a></p>
</dd>
<dt><a href="#updateCamera">updateCamera(camera, parent)</a></dt>
<dd><p>Updates the world matrices for the given camera based on the parent 3D object.</p>
</dd>
<dt><a href="#updateUserCamera">updateUserCamera(camera, cameraXR, parent)</a></dt>
<dd><p>Updates the given camera with the transformation of the XR camera and parent object.</p>
</dd>
</dl>

<a name="XRManager"></a>

## XRManager ⇐ <code>EventDispatcher</code>
The XR manager is built on top of the WebXR Device API to
manage XR sessions with `WebGPURenderer`.

XR is currently only supported with a WebGL 2 backend.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [XRManager](#XRManager) ⇐ <code>EventDispatcher</code>
    * [new XRManager(renderer)](#new_XRManager_new)
    * [.enabled](#XRManager+enabled) : <code>boolean</code>
    * [.isPresenting](#XRManager+isPresenting) : <code>boolean</code>
    * [.cameraAutoUpdate](#XRManager+cameraAutoUpdate) : <code>boolean</code>
    * [._supportsLayers](#XRManager+_supportsLayers) : <code>boolean</code>
    * [.getController(index)](#XRManager+getController) ⇒ <code>Group</code>
    * [.getControllerGrip(index)](#XRManager+getControllerGrip) ⇒ <code>Group</code>
    * [.getHand(index)](#XRManager+getHand) ⇒ <code>Group</code>
    * [.getFoveation()](#XRManager+getFoveation) ⇒ <code>number</code> \| <code>undefined</code>
    * [.setFoveation(foveation)](#XRManager+setFoveation)
    * [.getFramebufferScaleFactor()](#XRManager+getFramebufferScaleFactor) ⇒ <code>number</code>
    * [.setFramebufferScaleFactor(factor)](#XRManager+setFramebufferScaleFactor)
    * [.getReferenceSpaceType()](#XRManager+getReferenceSpaceType) ⇒ <code>XRReferenceSpaceType</code>
    * [.setReferenceSpaceType(type)](#XRManager+setReferenceSpaceType)
    * [.getReferenceSpace()](#XRManager+getReferenceSpace) ⇒ <code>XRReferenceSpace</code>
    * [.setReferenceSpace(space)](#XRManager+setReferenceSpace)
    * [.getCamera()](#XRManager+getCamera) ⇒ <code>ArrayCamera</code>
    * [.getEnvironmentBlendMode()](#XRManager+getEnvironmentBlendMode) ⇒ <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code>
    * [.getFrame()](#XRManager+getFrame) ⇒ <code>XRFrame</code>
    * [.getSession()](#XRManager+getSession) ⇒ <code>XRSession</code>
    * [.setSession(session)](#XRManager+setSession) ⇒ <code>Promise</code>
    * [.updateCamera(camera)](#XRManager+updateCamera)

<a name="new_XRManager_new"></a>

### new XRManager(renderer)
Constructs a new XR manager.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | The renderer. |

<a name="XRManager+enabled"></a>

### xrManager.enabled : <code>boolean</code>
This flag globally enables XR rendering.

**Kind**: instance property of [<code>XRManager</code>](#XRManager)  
**Default**: <code>false</code>  
<a name="XRManager+isPresenting"></a>

### xrManager.isPresenting : <code>boolean</code>
Whether the XR device is currently presenting or not.

**Kind**: instance property of [<code>XRManager</code>](#XRManager)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="XRManager+cameraAutoUpdate"></a>

### xrManager.cameraAutoUpdate : <code>boolean</code>
Whether the XR camera should automatically be updated or not.

**Kind**: instance property of [<code>XRManager</code>](#XRManager)  
**Default**: <code>true</code>  
<a name="XRManager+_supportsLayers"></a>

### xrManager.\_supportsLayers : <code>boolean</code>
Whether the device has support for all layer types.

**Kind**: instance property of [<code>XRManager</code>](#XRManager)  
**Default**: <code>false</code>  
<a name="XRManager+getController"></a>

### xrManager.getController(index) ⇒ <code>Group</code>
Returns an instance of `THREE.Group` that represents the transformation
of a XR controller in target ray space. The requested controller is defined
by the given index.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>Group</code> - A group that represents the controller's transformation.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the XR controller. |

<a name="XRManager+getControllerGrip"></a>

### xrManager.getControllerGrip(index) ⇒ <code>Group</code>
Returns an instance of `THREE.Group` that represents the transformation
of a XR controller in grip space. The requested controller is defined
by the given index.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>Group</code> - A group that represents the controller's transformation.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the XR controller. |

<a name="XRManager+getHand"></a>

### xrManager.getHand(index) ⇒ <code>Group</code>
Returns an instance of `THREE.Group` that represents the transformation
of a XR controller in hand space. The requested controller is defined
by the given index.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>Group</code> - A group that represents the controller's transformation.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the XR controller. |

<a name="XRManager+getFoveation"></a>

### xrManager.getFoveation() ⇒ <code>number</code> \| <code>undefined</code>
Returns the foveation value.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>number</code> \| <code>undefined</code> - The foveation value. Returns `undefined` if no base or projection layer is defined.  
<a name="XRManager+setFoveation"></a>

### xrManager.setFoveation(foveation)
Sets the foveation value.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| foveation | <code>number</code> | A number in the range `[0,1]` where `0` means no foveation (full resolution) and `1` means maximum foveation (the edges render at lower resolution). |

<a name="XRManager+getFramebufferScaleFactor"></a>

### xrManager.getFramebufferScaleFactor() ⇒ <code>number</code>
Returns the framebuffer scale factor.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>number</code> - The framebuffer scale factor.  
<a name="XRManager+setFramebufferScaleFactor"></a>

### xrManager.setFramebufferScaleFactor(factor)
Sets the framebuffer scale factor.

This method can not be used during a XR session.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| factor | <code>number</code> | The framebuffer scale factor. |

<a name="XRManager+getReferenceSpaceType"></a>

### xrManager.getReferenceSpaceType() ⇒ <code>XRReferenceSpaceType</code>
Returns the reference space type.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>XRReferenceSpaceType</code> - The reference space type.  
<a name="XRManager+setReferenceSpaceType"></a>

### xrManager.setReferenceSpaceType(type)
Sets the reference space type.

This method can not be used during a XR session.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>XRReferenceSpaceType</code> | The reference space type. |

<a name="XRManager+getReferenceSpace"></a>

### xrManager.getReferenceSpace() ⇒ <code>XRReferenceSpace</code>
Returns the XR reference space.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>XRReferenceSpace</code> - The XR reference space.  
<a name="XRManager+setReferenceSpace"></a>

### xrManager.setReferenceSpace(space)
Sets a custom XR reference space.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| space | <code>XRReferenceSpace</code> | The XR reference space. |

<a name="XRManager+getCamera"></a>

### xrManager.getCamera() ⇒ <code>ArrayCamera</code>
Returns the XR camera.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>ArrayCamera</code> - The XR camera.  
<a name="XRManager+getEnvironmentBlendMode"></a>

### xrManager.getEnvironmentBlendMode() ⇒ <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code>
Returns the environment blend mode from the current XR session.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code> - The environment blend mode. Returns `undefined` when used outside of a XR session.  
<a name="XRManager+getFrame"></a>

### xrManager.getFrame() ⇒ <code>XRFrame</code>
Returns the current XR frame.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>XRFrame</code> - The XR frame. Returns `null` when used outside a XR session.  
<a name="XRManager+getSession"></a>

### xrManager.getSession() ⇒ <code>XRSession</code>
Returns the current XR session.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>XRSession</code> - The XR session. Returns `null` when used outside a XR session.  
<a name="XRManager+setSession"></a>

### xrManager.setSession(session) ⇒ <code>Promise</code>
After a XR session has been requested usually with one of the `*Button` modules, it
is injected into the renderer with this method. This method triggers the start of
the actual XR rendering.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  
**Returns**: <code>Promise</code> - A Promise that resolves when the session has been set.  

| Param | Type | Description |
| --- | --- | --- |
| session | <code>XRSession</code> | The XR session to set. |

<a name="XRManager+updateCamera"></a>

### xrManager.updateCamera(camera)
This method is called by the renderer per frame and updates the XR camera
and it sub cameras based on the given camera. The given camera is the "user"
camera created on application level and used for non-XR rendering.

**Kind**: instance method of [<code>XRManager</code>](#XRManager)  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>PerspectiveCamera</code> | The camera. |

<a name="setProjectionFromUnion"></a>

## setProjectionFromUnion(camera, cameraL, cameraR)
Assumes 2 cameras that are parallel and share an X-axis, and that
the cameras' projection and world matrices have already been set.
And that near and far planes are identical for both cameras.
Visualization of this technique: https://computergraphics.stackexchange.com/a/4765

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>ArrayCamera</code> | The camera to update. |
| cameraL | <code>PerspectiveCamera</code> | The left camera. |
| cameraR | <code>PerspectiveCamera</code> | The right camera. |

<a name="updateCamera"></a>

## updateCamera(camera, parent)
Updates the world matrices for the given camera based on the parent 3D object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera to update. |
| parent | <code>Object3D</code> | The parent 3D object. |

<a name="updateUserCamera"></a>

## updateUserCamera(camera, cameraXR, parent)
Updates the given camera with the transformation of the XR camera and parent object.

**Kind**: global function  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera to update. |
| cameraXR | <code>ArrayCamera</code> | The XR camera. |
| parent | <code>Object3D</code> | The parent 3D object. |

<a name="GLSLNodeBuilder"></a>

## GLSLNodeBuilder ⇐ <code>NodeBuilder</code>
A node builder targeting GLSL.

This module generates GLSL shader code from node materials and also
generates the respective bindings and vertex buffer definitions. These
data are later used by the renderer to create render and compute pipelines
for render objects.

**Kind**: global class  
**Extends**: <code>NodeBuilder</code>  

* [GLSLNodeBuilder](#GLSLNodeBuilder) ⇐ <code>NodeBuilder</code>
    * [new GLSLNodeBuilder(object, renderer)](#new_GLSLNodeBuilder_new)
    * [.uniformGroups](#GLSLNodeBuilder+uniformGroups) : <code>Object.&lt;string, Object.&lt;string, NodeUniformsGroup&gt;&gt;</code>
    * [.transforms](#GLSLNodeBuilder+transforms) : <code>Array.&lt;Object.&lt;string, (AttributeNode\|string)&gt;&gt;</code>
    * [.extensions](#GLSLNodeBuilder+extensions) : <code>Object.&lt;string, Map.&lt;string, Object&gt;&gt;</code>
    * [.builtins](#GLSLNodeBuilder+builtins) : <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code>
    * [.needsToWorkingColorSpace(texture)](#GLSLNodeBuilder+needsToWorkingColorSpace) ⇒ <code>boolean</code>
    * [.getMethod(method)](#GLSLNodeBuilder+getMethod) ⇒ <code>string</code>
    * [.getOutputStructName()](#GLSLNodeBuilder+getOutputStructName) ⇒ <code>string</code>
    * [.buildFunctionCode(shaderNode)](#GLSLNodeBuilder+buildFunctionCode) ⇒ <code>string</code>
    * [.setupPBO(storageBufferNode)](#GLSLNodeBuilder+setupPBO)
    * [.getPropertyName(node, [shaderStage])](#GLSLNodeBuilder+getPropertyName) ⇒ <code>string</code>
    * [.generatePBO(storageArrayElementNode)](#GLSLNodeBuilder+generatePBO) ⇒ <code>string</code>
    * [.generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, [levelSnippet])](#GLSLNodeBuilder+generateTextureLoad) ⇒ <code>string</code>
    * [.generateTexture(texture, textureProperty, uvSnippet, depthSnippet)](#GLSLNodeBuilder+generateTexture) ⇒ <code>string</code>
    * [.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet)](#GLSLNodeBuilder+generateTextureLevel) ⇒ <code>string</code>
    * [.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet)](#GLSLNodeBuilder+generateTextureBias) ⇒ <code>string</code>
    * [.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet)](#GLSLNodeBuilder+generateTextureGrad) ⇒ <code>string</code>
    * [.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, [shaderStage])](#GLSLNodeBuilder+generateTextureCompare) ⇒ <code>string</code>
    * [.getVars(shaderStage)](#GLSLNodeBuilder+getVars) ⇒ <code>string</code>
    * [.getUniforms(shaderStage)](#GLSLNodeBuilder+getUniforms) ⇒ <code>string</code>
    * [.getTypeFromAttribute(attribute)](#GLSLNodeBuilder+getTypeFromAttribute) ⇒ <code>string</code>
    * [.getAttributes(shaderStage)](#GLSLNodeBuilder+getAttributes) ⇒ <code>string</code>
    * [.getStructMembers(struct)](#GLSLNodeBuilder+getStructMembers) ⇒ <code>string</code>
    * [.getStructs(shaderStage)](#GLSLNodeBuilder+getStructs) ⇒ <code>string</code>
    * [.getVaryings(shaderStage)](#GLSLNodeBuilder+getVaryings) ⇒ <code>string</code>
    * [.getVertexIndex()](#GLSLNodeBuilder+getVertexIndex) ⇒ <code>string</code>
    * [.getInstanceIndex()](#GLSLNodeBuilder+getInstanceIndex) ⇒ <code>string</code>
    * [.getInvocationLocalIndex()](#GLSLNodeBuilder+getInvocationLocalIndex) ⇒ <code>string</code>
    * [.getDrawIndex()](#GLSLNodeBuilder+getDrawIndex) ⇒ <code>string</code>
    * [.getFrontFacing()](#GLSLNodeBuilder+getFrontFacing) ⇒ <code>string</code>
    * [.getFragCoord()](#GLSLNodeBuilder+getFragCoord) ⇒ <code>string</code>
    * [.getFragDepth()](#GLSLNodeBuilder+getFragDepth) ⇒ <code>string</code>
    * [.enableExtension(name, behavior, [shaderStage])](#GLSLNodeBuilder+enableExtension)
    * [.getExtensions(shaderStage)](#GLSLNodeBuilder+getExtensions) ⇒ <code>string</code>
    * [.getClipDistance()](#GLSLNodeBuilder+getClipDistance) ⇒ <code>string</code>
    * [.isAvailable(name)](#GLSLNodeBuilder+isAvailable) ⇒ <code>boolean</code>
    * [.isFlipY()](#GLSLNodeBuilder+isFlipY) ⇒ <code>boolean</code>
    * [.enableHardwareClipping(planeCount)](#GLSLNodeBuilder+enableHardwareClipping)
    * [.registerTransform(varyingName, attributeNode)](#GLSLNodeBuilder+registerTransform)
    * [.getTransforms(shaderStage)](#GLSLNodeBuilder+getTransforms) ⇒ <code>string</code>
    * [.buildCode()](#GLSLNodeBuilder+buildCode)
    * [.getUniformFromNode(node, type, shaderStage, [name])](#GLSLNodeBuilder+getUniformFromNode) ⇒ <code>NodeUniform</code>

<a name="new_GLSLNodeBuilder_new"></a>

### new GLSLNodeBuilder(object, renderer)
Constructs a new GLSL node builder renderer.


| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object. |
| renderer | <code>Renderer</code> | The renderer. |

<a name="GLSLNodeBuilder+uniformGroups"></a>

### glslNodeBuilder.uniformGroups : <code>Object.&lt;string, Object.&lt;string, NodeUniformsGroup&gt;&gt;</code>
A dictionary holds for each shader stage ('vertex', 'fragment', 'compute')
another dictionary which manages UBOs per group ('render','frame','object').

**Kind**: instance property of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+transforms"></a>

### glslNodeBuilder.transforms : <code>Array.&lt;Object.&lt;string, (AttributeNode\|string)&gt;&gt;</code>
An array that holds objects defining the varying and attribute data in
context of Transform Feedback.

**Kind**: instance property of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+extensions"></a>

### glslNodeBuilder.extensions : <code>Object.&lt;string, Map.&lt;string, Object&gt;&gt;</code>
A dictionary that holds for each shader stage a Map of used extensions.

**Kind**: instance property of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+builtins"></a>

### glslNodeBuilder.builtins : <code>Object.&lt;string, Array.&lt;string&gt;&gt;</code>
A dictionary that holds for each shader stage an Array of used builtins.

**Kind**: instance property of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+needsToWorkingColorSpace"></a>

### glslNodeBuilder.needsToWorkingColorSpace(texture) ⇒ <code>boolean</code>
Checks if the given texture requires a manual conversion to the working color space.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture requires a conversion to working color space or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to check. |

<a name="GLSLNodeBuilder+getMethod"></a>

### glslNodeBuilder.getMethod(method) ⇒ <code>string</code>
Returns the native shader method name for a given generic name.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The resolved GLSL method name.  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The method name to resolve. |

<a name="GLSLNodeBuilder+getOutputStructName"></a>

### glslNodeBuilder.getOutputStructName() ⇒ <code>string</code>
Returns the output struct name. Not relevant for GLSL.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+buildFunctionCode"></a>

### glslNodeBuilder.buildFunctionCode(shaderNode) ⇒ <code>string</code>
Builds the given shader node.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL function code.  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | The shader node. |

<a name="GLSLNodeBuilder+setupPBO"></a>

### glslNodeBuilder.setupPBO(storageBufferNode)
Setups the Pixel Buffer Object (PBO) for the given storage
buffer node.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| storageBufferNode | <code>StorageBufferNode</code> | The storage buffer node. |

<a name="GLSLNodeBuilder+getPropertyName"></a>

### glslNodeBuilder.getPropertyName(node, [shaderStage]) ⇒ <code>string</code>
Returns a GLSL snippet that represents the property name of the given node.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="GLSLNodeBuilder+generatePBO"></a>

### glslNodeBuilder.generatePBO(storageArrayElementNode) ⇒ <code>string</code>
Setups the Pixel Buffer Object (PBO) for the given storage
buffer node.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Description |
| --- | --- | --- |
| storageArrayElementNode | <code>StorageArrayElementNode</code> | The storage array element node. |

<a name="GLSLNodeBuilder+generateTextureLoad"></a>

### glslNodeBuilder.generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, [levelSnippet]) ⇒ <code>string</code>
Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvIndexSnippet | <code>string</code> |  | A GLSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> |  | A GLSL snippet that represents the 0-based texture array index to sample. |
| [levelSnippet] | <code>string</code> | <code>&quot;&#x27;0u&#x27;&quot;</code> | A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="GLSLNodeBuilder+generateTexture"></a>

### glslNodeBuilder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet) ⇒ <code>string</code>
Generates the GLSL snippet for sampling/loading the given texture.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> | A GLSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> | A GLSL snippet that represents the 0-based texture array index to sample. |

<a name="GLSLNodeBuilder+generateTextureLevel"></a>

### glslNodeBuilder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) ⇒ <code>string</code>
Generates the GLSL snippet when sampling textures with explicit mip level.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> | A GLSL snippet that represents texture coordinates used for sampling. |
| levelSnippet | <code>string</code> | A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="GLSLNodeBuilder+generateTextureBias"></a>

### glslNodeBuilder.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet) ⇒ <code>string</code>
Generates the GLSL snippet when sampling textures with a bias to the mip level.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> | A GLSL snippet that represents texture coordinates used for sampling. |
| biasSnippet | <code>string</code> | A GLSL snippet that represents the bias to apply to the mip level before sampling. |

<a name="GLSLNodeBuilder+generateTextureGrad"></a>

### glslNodeBuilder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) ⇒ <code>string</code>
Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> | A GLSL snippet that represents texture coordinates used for sampling. |
| gradSnippet | <code>Array.&lt;string&gt;</code> | An array holding both gradient GLSL snippets. |

<a name="GLSLNodeBuilder+generateTextureCompare"></a>

### glslNodeBuilder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values
against a reference value.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A GLSL snippet that represents texture coordinates used for sampling. |
| compareSnippet | <code>string</code> |  | A GLSL snippet that represents the reference value. |
| depthSnippet | <code>string</code> |  | A GLSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="GLSLNodeBuilder+getVars"></a>

### glslNodeBuilder.getVars(shaderStage) ⇒ <code>string</code>
Returns the variables of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the variables.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getUniforms"></a>

### glslNodeBuilder.getUniforms(shaderStage) ⇒ <code>string</code>
Returns the uniforms of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the uniforms.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getTypeFromAttribute"></a>

### glslNodeBuilder.getTypeFromAttribute(attribute) ⇒ <code>string</code>
Returns the type for a given buffer attribute.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The type.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute. |

<a name="GLSLNodeBuilder+getAttributes"></a>

### glslNodeBuilder.getAttributes(shaderStage) ⇒ <code>string</code>
Returns the shader attributes of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the shader attributes.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getStructMembers"></a>

### glslNodeBuilder.getStructMembers(struct) ⇒ <code>string</code>
Returns the members of the given struct type node as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the struct members.  

| Param | Type | Description |
| --- | --- | --- |
| struct | <code>StructTypeNode</code> | The struct type node. |

<a name="GLSLNodeBuilder+getStructs"></a>

### glslNodeBuilder.getStructs(shaderStage) ⇒ <code>string</code>
Returns the structs of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the structs.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getVaryings"></a>

### glslNodeBuilder.getVaryings(shaderStage) ⇒ <code>string</code>
Returns the varyings of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the varyings.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getVertexIndex"></a>

### glslNodeBuilder.getVertexIndex() ⇒ <code>string</code>
Returns the vertex index builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The vertex index.  
<a name="GLSLNodeBuilder+getInstanceIndex"></a>

### glslNodeBuilder.getInstanceIndex() ⇒ <code>string</code>
Returns the instance index builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The instance index.  
<a name="GLSLNodeBuilder+getInvocationLocalIndex"></a>

### glslNodeBuilder.getInvocationLocalIndex() ⇒ <code>string</code>
Returns the invocation local index builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The invocation local index.  
<a name="GLSLNodeBuilder+getDrawIndex"></a>

### glslNodeBuilder.getDrawIndex() ⇒ <code>string</code>
Returns the draw index builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.  
<a name="GLSLNodeBuilder+getFrontFacing"></a>

### glslNodeBuilder.getFrontFacing() ⇒ <code>string</code>
Returns the front facing builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The front facing builtin.  
<a name="GLSLNodeBuilder+getFragCoord"></a>

### glslNodeBuilder.getFragCoord() ⇒ <code>string</code>
Returns the frag coord builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The frag coord builtin.  
<a name="GLSLNodeBuilder+getFragDepth"></a>

### glslNodeBuilder.getFragDepth() ⇒ <code>string</code>
Returns the frag depth builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The frag depth builtin.  
<a name="GLSLNodeBuilder+enableExtension"></a>

### glslNodeBuilder.enableExtension(name, behavior, [shaderStage])
Enables the given extension.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The extension name. |
| behavior | <code>string</code> |  | The extension behavior. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage. |

<a name="GLSLNodeBuilder+getExtensions"></a>

### glslNodeBuilder.getExtensions(shaderStage) ⇒ <code>string</code>
Returns the enabled extensions of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the enabled extensions.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+getClipDistance"></a>

### glslNodeBuilder.getClipDistance() ⇒ <code>string</code>
Returns the clip distances builtin.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The clip distances builtin.  
<a name="GLSLNodeBuilder+isAvailable"></a>

### glslNodeBuilder.isAvailable(name) ⇒ <code>boolean</code>
Whether the requested feature is available or not.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the requested feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The requested feature. |

<a name="GLSLNodeBuilder+isFlipY"></a>

### glslNodeBuilder.isFlipY() ⇒ <code>boolean</code>
Whether to flip texture data along its vertical axis or not.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>boolean</code> - Returns always `true` in context of GLSL.  
<a name="GLSLNodeBuilder+enableHardwareClipping"></a>

### glslNodeBuilder.enableHardwareClipping(planeCount)
Enables hardware clipping.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| planeCount | <code>string</code> | The clipping plane count. |

<a name="GLSLNodeBuilder+registerTransform"></a>

### glslNodeBuilder.registerTransform(varyingName, attributeNode)
Registers a transform in context of Transform Feedback.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| varyingName | <code>string</code> | The varying name. |
| attributeNode | <code>AttributeNode</code> | The attribute node. |

<a name="GLSLNodeBuilder+getTransforms"></a>

### glslNodeBuilder.getTransforms(shaderStage) ⇒ <code>string</code>
Returns the transforms of the given shader stage as a GLSL string.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>string</code> - The GLSL snippet that defines the transforms.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="GLSLNodeBuilder+buildCode"></a>

### glslNodeBuilder.buildCode()
Controls the code build of the shader stages.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
<a name="GLSLNodeBuilder+getUniformFromNode"></a>

### glslNodeBuilder.getUniformFromNode(node, type, shaderStage, [name]) ⇒ <code>NodeUniform</code>
This method is one of the more important ones since it's responsible
for generating a matching binding instance for the given uniform node.

These bindings are later used in the renderer to create bind groups
and layouts.

**Kind**: instance method of [<code>GLSLNodeBuilder</code>](#GLSLNodeBuilder)  
**Returns**: <code>NodeUniform</code> - The node uniform object.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>UniformNode</code> |  | The uniform node. |
| type | <code>string</code> |  | The node data type. |
| shaderStage | <code>string</code> |  | The shader stage. |
| [name] | <code>string</code> | <code>null</code> | An optional uniform name. |

<a name="WebGLTimestampQueryPool"></a>

## WebGLTimestampQueryPool ⇐ <code>TimestampQueryPool</code>
Manages a pool of WebGL timestamp queries for performance measurement.
Handles creation, execution, and resolution of timer queries using WebGL extensions.

**Kind**: global class  
**Extends**: <code>TimestampQueryPool</code>  

* [WebGLTimestampQueryPool](#WebGLTimestampQueryPool) ⇐ <code>TimestampQueryPool</code>
    * [new WebGLTimestampQueryPool(gl, type, [maxQueries])](#new_WebGLTimestampQueryPool_new)
    * [.allocateQueriesForContext(renderContext)](#WebGLTimestampQueryPool+allocateQueriesForContext) ⇒ <code>number</code>
    * [.beginQuery(renderContext)](#WebGLTimestampQueryPool+beginQuery)
    * [.endQuery(renderContext)](#WebGLTimestampQueryPool+endQuery)
    * [.resolveQueriesAsync()](#WebGLTimestampQueryPool+resolveQueriesAsync) ⇒ <code>Promise.&lt;number&gt;</code>
    * [.resolveQuery(query)](#WebGLTimestampQueryPool+resolveQuery) ⇒ <code>Promise.&lt;number&gt;</code>
    * [.dispose()](#WebGLTimestampQueryPool+dispose)

<a name="new_WebGLTimestampQueryPool_new"></a>

### new WebGLTimestampQueryPool(gl, type, [maxQueries])
Creates a new WebGL timestamp query pool.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| gl | <code>WebGLRenderingContext</code> \| <code>WebGL2RenderingContext</code> |  | The WebGL context. |
| type | <code>string</code> |  | The type identifier for this query pool. |
| [maxQueries] | <code>number</code> | <code>2048</code> | Maximum number of queries this pool can hold. |

<a name="WebGLTimestampQueryPool+allocateQueriesForContext"></a>

### webGLTimestampQueryPool.allocateQueriesForContext(renderContext) ⇒ <code>number</code>
Allocates a pair of queries for a given render context.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  
**Returns**: <code>number</code> - The base offset for the allocated queries, or null if allocation failed.  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to allocate queries for. |

<a name="WebGLTimestampQueryPool+beginQuery"></a>

### webGLTimestampQueryPool.beginQuery(renderContext)
Begins a timestamp query for the specified render context.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to begin timing for. |

<a name="WebGLTimestampQueryPool+endQuery"></a>

### webGLTimestampQueryPool.endQuery(renderContext)
Ends the active timestamp query for the specified render context.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to end timing for. |
| renderContext.id | <code>string</code> | Unique identifier for the render context. |

<a name="WebGLTimestampQueryPool+resolveQueriesAsync"></a>

### webGLTimestampQueryPool.resolveQueriesAsync() ⇒ <code>Promise.&lt;number&gt;</code>
Asynchronously resolves all completed queries and returns the total duration.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  
**Returns**: <code>Promise.&lt;number&gt;</code> - The total duration in milliseconds, or the last valid value if resolution fails.  
<a name="WebGLTimestampQueryPool+resolveQuery"></a>

### webGLTimestampQueryPool.resolveQuery(query) ⇒ <code>Promise.&lt;number&gt;</code>
Resolves a single query, checking for completion and disjoint operation.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  
**Returns**: <code>Promise.&lt;number&gt;</code> - The elapsed time in milliseconds.  

| Param | Type | Description |
| --- | --- | --- |
| query | <code>WebGLQuery</code> | The query object to resolve. |

<a name="WebGLTimestampQueryPool+dispose"></a>

### webGLTimestampQueryPool.dispose()
Releases all resources held by this query pool.
This includes deleting all query objects and clearing internal state.

**Kind**: instance method of [<code>WebGLTimestampQueryPool</code>](#WebGLTimestampQueryPool)  
<a name="WebGPURenderer"></a>

## WebGPURenderer ⇐ <code>Renderer</code>
This renderer is the new alternative of `WebGLRenderer`. `WebGPURenderer` has the ability
to target different backends. By default, the renderer tries to use a WebGPU backend if the
browser supports WebGPU. If not, `WebGPURenderer` falls backs to a WebGL 2 backend.

**Kind**: global class  
**Extends**: <code>Renderer</code>  

* [WebGPURenderer](#WebGPURenderer) ⇐ <code>Renderer</code>
    * [new WebGPURenderer([parameters])](#new_WebGPURenderer_new)
    * _instance_
        * [.library](#WebGPURenderer+library) : <code>StandardNodeLibrary</code>
        * [.isWebGPURenderer](#WebGPURenderer+isWebGPURenderer) : <code>boolean</code>
    * _inner_
        * [~Options](#WebGPURenderer..Options) : <code>Object</code>

<a name="new_WebGPURenderer_new"></a>

### new WebGPURenderer([parameters])
Constructs a new WebGPU renderer.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | [<code>Options</code>](#WebGPURenderer..Options) | The configuration parameter. |

<a name="WebGPURenderer+library"></a>

### webGPURenderer.library : <code>StandardNodeLibrary</code>
The generic default value is overwritten with the
standard node library for type mapping.

**Kind**: instance property of [<code>WebGPURenderer</code>](#WebGPURenderer)  
<a name="WebGPURenderer+isWebGPURenderer"></a>

### webGPURenderer.isWebGPURenderer : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WebGPURenderer</code>](#WebGPURenderer)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WebGPURenderer..Options"></a>

### WebGPURenderer~Options : <code>Object</code>
WebGPURenderer options.

**Kind**: inner typedef of [<code>WebGPURenderer</code>](#WebGPURenderer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [logarithmicDepthBuffer] | <code>boolean</code> | <code>false</code> | Whether logarithmic depth buffer is enabled or not. |
| [alpha] | <code>boolean</code> | <code>true</code> | Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque. |
| [depth] | <code>boolean</code> | <code>true</code> | Whether the default framebuffer should have a depth buffer or not. |
| [stencil] | <code>boolean</code> | <code>false</code> | Whether the default framebuffer should have a stencil buffer or not. |
| [antialias] | <code>boolean</code> | <code>false</code> | Whether MSAA as the default anti-aliasing should be enabled or not. |
| [samples] | <code>number</code> | <code>0</code> | When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default. |
| [forceWebGL] | <code>boolean</code> | <code>false</code> | If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not. |
| [outputType] | <code>number</code> |  | Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead. |
| [colorBufferType] | <code>number</code> | <code>HalfFloatType</code> | Defines the type of color buffers. The default `HalfFloatType` is recommend for best quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though. |

<a name="WGSLNodeBuilder"></a>

## WGSLNodeBuilder ⇐ <code>NodeBuilder</code>
A node builder targeting WGSL.

This module generates WGSL shader code from node materials and also
generates the respective bindings and vertex buffer definitions. These
data are later used by the renderer to create render and compute pipelines
for render objects.

**Kind**: global class  
**Extends**: <code>NodeBuilder</code>  

* [WGSLNodeBuilder](#WGSLNodeBuilder) ⇐ <code>NodeBuilder</code>
    * [new WGSLNodeBuilder(object, renderer)](#new_WGSLNodeBuilder_new)
    * [.uniformGroups](#WGSLNodeBuilder+uniformGroups) : <code>Object.&lt;string, Object.&lt;string, NodeUniformsGroup&gt;&gt;</code>
    * [.builtins](#WGSLNodeBuilder+builtins) : <code>Object.&lt;string, Map.&lt;string, Object&gt;&gt;</code>
    * [.directives](#WGSLNodeBuilder+directives) : <code>Object.&lt;string, Set.&lt;string&gt;&gt;</code>
    * [.scopedArrays](#WGSLNodeBuilder+scopedArrays) : <code>Map.&lt;string, Object&gt;</code>
    * [.needsToWorkingColorSpace(texture)](#WGSLNodeBuilder+needsToWorkingColorSpace) ⇒ <code>boolean</code>
    * [.generateWrapFunction(texture)](#WGSLNodeBuilder+generateWrapFunction) ⇒ <code>string</code>
    * [.generateArrayDeclaration(type, [count])](#WGSLNodeBuilder+generateArrayDeclaration) ⇒ <code>string</code>
    * [.generateTextureDimension(texture, textureProperty, levelSnippet)](#WGSLNodeBuilder+generateTextureDimension) ⇒ <code>string</code>
    * [.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet)](#WGSLNodeBuilder+generateFilteredTexture) ⇒ <code>string</code>
    * [.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, [levelSnippet])](#WGSLNodeBuilder+generateTextureLod) ⇒ <code>string</code>
    * [.generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, [levelSnippet])](#WGSLNodeBuilder+generateTextureLoad) ⇒ <code>string</code>
    * [.generateTextureStore(texture, textureProperty, uvIndexSnippet, valueSnippet)](#WGSLNodeBuilder+generateTextureStore) ⇒ <code>string</code>
    * [.isSampleCompare(texture)](#WGSLNodeBuilder+isSampleCompare) ⇒ <code>boolean</code>
    * [.isUnfilterable(texture)](#WGSLNodeBuilder+isUnfilterable) ⇒ <code>boolean</code>
    * [.generateTexture(texture, textureProperty, uvSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTexture) ⇒ <code>string</code>
    * [.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTextureGrad) ⇒ <code>string</code>
    * [.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTextureCompare) ⇒ <code>string</code>
    * [.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTextureLevel) ⇒ <code>string</code>
    * [.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, [shaderStage])](#WGSLNodeBuilder+generateTextureBias) ⇒ <code>string</code>
    * [.getPropertyName(node, [shaderStage])](#WGSLNodeBuilder+getPropertyName) ⇒ <code>string</code>
    * [.getOutputStructName()](#WGSLNodeBuilder+getOutputStructName) ⇒ <code>string</code>
    * [.getFunctionOperator(op)](#WGSLNodeBuilder+getFunctionOperator) ⇒ <code>string</code>
    * [.getNodeAccess(node, shaderStage)](#WGSLNodeBuilder+getNodeAccess) ⇒ <code>string</code>
    * [.getStorageAccess(node, shaderStage)](#WGSLNodeBuilder+getStorageAccess) ⇒ <code>string</code>
    * [.getUniformFromNode(node, type, shaderStage, [name])](#WGSLNodeBuilder+getUniformFromNode) ⇒ <code>NodeUniform</code>
    * [.getBuiltin(name, property, type, [shaderStage])](#WGSLNodeBuilder+getBuiltin) ⇒ <code>string</code>
    * [.hasBuiltin(name, [shaderStage])](#WGSLNodeBuilder+hasBuiltin) ⇒ <code>boolean</code>
    * [.getVertexIndex()](#WGSLNodeBuilder+getVertexIndex) ⇒ <code>string</code>
    * [.buildFunctionCode(shaderNode)](#WGSLNodeBuilder+buildFunctionCode) ⇒ <code>string</code>
    * [.getInstanceIndex()](#WGSLNodeBuilder+getInstanceIndex) ⇒ <code>string</code>
    * [.getInvocationLocalIndex()](#WGSLNodeBuilder+getInvocationLocalIndex) ⇒ <code>string</code>
    * [.getSubgroupSize()](#WGSLNodeBuilder+getSubgroupSize) ⇒ <code>string</code>
    * [.getInvocationSubgroupIndex()](#WGSLNodeBuilder+getInvocationSubgroupIndex) ⇒ <code>string</code>
    * [.getSubgroupIndex()](#WGSLNodeBuilder+getSubgroupIndex) ⇒ <code>string</code>
    * [.getDrawIndex()](#WGSLNodeBuilder+getDrawIndex) ⇒ <code>null</code>
    * [.getFrontFacing()](#WGSLNodeBuilder+getFrontFacing) ⇒ <code>string</code>
    * [.getFragCoord()](#WGSLNodeBuilder+getFragCoord) ⇒ <code>string</code>
    * [.getFragDepth()](#WGSLNodeBuilder+getFragDepth) ⇒ <code>string</code>
    * [.getClipDistance()](#WGSLNodeBuilder+getClipDistance) ⇒ <code>string</code>
    * [.isFlipY()](#WGSLNodeBuilder+isFlipY) ⇒ <code>boolean</code>
    * [.enableDirective(name, [shaderStage])](#WGSLNodeBuilder+enableDirective)
    * [.getDirectives(shaderStage)](#WGSLNodeBuilder+getDirectives) ⇒ <code>string</code>
    * [.enableSubGroups()](#WGSLNodeBuilder+enableSubGroups)
    * [.enableSubgroupsF16()](#WGSLNodeBuilder+enableSubgroupsF16)
    * [.enableClipDistances()](#WGSLNodeBuilder+enableClipDistances)
    * [.enableShaderF16()](#WGSLNodeBuilder+enableShaderF16)
    * [.enableDualSourceBlending()](#WGSLNodeBuilder+enableDualSourceBlending)
    * [.enableHardwareClipping(planeCount)](#WGSLNodeBuilder+enableHardwareClipping)
    * [.getBuiltins(shaderStage)](#WGSLNodeBuilder+getBuiltins) ⇒ <code>string</code>
    * [.getScopedArray(name, scope, bufferType, bufferCount)](#WGSLNodeBuilder+getScopedArray) ⇒ <code>string</code>
    * [.getScopedArrays(shaderStage)](#WGSLNodeBuilder+getScopedArrays) ⇒ <code>string</code> \| <code>undefined</code>
    * [.getAttributes(shaderStage)](#WGSLNodeBuilder+getAttributes) ⇒ <code>string</code>
    * [.getStructMembers(struct)](#WGSLNodeBuilder+getStructMembers) ⇒ <code>string</code>
    * [.getStructs(shaderStage)](#WGSLNodeBuilder+getStructs) ⇒ <code>string</code>
    * [.getVar(type, name, [count])](#WGSLNodeBuilder+getVar) ⇒ <code>string</code>
    * [.getVars(shaderStage)](#WGSLNodeBuilder+getVars) ⇒ <code>string</code>
    * [.getVaryings(shaderStage)](#WGSLNodeBuilder+getVaryings) ⇒ <code>string</code>
    * [.getUniforms(shaderStage)](#WGSLNodeBuilder+getUniforms) ⇒ <code>string</code>
    * [.buildCode()](#WGSLNodeBuilder+buildCode)
    * [.getMethod(method, [output])](#WGSLNodeBuilder+getMethod) ⇒ <code>string</code>
    * [.getType(type)](#WGSLNodeBuilder+getType) ⇒ <code>string</code>
    * [.isAvailable(name)](#WGSLNodeBuilder+isAvailable) ⇒ <code>boolean</code>

<a name="new_WGSLNodeBuilder_new"></a>

### new WGSLNodeBuilder(object, renderer)
Constructs a new WGSL node builder renderer.


| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object. |
| renderer | <code>Renderer</code> | The renderer. |

<a name="WGSLNodeBuilder+uniformGroups"></a>

### wgslNodeBuilder.uniformGroups : <code>Object.&lt;string, Object.&lt;string, NodeUniformsGroup&gt;&gt;</code>
A dictionary that holds for each shader stage ('vertex', 'fragment', 'compute')
another dictionary which manages UBOs per group ('render','frame','object').

**Kind**: instance property of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+builtins"></a>

### wgslNodeBuilder.builtins : <code>Object.&lt;string, Map.&lt;string, Object&gt;&gt;</code>
A dictionary that holds for each shader stage a Map of builtins.

**Kind**: instance property of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+directives"></a>

### wgslNodeBuilder.directives : <code>Object.&lt;string, Set.&lt;string&gt;&gt;</code>
A dictionary that holds for each shader stage a Set of directives.

**Kind**: instance property of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+scopedArrays"></a>

### wgslNodeBuilder.scopedArrays : <code>Map.&lt;string, Object&gt;</code>
A map for managing scope arrays. Only relevant for when using
[WorkgroupInfoNode](WorkgroupInfoNode) in context of compute shaders.

**Kind**: instance property of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+needsToWorkingColorSpace"></a>

### wgslNodeBuilder.needsToWorkingColorSpace(texture) ⇒ <code>boolean</code>
Checks if the given texture requires a manual conversion to the working color space.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture requires a conversion to working color space or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to check. |

<a name="WGSLNodeBuilder+generateWrapFunction"></a>

### wgslNodeBuilder.generateWrapFunction(texture) ⇒ <code>string</code>
Generates a wrap function used in context of textures.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The name of the generated function.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to generate the function for. |

<a name="WGSLNodeBuilder+generateArrayDeclaration"></a>

### wgslNodeBuilder.generateArrayDeclaration(type, [count]) ⇒ <code>string</code>
Generates the array declaration string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |
| [count] | <code>number</code> | The count. |

<a name="WGSLNodeBuilder+generateTextureDimension"></a>

### wgslNodeBuilder.generateTextureDimension(texture, textureProperty, levelSnippet) ⇒ <code>string</code>
Generates a WGSL variable that holds the texture dimension of the given texture.
It also returns information about the number of layers (elements) of an arrayed
texture as well as the cube face count of cube textures.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The name of the dimension variable.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to generate the function for. |
| textureProperty | <code>string</code> | The name of the video texture uniform in the shader. |
| levelSnippet | <code>string</code> | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="WGSLNodeBuilder+generateFilteredTexture"></a>

### wgslNodeBuilder.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet) ⇒ <code>string</code>
Generates the WGSL snippet for a manual filtered texture.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| levelSnippet | <code>string</code> | <code>&quot;0u&quot;</code> | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="WGSLNodeBuilder+generateTextureLod"></a>

### wgslNodeBuilder.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, [levelSnippet]) ⇒ <code>string</code>
Generates the WGSL snippet for a texture lookup with explicit level-of-detail.
Since it's a lookup, no sampling or filtering is applied.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [levelSnippet] | <code>string</code> | <code>&quot;&#x27;0u&#x27;&quot;</code> | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="WGSLNodeBuilder+generateTextureLoad"></a>

### wgslNodeBuilder.generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet, [levelSnippet]) ⇒ <code>string</code>
Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvIndexSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [levelSnippet] | <code>string</code> | <code>&quot;&#x27;0u&#x27;&quot;</code> | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |

<a name="WGSLNodeBuilder+generateTextureStore"></a>

### wgslNodeBuilder.generateTextureStore(texture, textureProperty, uvIndexSnippet, valueSnippet) ⇒ <code>string</code>
Generates the WGSL snippet that writes a single texel to a texture.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The name of the texture uniform in the shader. |
| uvIndexSnippet | <code>string</code> | A WGSL snippet that represents texture coordinates used for sampling. |
| valueSnippet | <code>string</code> | A WGSL snippet that represent the new texel value. |

<a name="WGSLNodeBuilder+isSampleCompare"></a>

### wgslNodeBuilder.isSampleCompare(texture) ⇒ <code>boolean</code>
Returns `true` if the sampled values of the given texture should be compared against a reference value.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the sampled values of the given texture should be compared against a reference value or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="WGSLNodeBuilder+isUnfilterable"></a>

### wgslNodeBuilder.isUnfilterable(texture) ⇒ <code>boolean</code>
Returns `true` if the given texture is unfilterable.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture is unfilterable or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="WGSLNodeBuilder+generateTexture"></a>

### wgslNodeBuilder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet for sampling/loading the given texture.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+generateTextureGrad"></a>

### wgslNodeBuilder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| gradSnippet | <code>Array.&lt;string&gt;</code> |  | An array holding both gradient WGSL snippets. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+generateTextureCompare"></a>

### wgslNodeBuilder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values
against a reference value.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| compareSnippet | <code>string</code> |  | A WGSL snippet that represents the reference value. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+generateTextureLevel"></a>

### wgslNodeBuilder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet when sampling textures with explicit mip level.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| levelSnippet | <code>string</code> |  | A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+generateTextureBias"></a>

### wgslNodeBuilder.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet, [shaderStage]) ⇒ <code>string</code>
Generates the WGSL snippet when sampling textures with a bias to the mip level.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| textureProperty | <code>string</code> |  | The name of the texture uniform in the shader. |
| uvSnippet | <code>string</code> |  | A WGSL snippet that represents texture coordinates used for sampling. |
| biasSnippet | <code>string</code> |  | A WGSL snippet that represents the bias to apply to the mip level before sampling. |
| depthSnippet | <code>string</code> |  | A WGSL snippet that represents 0-based texture array index to sample. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+getPropertyName"></a>

### wgslNodeBuilder.getPropertyName(node, [shaderStage]) ⇒ <code>string</code>
Returns a WGSL snippet that represents the property name of the given node.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+getOutputStructName"></a>

### wgslNodeBuilder.getOutputStructName() ⇒ <code>string</code>
Returns the output struct name.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The name of the output struct.  
<a name="WGSLNodeBuilder+getFunctionOperator"></a>

### wgslNodeBuilder.getFunctionOperator(op) ⇒ <code>string</code>
Returns the native shader operator name for a given generic name.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The resolved operator name.  

| Param | Type | Description |
| --- | --- | --- |
| op | <code>string</code> | The operator name to resolve. |

<a name="WGSLNodeBuilder+getNodeAccess"></a>

### wgslNodeBuilder.getNodeAccess(node, shaderStage) ⇒ <code>string</code>
Returns the node access for the given node and shader stage.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The node access.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>StorageTextureNode</code> \| <code>StorageBufferNode</code> | The storage node. |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getStorageAccess"></a>

### wgslNodeBuilder.getStorageAccess(node, shaderStage) ⇒ <code>string</code>
Returns A WGSL snippet representing the storage access.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet representing the storage access.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>StorageTextureNode</code> \| <code>StorageBufferNode</code> | The storage node. |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getUniformFromNode"></a>

### wgslNodeBuilder.getUniformFromNode(node, type, shaderStage, [name]) ⇒ <code>NodeUniform</code>
This method is one of the more important ones since it's responsible
for generating a matching binding instance for the given uniform node.

These bindings are later used in the renderer to create bind groups
and layouts.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>NodeUniform</code> - The node uniform object.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>UniformNode</code> |  | The uniform node. |
| type | <code>string</code> |  | The node data type. |
| shaderStage | <code>string</code> |  | The shader stage. |
| [name] | <code>string</code> | <code>null</code> | An optional uniform name. |

<a name="WGSLNodeBuilder+getBuiltin"></a>

### wgslNodeBuilder.getBuiltin(name, property, type, [shaderStage]) ⇒ <code>string</code>
This method should be used whenever builtins are required in nodes.
The internal builtins data structure will make sure builtins are
defined in the WGSL source.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The builtin name. |
| property | <code>string</code> |  | The property name. |
| type | <code>string</code> |  | The node data type. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+hasBuiltin"></a>

### wgslNodeBuilder.hasBuiltin(name, [shaderStage]) ⇒ <code>boolean</code>
Returns `true` if the given builtin is defined in the given shader stage.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given builtin is defined in the given shader stage or not.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The builtin name. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage this code snippet is generated for. |

<a name="WGSLNodeBuilder+getVertexIndex"></a>

### wgslNodeBuilder.getVertexIndex() ⇒ <code>string</code>
Returns the vertex index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The vertex index.  
<a name="WGSLNodeBuilder+buildFunctionCode"></a>

### wgslNodeBuilder.buildFunctionCode(shaderNode) ⇒ <code>string</code>
Builds the given shader node.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL function code.  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | The shader node. |

<a name="WGSLNodeBuilder+getInstanceIndex"></a>

### wgslNodeBuilder.getInstanceIndex() ⇒ <code>string</code>
Returns the instance index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The instance index.  
<a name="WGSLNodeBuilder+getInvocationLocalIndex"></a>

### wgslNodeBuilder.getInvocationLocalIndex() ⇒ <code>string</code>
Returns the invocation local index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The invocation local index.  
<a name="WGSLNodeBuilder+getSubgroupSize"></a>

### wgslNodeBuilder.getSubgroupSize() ⇒ <code>string</code>
Returns the subgroup size builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The subgroup size.  
<a name="WGSLNodeBuilder+getInvocationSubgroupIndex"></a>

### wgslNodeBuilder.getInvocationSubgroupIndex() ⇒ <code>string</code>
Returns the invocation subgroup index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The invocation subgroup index.  
<a name="WGSLNodeBuilder+getSubgroupIndex"></a>

### wgslNodeBuilder.getSubgroupIndex() ⇒ <code>string</code>
Returns the subgroup index builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The subgroup index.  
<a name="WGSLNodeBuilder+getDrawIndex"></a>

### wgslNodeBuilder.getDrawIndex() ⇒ <code>null</code>
Overwritten as a NOP since this method is intended for the WebGL 2 backend.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>null</code> - Null.  
<a name="WGSLNodeBuilder+getFrontFacing"></a>

### wgslNodeBuilder.getFrontFacing() ⇒ <code>string</code>
Returns the front facing builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The front facing builtin.  
<a name="WGSLNodeBuilder+getFragCoord"></a>

### wgslNodeBuilder.getFragCoord() ⇒ <code>string</code>
Returns the frag coord builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The frag coord builtin.  
<a name="WGSLNodeBuilder+getFragDepth"></a>

### wgslNodeBuilder.getFragDepth() ⇒ <code>string</code>
Returns the frag depth builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The frag depth builtin.  
<a name="WGSLNodeBuilder+getClipDistance"></a>

### wgslNodeBuilder.getClipDistance() ⇒ <code>string</code>
Returns the clip distances builtin.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The clip distances builtin.  
<a name="WGSLNodeBuilder+isFlipY"></a>

### wgslNodeBuilder.isFlipY() ⇒ <code>boolean</code>
Whether to flip texture data along its vertical axis or not.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Returns always `false` in context of WGSL.  
<a name="WGSLNodeBuilder+enableDirective"></a>

### wgslNodeBuilder.enableDirective(name, [shaderStage])
Enables the given directive for the given shader stage.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The directive name. |
| [shaderStage] | <code>string</code> | <code>&quot;this.shaderStage&quot;</code> | The shader stage to enable the directive for. |

<a name="WGSLNodeBuilder+getDirectives"></a>

### wgslNodeBuilder.getDirectives(shaderStage) ⇒ <code>string</code>
Returns the directives of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - A WGSL snippet that enables the directives of the given stage.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+enableSubGroups"></a>

### wgslNodeBuilder.enableSubGroups()
Enables the 'subgroups' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableSubgroupsF16"></a>

### wgslNodeBuilder.enableSubgroupsF16()
Enables the 'subgroups-f16' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableClipDistances"></a>

### wgslNodeBuilder.enableClipDistances()
Enables the 'clip_distances' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableShaderF16"></a>

### wgslNodeBuilder.enableShaderF16()
Enables the 'f16' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableDualSourceBlending"></a>

### wgslNodeBuilder.enableDualSourceBlending()
Enables the 'dual_source_blending' directive.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+enableHardwareClipping"></a>

### wgslNodeBuilder.enableHardwareClipping(planeCount)
Enables hardware clipping.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| planeCount | <code>string</code> | The clipping plane count. |

<a name="WGSLNodeBuilder+getBuiltins"></a>

### wgslNodeBuilder.getBuiltins(shaderStage) ⇒ <code>string</code>
Returns the builtins of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - A WGSL snippet that represents the builtins of the given stage.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getScopedArray"></a>

### wgslNodeBuilder.getScopedArray(name, scope, bufferType, bufferCount) ⇒ <code>string</code>
This method should be used when a new scoped buffer is used in context of
compute shaders. It adds the array to the internal data structure which is
later used to generate the respective WGSL.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The array name.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The array name. |
| scope | <code>string</code> | The scope. |
| bufferType | <code>string</code> | The buffer type. |
| bufferCount | <code>string</code> | The buffer count. |

<a name="WGSLNodeBuilder+getScopedArrays"></a>

### wgslNodeBuilder.getScopedArrays(shaderStage) ⇒ <code>string</code> \| <code>undefined</code>
Returns the scoped arrays of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> \| <code>undefined</code> - The WGSL snippet that defines the scoped arrays.
Returns `undefined` when used in the vertex or fragment stage.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getAttributes"></a>

### wgslNodeBuilder.getAttributes(shaderStage) ⇒ <code>string</code>
Returns the shader attributes of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the shader attributes.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getStructMembers"></a>

### wgslNodeBuilder.getStructMembers(struct) ⇒ <code>string</code>
Returns the members of the given struct type node as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the struct members.  

| Param | Type | Description |
| --- | --- | --- |
| struct | <code>StructTypeNode</code> | The struct type node. |

<a name="WGSLNodeBuilder+getStructs"></a>

### wgslNodeBuilder.getStructs(shaderStage) ⇒ <code>string</code>
Returns the structs of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the structs.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getVar"></a>

### wgslNodeBuilder.getVar(type, name, [count]) ⇒ <code>string</code>
Returns a WGSL string representing a variable.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines a variable.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The variable's type. |
| name | <code>string</code> |  | The variable's name. |
| [count] | <code>number</code> | <code></code> | The array length. |

<a name="WGSLNodeBuilder+getVars"></a>

### wgslNodeBuilder.getVars(shaderStage) ⇒ <code>string</code>
Returns the variables of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the variables.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getVaryings"></a>

### wgslNodeBuilder.getVaryings(shaderStage) ⇒ <code>string</code>
Returns the varyings of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the varyings.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+getUniforms"></a>

### wgslNodeBuilder.getUniforms(shaderStage) ⇒ <code>string</code>
Returns the uniforms of the given shader stage as a WGSL string.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL snippet that defines the uniforms.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>string</code> | The shader stage. |

<a name="WGSLNodeBuilder+buildCode"></a>

### wgslNodeBuilder.buildCode()
Controls the code build of the shader stages.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
<a name="WGSLNodeBuilder+getMethod"></a>

### wgslNodeBuilder.getMethod(method, [output]) ⇒ <code>string</code>
Returns the native shader method name for a given generic name.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The resolved WGSL method name.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| method | <code>string</code> |  | The method name to resolve. |
| [output] | <code>string</code> | <code>null</code> | An optional output. |

<a name="WGSLNodeBuilder+getType"></a>

### wgslNodeBuilder.getType(type) ⇒ <code>string</code>
Returns the WGSL type of the given node data type.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>string</code> - The WGSL type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The node data type. |

<a name="WGSLNodeBuilder+isAvailable"></a>

### wgslNodeBuilder.isAvailable(name) ⇒ <code>boolean</code>
Whether the requested feature is available or not.

**Kind**: instance method of [<code>WGSLNodeBuilder</code>](#WGSLNodeBuilder)  
**Returns**: <code>boolean</code> - Whether the requested feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The requested feature. |

<a name="WGSLNodeFunction"></a>

## WGSLNodeFunction ⇐ <code>NodeFunction</code>
This class represents a WSL node function.

**Kind**: global class  
**Extends**: <code>NodeFunction</code>  

* [WGSLNodeFunction](#WGSLNodeFunction) ⇐ <code>NodeFunction</code>
    * [new WGSLNodeFunction(source)](#new_WGSLNodeFunction_new)
    * [.getCode([name])](#WGSLNodeFunction+getCode) ⇒ <code>string</code>

<a name="new_WGSLNodeFunction_new"></a>

### new WGSLNodeFunction(source)
Constructs a new WGSL node function.


| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The WGSL source. |

<a name="WGSLNodeFunction+getCode"></a>

### wgslNodeFunction.getCode([name]) ⇒ <code>string</code>
This method returns the WGSL code of the node function.

**Kind**: instance method of [<code>WGSLNodeFunction</code>](#WGSLNodeFunction)  
**Returns**: <code>string</code> - The shader code.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;this.name&quot;</code> | The function's name. |

<a name="WGSLNodeParser"></a>

## WGSLNodeParser ⇐ <code>NodeParser</code>
A WGSL node parser.

**Kind**: global class  
**Extends**: <code>NodeParser</code>  
<a name="WGSLNodeParser+parseFunction"></a>

### wgslNodeParser.parseFunction(source) ⇒ <code>WGSLNodeFunction</code>
The method parses the given WGSL code an returns a node function.

**Kind**: instance method of [<code>WGSLNodeParser</code>](#WGSLNodeParser)  
**Returns**: <code>WGSLNodeFunction</code> - A node function.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The WGSL code. |

<a name="getFormat"></a>

## getFormat(texture, [device]) ⇒ <code>string</code>
Returns the GPU format for the given texture.

**Kind**: global function  
**Returns**: <code>string</code> - The GPU format.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The texture. |
| [device] | <code>GPUDevice</code> | <code></code> | The GPU device which is used for feature detection. It is not necessary to apply the device for most formats. |

<a name="WebGPUTimestampQueryPool"></a>

## WebGPUTimestampQueryPool ⇐ <code>TimestampQueryPool</code>
Manages a pool of WebGPU timestamp queries for performance measurement.
Extends the base TimestampQueryPool to provide WebGPU-specific implementation.

**Kind**: global class  
**Extends**: <code>TimestampQueryPool</code>  

* [WebGPUTimestampQueryPool](#WebGPUTimestampQueryPool) ⇐ <code>TimestampQueryPool</code>
    * [new WebGPUTimestampQueryPool(device, type, [maxQueries])](#new_WebGPUTimestampQueryPool_new)
    * [.allocateQueriesForContext(renderContext)](#WebGPUTimestampQueryPool+allocateQueriesForContext) ⇒ <code>number</code>
    * [.resolveQueriesAsync()](#WebGPUTimestampQueryPool+resolveQueriesAsync) ⇒ <code>Promise.&lt;number&gt;</code>
    * [.dispose()](#WebGPUTimestampQueryPool+dispose) ⇒ <code>Promise</code>

<a name="new_WebGPUTimestampQueryPool_new"></a>

### new WebGPUTimestampQueryPool(device, type, [maxQueries])
Creates a new WebGPU timestamp query pool.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| device | <code>GPUDevice</code> |  | The WebGPU device to create queries on. |
| type | <code>string</code> |  | The type identifier for this query pool. |
| [maxQueries] | <code>number</code> | <code>2048</code> | Maximum number of queries this pool can hold. |

<a name="WebGPUTimestampQueryPool+allocateQueriesForContext"></a>

### webGPUTimestampQueryPool.allocateQueriesForContext(renderContext) ⇒ <code>number</code>
Allocates a pair of queries for a given render context.

**Kind**: instance method of [<code>WebGPUTimestampQueryPool</code>](#WebGPUTimestampQueryPool)  
**Returns**: <code>number</code> - The base offset for the allocated queries, or null if allocation failed.  

| Param | Type | Description |
| --- | --- | --- |
| renderContext | <code>Object</code> | The render context to allocate queries for. |

<a name="WebGPUTimestampQueryPool+resolveQueriesAsync"></a>

### webGPUTimestampQueryPool.resolveQueriesAsync() ⇒ <code>Promise.&lt;number&gt;</code>
Asynchronously resolves all pending queries and returns the total duration.
If there's already a pending resolve operation, returns that promise instead.

**Kind**: instance method of [<code>WebGPUTimestampQueryPool</code>](#WebGPUTimestampQueryPool)  
**Returns**: <code>Promise.&lt;number&gt;</code> - The total duration in milliseconds, or the last valid value if resolution fails.  
<a name="WebGPUTimestampQueryPool+dispose"></a>

### webGPUTimestampQueryPool.dispose() ⇒ <code>Promise</code>
Dispose of the query pool.

**Kind**: instance method of [<code>WebGPUTimestampQueryPool</code>](#WebGPUTimestampQueryPool)  
**Returns**: <code>Promise</code> - A Promise that resolves when the dispose has been executed.  
<a name="WebXRDepthSensing"></a>

## WebXRDepthSensing
A XR module that manages the access to the Depth Sensing API.

**Kind**: global class  

* [WebXRDepthSensing](#WebXRDepthSensing)
    * [new WebXRDepthSensing()](#new_WebXRDepthSensing_new)
    * [.texture](#WebXRDepthSensing+texture) : <code>Texture</code>
    * [.mesh](#WebXRDepthSensing+mesh) : <code>Mesh</code>
    * [.depthNear](#WebXRDepthSensing+depthNear) : <code>number</code>
    * [.depthFar](#WebXRDepthSensing+depthFar) : <code>number</code>
    * [.init(renderer, depthData, renderState)](#WebXRDepthSensing+init)
    * [.getMesh(cameraXR)](#WebXRDepthSensing+getMesh) ⇒ <code>Mesh</code>
    * [.reset()](#WebXRDepthSensing+reset)
    * [.getDepthTexture()](#WebXRDepthSensing+getDepthTexture) ⇒ <code>Texture</code>

<a name="new_WebXRDepthSensing_new"></a>

### new WebXRDepthSensing()
Constructs a new depth sensing module.

<a name="WebXRDepthSensing+texture"></a>

### webXRDepthSensing.texture : <code>Texture</code>
A texture representing the depth of the user's environment.

**Kind**: instance property of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+mesh"></a>

### webXRDepthSensing.mesh : <code>Mesh</code>
A plane mesh for visualizing the depth texture.

**Kind**: instance property of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+depthNear"></a>

### webXRDepthSensing.depthNear : <code>number</code>
The depth near value.

**Kind**: instance property of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+depthFar"></a>

### webXRDepthSensing.depthFar : <code>number</code>
The depth near far.

**Kind**: instance property of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+init"></a>

### webXRDepthSensing.init(renderer, depthData, renderState)
Inits the depth sensing module

**Kind**: instance method of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| depthData | <code>XRWebGLDepthInformation</code> | The XR depth data. |
| renderState | <code>XRRenderState</code> | The XR render state. |

<a name="WebXRDepthSensing+getMesh"></a>

### webXRDepthSensing.getMesh(cameraXR) ⇒ <code>Mesh</code>
Returns a plane mesh that visualizes the depth texture.

**Kind**: instance method of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
**Returns**: <code>Mesh</code> - The plane mesh.  

| Param | Type | Description |
| --- | --- | --- |
| cameraXR | <code>ArrayCamera</code> | The XR camera. |

<a name="WebXRDepthSensing+reset"></a>

### webXRDepthSensing.reset()
Resets the module

**Kind**: instance method of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
<a name="WebXRDepthSensing+getDepthTexture"></a>

### webXRDepthSensing.getDepthTexture() ⇒ <code>Texture</code>
Returns a texture representing the depth of the user's environment.

**Kind**: instance method of [<code>WebXRDepthSensing</code>](#WebXRDepthSensing)  
**Returns**: <code>Texture</code> - The depth texture.  
<a name="WebXRManager"></a>

## WebXRManager ⇐ <code>EventDispatcher</code>
This class represents an abstraction of the WebXR Device API and is
internally used by [WebGLRenderer](WebGLRenderer). `WebXRManager` also provides a public
interface that allows users to enable/disable XR and perform XR related
tasks like for instance retrieving controllers.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [WebXRManager](#WebXRManager) ⇐ <code>EventDispatcher</code>
    * [.cameraAutoUpdate](#WebXRManager+cameraAutoUpdate) : <code>boolean</code>
    * [.enabled](#WebXRManager+enabled) : <code>boolean</code>
    * [.isPresenting](#WebXRManager+isPresenting) : <code>boolean</code>
    * [.getController(index)](#WebXRManager+getController) ⇒ <code>Group</code>
    * [.getControllerGrip(index)](#WebXRManager+getControllerGrip) ⇒ <code>Group</code>
    * [.getHand(index)](#WebXRManager+getHand) ⇒ <code>Group</code>
    * [.setFramebufferScaleFactor(value)](#WebXRManager+setFramebufferScaleFactor)
    * [.setReferenceSpaceType(value)](#WebXRManager+setReferenceSpaceType)
    * [.getReferenceSpace()](#WebXRManager+getReferenceSpace) ⇒ <code>XRReferenceSpace</code>
    * [.setReferenceSpace(space)](#WebXRManager+setReferenceSpace)
    * [.getBaseLayer()](#WebXRManager+getBaseLayer) ⇒ <code>XRWebGLLayer</code> \| <code>XRProjectionLayer</code>
    * [.getBinding()](#WebXRManager+getBinding) ⇒ <code>XRWebGLBinding</code>
    * [.getFrame()](#WebXRManager+getFrame) ⇒ <code>XRFrame</code>
    * [.getSession()](#WebXRManager+getSession) ⇒ <code>XRSession</code>
    * [.setSession(value)](#WebXRManager+setSession) ⇒ <code>Promise</code>
    * [.getEnvironmentBlendMode()](#WebXRManager+getEnvironmentBlendMode) ⇒ <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code>
    * [.getDepthTexture()](#WebXRManager+getDepthTexture) ⇒ <code>Texture</code>
    * [.updateCamera(camera)](#WebXRManager+updateCamera)
    * [.getCamera()](#WebXRManager+getCamera) ⇒ <code>ArrayCamera</code>
    * [.getFoveation()](#WebXRManager+getFoveation) ⇒ <code>number</code>
    * [.setFoveation(value)](#WebXRManager+setFoveation)
    * [.hasDepthSensing()](#WebXRManager+hasDepthSensing) ⇒ <code>boolean</code>
    * [.getDepthSensingMesh()](#WebXRManager+getDepthSensingMesh) ⇒ <code>Mesh</code>

<a name="WebXRManager+cameraAutoUpdate"></a>

### webXRManager.cameraAutoUpdate : <code>boolean</code>
Whether the manager's XR camera should be automatically updated or not.

**Kind**: instance property of [<code>WebXRManager</code>](#WebXRManager)  
**Default**: <code>true</code>  
<a name="WebXRManager+enabled"></a>

### webXRManager.enabled : <code>boolean</code>
This flag notifies the renderer to be ready for XR rendering. Set it to `true`
if you are going to use XR in your app.

**Kind**: instance property of [<code>WebXRManager</code>](#WebXRManager)  
**Default**: <code>false</code>  
<a name="WebXRManager+isPresenting"></a>

### webXRManager.isPresenting : <code>boolean</code>
Whether XR presentation is active or not.

**Kind**: instance property of [<code>WebXRManager</code>](#WebXRManager)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="WebXRManager+getController"></a>

### webXRManager.getController(index) ⇒ <code>Group</code>
Returns a group representing the `target ray` space of the XR controller.
Use this space for visualizing 3D objects that support the user in pointing
tasks like UI interaction.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Group</code> - A group representing the `target ray` space.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the controller. |

<a name="WebXRManager+getControllerGrip"></a>

### webXRManager.getControllerGrip(index) ⇒ <code>Group</code>
Returns a group representing the `grip` space of the XR controller.
Use this space for visualizing 3D objects that support the user in pointing
tasks like UI interaction.

Note: If you want to show something in the user's hand AND offer a
pointing ray at the same time, you'll want to attached the handheld object
to the group returned by `getControllerGrip()` and the ray to the
group returned by `getController()`. The idea is to have two
different groups in two different coordinate spaces for the same WebXR
controller.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Group</code> - A group representing the `grip` space.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the controller. |

<a name="WebXRManager+getHand"></a>

### webXRManager.getHand(index) ⇒ <code>Group</code>
Returns a group representing the `hand` space of the XR controller.
Use this space for visualizing 3D objects that support the user in pointing
tasks like UI interaction.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Group</code> - A group representing the `hand` space.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The index of the controller. |

<a name="WebXRManager+setFramebufferScaleFactor"></a>

### webXRManager.setFramebufferScaleFactor(value)
Sets the framebuffer scale factor.

This method can not be used during a XR session.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The framebuffer scale factor. |

<a name="WebXRManager+setReferenceSpaceType"></a>

### webXRManager.setReferenceSpaceType(value)
Sets the reference space type. Can be used to configure a spatial relationship with the user's physical
environment. Depending on how the user moves in 3D space, setting an appropriate reference space can
improve tracking. Default is `local-floor`.

This method can not be used during a XR session.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>string</code> | The reference space type. |

<a name="WebXRManager+getReferenceSpace"></a>

### webXRManager.getReferenceSpace() ⇒ <code>XRReferenceSpace</code>
Returns the XR reference space.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRReferenceSpace</code> - The XR reference space.  
<a name="WebXRManager+setReferenceSpace"></a>

### webXRManager.setReferenceSpace(space)
Sets a custom XR reference space.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| space | <code>XRReferenceSpace</code> | The XR reference space. |

<a name="WebXRManager+getBaseLayer"></a>

### webXRManager.getBaseLayer() ⇒ <code>XRWebGLLayer</code> \| <code>XRProjectionLayer</code>
Returns the current base layer.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRWebGLLayer</code> \| <code>XRProjectionLayer</code> - The XR base layer.  
<a name="WebXRManager+getBinding"></a>

### webXRManager.getBinding() ⇒ <code>XRWebGLBinding</code>
Returns the current XR binding.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRWebGLBinding</code> - The XR binding.  
<a name="WebXRManager+getFrame"></a>

### webXRManager.getFrame() ⇒ <code>XRFrame</code>
Returns the current XR frame.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRFrame</code> - The XR frame. Returns `null` when used outside a XR session.  
<a name="WebXRManager+getSession"></a>

### webXRManager.getSession() ⇒ <code>XRSession</code>
Returns the current XR session.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>XRSession</code> - The XR session. Returns `null` when used outside a XR session.  
<a name="WebXRManager+setSession"></a>

### webXRManager.setSession(value) ⇒ <code>Promise</code>
After a XR session has been requested usually with one of the `*Button` modules, it
is injected into the renderer with this method. This method triggers the start of
the actual XR rendering.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Promise</code> - A Promise that resolves when the session has been set.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>XRSession</code> | The XR session to set. |

<a name="WebXRManager+getEnvironmentBlendMode"></a>

### webXRManager.getEnvironmentBlendMode() ⇒ <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code>
Returns the environment blend mode from the current XR session.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>&#x27;opaque&#x27;</code> \| <code>&#x27;additive&#x27;</code> \| <code>&#x27;alpha-blend&#x27;</code> \| <code>undefined</code> - The environment blend mode. Returns `undefined` when used outside of a XR session.  
<a name="WebXRManager+getDepthTexture"></a>

### webXRManager.getDepthTexture() ⇒ <code>Texture</code>
Returns the current depth texture computed via depth sensing.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Texture</code> - The depth texture.  
<a name="WebXRManager+updateCamera"></a>

### webXRManager.updateCamera(camera)
Updates the state of the XR camera. Use this method on app level if you
set cameraAutoUpdate` to `false`. The method requires the non-XR
camera of the scene as a parameter. The passed in camera's transformation
is automatically adjusted to the position of the XR camera when calling
this method.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| camera | <code>Camera</code> | The camera. |

<a name="WebXRManager+getCamera"></a>

### webXRManager.getCamera() ⇒ <code>ArrayCamera</code>
Returns an instance of [ArrayCamera](ArrayCamera) which represents the XR camera
of the active XR session. For each view it holds a separate camera object.

The camera's `fov` is currently not used and does not reflect the fov of
the XR camera. If you need the fov on app level, you have to compute in
manually from the XR camera's projection matrices.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>ArrayCamera</code> - The XR camera.  
<a name="WebXRManager+getFoveation"></a>

### webXRManager.getFoveation() ⇒ <code>number</code>
Returns the amount of foveation used by the XR compositor for the projection layer.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>number</code> - The amount of foveation.  
<a name="WebXRManager+setFoveation"></a>

### webXRManager.setFoveation(value)
Sets the foveation value.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | A number in the range `[0,1]` where `0` means no foveation (full resolution) and `1` means maximum foveation (the edges render at lower resolution). |

<a name="WebXRManager+hasDepthSensing"></a>

### webXRManager.hasDepthSensing() ⇒ <code>boolean</code>
Returns `true` if depth sensing is supported.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>boolean</code> - Whether depth sensing is supported or not.  
<a name="WebXRManager+getDepthSensingMesh"></a>

### webXRManager.getDepthSensingMesh() ⇒ <code>Mesh</code>
Returns the depth sensing mesh.

**Kind**: instance method of [<code>WebXRManager</code>](#WebXRManager)  
**Returns**: <code>Mesh</code> - The depth sensing mesh.  
<a name="Fog"></a>

## Fog
This class can be used to define a linear fog that grows linearly denser
with the distance.

```js
const scene = new THREE.Scene();
scene.fog = new THREE.Fog( 0xcccccc, 10, 15 );
```

**Kind**: global class  

* [Fog](#Fog)
    * [new Fog(color, [near], [far])](#new_Fog_new)
    * [.isFog](#Fog+isFog) : <code>boolean</code>
    * [.name](#Fog+name) : <code>string</code>
    * [.color](#Fog+color) : <code>Color</code>
    * [.near](#Fog+near) : <code>number</code>
    * [.far](#Fog+far) : <code>number</code>
    * [.clone()](#Fog+clone) ⇒ [<code>Fog</code>](#Fog)
    * [.toJSON(meta)](#Fog+toJSON) ⇒ <code>Object</code>

<a name="new_Fog_new"></a>

### new Fog(color, [near], [far])
Constructs a new fog.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>number</code> \| <code>Color</code> |  | The fog's color. |
| [near] | <code>number</code> | <code>1</code> | The minimum distance to start applying fog. |
| [far] | <code>number</code> | <code>1000</code> | The maximum distance at which fog stops being calculated and applied. |

<a name="Fog+isFog"></a>

### fog.isFog : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Fog+name"></a>

### fog.name : <code>string</code>
The name of the fog.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
<a name="Fog+color"></a>

### fog.color : <code>Color</code>
The fog's color.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
<a name="Fog+near"></a>

### fog.near : <code>number</code>
The minimum distance to start applying fog. Objects that are less than
`near` units from the active camera won't be affected by fog.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
**Default**: <code>1</code>  
<a name="Fog+far"></a>

### fog.far : <code>number</code>
The maximum distance at which fog stops being calculated and applied.
Objects that are more than `far` units away from the active camera won't
be affected by fog.

**Kind**: instance property of [<code>Fog</code>](#Fog)  
**Default**: <code>1000</code>  
<a name="Fog+clone"></a>

### fog.clone() ⇒ [<code>Fog</code>](#Fog)
Returns a new fog with copied values from this instance.

**Kind**: instance method of [<code>Fog</code>](#Fog)  
**Returns**: [<code>Fog</code>](#Fog) - A clone of this instance.  
<a name="Fog+toJSON"></a>

### fog.toJSON(meta) ⇒ <code>Object</code>
Serializes the fog into JSON.

**Kind**: instance method of [<code>Fog</code>](#Fog)  
**Returns**: <code>Object</code> - A JSON object representing the serialized fog  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="FogExp2"></a>

## FogExp2
This class can be used to define an exponential squared fog,
which gives a clear view near the camera and a faster than exponentially
densening fog farther from the camera.

```js
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
```

**Kind**: global class  

* [FogExp2](#FogExp2)
    * [new FogExp2(color, [density])](#new_FogExp2_new)
    * [.isFogExp2](#FogExp2+isFogExp2) : <code>boolean</code>
    * [.name](#FogExp2+name) : <code>string</code>
    * [.color](#FogExp2+color) : <code>Color</code>
    * [.density](#FogExp2+density) : <code>number</code>
    * [.clone()](#FogExp2+clone) ⇒ [<code>FogExp2</code>](#FogExp2)
    * [.toJSON(meta)](#FogExp2+toJSON) ⇒ <code>Object</code>

<a name="new_FogExp2_new"></a>

### new FogExp2(color, [density])
Constructs a new fog.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>number</code> \| <code>Color</code> |  | The fog's color. |
| [density] | <code>number</code> | <code>0.00025</code> | Defines how fast the fog will grow dense. |

<a name="FogExp2+isFogExp2"></a>

### fogExp2.isFogExp2 : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>FogExp2</code>](#FogExp2)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="FogExp2+name"></a>

### fogExp2.name : <code>string</code>
The name of the fog.

**Kind**: instance property of [<code>FogExp2</code>](#FogExp2)  
<a name="FogExp2+color"></a>

### fogExp2.color : <code>Color</code>
The fog's color.

**Kind**: instance property of [<code>FogExp2</code>](#FogExp2)  
<a name="FogExp2+density"></a>

### fogExp2.density : <code>number</code>
Defines how fast the fog will grow dense.

**Kind**: instance property of [<code>FogExp2</code>](#FogExp2)  
**Default**: <code>0.00025</code>  
<a name="FogExp2+clone"></a>

### fogExp2.clone() ⇒ [<code>FogExp2</code>](#FogExp2)
Returns a new fog with copied values from this instance.

**Kind**: instance method of [<code>FogExp2</code>](#FogExp2)  
**Returns**: [<code>FogExp2</code>](#FogExp2) - A clone of this instance.  
<a name="FogExp2+toJSON"></a>

### fogExp2.toJSON(meta) ⇒ <code>Object</code>
Serializes the fog into JSON.

**Kind**: instance method of [<code>FogExp2</code>](#FogExp2)  
**Returns**: <code>Object</code> - A JSON object representing the serialized fog  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="Scene"></a>

## Scene ⇐ <code>Object3D</code>
Scenes allow you to set up what is to be rendered and where by three.js.
This is where you place 3D objects like meshes, lines or lights.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [Scene](#Scene) ⇐ <code>Object3D</code>
    * [new Scene()](#new_Scene_new)
    * [.isScene](#Scene+isScene) : <code>boolean</code>
    * [.background](#Scene+background) : <code>Color</code> \| <code>Texture</code>
    * [.environment](#Scene+environment) : <code>Texture</code>
    * [.fog](#Scene+fog) : <code>Fog</code> \| <code>FogExp2</code>
    * [.backgroundBlurriness](#Scene+backgroundBlurriness) : <code>number</code>
    * [.backgroundIntensity](#Scene+backgroundIntensity) : <code>number</code>
    * [.backgroundRotation](#Scene+backgroundRotation) : <code>Euler</code>
    * [.environmentIntensity](#Scene+environmentIntensity) : <code>number</code>
    * [.environmentRotation](#Scene+environmentRotation) : <code>Euler</code>
    * [.overrideMaterial](#Scene+overrideMaterial) : <code>Material</code>

<a name="new_Scene_new"></a>

### new Scene()
Constructs a new scene.

<a name="Scene+isScene"></a>

### scene.isScene : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Scene+background"></a>

### scene.background : <code>Color</code> \| <code>Texture</code>
Defines the background of the scene. Valid inputs are:

- A color for defining a uniform colored background.
- A texture for defining a (flat) textured background.
- Cube textures or equirectangular textures for defining a skybox.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>null</code>  
<a name="Scene+environment"></a>

### scene.environment : <code>Texture</code>
Sets the environment map for all physical materials in the scene. However,
it's not possible to overwrite an existing texture assigned to the `envMap`
material property.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>null</code>  
<a name="Scene+fog"></a>

### scene.fog : <code>Fog</code> \| <code>FogExp2</code>
A fog instance defining the type of fog that affects everything
rendered in the scene.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>null</code>  
<a name="Scene+backgroundBlurriness"></a>

### scene.backgroundBlurriness : <code>number</code>
Sets the blurriness of the background. Only influences environment maps
assigned to [background](#Scene+background). Valid input is a float between `0`
and `1`.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>0</code>  
<a name="Scene+backgroundIntensity"></a>

### scene.backgroundIntensity : <code>number</code>
Attenuates the color of the background. Only applies to background textures.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>1</code>  
<a name="Scene+backgroundRotation"></a>

### scene.backgroundRotation : <code>Euler</code>
The rotation of the background in radians. Only influences environment maps
assigned to [background](#Scene+background).

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>(0,0,0)</code>  
<a name="Scene+environmentIntensity"></a>

### scene.environmentIntensity : <code>number</code>
Attenuates the color of the environment. Only influences environment maps
assigned to [environment](#Scene+environment).

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>1</code>  
<a name="Scene+environmentRotation"></a>

### scene.environmentRotation : <code>Euler</code>
The rotation of the environment map in radians. Only influences physical materials
in the scene when [environment](#Scene+environment) is used.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>(0,0,0)</code>  
<a name="Scene+overrideMaterial"></a>

### scene.overrideMaterial : <code>Material</code>
Forces everything in the scene to be rendered with the defined material. It is possible
to exclude materials from override by setting [Material#allowOverride](Material#allowOverride) to `false`.

**Kind**: instance property of [<code>Scene</code>](#Scene)  
**Default**: <code>null</code>  
<a name="CanvasTexture"></a>

## CanvasTexture ⇐ <code>Texture</code>
Creates a texture from a canvas element.

This is almost the same as the base texture class, except that it sets [Texture#needsUpdate](Texture#needsUpdate)
to `true` immediately since a canvas can directly be used for rendering.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [CanvasTexture](#CanvasTexture) ⇐ <code>Texture</code>
    * [new CanvasTexture([canvas], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])](#new_CanvasTexture_new)
    * [.isCanvasTexture](#CanvasTexture+isCanvasTexture) : <code>boolean</code>

<a name="new_CanvasTexture_new"></a>

### new CanvasTexture([canvas], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])
Constructs a new texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [canvas] | <code>HTMLCanvasElement</code> |  | The HTML canvas element. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearMipmapLinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |

<a name="CanvasTexture+isCanvasTexture"></a>

### canvasTexture.isCanvasTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CanvasTexture</code>](#CanvasTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedArrayTexture"></a>

## CompressedArrayTexture ⇐ <code>CompressedTexture</code>
Creates a texture 2D array based on data in compressed form.

These texture are usually loaded with [CompressedTextureLoader](CompressedTextureLoader).

**Kind**: global class  
**Extends**: <code>CompressedTexture</code>  

* [CompressedArrayTexture](#CompressedArrayTexture) ⇐ <code>CompressedTexture</code>
    * [new CompressedArrayTexture(mipmaps, width, height, depth, [format], [type])](#new_CompressedArrayTexture_new)
    * [.isCompressedArrayTexture](#CompressedArrayTexture+isCompressedArrayTexture) : <code>boolean</code>
    * [.image](#CompressedArrayTexture+image) : <code>Object</code>
    * [.wrapR](#CompressedArrayTexture+wrapR) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
    * [.layerUpdates](#CompressedArrayTexture+layerUpdates) : <code>Set.&lt;number&gt;</code>
    * [.addLayerUpdate(layerIndex)](#CompressedArrayTexture+addLayerUpdate)
    * [.clearLayerUpdates()](#CompressedArrayTexture+clearLayerUpdates)

<a name="new_CompressedArrayTexture_new"></a>

### new CompressedArrayTexture(mipmaps, width, height, depth, [format], [type])
Constructs a new compressed array texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mipmaps | <code>Array.&lt;Object&gt;</code> |  | This array holds for all mipmaps (including the bases mip) the data and dimensions. |
| width | <code>number</code> |  | The width of the texture. |
| height | <code>number</code> |  | The height of the texture. |
| depth | <code>number</code> |  | The depth of the texture. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The min filter value. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The min filter value. |

<a name="CompressedArrayTexture+isCompressedArrayTexture"></a>

### compressedArrayTexture.isCompressedArrayTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedArrayTexture+image"></a>

### compressedArrayTexture.image : <code>Object</code>
The image property of a compressed texture just defines its dimensions.

**Kind**: instance property of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
<a name="CompressedArrayTexture+wrapR"></a>

### compressedArrayTexture.wrapR : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped in the depth and corresponds to
*W* in UVW mapping.

**Kind**: instance property of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="CompressedArrayTexture+layerUpdates"></a>

### compressedArrayTexture.layerUpdates : <code>Set.&lt;number&gt;</code>
A set of all layers which need to be updated in the texture.

**Kind**: instance property of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
<a name="CompressedArrayTexture+addLayerUpdate"></a>

### compressedArrayTexture.addLayerUpdate(layerIndex)
Describes that a specific layer of the texture needs to be updated.
Normally when [Texture#needsUpdate](Texture#needsUpdate) is set to `true`, the
entire compressed texture array is sent to the GPU. Marking specific
layers will only transmit subsets of all mipmaps associated with a
specific depth in the array which is often much more performant.

**Kind**: instance method of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  

| Param | Type | Description |
| --- | --- | --- |
| layerIndex | <code>number</code> | The layer index that should be updated. |

<a name="CompressedArrayTexture+clearLayerUpdates"></a>

### compressedArrayTexture.clearLayerUpdates()
Resets the layer updates registry.

**Kind**: instance method of [<code>CompressedArrayTexture</code>](#CompressedArrayTexture)  
<a name="CompressedCubeTexture"></a>

## CompressedCubeTexture ⇐ <code>CompressedTexture</code>
Creates a cube texture based on data in compressed form.

These texture are usually loaded with [CompressedTextureLoader](CompressedTextureLoader).

**Kind**: global class  
**Extends**: <code>CompressedTexture</code>  

* [CompressedCubeTexture](#CompressedCubeTexture) ⇐ <code>CompressedTexture</code>
    * [new CompressedCubeTexture(images, [format], [type])](#new_CompressedCubeTexture_new)
    * [.isCompressedCubeTexture](#CompressedCubeTexture+isCompressedCubeTexture) : <code>boolean</code>
    * [.isCubeTexture](#CompressedCubeTexture+isCubeTexture) : <code>boolean</code>

<a name="new_CompressedCubeTexture_new"></a>

### new CompressedCubeTexture(images, [format], [type])
Constructs a new compressed texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| images | <code>Array.&lt;CompressedTexture&gt;</code> |  | An array of compressed textures. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |

<a name="CompressedCubeTexture+isCompressedCubeTexture"></a>

### compressedCubeTexture.isCompressedCubeTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CompressedCubeTexture</code>](#CompressedCubeTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedCubeTexture+isCubeTexture"></a>

### compressedCubeTexture.isCubeTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CompressedCubeTexture</code>](#CompressedCubeTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedTexture"></a>

## CompressedTexture ⇐ <code>Texture</code>
Creates a texture based on data in compressed form.

These texture are usually loaded with [CompressedTextureLoader](CompressedTextureLoader).

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [CompressedTexture](#CompressedTexture) ⇐ <code>Texture</code>
    * [new CompressedTexture(mipmaps, width, height, [format], [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [colorSpace])](#new_CompressedTexture_new)
    * [.isCompressedTexture](#CompressedTexture+isCompressedTexture) : <code>boolean</code>
    * [.image](#CompressedTexture+image) : <code>Object</code>
    * [.mipmaps](#CompressedTexture+mipmaps) : <code>Array.&lt;Object&gt;</code>
    * [.flipY](#CompressedTexture+flipY) : <code>boolean</code>
    * [.generateMipmaps](#CompressedTexture+generateMipmaps) : <code>boolean</code>

<a name="new_CompressedTexture_new"></a>

### new CompressedTexture(mipmaps, width, height, [format], [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [colorSpace])
Constructs a new compressed texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mipmaps | <code>Array.&lt;Object&gt;</code> |  | This array holds for all mipmaps (including the bases mip) the data and dimensions. |
| width | <code>number</code> |  | The width of the texture. |
| height | <code>number</code> |  | The height of the texture. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearMipmapLinearFilter</code> | The min filter value. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [colorSpace] | <code>string</code> | <code>&quot;NoColorSpace&quot;</code> | The color space. |

<a name="CompressedTexture+isCompressedTexture"></a>

### compressedTexture.isCompressedTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CompressedTexture+image"></a>

### compressedTexture.image : <code>Object</code>
The image property of a compressed texture just defines its dimensions.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
<a name="CompressedTexture+mipmaps"></a>

### compressedTexture.mipmaps : <code>Array.&lt;Object&gt;</code>
This array holds for all mipmaps (including the bases mip) the data and dimensions.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
<a name="CompressedTexture+flipY"></a>

### compressedTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default since it is not possible to
flip compressed textures.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="CompressedTexture+generateMipmaps"></a>

### compressedTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default since it is not
possible to generate mipmaps for compressed data. Mipmaps
must be embedded in the compressed texture file.

**Kind**: instance property of [<code>CompressedTexture</code>](#CompressedTexture)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="CubeTexture"></a>

## CubeTexture ⇐ <code>Texture</code>
Creates a cube texture made up of six images.

```js
const loader = new THREE.CubeTextureLoader();
loader.setPath( 'textures/cube/pisa/' );

const textureCube = loader.load( [
	'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'
] );

const material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
```

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [CubeTexture](#CubeTexture) ⇐ <code>Texture</code>
    * [new CubeTexture([images], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy], [colorSpace])](#new_CubeTexture_new)
    * [.isCubeTexture](#CubeTexture+isCubeTexture) : <code>boolean</code>
    * [.flipY](#CubeTexture+flipY) : <code>boolean</code>
    * [.images](#CubeTexture+images) : <code>Array.&lt;Image&gt;</code>

<a name="new_CubeTexture_new"></a>

### new CubeTexture([images], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy], [colorSpace])
Constructs a new cube texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [images] | <code>Array.&lt;Image&gt;</code> | <code>[]</code> | An array holding a image for each side of a cube. |
| [mapping] | <code>number</code> | <code>CubeReflectionMapping</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearMipmapLinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [colorSpace] | <code>string</code> | <code>&quot;NoColorSpace&quot;</code> | The color space value. |

<a name="CubeTexture+isCubeTexture"></a>

### cubeTexture.isCubeTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubeTexture</code>](#CubeTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubeTexture+flipY"></a>

### cubeTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>CubeTexture</code>](#CubeTexture)  
**Default**: <code>false</code>  
<a name="CubeTexture+images"></a>

### cubeTexture.images : <code>Array.&lt;Image&gt;</code>
Alias for [CubeTexture#image](CubeTexture#image).

**Kind**: instance property of [<code>CubeTexture</code>](#CubeTexture)  
<a name="Data3DTexture"></a>

## Data3DTexture ⇐ <code>Texture</code>
Creates a three-dimensional texture from raw data, with parameters to
divide it into width, height, and depth.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [Data3DTexture](#Data3DTexture) ⇐ <code>Texture</code>
    * [new Data3DTexture([data], [width], [height], [depth])](#new_Data3DTexture_new)
    * [.isData3DTexture](#Data3DTexture+isData3DTexture) : <code>boolean</code>
    * [.image](#Data3DTexture+image) : <code>Object</code>
    * [.magFilter](#Data3DTexture+magFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.minFilter](#Data3DTexture+minFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.wrapR](#Data3DTexture+wrapR) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
    * [.generateMipmaps](#Data3DTexture+generateMipmaps) : <code>boolean</code>
    * [.flipY](#Data3DTexture+flipY) : <code>boolean</code>
    * [.unpackAlignment](#Data3DTexture+unpackAlignment) : <code>boolean</code>

<a name="new_Data3DTexture_new"></a>

### new Data3DTexture([data], [width], [height], [depth])
Constructs a new data array texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [data] | <code>TypedArray</code> | <code></code> | The buffer data. |
| [width] | <code>number</code> | <code>1</code> | The width of the texture. |
| [height] | <code>number</code> | <code>1</code> | The height of the texture. |
| [depth] | <code>number</code> | <code>1</code> | The depth of the texture. |

<a name="Data3DTexture+isData3DTexture"></a>

### data3DTexture.isData3DTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Data3DTexture+image"></a>

### data3DTexture.image : <code>Object</code>
The image definition of a data texture.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
<a name="Data3DTexture+magFilter"></a>

### data3DTexture.magFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers more than one pixel.

Overwritten and set to `NearestFilter` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>NearestFilter</code>  
<a name="Data3DTexture+minFilter"></a>

### data3DTexture.minFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers less than one pixel.

Overwritten and set to `NearestFilter` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>NearestFilter</code>  
<a name="Data3DTexture+wrapR"></a>

### data3DTexture.wrapR : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped in the depth and corresponds to
*W* in UVW mapping.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="Data3DTexture+generateMipmaps"></a>

### data3DTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>false</code>  
<a name="Data3DTexture+flipY"></a>

### data3DTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>false</code>  
<a name="Data3DTexture+unpackAlignment"></a>

### data3DTexture.unpackAlignment : <code>boolean</code>
Specifies the alignment requirements for the start of each pixel row in memory.

Overwritten and set to `1` by default.

**Kind**: instance property of [<code>Data3DTexture</code>](#Data3DTexture)  
**Default**: <code>1</code>  
<a name="DataArrayTexture"></a>

## DataArrayTexture ⇐ <code>Texture</code>
Creates an array of textures directly from raw buffer data.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [DataArrayTexture](#DataArrayTexture) ⇐ <code>Texture</code>
    * [new DataArrayTexture([data], [width], [height], [depth])](#new_DataArrayTexture_new)
    * [.isDataArrayTexture](#DataArrayTexture+isDataArrayTexture) : <code>boolean</code>
    * [.image](#DataArrayTexture+image) : <code>Object</code>
    * [.magFilter](#DataArrayTexture+magFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.minFilter](#DataArrayTexture+minFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.wrapR](#DataArrayTexture+wrapR) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
    * [.generateMipmaps](#DataArrayTexture+generateMipmaps) : <code>boolean</code>
    * [.flipY](#DataArrayTexture+flipY) : <code>boolean</code>
    * [.unpackAlignment](#DataArrayTexture+unpackAlignment) : <code>boolean</code>
    * [.layerUpdates](#DataArrayTexture+layerUpdates) : <code>Set.&lt;number&gt;</code>
    * [.addLayerUpdate(layerIndex)](#DataArrayTexture+addLayerUpdate)
    * [.clearLayerUpdates()](#DataArrayTexture+clearLayerUpdates)

<a name="new_DataArrayTexture_new"></a>

### new DataArrayTexture([data], [width], [height], [depth])
Constructs a new data array texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [data] | <code>TypedArray</code> | <code></code> | The buffer data. |
| [width] | <code>number</code> | <code>1</code> | The width of the texture. |
| [height] | <code>number</code> | <code>1</code> | The height of the texture. |
| [depth] | <code>number</code> | <code>1</code> | The depth of the texture. |

<a name="DataArrayTexture+isDataArrayTexture"></a>

### dataArrayTexture.isDataArrayTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DataArrayTexture+image"></a>

### dataArrayTexture.image : <code>Object</code>
The image definition of a data texture.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
<a name="DataArrayTexture+magFilter"></a>

### dataArrayTexture.magFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers more than one pixel.

Overwritten and set to `NearestFilter` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>NearestFilter</code>  
<a name="DataArrayTexture+minFilter"></a>

### dataArrayTexture.minFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers less than one pixel.

Overwritten and set to `NearestFilter` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>NearestFilter</code>  
<a name="DataArrayTexture+wrapR"></a>

### dataArrayTexture.wrapR : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped in the depth and corresponds to
*W* in UVW mapping.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="DataArrayTexture+generateMipmaps"></a>

### dataArrayTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>false</code>  
<a name="DataArrayTexture+flipY"></a>

### dataArrayTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>false</code>  
<a name="DataArrayTexture+unpackAlignment"></a>

### dataArrayTexture.unpackAlignment : <code>boolean</code>
Specifies the alignment requirements for the start of each pixel row in memory.

Overwritten and set to `1` by default.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
**Default**: <code>1</code>  
<a name="DataArrayTexture+layerUpdates"></a>

### dataArrayTexture.layerUpdates : <code>Set.&lt;number&gt;</code>
A set of all layers which need to be updated in the texture.

**Kind**: instance property of [<code>DataArrayTexture</code>](#DataArrayTexture)  
<a name="DataArrayTexture+addLayerUpdate"></a>

### dataArrayTexture.addLayerUpdate(layerIndex)
Describes that a specific layer of the texture needs to be updated.
Normally when [Texture#needsUpdate](Texture#needsUpdate) is set to `true`, the
entire data texture array is sent to the GPU. Marking specific
layers will only transmit subsets of all mipmaps associated with a
specific depth in the array which is often much more performant.

**Kind**: instance method of [<code>DataArrayTexture</code>](#DataArrayTexture)  

| Param | Type | Description |
| --- | --- | --- |
| layerIndex | <code>number</code> | The layer index that should be updated. |

<a name="DataArrayTexture+clearLayerUpdates"></a>

### dataArrayTexture.clearLayerUpdates()
Resets the layer updates registry.

**Kind**: instance method of [<code>DataArrayTexture</code>](#DataArrayTexture)  
<a name="DataTexture"></a>

## DataTexture ⇐ <code>Texture</code>
Creates a texture directly from raw buffer data.

The interpretation of the data depends on type and format: If the type is
`UnsignedByteType`, a `Uint8Array` will be useful for addressing the
texel data. If the format is `RGBAFormat`, data needs four values for
one texel; Red, Green, Blue and Alpha (typically the opacity).

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [DataTexture](#DataTexture) ⇐ <code>Texture</code>
    * [new DataTexture([data], [width], [height], [format], [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [colorSpace])](#new_DataTexture_new)
    * [.isDataTexture](#DataTexture+isDataTexture) : <code>boolean</code>
    * [.image](#DataTexture+image) : <code>Object</code>
    * [.generateMipmaps](#DataTexture+generateMipmaps) : <code>boolean</code>
    * [.flipY](#DataTexture+flipY) : <code>boolean</code>
    * [.unpackAlignment](#DataTexture+unpackAlignment) : <code>boolean</code>

<a name="new_DataTexture_new"></a>

### new DataTexture([data], [width], [height], [format], [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [colorSpace])
Constructs a new data texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [data] | <code>TypedArray</code> | <code></code> | The buffer data. |
| [width] | <code>number</code> | <code>1</code> | The width of the texture. |
| [height] | <code>number</code> | <code>1</code> | The height of the texture. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>NearestFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>NearestFilter</code> | The min filter value. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [colorSpace] | <code>string</code> | <code>&quot;NoColorSpace&quot;</code> | The color space. |

<a name="DataTexture+isDataTexture"></a>

### dataTexture.isDataTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DataTexture+image"></a>

### dataTexture.image : <code>Object</code>
The image definition of a data texture.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
<a name="DataTexture+generateMipmaps"></a>

### dataTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
**Default**: <code>false</code>  
<a name="DataTexture+flipY"></a>

### dataTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
**Default**: <code>false</code>  
<a name="DataTexture+unpackAlignment"></a>

### dataTexture.unpackAlignment : <code>boolean</code>
Specifies the alignment requirements for the start of each pixel row in memory.

Overwritten and set to `1` by default.

**Kind**: instance property of [<code>DataTexture</code>](#DataTexture)  
**Default**: <code>1</code>  
<a name="DepthTexture"></a>

## DepthTexture ⇐ <code>Texture</code>
This class can be used to automatically save the depth information of a
rendering into a texture.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [DepthTexture](#DepthTexture) ⇐ <code>Texture</code>
    * [new DepthTexture(width, height, [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [format])](#new_DepthTexture_new)
    * [.isDepthTexture](#DepthTexture+isDepthTexture) : <code>boolean</code>
    * [.image](#DepthTexture+image) : <code>Object</code>
    * [.flipY](#DepthTexture+flipY) : <code>boolean</code>
    * [.generateMipmaps](#DepthTexture+generateMipmaps) : <code>boolean</code>
    * [.compareFunction](#DepthTexture+compareFunction) : <code>NeverCompare</code> \| <code>LessCompare</code> \| <code>EqualCompare</code> \| <code>LessEqualCompare</code> \| <code>GreaterCompare</code> \| <code>NotEqualCompare</code> \| <code>GreaterEqualCompare</code> \| <code>AlwaysCompare</code>

<a name="new_DepthTexture_new"></a>

### new DepthTexture(width, height, [type], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [anisotropy], [format])
Constructs a new depth texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| width | <code>number</code> |  | The width of the texture. |
| height | <code>number</code> |  | The height of the texture. |
| [type] | <code>number</code> | <code>UnsignedIntType</code> | The texture type. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearFilter</code> | The min filter value. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [format] | <code>number</code> | <code>DepthFormat</code> | The texture format. |

<a name="DepthTexture+isDepthTexture"></a>

### depthTexture.isDepthTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="DepthTexture+image"></a>

### depthTexture.image : <code>Object</code>
The image property of a depth texture just defines its dimensions.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
<a name="DepthTexture+flipY"></a>

### depthTexture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
**Default**: <code>false</code>  
<a name="DepthTexture+generateMipmaps"></a>

### depthTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
**Default**: <code>false</code>  
<a name="DepthTexture+compareFunction"></a>

### depthTexture.compareFunction : <code>NeverCompare</code> \| <code>LessCompare</code> \| <code>EqualCompare</code> \| <code>LessEqualCompare</code> \| <code>GreaterCompare</code> \| <code>NotEqualCompare</code> \| <code>GreaterEqualCompare</code> \| <code>AlwaysCompare</code>
The depth compare function.

**Kind**: instance property of [<code>DepthTexture</code>](#DepthTexture)  
**Default**: <code>null</code>  
<a name="FramebufferTexture"></a>

## FramebufferTexture ⇐ <code>Texture</code>
This class can only be used in combination with `copyFramebufferToTexture()` methods
of renderers. It extracts the contents of the current bound framebuffer and provides it
as a texture for further usage.

```js
const pixelRatio = window.devicePixelRatio;
const textureSize = 128 * pixelRatio;

const frameTexture = new FramebufferTexture( textureSize, textureSize );

// calculate start position for copying part of the frame data
const vector = new Vector2();
vector.x = ( window.innerWidth * pixelRatio / 2 ) - ( textureSize / 2 );
vector.y = ( window.innerHeight * pixelRatio / 2 ) - ( textureSize / 2 );

renderer.render( scene, camera );

// copy part of the rendered frame into the framebuffer texture
renderer.copyFramebufferToTexture( frameTexture, vector );
```

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [FramebufferTexture](#FramebufferTexture) ⇐ <code>Texture</code>
    * [new FramebufferTexture(width, height)](#new_FramebufferTexture_new)
    * [.isFramebufferTexture](#FramebufferTexture+isFramebufferTexture) : <code>boolean</code>
    * [.magFilter](#FramebufferTexture+magFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.minFilter](#FramebufferTexture+minFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
    * [.generateMipmaps](#FramebufferTexture+generateMipmaps) : <code>boolean</code>

<a name="new_FramebufferTexture_new"></a>

### new FramebufferTexture(width, height)
Constructs a new framebuffer texture.


| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the texture. |
| height | <code>number</code> | The height of the texture. |

<a name="FramebufferTexture+isFramebufferTexture"></a>

### framebufferTexture.isFramebufferTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>FramebufferTexture</code>](#FramebufferTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="FramebufferTexture+magFilter"></a>

### framebufferTexture.magFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers more than one pixel.

Overwritten and set to `NearestFilter` by default to disable filtering.

**Kind**: instance property of [<code>FramebufferTexture</code>](#FramebufferTexture)  
**Default**: <code>NearestFilter</code>  
<a name="FramebufferTexture+minFilter"></a>

### framebufferTexture.minFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers less than one pixel.

Overwritten and set to `NearestFilter` by default to disable filtering.

**Kind**: instance property of [<code>FramebufferTexture</code>](#FramebufferTexture)  
**Default**: <code>NearestFilter</code>  
<a name="FramebufferTexture+generateMipmaps"></a>

### framebufferTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>FramebufferTexture</code>](#FramebufferTexture)  
**Default**: <code>false</code>  
<a name="Source"></a>

## Source
Represents the data source of a texture.

The main purpose of this class is to decouple the data definition from the texture
definition so the same data can be used with multiple texture instances.

**Kind**: global class  

* [Source](#Source)
    * [new Source([data])](#new_Source_new)
    * [.isSource](#Source+isSource) : <code>boolean</code>
    * [.id](#Source+id) : <code>number</code>
    * [.uuid](#Source+uuid) : <code>string</code>
    * [.data](#Source+data) : <code>any</code>
    * [.dataReady](#Source+dataReady) : <code>boolean</code>
    * [.version](#Source+version) : <code>number</code>
    * [.needsUpdate](#Source+needsUpdate) : <code>boolean</code>
    * [.toJSON(meta)](#Source+toJSON) ⇒ <code>Object</code>

<a name="new_Source_new"></a>

### new Source([data])
Constructs a new video texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [data] | <code>any</code> | <code></code> | The data definition of a texture. |

<a name="Source+isSource"></a>

### source.isSource : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Source+id"></a>

### source.id : <code>number</code>
The ID of the source.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Read only**: true  
<a name="Source+uuid"></a>

### source.uuid : <code>string</code>
The UUID of the source.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Read only**: true  
<a name="Source+data"></a>

### source.data : <code>any</code>
The data definition of a texture.

**Kind**: instance property of [<code>Source</code>](#Source)  
<a name="Source+dataReady"></a>

### source.dataReady : <code>boolean</code>
This property is only relevant when [needsUpdate](#Source+needsUpdate) is set to `true` and
provides more control on how texture data should be processed. When `dataReady` is set
to `false`, the engine performs the memory allocation (if necessary) but does not transfer
the data into the GPU memory.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Default**: <code>true</code>  
<a name="Source+version"></a>

### source.version : <code>number</code>
This starts at `0` and counts how many times [needsUpdate](#Source+needsUpdate) is set to `true`.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Source+needsUpdate"></a>

### source.needsUpdate : <code>boolean</code>
When the property is set to `true`, the engine allocates the memory
for the texture (if necessary) and triggers the actual texture upload
to the GPU next time the source is used.

**Kind**: instance property of [<code>Source</code>](#Source)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Source+toJSON"></a>

### source.toJSON(meta) ⇒ <code>Object</code>
Serializes the source into JSON.

**Kind**: instance method of [<code>Source</code>](#Source)  
**Returns**: <code>Object</code> - A JSON object representing the serialized source.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="Texture"></a>

## Texture ⇐ <code>EventDispatcher</code>
Base class for all textures.

Note: After the initial use of a texture, its dimensions, format, and type
cannot be changed. Instead, call [dispose](#Texture+dispose) on the texture and instantiate a new one.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [Texture](#Texture) ⇐ <code>EventDispatcher</code>
    * [new Texture([image], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy], [colorSpace])](#new_Texture_new)
    * _instance_
        * [.isTexture](#Texture+isTexture) : <code>boolean</code>
        * [.id](#Texture+id) : <code>number</code>
        * [.uuid](#Texture+uuid) : <code>string</code>
        * [.name](#Texture+name) : <code>string</code>
        * [.source](#Texture+source) : <code>Source</code>
        * [.mipmaps](#Texture+mipmaps) : <code>Array.&lt;Object&gt;</code>
        * [.mapping](#Texture+mapping) : <code>UVMapping</code> \| <code>CubeReflectionMapping</code> \| <code>CubeRefractionMapping</code> \| <code>EquirectangularReflectionMapping</code> \| <code>EquirectangularRefractionMapping</code> \| <code>CubeUVReflectionMapping</code>
        * [.channel](#Texture+channel) : <code>number</code>
        * [.wrapS](#Texture+wrapS) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
        * [.wrapT](#Texture+wrapT) : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
        * [.magFilter](#Texture+magFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
        * [.minFilter](#Texture+minFilter) : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
        * [.anisotropy](#Texture+anisotropy) : <code>number</code>
        * [.format](#Texture+format) : <code>number</code>
        * [.internalFormat](#Texture+internalFormat) : <code>string</code>
        * [.type](#Texture+type) : <code>number</code>
        * [.offset](#Texture+offset) : <code>Vector2</code>
        * [.repeat](#Texture+repeat) : <code>Vector2</code>
        * [.center](#Texture+center) : <code>Vector2</code>
        * [.rotation](#Texture+rotation) : <code>number</code>
        * [.matrixAutoUpdate](#Texture+matrixAutoUpdate) : <code>boolean</code>
        * [.matrix](#Texture+matrix) : <code>Matrix3</code>
        * [.generateMipmaps](#Texture+generateMipmaps) : <code>boolean</code>
        * [.premultiplyAlpha](#Texture+premultiplyAlpha) : <code>boolean</code>
        * [.flipY](#Texture+flipY) : <code>boolean</code>
        * [.unpackAlignment](#Texture+unpackAlignment) : <code>number</code>
        * [.colorSpace](#Texture+colorSpace) : <code>string</code>
        * [.userData](#Texture+userData) : <code>Object</code>
        * [.version](#Texture+version) : <code>number</code>
        * [.onUpdate](#Texture+onUpdate) : <code>function</code>
        * [.renderTarget](#Texture+renderTarget) : <code>RenderTarget</code> \| <code>WebGLRenderTarget</code>
        * [.isRenderTargetTexture](#Texture+isRenderTargetTexture) : <code>boolean</code>
        * [.pmremVersion](#Texture+pmremVersion) : <code>number</code>
        * [.image](#Texture+image) : <code>Object</code>
        * [.needsUpdate](#Texture+needsUpdate) : <code>boolean</code>
        * [.needsPMREMUpdate](#Texture+needsPMREMUpdate) : <code>boolean</code>
        * [.updateMatrix()](#Texture+updateMatrix)
        * [.clone()](#Texture+clone) ⇒ [<code>Texture</code>](#Texture)
        * [.copy(source)](#Texture+copy) ⇒ [<code>Texture</code>](#Texture)
        * [.toJSON(meta)](#Texture+toJSON) ⇒ <code>Object</code>
        * [.dispose()](#Texture+dispose)
        * [.transformUv(uv)](#Texture+transformUv) ⇒ <code>Vector2</code>
        * ["dispose"](#Texture+event_dispose)
    * _static_
        * [.DEFAULT_IMAGE](#Texture.DEFAULT_IMAGE) : <code>Image</code>
        * [.DEFAULT_MAPPING](#Texture.DEFAULT_MAPPING) : <code>number</code>
        * [.DEFAULT_ANISOTROPY](#Texture.DEFAULT_ANISOTROPY) : <code>number</code>

<a name="new_Texture_new"></a>

### new Texture([image], [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy], [colorSpace])
Constructs a new texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [image] | <code>Object</code> | <code>Texture.DEFAULT_IMAGE</code> | The image holding the texture data. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearMipmapLinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |
| [colorSpace] | <code>string</code> | <code>&quot;NoColorSpace&quot;</code> | The color space. |

<a name="Texture+isTexture"></a>

### texture.isTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Texture+id"></a>

### texture.id : <code>number</code>
The ID of the texture.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Read only**: true  
<a name="Texture+uuid"></a>

### texture.uuid : <code>string</code>
The UUID of the material.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Read only**: true  
<a name="Texture+name"></a>

### texture.name : <code>string</code>
The name of the material.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+source"></a>

### texture.source : <code>Source</code>
The data definition of a texture. A reference to the data source can be
shared across textures. This is often useful in context of spritesheets
where multiple textures render the same data but with different texture
transformations.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+mipmaps"></a>

### texture.mipmaps : <code>Array.&lt;Object&gt;</code>
An array holding user-defined mipmaps.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+mapping"></a>

### texture.mapping : <code>UVMapping</code> \| <code>CubeReflectionMapping</code> \| <code>CubeRefractionMapping</code> \| <code>EquirectangularReflectionMapping</code> \| <code>EquirectangularRefractionMapping</code> \| <code>CubeUVReflectionMapping</code>
How the texture is applied to the object. The value `UVMapping`
is the default, where texture or uv coordinates are used to apply the map.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>UVMapping</code>  
<a name="Texture+channel"></a>

### texture.channel : <code>number</code>
Lets you select the uv attribute to map the texture to. `0` for `uv`,
`1` for `uv1`, `2` for `uv2` and `3` for `uv3`.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
<a name="Texture+wrapS"></a>

### texture.wrapS : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped horizontally and corresponds to
*U* in UV mapping.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="Texture+wrapT"></a>

### texture.wrapT : <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code>
This defines how the texture is wrapped horizontally and corresponds to
*V* in UV mapping.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>ClampToEdgeWrapping</code>  
<a name="Texture+magFilter"></a>

### texture.magFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers more than one pixel.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>LinearFilter</code>  
<a name="Texture+minFilter"></a>

### texture.minFilter : <code>NearestFilter</code> \| <code>NearestMipmapNearestFilter</code> \| <code>NearestMipmapLinearFilter</code> \| <code>LinearFilter</code> \| <code>LinearMipmapNearestFilter</code> \| <code>LinearMipmapLinearFilter</code>
How the texture is sampled when a texel covers less than one pixel.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>LinearMipmapLinearFilter</code>  
<a name="Texture+anisotropy"></a>

### texture.anisotropy : <code>number</code>
The number of samples taken along the axis through the pixel that has the
highest density of texels. By default, this value is `1`. A higher value
gives a less blurry result than a basic mipmap, at the cost of more
texture samples being used.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
<a name="Texture+format"></a>

### texture.format : <code>number</code>
The format of the texture.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>RGBAFormat</code>  
<a name="Texture+internalFormat"></a>

### texture.internalFormat : <code>string</code>
The default internal format is derived from [format](#Texture+format) and [type](#Texture+type) and
defines how the texture data is going to be stored on the GPU.

This property allows to overwrite the default format.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>&quot;null&quot;</code>  
<a name="Texture+type"></a>

### texture.type : <code>number</code>
The data type of the texture.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>UnsignedByteType</code>  
<a name="Texture+offset"></a>

### texture.offset : <code>Vector2</code>
How much a single repetition of the texture is offset from the beginning,
in each direction U and V. Typical range is `0.0` to `1.0`.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>(0,0)</code>  
<a name="Texture+repeat"></a>

### texture.repeat : <code>Vector2</code>
How many times the texture is repeated across the surface, in each
direction U and V. If repeat is set greater than `1` in either direction,
the corresponding wrap parameter should also be set to `RepeatWrapping`
or `MirroredRepeatWrapping` to achieve the desired tiling effect.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>(1,1)</code>  
<a name="Texture+center"></a>

### texture.center : <code>Vector2</code>
The point around which rotation occurs. A value of `(0.5, 0.5)` corresponds
to the center of the texture. Default is `(0, 0)`, the lower left.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>(0,0)</code>  
<a name="Texture+rotation"></a>

### texture.rotation : <code>number</code>
How much the texture is rotated around the center point, in radians.
Positive values are counter-clockwise.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
<a name="Texture+matrixAutoUpdate"></a>

### texture.matrixAutoUpdate : <code>boolean</code>
Whether to update the texture's uv-transformation [matrix](#Texture+matrix)
from the properties [offset](#Texture+offset), [repeat](#Texture+repeat),
[rotation](#Texture+rotation), and [center](#Texture+center).

Set this to `false` if you are specifying the uv-transform matrix directly.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>true</code>  
<a name="Texture+matrix"></a>

### texture.matrix : <code>Matrix3</code>
The uv-transformation matrix of the texture.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+generateMipmaps"></a>

### texture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Set this to `false` if you are creating mipmaps manually.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>true</code>  
<a name="Texture+premultiplyAlpha"></a>

### texture.premultiplyAlpha : <code>boolean</code>
If set to `true`, the alpha channel, if present, is multiplied into the
color channels when the texture is uploaded to the GPU.

Note that this property has no effect when using `ImageBitmap`. You need to
configure premultiply alpha on bitmap creation instead.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>false</code>  
<a name="Texture+flipY"></a>

### texture.flipY : <code>boolean</code>
If set to `true`, the texture is flipped along the vertical axis when
uploaded to the GPU.

Note that this property has no effect when using `ImageBitmap`. You need to
configure the flip on bitmap creation instead.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>true</code>  
<a name="Texture+unpackAlignment"></a>

### texture.unpackAlignment : <code>number</code>
Specifies the alignment requirements for the start of each pixel row in memory.
The allowable values are `1` (byte-alignment), `2` (rows aligned to even-numbered bytes),
`4` (word-alignment), and `8` (rows start on double-word boundaries).

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>4</code>  
<a name="Texture+colorSpace"></a>

### texture.colorSpace : <code>string</code>
Textures containing color data should be annotated with `SRGBColorSpace` or `LinearSRGBColorSpace`.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>&quot;NoColorSpace&quot;</code>  
<a name="Texture+userData"></a>

### texture.userData : <code>Object</code>
An object that can be used to store custom data about the texture. It
should not hold references to functions as these will not be cloned.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+version"></a>

### texture.version : <code>number</code>
This starts at `0` and counts how many times [needsUpdate](#Texture+needsUpdate) is set to `true`.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Texture+onUpdate"></a>

### texture.onUpdate : <code>function</code>
A callback function, called when the texture is updated (e.g., when
[needsUpdate](#Texture+needsUpdate) has been set to true and then the texture is used).

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>null</code>  
<a name="Texture+renderTarget"></a>

### texture.renderTarget : <code>RenderTarget</code> \| <code>WebGLRenderTarget</code>
An optional back reference to the textures render target.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>null</code>  
<a name="Texture+isRenderTargetTexture"></a>

### texture.isRenderTargetTexture : <code>boolean</code>
Indicates whether a texture belongs to a render target or not.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>false</code>  
**Read only**: true  
<a name="Texture+pmremVersion"></a>

### texture.pmremVersion : <code>number</code>
Indicates whether this texture should be processed by `PMREMGenerator` or not
(only relevant for render target textures).

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Texture+image"></a>

### texture.image : <code>Object</code>
The image object holding the texture data.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
<a name="Texture+needsUpdate"></a>

### texture.needsUpdate : <code>boolean</code>
Setting this property to `true` indicates the engine the texture
must be updated in the next render. This triggers a texture upload
to the GPU and ensures correct texture parameter configuration.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Texture+needsPMREMUpdate"></a>

### texture.needsPMREMUpdate : <code>boolean</code>
Setting this property to `true` indicates the engine the PMREM
must be regenerated.

**Kind**: instance property of [<code>Texture</code>](#Texture)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Texture+updateMatrix"></a>

### texture.updateMatrix()
Updates the texture transformation matrix from the from the properties [offset](#Texture+offset),
[repeat](#Texture+repeat), [rotation](#Texture+rotation), and [center](#Texture+center).

**Kind**: instance method of [<code>Texture</code>](#Texture)  
<a name="Texture+clone"></a>

### texture.clone() ⇒ [<code>Texture</code>](#Texture)
Returns a new texture with copied values from this instance.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Returns**: [<code>Texture</code>](#Texture) - A clone of this instance.  
<a name="Texture+copy"></a>

### texture.copy(source) ⇒ [<code>Texture</code>](#Texture)
Copies the values of the given texture to this instance.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Returns**: [<code>Texture</code>](#Texture) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| source | [<code>Texture</code>](#Texture) | The texture to copy. |

<a name="Texture+toJSON"></a>

### texture.toJSON(meta) ⇒ <code>Object</code>
Serializes the texture into JSON.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Returns**: <code>Object</code> - A JSON object representing the serialized texture.  
**See**: [ObjectLoader#parse](ObjectLoader#parse)  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> \| <code>string</code> | An optional value holding meta information about the serialization. |

<a name="Texture+dispose"></a>

### texture.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Emits**: [<code>dispose</code>](#Texture+event_dispose)  
<a name="Texture+transformUv"></a>

### texture.transformUv(uv) ⇒ <code>Vector2</code>
Transforms the given uv vector with the textures uv transformation matrix.

**Kind**: instance method of [<code>Texture</code>](#Texture)  
**Returns**: <code>Vector2</code> - The transformed uv vector.  

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Vector2</code> | The uv vector. |

<a name="Texture+event_dispose"></a>

### "dispose"
Fires when the texture has been disposed of.

**Kind**: event emitted by [<code>Texture</code>](#Texture)  
<a name="Texture.DEFAULT_IMAGE"></a>

### Texture.DEFAULT\_IMAGE : <code>Image</code>
The default image for all textures.

**Kind**: static property of [<code>Texture</code>](#Texture)  
**Default**: <code>null</code>  
<a name="Texture.DEFAULT_MAPPING"></a>

### Texture.DEFAULT\_MAPPING : <code>number</code>
The default mapping for all textures.

**Kind**: static property of [<code>Texture</code>](#Texture)  
**Default**: <code>UVMapping</code>  
<a name="Texture.DEFAULT_ANISOTROPY"></a>

### Texture.DEFAULT\_ANISOTROPY : <code>number</code>
The default anisotropy value for all textures.

**Kind**: static property of [<code>Texture</code>](#Texture)  
**Default**: <code>1</code>  
<a name="VideoFrameTexture"></a>

## VideoFrameTexture ⇐ <code>VideoTexture</code>
This class can be used as an alternative way to define video data. Instead of using
an instance of `HTMLVideoElement` like with `VideoTexture`, `VideoFrameTexture` expects each frame is
defined manually via [setFrame](#VideoFrameTexture+setFrame). A typical use case for this module is when
video frames are decoded with the WebCodecs API.

```js
const texture = new THREE.VideoFrameTexture();
texture.setFrame( frame );
```

**Kind**: global class  
**Extends**: <code>VideoTexture</code>  

* [VideoFrameTexture](#VideoFrameTexture) ⇐ <code>VideoTexture</code>
    * [new VideoFrameTexture([mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])](#new_VideoFrameTexture_new)
    * [.isVideoFrameTexture](#VideoFrameTexture+isVideoFrameTexture) : <code>boolean</code>
    * [.update()](#VideoFrameTexture+update)
    * [.setFrame(frame)](#VideoFrameTexture+setFrame)

<a name="new_VideoFrameTexture_new"></a>

### new VideoFrameTexture([mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])
Constructs a new video frame texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |

<a name="VideoFrameTexture+isVideoFrameTexture"></a>

### videoFrameTexture.isVideoFrameTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VideoFrameTexture</code>](#VideoFrameTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VideoFrameTexture+update"></a>

### videoFrameTexture.update()
This method overwritten with an empty implementation since
this type of texture is updated via `setFrame()`.

**Kind**: instance method of [<code>VideoFrameTexture</code>](#VideoFrameTexture)  
<a name="VideoFrameTexture+setFrame"></a>

### videoFrameTexture.setFrame(frame)
Sets the current frame of the video. This will automatically update the texture
so the data can be used for rendering.

**Kind**: instance method of [<code>VideoFrameTexture</code>](#VideoFrameTexture)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>VideoFrame</code> | The video frame. |

<a name="VideoTexture"></a>

## VideoTexture ⇐ <code>Texture</code>
A texture for use with a video.

```js
// assuming you have created a HTML video element with id="video"
const video = document.getElementById( 'video' );
const texture = new THREE.VideoTexture( video );
```

Note: After the initial use of a texture, its dimensions, format, and type
cannot be changed. Instead, call [Texture#dispose](Texture#dispose) on the texture and instantiate a new one.

**Kind**: global class  
**Extends**: <code>Texture</code>  

* [VideoTexture](#VideoTexture) ⇐ <code>Texture</code>
    * [new VideoTexture(video, [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])](#new_VideoTexture_new)
    * [.isVideoTexture](#VideoTexture+isVideoTexture) : <code>boolean</code>
    * [.generateMipmaps](#VideoTexture+generateMipmaps) : <code>boolean</code>
    * [.update()](#VideoTexture+update)

<a name="new_VideoTexture_new"></a>

### new VideoTexture(video, [mapping], [wrapS], [wrapT], [magFilter], [minFilter], [format], [type], [anisotropy])
Constructs a new video texture.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| video | <code>Video</code> |  | The video element to use as a data source for the texture. |
| [mapping] | <code>number</code> | <code>Texture.DEFAULT_MAPPING</code> | The texture mapping. |
| [wrapS] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapS value. |
| [wrapT] | <code>number</code> | <code>ClampToEdgeWrapping</code> | The wrapT value. |
| [magFilter] | <code>number</code> | <code>LinearFilter</code> | The mag filter value. |
| [minFilter] | <code>number</code> | <code>LinearFilter</code> | The min filter value. |
| [format] | <code>number</code> | <code>RGBAFormat</code> | The texture format. |
| [type] | <code>number</code> | <code>UnsignedByteType</code> | The texture type. |
| [anisotropy] | <code>number</code> | <code>Texture.DEFAULT_ANISOTROPY</code> | The anisotropy value. |

<a name="VideoTexture+isVideoTexture"></a>

### videoTexture.isVideoTexture : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VideoTexture</code>](#VideoTexture)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VideoTexture+generateMipmaps"></a>

### videoTexture.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps (if possible) for a texture.

Overwritten and set to `false` by default.

**Kind**: instance property of [<code>VideoTexture</code>](#VideoTexture)  
**Default**: <code>false</code>  
<a name="VideoTexture+update"></a>

### videoTexture.update()
This method is called automatically by the renderer and sets [Texture#needsUpdate](Texture#needsUpdate)
to `true` every time a new frame is available.

Only relevant if `requestVideoFrameCallback` is not supported in the browser.

**Kind**: instance method of [<code>VideoTexture</code>](#VideoTexture)  
