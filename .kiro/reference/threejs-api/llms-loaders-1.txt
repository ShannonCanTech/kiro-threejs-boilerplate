# three.js 

> JavaScript 3D Library. 

<a name="AnimationClipCreator"></a>

## Rhino3dmLoader ⇐ <code>Loader</code>
A loader for Rhinoceros 3D files and objects.

Rhinoceros is a 3D modeler used to create, edit, analyze, document, render,
animate, and translate NURBS curves, surfaces, breps, extrusions, point clouds,
as well as polygon meshes and SubD objects. `rhino3dm.js` is compiled to WebAssembly
from the open source geometry library `openNURBS`. The loader currently uses
`rhino3dm.js 8.4.0`.

```js
const loader = new Rhino3dmLoader();
loader.setLibraryPath( 'https://cdn.jsdelivr.net/npm/rhino3dm@8.0.1' );

const object = await loader.loadAsync( 'models/3dm/Rhino_Logo.3dm' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [Rhino3dmLoader](#Rhino3dmLoader) ⇐ <code>Loader</code>
    * [new Rhino3dmLoader([manager])](#new_Rhino3dmLoader_new)
    * [.setLibraryPath(path)](#Rhino3dmLoader+setLibraryPath) ⇒ [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)
    * [.setWorkerLimit(workerLimit)](#Rhino3dmLoader+setWorkerLimit) ⇒ [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)
    * [.load(url, onLoad, onProgress, onError)](#Rhino3dmLoader+load)
    * [.debug()](#Rhino3dmLoader+debug)
    * [.decodeObjects(buffer, url)](#Rhino3dmLoader+decodeObjects) ⇒ <code>Promise.&lt;Object3D&gt;</code>
    * [.parse(data, onLoad, onError)](#Rhino3dmLoader+parse)
    * [.dispose()](#Rhino3dmLoader+dispose)

<a name="new_Rhino3dmLoader_new"></a>

### new Rhino3dmLoader([manager])
Constructs a new Rhino 3DM loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="Rhino3dmLoader+setLibraryPath"></a>

### rhino3dmLoader.setLibraryPath(path) ⇒ [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)
Path to a folder containing the JS and WASM libraries.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
**Returns**: [<code>Rhino3dmLoader</code>](#Rhino3dmLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The library path to set. |

<a name="Rhino3dmLoader+setWorkerLimit"></a>

### rhino3dmLoader.setWorkerLimit(workerLimit) ⇒ [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)
Sets the maximum number of Web Workers to be used during decoding.
A lower limit may be preferable if workers are also for other
tasks in the application.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
**Returns**: [<code>Rhino3dmLoader</code>](#Rhino3dmLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| workerLimit | <code>number</code> | The worker limit. |

<a name="Rhino3dmLoader+load"></a>

### rhino3dmLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded 3DM asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="Rhino3dmLoader+debug"></a>

### rhino3dmLoader.debug()
Prints debug messages to the browser console.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
<a name="Rhino3dmLoader+decodeObjects"></a>

### rhino3dmLoader.decodeObjects(buffer, url) ⇒ <code>Promise.&lt;Object3D&gt;</code>
Decodes the 3DM asset data with a Web Worker.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
**Returns**: <code>Promise.&lt;Object3D&gt;</code> - A Promise that resolved with the decoded 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw 3DM asset data as an array buffer. |
| url | <code>string</code> | The asset URL. |

<a name="Rhino3dmLoader+parse"></a>

### rhino3dmLoader.parse(data, onLoad, onError)
Parses the given 3DM data and passes the loaded 3DM asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw 3DM asset data as an array buffer. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="Rhino3dmLoader+dispose"></a>

### rhino3dmLoader.dispose()
Frees internal resources. This method should be called
when the loader is no longer required.

**Kind**: instance method of [<code>Rhino3dmLoader</code>](#Rhino3dmLoader)  
<a name="ThreeMFLoader"></a>

## ThreeMFLoader ⇐ <code>Loader</code>
A loader for the [3D Manufacturing Format (3MF)](https://3mf.io/specification/) format.

The following features from the core specification are supported:

- 3D Models
- Object Resources (Meshes and Components)
- Material Resources (Base Materials)

3MF Materials and Properties Extension are only partially supported.

- Texture 2D
- Texture 2D Groups
- Color Groups (Vertex Colors)
- Metallic Display Properties (PBR)

```js
const loader = new ThreeMFLoader();

const object = await loader.loadAsync( './models/3mf/truck.3mf' );
object.rotation.set( - Math.PI / 2, 0, 0 ); // z-up conversion
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ThreeMFLoader](#ThreeMFLoader) ⇐ <code>Loader</code>
    * [new ThreeMFLoader([manager])](#new_ThreeMFLoader_new)
    * [.availableExtensions](#ThreeMFLoader+availableExtensions) : <code>Array.&lt;Object&gt;</code>
    * [.load(url, onLoad, onProgress, onError)](#ThreeMFLoader+load)
    * [.parse(data)](#ThreeMFLoader+parse) ⇒ <code>Group</code>
    * [.addExtension(extension)](#ThreeMFLoader+addExtension)

<a name="new_ThreeMFLoader_new"></a>

### new ThreeMFLoader([manager])
Constructs a new 3MF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="ThreeMFLoader+availableExtensions"></a>

### threeMFLoader.availableExtensions : <code>Array.&lt;Object&gt;</code>
An array of available extensions.

**Kind**: instance property of [<code>ThreeMFLoader</code>](#ThreeMFLoader)  
<a name="ThreeMFLoader+load"></a>

### threeMFLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded 3MF asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>ThreeMFLoader</code>](#ThreeMFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="ThreeMFLoader+parse"></a>

### threeMFLoader.parse(data) ⇒ <code>Group</code>
Parses the given 3MF data and returns the resulting group.

**Kind**: instance method of [<code>ThreeMFLoader</code>](#ThreeMFLoader)  
**Returns**: <code>Group</code> - A group representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw 3MF asset data as an array buffer. |

<a name="ThreeMFLoader+addExtension"></a>

### threeMFLoader.addExtension(extension)
Adds a 3MF extension.

**Kind**: instance method of [<code>ThreeMFLoader</code>](#ThreeMFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| extension | <code>Object</code> | The extension to add. |

<a name="AMFLoader"></a>

## AMFLoader ⇐ <code>Loader</code>
A loader for the AMF format.

The loader supports materials, color and ZIP compressed files.
No constellation support (yet).

```js
const loader = new AMFLoader();

const object = await loader.loadAsync( './models/amf/rook.amf' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [AMFLoader](#AMFLoader) ⇐ <code>Loader</code>
    * [new AMFLoader([manager])](#new_AMFLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#AMFLoader+load)
    * [.parse(data)](#AMFLoader+parse) ⇒ <code>Group</code>

<a name="new_AMFLoader_new"></a>

### new AMFLoader([manager])
Constructs a new AMF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="AMFLoader+load"></a>

### amfLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded AMF asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>AMFLoader</code>](#AMFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="AMFLoader+parse"></a>

### amfLoader.parse(data) ⇒ <code>Group</code>
Parses the given AMF data and returns the resulting group.

**Kind**: instance method of [<code>AMFLoader</code>](#AMFLoader)  
**Returns**: <code>Group</code> - A group representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw AMF asset data as an array buffer. |

<a name="BVHLoader"></a>

## BVHLoader ⇐ <code>Loader</code>
A loader for the BVH format.

Imports BVH files and outputs a single [Skeleton](Skeleton) and [AnimationClip](AnimationClip).
The loader only supports BVH files containing a single root right now.

```js
const loader = new BVHLoader();
const result = await loader.loadAsync( 'models/bvh/pirouette.bvh' );

// visualize skeleton
const skeletonHelper = new THREE.SkeletonHelper( result.skeleton.bones[ 0 ] );
scene.add( result.skeleton.bones[ 0 ] );
scene.add( skeletonHelper );

// play animation clip
mixer = new THREE.AnimationMixer( result.skeleton.bones[ 0 ] );
mixer.clipAction( result.clip ).play();
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [BVHLoader](#BVHLoader) ⇐ <code>Loader</code>
    * [new BVHLoader([manager])](#new_BVHLoader_new)
    * [.animateBonePositions](#BVHLoader+animateBonePositions) : <code>boolean</code>
    * [.animateBoneRotations](#BVHLoader+animateBoneRotations) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#BVHLoader+load)
    * [.parse(text)](#BVHLoader+parse) ⇒ <code>Object</code>

<a name="new_BVHLoader_new"></a>

### new BVHLoader([manager])
Constructs a new BVH loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="BVHLoader+animateBonePositions"></a>

### bvhLoader.animateBonePositions : <code>boolean</code>
Whether to animate bone positions or not.

**Kind**: instance property of [<code>BVHLoader</code>](#BVHLoader)  
**Default**: <code>true</code>  
<a name="BVHLoader+animateBoneRotations"></a>

### bvhLoader.animateBoneRotations : <code>boolean</code>
Whether to animate bone rotations or not.

**Kind**: instance property of [<code>BVHLoader</code>](#BVHLoader)  
**Default**: <code>true</code>  
<a name="BVHLoader+load"></a>

### bvhLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded BVH asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>BVHLoader</code>](#BVHLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="BVHLoader+parse"></a>

### bvhLoader.parse(text) ⇒ <code>Object</code>
Parses the given BVH data and returns the resulting data.

**Kind**: instance method of [<code>BVHLoader</code>](#BVHLoader)  
**Returns**: <code>Object</code> - An object representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw BVH data as a string. |

<a name="ColladaLoader"></a>

## ColladaLoader ⇐ <code>Loader</code>
A loader for the Collada format.

The Collada format is very complex so this loader only supports a subset of what
is defined in the [official specification](https://www.khronos.org/files/collada_spec_1_5.pdf).

Assets with a Z-UP coordinate system are transformed it into Y-UP by a simple rotation.
The vertex data are not converted.

```js
const loader = new ColladaLoader();

const result = await loader.loadAsync( './models/collada/elf/elf.dae' );
scene.add( result.scene );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [ColladaLoader](#ColladaLoader) ⇐ <code>Loader</code>
    * [.load(url, onLoad, onProgress, onError)](#ColladaLoader+load)
    * [.parse(text, path)](#ColladaLoader+parse) ⇒ <code>Object</code>

<a name="ColladaLoader+load"></a>

### colladaLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded Collada asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>ColladaLoader</code>](#ColladaLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="ColladaLoader+parse"></a>

### colladaLoader.parse(text, path) ⇒ <code>Object</code>
Parses the given Collada data and returns a result oject holding the parsed scene,
an array of animation clips and kinematics.

**Kind**: instance method of [<code>ColladaLoader</code>](#ColladaLoader)  
**Returns**: <code>Object</code> - An object representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw Collada data as a string. |
| path | <code>string</code> | The asset path. |

<a name="DDSLoader"></a>

## DDSLoader ⇐ <code>CompressedTextureLoader</code>
A loader for the S3TC texture compression format.

```js
const loader = new DDSLoader();

const map = loader.load( 'textures/compressed/disturb_dxt1_nomip.dds' );
map.colorSpace = THREE.SRGBColorSpace; // only for color textures
```

**Kind**: global class  
**Extends**: <code>CompressedTextureLoader</code>  

* [DDSLoader](#DDSLoader) ⇐ <code>CompressedTextureLoader</code>
    * [new DDSLoader([manager])](#new_DDSLoader_new)
    * [.parse(buffer, loadMipmaps)](#DDSLoader+parse) ⇒ <code>CompressedTextureLoader~TexData</code>

<a name="new_DDSLoader_new"></a>

### new DDSLoader([manager])
Constructs a new DDS loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="DDSLoader+parse"></a>

### ddsLoader.parse(buffer, loadMipmaps) ⇒ <code>CompressedTextureLoader~TexData</code>
Parses the given S3TC texture data.

**Kind**: instance method of [<code>DDSLoader</code>](#DDSLoader)  
**Returns**: <code>CompressedTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |
| loadMipmaps | <code>boolean</code> | Whether to load mipmaps or not. |

<a name="DRACOLoader"></a>

## DRACOLoader ⇐ <code>Loader</code>
A loader for the Draco format.

[Draco](https://google.github.io/draco/) is an open source library for compressing
and decompressing 3D meshes and point clouds. Compressed geometry can be significantly smaller,
at the cost of additional decoding time on the client device.

Standalone Draco files have a `.drc` extension, and contain vertex positions, normals, colors,
and other attributes. Draco files do not contain materials, textures, animation, or node hierarchies –
to use these features, embed Draco geometry inside of a glTF file. A normal glTF file can be converted
to a Draco-compressed glTF file using [glTF-Pipeline](https://github.com/CesiumGS/gltf-pipeline).
When using Draco with glTF, an instance of `DRACOLoader` will be used internally by [GLTFLoader](GLTFLoader).

It is recommended to create one DRACOLoader instance and reuse it to avoid loading and creating
multiple decoder instances.

`DRACOLoader` will automatically use either the JS or the WASM decoding library, based on
browser capabilities.

```js
const loader = new DRACOLoader();
loader.setDecoderPath( '/examples/jsm/libs/draco/' );

const geometry = await dracoLoader.loadAsync( 'models/draco/bunny.drc' );
geometry.computeVertexNormals(); // optional

dracoLoader.dispose();
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [DRACOLoader](#DRACOLoader) ⇐ <code>Loader</code>
    * [new DRACOLoader([manager])](#new_DRACOLoader_new)
    * [.setDecoderPath(path)](#DRACOLoader+setDecoderPath) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
    * [.setDecoderConfig(config)](#DRACOLoader+setDecoderConfig) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
    * [.setWorkerLimit(workerLimit)](#DRACOLoader+setWorkerLimit) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
    * [.load(url, onLoad, onProgress, onError)](#DRACOLoader+load)
    * [.parse(buffer, onLoad, onError)](#DRACOLoader+parse)

<a name="new_DRACOLoader_new"></a>

### new DRACOLoader([manager])
Constructs a new Draco loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="DRACOLoader+setDecoderPath"></a>

### dracoLoader.setDecoderPath(path) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
Provides configuration for the decoder libraries. Configuration cannot be changed after decoding begins.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  
**Returns**: [<code>DRACOLoader</code>](#DRACOLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The decoder path. |

<a name="DRACOLoader+setDecoderConfig"></a>

### dracoLoader.setDecoderConfig(config) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
Provides configuration for the decoder libraries. Configuration cannot be changed after decoding begins.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  
**Returns**: [<code>DRACOLoader</code>](#DRACOLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| config | <code>Object</code> | The decoder config. |

<a name="DRACOLoader+setWorkerLimit"></a>

### dracoLoader.setWorkerLimit(workerLimit) ⇒ [<code>DRACOLoader</code>](#DRACOLoader)
Sets the maximum number of Web Workers to be used during decoding.
A lower limit may be preferable if workers are also for other tasks in the application.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  
**Returns**: [<code>DRACOLoader</code>](#DRACOLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| workerLimit | <code>number</code> | The worker limit. |

<a name="DRACOLoader+load"></a>

### dracoLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded Draco asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="DRACOLoader+parse"></a>

### dracoLoader.parse(buffer, onLoad, onError)
Parses the given Draco data.

**Kind**: instance method of [<code>DRACOLoader</code>](#DRACOLoader)  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw Draco data as an array buffer. |
| onLoad | <code>function</code> | Executed when the loading/parsing process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="EXRLoader"></a>

## EXRLoader ⇐ <code>DataTextureLoader</code>
A loader for the OpenEXR texture format.

`EXRLoader` currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.
Supports reading as UnsignedByte, HalfFloat and Float type data texture.

```js
const loader = new EXRLoader();
const texture = await loader.loadAsync( 'textures/memorial.exr' );
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [EXRLoader](#EXRLoader) ⇐ <code>DataTextureLoader</code>
    * [new EXRLoader([manager])](#new_EXRLoader_new)
    * [.type](#EXRLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.parse(buffer)](#EXRLoader+parse) ⇒ <code>DataTextureLoader~TexData</code>
    * [.setDataType(value)](#EXRLoader+setDataType) ⇒ <code>RGBMLoader</code>

<a name="new_EXRLoader_new"></a>

### new EXRLoader([manager])
Constructs a new EXR loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="EXRLoader+type"></a>

### exrLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>EXRLoader</code>](#EXRLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="EXRLoader+parse"></a>

### exrLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given EXR texture data.

**Kind**: instance method of [<code>EXRLoader</code>](#EXRLoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="EXRLoader+setDataType"></a>

### exrLoader.setDataType(value) ⇒ <code>RGBMLoader</code>
Sets the texture type.

**Kind**: instance method of [<code>EXRLoader</code>](#EXRLoader)  
**Returns**: <code>RGBMLoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="FBXLoader"></a>

## FBXLoader ⇐ <code>Loader</code>
A loader for the FBX format.

Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format.
Versions lower than this may load but will probably have errors.

Needs Support:
- Morph normals / blend shape normals

FBX format references:
- [C++ SDK reference](https://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html)

Binary format specification:
- [FBX binary file format specification](https://code.blender.org/2013/08/fbx-binary-file-format-specification/)

```js
const loader = new FBXLoader();
const object = await loader.loadAsync( 'models/fbx/stanford-bunny.fbx' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [FBXLoader](#FBXLoader) ⇐ <code>Loader</code>
    * [new FBXLoader([manager])](#new_FBXLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#FBXLoader+load)
    * [.parse(FBXBuffer, path)](#FBXLoader+parse) ⇒ <code>Group</code>

<a name="new_FBXLoader_new"></a>

### new FBXLoader([manager])
Constructs a new FBX loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="FBXLoader+load"></a>

### fbxLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded FBX asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>FBXLoader</code>](#FBXLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="FBXLoader+parse"></a>

### fbxLoader.parse(FBXBuffer, path) ⇒ <code>Group</code>
Parses the given FBX data and returns the resulting group.

**Kind**: instance method of [<code>FBXLoader</code>](#FBXLoader)  
**Returns**: <code>Group</code> - An object representing the parsed asset.  

| Param | Type | Description |
| --- | --- | --- |
| FBXBuffer | <code>Array</code> | The raw FBX data as an array buffer. |
| path | <code>string</code> | The URL base path. |

## Classes

<dl>
<dt><a href="#FontLoader">FontLoader</a> ⇐ <code>Loader</code></dt>
<dd><p>A loader for loading fonts.</p>
<p>You can convert fonts online using <a href="https://gero3.github.io/facetype.js/">facetype.js</a>.</p>
<pre><code class="language-js">const loader = new FontLoader();
const font = await loader.loadAsync( &#39;fonts/helvetiker_regular.typeface.json&#39; );
</code></pre>
</dd>
<dt><a href="#Font">Font</a></dt>
<dd><p>Class representing a font.</p>
</dd>
</dl>

<a name="FontLoader"></a>

## FontLoader ⇐ <code>Loader</code>
A loader for loading fonts.

You can convert fonts online using [facetype.js](https://gero3.github.io/facetype.js/).

```js
const loader = new FontLoader();
const font = await loader.loadAsync( 'fonts/helvetiker_regular.typeface.json' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [FontLoader](#FontLoader) ⇐ <code>Loader</code>
    * [new FontLoader([manager])](#new_FontLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#FontLoader+load)
    * [.parse(json)](#FontLoader+parse) ⇒ [<code>Font</code>](#Font)

<a name="new_FontLoader_new"></a>

### new FontLoader([manager])
Constructs a new font loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="FontLoader+load"></a>

### fontLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded font
to the `onLoad()` callback.

**Kind**: instance method of [<code>FontLoader</code>](#FontLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="FontLoader+parse"></a>

### fontLoader.parse(json) ⇒ [<code>Font</code>](#Font)
Parses the given font data and returns the resulting font.

**Kind**: instance method of [<code>FontLoader</code>](#FontLoader)  
**Returns**: [<code>Font</code>](#Font) - The font.  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The raw font data as a JSON object. |

<a name="Font"></a>

## Font
Class representing a font.

**Kind**: global class  

* [Font](#Font)
    * [new Font(data)](#new_Font_new)
    * [.isFont](#Font+isFont) : <code>boolean</code>
    * [.data](#Font+data) : <code>Object</code>
    * [.generateShapes(text, [size])](#Font+generateShapes) ⇒ <code>Array.&lt;Shape&gt;</code>

<a name="new_Font_new"></a>

### new Font(data)
Constructs a new font.


| Param | Type | Description |
| --- | --- | --- |
| data | <code>Object</code> | The font data as JSON. |

<a name="Font+isFont"></a>

### font.isFont : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Font</code>](#Font)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Font+data"></a>

### font.data : <code>Object</code>
The font data as JSON.

**Kind**: instance property of [<code>Font</code>](#Font)  
<a name="Font+generateShapes"></a>

### font.generateShapes(text, [size]) ⇒ <code>Array.&lt;Shape&gt;</code>
Generates geometry shapes from the given text and size. The result of this method
should be used with [ShapeGeometry](ShapeGeometry) to generate the actual geometry data.

**Kind**: instance method of [<code>Font</code>](#Font)  
**Returns**: <code>Array.&lt;Shape&gt;</code> - An array of shapes representing the text.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| text | <code>string</code> |  | The text. |
| [size] | <code>number</code> | <code>100</code> | The text size. |

<a name="GCodeLoader"></a>

## GCodeLoader ⇐ <code>Loader</code>
A loader for the GCode format.

GCode files are usually used for 3D printing or CNC applications.

```js
const loader = new GCodeLoader();
const object = await loader.loadAsync( 'models/gcode/benchy.gcode' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [GCodeLoader](#GCodeLoader) ⇐ <code>Loader</code>
    * [new GCodeLoader([manager])](#new_GCodeLoader_new)
    * [.splitLayer](#GCodeLoader+splitLayer) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#GCodeLoader+load)
    * [.parse(data)](#GCodeLoader+parse) ⇒ <code>Group</code>

<a name="new_GCodeLoader_new"></a>

### new GCodeLoader([manager])
Constructs a new GCode loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="GCodeLoader+splitLayer"></a>

### gCodeLoader.splitLayer : <code>boolean</code>
Whether to split layers or not.

**Kind**: instance property of [<code>GCodeLoader</code>](#GCodeLoader)  
**Default**: <code>false</code>  
<a name="GCodeLoader+load"></a>

### gCodeLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded GCode asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>GCodeLoader</code>](#GCodeLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="GCodeLoader+parse"></a>

### gCodeLoader.parse(data) ⇒ <code>Group</code>
Parses the given GCode data and returns a group with lines.

**Kind**: instance method of [<code>GCodeLoader</code>](#GCodeLoader)  
**Returns**: <code>Group</code> - The parsed GCode asset.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>string</code> | The raw Gcode data as a string. |

<a name="GLTFLoader"></a>

## GLTFLoader ⇐ <code>Loader</code>
A loader for the glTF 2.0 format.

[glTF](https://www.khronos.org/gltf/) (GL Transmission Format) is an [open format specification](https://github.com/KhronosGroup/glTF/tree/main/specification/2.0)
for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf) or binary (.glb)
format. External files store textures (.jpg, .png) and additional binary data (.bin). A glTF asset may deliver
one or more scenes, including meshes, materials, textures, skins, skeletons, morph targets, animations, lights,
and/or cameras.

`GLTFLoader` uses [ImageBitmapLoader](ImageBitmapLoader) whenever possible. Be advised that image bitmaps are not
automatically GC-collected when they are no longer referenced, and they require special handling during
the disposal process.

`GLTFLoader` supports the following glTF 2.0 extensions:
- KHR_draco_mesh_compression
- KHR_materials_clearcoat
- KHR_materials_dispersion
- KHR_materials_ior
- KHR_materials_specular
- KHR_materials_transmission
- KHR_materials_iridescence
- KHR_materials_unlit
- KHR_materials_volume
- KHR_mesh_quantization
- KHR_lights_punctual
- KHR_texture_basisu
- KHR_texture_transform
- EXT_texture_webp
- EXT_meshopt_compression
- EXT_mesh_gpu_instancing

The following glTF 2.0 extension is supported by an external user plugin:
- [KHR_materials_variants](https://github.com/takahirox/three-gltf-extensions)
- [MSFT_texture_dds](https://github.com/takahirox/three-gltf-extensions)

```js
const loader = new GLTFLoader();

// Optional: Provide a DRACOLoader instance to decode compressed mesh data
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath( '/examples/jsm/libs/draco/' );
loader.setDRACOLoader( dracoLoader );

const gltf = await loader.loadAsync( 'models/gltf/duck/duck.gltf' );
scene.add( gltf.scene );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [GLTFLoader](#GLTFLoader) ⇐ <code>Loader</code>
    * [new GLTFLoader([manager])](#new_GLTFLoader_new)
    * _instance_
        * [.load(url, onLoad, onProgress, onError)](#GLTFLoader+load)
        * [.setDRACOLoader(dracoLoader)](#GLTFLoader+setDRACOLoader) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.setKTX2Loader(ktx2Loader)](#GLTFLoader+setKTX2Loader) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.setMeshoptDecoder(meshoptDecoder)](#GLTFLoader+setMeshoptDecoder) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.register(callback)](#GLTFLoader+register) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.unregister(callback)](#GLTFLoader+unregister) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
        * [.parse(data, path, onLoad, onError)](#GLTFLoader+parse)
        * [.parseAsync(data, path)](#GLTFLoader+parseAsync) ⇒ [<code>Promise.&lt;LoadObject&gt;</code>](#GLTFLoader..LoadObject)
    * _inner_
        * [~LoadObject](#GLTFLoader..LoadObject) : <code>Object</code>

<a name="new_GLTFLoader_new"></a>

### new GLTFLoader([manager])
Constructs a new glTF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="GLTFLoader+load"></a>

### gltfLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded glTF asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="GLTFLoader+setDRACOLoader"></a>

### gltfLoader.setDRACOLoader(dracoLoader) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Sets the given Draco loader to this loader. Required for decoding assets
compressed with the `KHR_draco_mesh_compression` extension.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| dracoLoader | <code>DRACOLoader</code> | The Draco loader to set. |

<a name="GLTFLoader+setKTX2Loader"></a>

### gltfLoader.setKTX2Loader(ktx2Loader) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Sets the given KTX2 loader to this loader. Required for loading KTX2
compressed textures.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| ktx2Loader | <code>KTX2Loader</code> | The KTX2 loader to set. |

<a name="GLTFLoader+setMeshoptDecoder"></a>

### gltfLoader.setMeshoptDecoder(meshoptDecoder) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Sets the given meshopt decoder. Required for decoding assets
compressed with the `EXT_meshopt_compression` extension.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| meshoptDecoder | <code>Object</code> | The meshopt decoder to set. |

<a name="GLTFLoader+register"></a>

### gltfLoader.register(callback) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Registers a plugin callback. This API is internally used to implement the various
glTF extensions but can also used by third-party code to add additional logic
to the loader.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The callback function to register. |

<a name="GLTFLoader+unregister"></a>

### gltfLoader.unregister(callback) ⇒ [<code>GLTFLoader</code>](#GLTFLoader)
Unregisters a plugin callback.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>GLTFLoader</code>](#GLTFLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The callback function to unregister. |

<a name="GLTFLoader+parse"></a>

### gltfLoader.parse(data, path, onLoad, onError)
Parses the given FBX data and returns the resulting group.

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>string</code> \| <code>ArrayBuffer</code> | The raw glTF data. |
| path | <code>string</code> | The URL base path. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="GLTFLoader+parseAsync"></a>

### gltfLoader.parseAsync(data, path) ⇒ [<code>Promise.&lt;LoadObject&gt;</code>](#GLTFLoader..LoadObject)
Async version of [parse](#GLTFLoader+parse).

**Kind**: instance method of [<code>GLTFLoader</code>](#GLTFLoader)  
**Returns**: [<code>Promise.&lt;LoadObject&gt;</code>](#GLTFLoader..LoadObject) - A Promise that resolves with the loaded glTF when the parsing has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>string</code> \| <code>ArrayBuffer</code> | The raw glTF data. |
| path | <code>string</code> | The URL base path. |

<a name="GLTFLoader..LoadObject"></a>

### GLTFLoader~LoadObject : <code>Object</code>
Loader result of `GLTFLoader`.

**Kind**: inner typedef of [<code>GLTFLoader</code>](#GLTFLoader)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| animations | <code>Array.&lt;AnimationClip&gt;</code> | An array of animation clips. |
| asset | <code>Object</code> | Meta data about the loaded asset. |
| cameras | <code>Array.&lt;Camera&gt;</code> | An array of cameras. |
| parser | <code>GLTFParser</code> | A reference to the internal parser. |
| scene | <code>Group</code> | The default scene. |
| scenes | <code>Array.&lt;Group&gt;</code> | glTF assets might define multiple scenes. |
| userData | <code>Object</code> | Additional data. |

<a name="HDRCubeTextureLoader"></a>

## HDRCubeTextureLoader ⇐ <code>Loader</code>
A loader for loading HDR cube textures.

```js
const loader = new HDRCubeTextureLoader();
loader.setPath( 'textures/cube/pisaHDR/' );
const cubeTexture = await loader.loadAsync( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ] );

scene.background = cubeTexture;
scene.environment = cubeTexture;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [HDRCubeTextureLoader](#HDRCubeTextureLoader) ⇐ <code>Loader</code>
    * [new HDRCubeTextureLoader([manager])](#new_HDRCubeTextureLoader_new)
    * [.hdrLoader](#HDRCubeTextureLoader+hdrLoader) : <code>RGBELoader</code>
    * [.type](#HDRCubeTextureLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.load(urls, onLoad, onProgress, onError)](#HDRCubeTextureLoader+load) ⇒ <code>CubeTexture</code>
    * [.setDataType(value)](#HDRCubeTextureLoader+setDataType) ⇒ <code>RGBELoader</code>

<a name="new_HDRCubeTextureLoader_new"></a>

### new HDRCubeTextureLoader([manager])
Constructs a new HDR cube texture loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="HDRCubeTextureLoader+hdrLoader"></a>

### hdrCubeTextureLoader.hdrLoader : <code>RGBELoader</code>
The internal HDR loader that loads the
individual textures for each cube face.

**Kind**: instance property of [<code>HDRCubeTextureLoader</code>](#HDRCubeTextureLoader)  
<a name="HDRCubeTextureLoader+type"></a>

### hdrCubeTextureLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>HDRCubeTextureLoader</code>](#HDRCubeTextureLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="HDRCubeTextureLoader+load"></a>

### hdrCubeTextureLoader.load(urls, onLoad, onProgress, onError) ⇒ <code>CubeTexture</code>
Starts loading from the given URLs and passes the loaded HDR cube texture
to the `onLoad()` callback.

**Kind**: instance method of [<code>HDRCubeTextureLoader</code>](#HDRCubeTextureLoader)  
**Returns**: <code>CubeTexture</code> - The HDR cube texture.  

| Param | Type | Description |
| --- | --- | --- |
| urls | <code>Array.&lt;string&gt;</code> | The paths/URLs of the files to be loaded. This can also be a data URIs. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="HDRCubeTextureLoader+setDataType"></a>

### hdrCubeTextureLoader.setDataType(value) ⇒ <code>RGBELoader</code>
Sets the texture type.

**Kind**: instance method of [<code>HDRCubeTextureLoader</code>](#HDRCubeTextureLoader)  
**Returns**: <code>RGBELoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="IESLoader"></a>

## IESLoader ⇐ <code>Loader</code>
A loader for the IES format.

The loaded texture should be assigned to [IESSpotLight#map](IESSpotLight#map).

```js
const loader = new IESLoader();
const texture = await loader.loadAsync( 'ies/007cfb11e343e2f42e3b476be4ab684e.ies' );

const spotLight = new THREE.IESSpotLight( 0xff0000, 500 );
spotLight.iesMap = texture;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [IESLoader](#IESLoader) ⇐ <code>Loader</code>
    * [new IESLoader([manager])](#new_IESLoader_new)
    * [.type](#IESLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.load(url, onLoad, onProgress, onError)](#IESLoader+load)
    * [.parse(text)](#IESLoader+parse) ⇒ <code>DataTexture</code>

<a name="new_IESLoader_new"></a>

### new IESLoader([manager])
Constructs a new IES loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="IESLoader+type"></a>

### iesLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>IESLoader</code>](#IESLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="IESLoader+load"></a>

### iesLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded IES texture
to the `onLoad()` callback.

**Kind**: instance method of [<code>IESLoader</code>](#IESLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="IESLoader+parse"></a>

### iesLoader.parse(text) ⇒ <code>DataTexture</code>
Parses the given IES data.

**Kind**: instance method of [<code>IESLoader</code>](#IESLoader)  
**Returns**: <code>DataTexture</code> - THE IES data as a texture.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw IES data. |

<a name="KMZLoader"></a>

## KMZLoader ⇐ <code>Loader</code>
A loader for the KMZ format.

```js
const loader = new KMZLoader();
const kmz = await loader.loadAsync( './models/kmz/Box.kmz' );

scene.add( kmz.scene );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [KMZLoader](#KMZLoader) ⇐ <code>Loader</code>
    * [new KMZLoader([manager])](#new_KMZLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#KMZLoader+load)
    * [.parse(data)](#KMZLoader+parse) ⇒ <code>Object</code>

<a name="new_KMZLoader_new"></a>

### new KMZLoader([manager])
Constructs a new KMZ loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="KMZLoader+load"></a>

### kmzLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded KMZ asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>KMZLoader</code>](#KMZLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="KMZLoader+parse"></a>

### kmzLoader.parse(data) ⇒ <code>Object</code>
Parses the given KMZ data and returns an object holding the scene.

**Kind**: instance method of [<code>KMZLoader</code>](#KMZLoader)  
**Returns**: <code>Object</code> - The parsed KMZ asset.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw KMZ data as an array buffer. |

<a name="KTX2Loader"></a>

## KTX2Loader ⇐ <code>Loader</code>
A loader for KTX 2.0 GPU Texture containers.

KTX 2.0 is a container format for various GPU texture formats. The loader supports Basis Universal GPU textures,
which can be quickly transcoded to a wide variety of GPU texture compression formats. While KTX 2.0 also allows
other hardware-specific formats, this loader does not yet parse them.

This loader parses the KTX 2.0 container and transcodes to a supported GPU compressed texture format.
The required WASM transcoder and JS wrapper are available from the `examples/jsm/libs/basis` directory.

This loader relies on Web Assembly which is not supported in older browsers.

References:
- [KTX specification](http://github.khronos.org/KTX-Specification/)
- [DFD](https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor)
- [BasisU HDR](https://github.com/BinomialLLC/basis_universal/wiki/UASTC-HDR-Texture-Specification-v1.0)

```js
const loader = new KTX2Loader();
loader.setTranscoderPath( 'examples/jsm/libs/basis/' );
loader.detectSupport( renderer );
const texture = loader.loadAsync( 'diffuse.ktx2' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [KTX2Loader](#KTX2Loader) ⇐ <code>Loader</code>
    * [new KTX2Loader([manager])](#new_KTX2Loader_new)
    * [.setTranscoderPath(path)](#KTX2Loader+setTranscoderPath) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
    * [.setWorkerLimit(workerLimit)](#KTX2Loader+setWorkerLimit) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
    * [.detectSupportAsync(renderer)](#KTX2Loader+detectSupportAsync) ⇒ <code>Promise</code>
    * [.detectSupport(renderer)](#KTX2Loader+detectSupport) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
    * [.load(url, onLoad, onProgress, onError)](#KTX2Loader+load)
    * [.parse(buffer, onLoad, onError)](#KTX2Loader+parse) ⇒ <code>Promise</code>
    * [.dispose()](#KTX2Loader+dispose)

<a name="new_KTX2Loader_new"></a>

### new KTX2Loader([manager])
Constructs a new KTX2 loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="KTX2Loader+setTranscoderPath"></a>

### ktX2Loader.setTranscoderPath(path) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
Sets the transcoder path.

The WASM transcoder and JS wrapper are available from the `examples/jsm/libs/basis` directory.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: [<code>KTX2Loader</code>](#KTX2Loader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The transcoder path to set. |

<a name="KTX2Loader+setWorkerLimit"></a>

### ktX2Loader.setWorkerLimit(workerLimit) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
Sets the maximum number of Web Workers to be allocated by this instance.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: [<code>KTX2Loader</code>](#KTX2Loader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| workerLimit | <code>number</code> | The worker limit. |

<a name="KTX2Loader+detectSupportAsync"></a>

### ktX2Loader.detectSupportAsync(renderer) ⇒ <code>Promise</code>
Async version of [detectSupport](#KTX2Loader+detectSupport).

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: <code>Promise</code> - A Promise that resolves when the support has been detected.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The renderer. |

<a name="KTX2Loader+detectSupport"></a>

### ktX2Loader.detectSupport(renderer) ⇒ [<code>KTX2Loader</code>](#KTX2Loader)
Detects hardware support for available compressed texture formats, to determine
the output format for the transcoder. Must be called before loading a texture.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: [<code>KTX2Loader</code>](#KTX2Loader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGPURenderer</code> \| <code>WebGLRenderer</code> | The renderer. |

<a name="KTX2Loader+load"></a>

### ktX2Loader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded KTX2 texture
to the `onLoad()` callback.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="KTX2Loader+parse"></a>

### ktX2Loader.parse(buffer, onLoad, onError) ⇒ <code>Promise</code>
Parses the given KTX2 data.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
**Returns**: <code>Promise</code> - A Promise that resolves when the parsing has been finished.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw KTX2 data as an array buffer. |
| onLoad | <code>function</code> | Executed when the loading/parsing process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="KTX2Loader+dispose"></a>

### ktX2Loader.dispose()
Frees internal resources. This method should be called
when the loader is no longer required.

**Kind**: instance method of [<code>KTX2Loader</code>](#KTX2Loader)  
<a name="KTXLoader"></a>

## KTXLoader ⇐ <code>CompressedTextureLoader</code>
A loader for the KTX texture compression format.

References:
- [The KTX File Format and Tools](https://www.khronos.org/opengles/sdk/tools/KTX/)
- [Babylon.JS khronosTextureContainer.ts](https://github.com/BabylonJS/Babylon.js/blob/master/src/Misc/khronosTextureContainer.ts)

```js
const loader = new KTXLoader();

const map = loader.load( 'textures/compressed/lensflare_ASTC8x8.ktx' )
map.colorSpace = THREE.SRGBColorSpace; // only for color textures
```

**Kind**: global class  
**Extends**: <code>CompressedTextureLoader</code>  

* [KTXLoader](#KTXLoader) ⇐ <code>CompressedTextureLoader</code>
    * [new KTXLoader([manager])](#new_KTXLoader_new)
    * [.parse(buffer, loadMipmaps)](#KTXLoader+parse) ⇒ <code>CompressedTextureLoader~TexData</code>

<a name="new_KTXLoader_new"></a>

### new KTXLoader([manager])
Constructs a new KTX loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="KTXLoader+parse"></a>

### ktxLoader.parse(buffer, loadMipmaps) ⇒ <code>CompressedTextureLoader~TexData</code>
Parses the given KTX texture data.

**Kind**: instance method of [<code>KTXLoader</code>](#KTXLoader)  
**Returns**: <code>CompressedTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |
| loadMipmaps | <code>boolean</code> | Whether to load mipmaps or not. |

<a name="LDrawLoader"></a>

## LDrawLoader ⇐ <code>Loader</code>
A loader for the LDraw format.

[LDraw](https://ldraw.org/) (LEGO Draw) is an [open format specification](https://ldraw.org/article/218.html)
for describing LEGO and other construction set 3D models.

An LDraw asset (a text file usually with extension .ldr, .dat or .txt) can describe just a single construction
piece, or an entire model. In the case of a model the LDraw file can reference other LDraw files, which are
loaded from a library path set with `setPartsLibraryPath`. You usually download the LDraw official parts library,
extract to a folder and point setPartsLibraryPath to it.

Library parts will be loaded by trial and error in subfolders 'parts', 'p' and 'models'. These file accesses
are not optimal for web environment, so a script tool has been made to pack an LDraw file with all its dependencies
into a single file, which loads much faster. See section 'Packing LDraw models'. The LDrawLoader example loads
several packed files. The official parts library is not included due to its large size.

`LDrawLoader` supports the following extensions:
- !COLOUR: Color and surface finish declarations.
- BFC: Back Face Culling specification.
- !CATEGORY: Model/part category declarations.
- !KEYWORDS: Model/part keywords declarations.

```js
const loader = new LDrawLoader();
loader.setConditionalLineMaterial( LDrawConditionalLineMaterial ); // the type of line material depends on the used renderer
const object = await loader.loadAsync( 'models/ldraw/officialLibrary/models/car.ldr_Packed.mpd' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [LDrawLoader](#LDrawLoader) ⇐ <code>Loader</code>
    * [new LDrawLoader([manager])](#new_LDrawLoader_new)
    * [.setPartsLibraryPath(path)](#LDrawLoader+setPartsLibraryPath) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
    * [.setConditionalLineMaterial(type)](#LDrawLoader+setConditionalLineMaterial) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
    * [.preloadMaterials(url)](#LDrawLoader+preloadMaterials) ⇒ <code>Promise</code>
    * [.load(url, onLoad, onProgress, onError)](#LDrawLoader+load)
    * [.parse(text, onLoad, onError)](#LDrawLoader+parse)
    * [.setFileMap(fileMap)](#LDrawLoader+setFileMap) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
    * [.getMaterial(colorCode)](#LDrawLoader+getMaterial) ⇒ <code>Material</code>
    * [.getMainMaterial()](#LDrawLoader+getMainMaterial) ⇒ <code>Material</code>
    * [.getMainEdgeMaterial()](#LDrawLoader+getMainEdgeMaterial) ⇒ <code>Material</code>

<a name="new_LDrawLoader_new"></a>

### new LDrawLoader([manager])
Constructs a new LDraw loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="LDrawLoader+setPartsLibraryPath"></a>

### lDrawLoader.setPartsLibraryPath(path) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
This method must be called prior to `load()` unless the model to load does not reference
library parts (usually it will be a model with all its parts packed in a single file).

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: [<code>LDrawLoader</code>](#LDrawLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | Path to library parts files to load referenced parts from. This is different from Loader.setPath, which indicates the path to load the main asset from. |

<a name="LDrawLoader+setConditionalLineMaterial"></a>

### lDrawLoader.setConditionalLineMaterial(type) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
Sets the conditional line material type which depends on the used renderer.
Use [LDrawConditionalLineMaterial](LDrawConditionalLineMaterial) when using `WebGLRenderer` and
[LDrawConditionalLineNodeMaterial](LDrawConditionalLineNodeMaterial) when using `WebGPURenderer`.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: [<code>LDrawLoader</code>](#LDrawLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>LDrawConditionalLineMaterial.constructor</code> \| <code>LDrawConditionalLineNodeMaterial.constructor</code> | The conditional line material type. |

<a name="LDrawLoader+preloadMaterials"></a>

### lDrawLoader.preloadMaterials(url) ⇒ <code>Promise</code>
This async method preloads materials from a single LDraw file. In the official
parts library there is a special file which is loaded always the first (LDConfig.ldr)
and contains all the standard color codes. This method is intended to be used with
not packed files, for example in an editor where materials are preloaded and parts
are loaded on demand.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: <code>Promise</code> - A Promise that resolves when the preload has finished.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | Path of the LDraw materials asset. |

<a name="LDrawLoader+load"></a>

### lDrawLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded LDraw asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="LDrawLoader+parse"></a>

### lDrawLoader.parse(text, onLoad, onError)
Parses the given LDraw data and returns the resulting group.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw VRML data as a string. |
| onLoad | <code>function</code> | Executed when the loading/parsing process has been finished. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="LDrawLoader+setFileMap"></a>

### lDrawLoader.setFileMap(fileMap) ⇒ [<code>LDrawLoader</code>](#LDrawLoader)
Sets a map which maps referenced library filenames to new filenames.
If a fileMap is not specified (the default), library parts will be accessed by trial and
error in subfolders 'parts', 'p' and 'models'.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: [<code>LDrawLoader</code>](#LDrawLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| fileMap | <code>Object.&lt;string, string&gt;</code> | The file map to set. |

<a name="LDrawLoader+getMaterial"></a>

### lDrawLoader.getMaterial(colorCode) ⇒ <code>Material</code>
Returns a material for the given color code.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: <code>Material</code> - The material. Returns `null` if no material has been found.  

| Param | Type | Description |
| --- | --- | --- |
| colorCode | <code>string</code> | The color code. |

<a name="LDrawLoader+getMainMaterial"></a>

### lDrawLoader.getMainMaterial() ⇒ <code>Material</code>
Returns the Material for the main LDraw color.

For an already loaded LDraw asset, returns the Material associated with the main color code.
This method can be useful to modify the main material of a model or part that exposes it.

The main color code is the standard way to color an LDraw part. It is '16' for triangles and
'24' for edges. Usually a complete model will not expose the main color (that is, no part
uses the code '16' at the top level, because they are assigned other specific colors) An LDraw
 part file on the other hand will expose the code '16' to be colored, and can have additional
fixed colors.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: <code>Material</code> - The material. Returns `null` if no material has been found.  
<a name="LDrawLoader+getMainEdgeMaterial"></a>

### lDrawLoader.getMainEdgeMaterial() ⇒ <code>Material</code>
Returns the material for the edges main LDraw color.

**Kind**: instance method of [<code>LDrawLoader</code>](#LDrawLoader)  
**Returns**: <code>Material</code> - The material. Returns `null` if no material has been found.  
<a name="LWOLoader"></a>

## LWOLoader ⇐ <code>Loader</code>
A loader for the LWO format.

LWO3 and LWO2 formats are supported.

References:
- [LWO3 format specification](https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo3.html)
- [LWO2 format specification](https://static.lightwave3d.com/sdk/2019/html/filefmts/lwo2.html)

```js
const loader = new LWOLoader();
const lwoData = await loader.loadAsync( 'models/lwo/Objects/LWO3/Demo.lwo' );

const mesh = object.meshes[ 0 ];
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [LWOLoader](#LWOLoader) ⇐ <code>Loader</code>
    * [new LWOLoader([manager])](#new_LWOLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#LWOLoader+load)
    * [.parse(iffBuffer, path, modelName)](#LWOLoader+parse) ⇒ <code>Object</code>

<a name="new_LWOLoader_new"></a>

### new LWOLoader([manager])
Constructs a new LWO loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="LWOLoader+load"></a>

### lwoLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded LWO asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>LWOLoader</code>](#LWOLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="LWOLoader+parse"></a>

### lwoLoader.parse(iffBuffer, path, modelName) ⇒ <code>Object</code>
Parses the given LWO data and returns the resulting meshes and materials.

**Kind**: instance method of [<code>LWOLoader</code>](#LWOLoader)  
**Returns**: <code>Object</code> - An object holding the parse meshes and materials.  

| Param | Type | Description |
| --- | --- | --- |
| iffBuffer | <code>ArrayBuffer</code> | The raw LWO data as an array buffer. |
| path | <code>string</code> | The URL base path. |
| modelName | <code>string</code> | The model name. |

<a name="LottieLoader"></a>

## LottieLoader ⇐ <code>Loader</code>
A loader for the Lottie texture animation format.

The loader returns an instance of [CanvasTexture](CanvasTexture) to represent
the animated texture. Two additional properties are added to each texture:
- `animation`: The return value of `lottie.loadAnimation()` which is an object
with an API for controlling the animation's playback.
- `image`: The image container.

```js
const loader = new LottieLoader();
loader.setQuality( 2 );
const texture = await loader.loadAsync( 'textures/lottie/24017-lottie-logo-animation.json' );

const geometry = new THREE.BoxGeometry();
const material = new THREE.MeshBasicMaterial( { map: texture } );
const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [LottieLoader](#LottieLoader) ⇐ <code>Loader</code>
    * [.setQuality(value)](#LottieLoader+setQuality)
    * [.load(url, onLoad, onProgress, onError)](#LottieLoader+load) ⇒ <code>CanvasTexture</code>

<a name="LottieLoader+setQuality"></a>

### lottieLoader.setQuality(value)
Sets the texture quality.

**Kind**: instance method of [<code>LottieLoader</code>](#LottieLoader)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The texture quality. |

<a name="LottieLoader+load"></a>

### lottieLoader.load(url, onLoad, onProgress, onError) ⇒ <code>CanvasTexture</code>
Starts loading from the given URL and passes the loaded Lottie asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>LottieLoader</code>](#LottieLoader)  
**Returns**: <code>CanvasTexture</code> - The Lottie texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MD2Loader"></a>

## MD2Loader ⇐ <code>Loader</code>
A loader for the MD2 format.

The loader represents the animations of the MD2 asset as an array of animation
clips and stores them in the `animations` property of the geometry.

```js
const loader = new MD2Loader();
const geometry = await loader.loadAsync( './models/md2/ogro/ogro.md2' );

const animations = geometry.animations;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MD2Loader](#MD2Loader) ⇐ <code>Loader</code>
    * [new MD2Loader([manager])](#new_MD2Loader_new)
    * [.load(url, onLoad, [onProgress], [onError])](#MD2Loader+load)
    * [.parse(buffer)](#MD2Loader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_MD2Loader_new"></a>

### new MD2Loader([manager])
Constructs a new MD2 loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="MD2Loader+load"></a>

### mD2Loader.load(url, onLoad, [onProgress], [onError])
Starts loading from the given URL and passes the loaded MD2 asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>MD2Loader</code>](#MD2Loader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| [onProgress] | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| [onError] | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MD2Loader+parse"></a>

### mD2Loader.parse(buffer) ⇒ <code>BufferGeometry</code>
Parses the given MD2 data and returns a geometry.

**Kind**: instance method of [<code>MD2Loader</code>](#MD2Loader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw MD2 data as an array buffer. |

<a name="MDDLoader"></a>

## MDDLoader ⇐ <code>Loader</code>
A loader for the MDD format.

MDD stores a position for every vertex in a model for every frame in an animation.
Similar to BVH, it can be used to transfer animation data between different 3D applications or engines.

MDD stores its data in binary format (big endian) in the following way:

- number of frames (a single uint32)
- number of vertices (a single uint32)
- time values for each frame (sequence of float32)
- vertex data for each frame (sequence of float32)

```js
const loader = new MDDLoader();
const result = await loader.loadAsync( 'models/mdd/cube.mdd' );

const morphTargets = result.morphTargets;
const clip = result.clip;
// clip.optimize(); // optional

const geometry = new THREE.BoxGeometry();
geometry.morphAttributes.position = morphTargets; // apply morph targets (vertex data must match)

const material = new THREE.MeshBasicMaterial();

const mesh = new THREE.Mesh( geometry, material );
scene.add( mesh );

const mixer = new THREE.AnimationMixer( mesh );
mixer.clipAction( clip ).play();
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MDDLoader](#MDDLoader) ⇐ <code>Loader</code>
    * [new MDDLoader([manager])](#new_MDDLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#MDDLoader+load)
    * [.parse(data)](#MDDLoader+parse) ⇒ <code>Object</code>

<a name="new_MDDLoader_new"></a>

### new MDDLoader([manager])
Constructs a new MDD loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="MDDLoader+load"></a>

### mddLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded MDD asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>MDDLoader</code>](#MDDLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MDDLoader+parse"></a>

### mddLoader.parse(data) ⇒ <code>Object</code>
Parses the given MDD data and returns an object holding the animation clip and the respective
morph targets.

**Kind**: instance method of [<code>MDDLoader</code>](#MDDLoader)  
**Returns**: <code>Object</code> - The result object.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw XYZ data as an array buffer. |

<a name="MTLLoader"></a>

## MTLLoader ⇐ <code>Loader</code>
A loader for the MTL format.

The Material Template Library format (MTL) or .MTL File Format is a companion file format
to OBJ that describes surface shading (material) properties of objects within one or more
OBJ files.

```js
const loader = new MTLLoader();
const materials = await loader.loadAsync( 'models/obj/male02/male02.mtl' );

const objLoader = new OBJLoader();
objLoader.setMaterials( materials );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MTLLoader](#MTLLoader) ⇐ <code>Loader</code>
    * _instance_
        * [.load(url, onLoad, onProgress, onError)](#MTLLoader+load)
        * [.setMaterialOptions(value)](#MTLLoader+setMaterialOptions) ⇒ [<code>MTLLoader</code>](#MTLLoader)
        * [.parse(text, path)](#MTLLoader+parse) ⇒ <code>MaterialCreator</code>
    * _inner_
        * [~MaterialOptions](#MTLLoader..MaterialOptions) : <code>Object</code>

<a name="MTLLoader+load"></a>

### mtlLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded MTL asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>MTLLoader</code>](#MTLLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MTLLoader+setMaterialOptions"></a>

### mtlLoader.setMaterialOptions(value) ⇒ [<code>MTLLoader</code>](#MTLLoader)
Sets the material options.

**Kind**: instance method of [<code>MTLLoader</code>](#MTLLoader)  
**Returns**: [<code>MTLLoader</code>](#MTLLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | [<code>MaterialOptions</code>](#MTLLoader..MaterialOptions) | The material options. |

<a name="MTLLoader+parse"></a>

### mtlLoader.parse(text, path) ⇒ <code>MaterialCreator</code>
Parses the given MTL data and returns the resulting material creator.

**Kind**: instance method of [<code>MTLLoader</code>](#MTLLoader)  
**Returns**: <code>MaterialCreator</code> - The material creator.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw MTL data as a string. |
| path | <code>string</code> | The URL base path. |

<a name="MTLLoader..MaterialOptions"></a>

### MTLLoader~MaterialOptions : <code>Object</code>
Material options of `MTLLoader`.

**Kind**: inner typedef of [<code>MTLLoader</code>](#MTLLoader)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [side] | <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code> | <code>FrontSide</code> | Which side to apply the material. |
| [wrap] | <code>RepeatWrapping</code> \| <code>ClampToEdgeWrapping</code> \| <code>MirroredRepeatWrapping</code> | <code>RepeatWrapping</code> | What type of wrapping to apply for textures. |
| [normalizeRGB] | <code>boolean</code> | <code>false</code> | Whether RGB colors should be normalized to `0-1` from `0-255`. |
| [ignoreZeroRGBs] | <code>boolean</code> | <code>false</code> | Ignore values of RGBs (Ka,Kd,Ks) that are all 0's. |

<a name="MaterialXLoader"></a>

## MaterialXLoader ⇐ <code>Loader</code>
A loader for the MaterialX format.

The node materials loaded with this loader can only be used with [WebGPURenderer](WebGPURenderer).

```js
const loader = new MaterialXLoader().setPath( SAMPLE_PATH );
const materials = await loader.loadAsync( 'standard_surface_brass_tiled.mtlx' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [MaterialXLoader](#MaterialXLoader) ⇐ <code>Loader</code>
    * [new MaterialXLoader([manager])](#new_MaterialXLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#MaterialXLoader+load) ⇒ [<code>MaterialXLoader</code>](#MaterialXLoader)
    * [.parse(text)](#MaterialXLoader+parse) ⇒ <code>Object.&lt;string, NodeMaterial&gt;</code>

<a name="new_MaterialXLoader_new"></a>

### new MaterialXLoader([manager])
Constructs a new MaterialX loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="MaterialXLoader+load"></a>

### materialXLoader.load(url, onLoad, onProgress, onError) ⇒ [<code>MaterialXLoader</code>](#MaterialXLoader)
Starts loading from the given URL and passes the loaded MaterialX asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>MaterialXLoader</code>](#MaterialXLoader)  
**Returns**: [<code>MaterialXLoader</code>](#MaterialXLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="MaterialXLoader+parse"></a>

### materialXLoader.parse(text) ⇒ <code>Object.&lt;string, NodeMaterial&gt;</code>
Parses the given MaterialX data and returns the resulting materials.

**Kind**: instance method of [<code>MaterialXLoader</code>](#MaterialXLoader)  
**Returns**: <code>Object.&lt;string, NodeMaterial&gt;</code> - A dictionary holding the parse node materials.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw MaterialX data as a string. |

<a name="NRRDLoader"></a>

## NRRDLoader ⇐ <code>Loader</code>
A loader for the NRRD format.

```js
const loader = new NRRDLoader();
const volume = await loader.loadAsync( 'models/nrrd/I.nrrd' );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [NRRDLoader](#NRRDLoader) ⇐ <code>Loader</code>
    * [new NRRDLoader([manager])](#new_NRRDLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#NRRDLoader+load)
    * [.setSegmentation(segmentation)](#NRRDLoader+setSegmentation)
    * [.parse(data)](#NRRDLoader+parse) ⇒ <code>Volume</code>

<a name="new_NRRDLoader_new"></a>

### new NRRDLoader([manager])
Constructs a new NRRD loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="NRRDLoader+load"></a>

### nrrdLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded NRRD asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>NRRDLoader</code>](#NRRDLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="NRRDLoader+setSegmentation"></a>

### nrrdLoader.setSegmentation(segmentation)
Toggles the segmentation mode.

**Kind**: instance method of [<code>NRRDLoader</code>](#NRRDLoader)  

| Param | Type | Description |
| --- | --- | --- |
| segmentation | <code>boolean</code> | Whether to use segmentation mode or not. |

<a name="NRRDLoader+parse"></a>

### nrrdLoader.parse(data) ⇒ <code>Volume</code>
Parses the given NRRD data and returns the resulting volume data.

**Kind**: instance method of [<code>NRRDLoader</code>](#NRRDLoader)  
**Returns**: <code>Volume</code> - The parsed volume.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw NRRD data as an array buffer. |

<a name="OBJLoader"></a>

## OBJLoader ⇐ <code>Loader</code>
A loader for the OBJ format.

The [OBJ format](https://en.wikipedia.org/wiki/Wavefront_.obj_file) is a simple data-format that
represents 3D geometry in a human readable format as the position of each vertex, the UV position of
each texture coordinate vertex, vertex normals, and the faces that make each polygon defined as a list
of vertices, and texture vertices.

```js
const loader = new OBJLoader();
const object = await loader.loadAsync( 'models/monster.obj' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [OBJLoader](#OBJLoader) ⇐ <code>Loader</code>
    * [new OBJLoader([manager])](#new_OBJLoader_new)
    * [.materials](#OBJLoader+materials) : <code>MaterialCreator</code>
    * [.load(url, onLoad, onProgress, onError)](#OBJLoader+load)
    * [.setMaterials(materials)](#OBJLoader+setMaterials) ⇒ [<code>OBJLoader</code>](#OBJLoader)
    * [.parse(text)](#OBJLoader+parse) ⇒ <code>Group</code>

<a name="new_OBJLoader_new"></a>

### new OBJLoader([manager])
Constructs a new OBJ loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="OBJLoader+materials"></a>

### objLoader.materials : <code>MaterialCreator</code>
A reference to a material creator.

**Kind**: instance property of [<code>OBJLoader</code>](#OBJLoader)  
**Default**: <code>null</code>  
<a name="OBJLoader+load"></a>

### objLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded OBJ asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>OBJLoader</code>](#OBJLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="OBJLoader+setMaterials"></a>

### objLoader.setMaterials(materials) ⇒ [<code>OBJLoader</code>](#OBJLoader)
Sets the material creator for this OBJ. This object is loaded via [MTLLoader](MTLLoader).

**Kind**: instance method of [<code>OBJLoader</code>](#OBJLoader)  
**Returns**: [<code>OBJLoader</code>](#OBJLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| materials | <code>MaterialCreator</code> | An object that creates the materials for this OBJ. |

<a name="OBJLoader+parse"></a>

### objLoader.parse(text) ⇒ <code>Group</code>
Parses the given OBJ data and returns the resulting group.

**Kind**: instance method of [<code>OBJLoader</code>](#OBJLoader)  
**Returns**: <code>Group</code> - The parsed OBJ.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw OBJ data as a string. |

<a name="PCDLoader"></a>

## PCDLoader ⇐ <code>Loader</code>
A loader for the Point Cloud Data (PCD) format.

PCDLoader supports ASCII and (compressed) binary files as well as the following PCD fields:
- x y z
- rgb
- normal_x normal_y normal_z
- intensity
- label

```js
const loader = new PCDLoader();

const points = await loader.loadAsync( './models/pcd/binary/Zaghetto.pcd' );
points.geometry.center(); // optional
points.geometry.rotateX( Math.PI ); // optional
scene.add( points );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [PCDLoader](#PCDLoader) ⇐ <code>Loader</code>
    * [new PCDLoader([manager])](#new_PCDLoader_new)
    * [.littleEndian](#PCDLoader+littleEndian) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#PCDLoader+load)
    * [.parse(data)](#PCDLoader+parse) ⇒ <code>Points</code>

<a name="new_PCDLoader_new"></a>

### new PCDLoader([manager])
Constructs a new PCD loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="PCDLoader+littleEndian"></a>

### pcdLoader.littleEndian : <code>boolean</code>
Whether to use little Endian or not.

**Kind**: instance property of [<code>PCDLoader</code>](#PCDLoader)  
**Default**: <code>true</code>  
<a name="PCDLoader+load"></a>

### pcdLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded PCD asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>PCDLoader</code>](#PCDLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="PCDLoader+parse"></a>

### pcdLoader.parse(data) ⇒ <code>Points</code>
Parses the given PCD data and returns a point cloud.

**Kind**: instance method of [<code>PCDLoader</code>](#PCDLoader)  
**Returns**: <code>Points</code> - The parsed point cloud.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw PCD data as an array buffer. |

<a name="PDBLoader"></a>

## PDBLoader ⇐ <code>Loader</code>
A loader for the PDB format.

The [Protein Data Bank](https://en.wikipedia.org/wiki/Protein_Data_Bank_(file_format))
file format is a textual file describing the three-dimensional structures of molecules.

```js
const loader = new PDBLoader();
const pdb = await loader.loadAsync( 'models/pdb/ethanol.pdb' );

const geometryAtoms = pdb.geometryAtoms;
const geometryBonds = pdb.geometryBonds;
const json = pdb.json;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [PDBLoader](#PDBLoader) ⇐ <code>Loader</code>
    * [new PDBLoader([manager])](#new_PDBLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#PDBLoader+load)
    * [.parse(text)](#PDBLoader+parse) ⇒ <code>Object</code>

<a name="new_PDBLoader_new"></a>

### new PDBLoader([manager])
Constructs a new PDB loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="PDBLoader+load"></a>

### pdbLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded PDB asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>PDBLoader</code>](#PDBLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="PDBLoader+parse"></a>

### pdbLoader.parse(text) ⇒ <code>Object</code>
Parses the given PDB data and returns an object holding the atoms and
bond geometries as well as the raw atom data as JSON.

**Kind**: instance method of [<code>PDBLoader</code>](#PDBLoader)  
**Returns**: <code>Object</code> - The result object.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw PDB data as a string. |

<a name="PLYLoader"></a>

## PLYLoader ⇐ <code>Loader</code>
A loader for PLY the PLY format (known as the Polygon
File Format or the Stanford Triangle Format).

Limitations:
 - ASCII decoding assumes file is UTF-8.

```js
const loader = new PLYLoader();
const geometry = await loader.loadAsync( './models/ply/ascii/dolphins.ply' );
scene.add( new THREE.Mesh( geometry ) );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [PLYLoader](#PLYLoader) ⇐ <code>Loader</code>
    * [new PLYLoader([manager])](#new_PLYLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#PLYLoader+load)
    * [.setPropertyNameMapping(mapping)](#PLYLoader+setPropertyNameMapping)
    * [.setCustomPropertyNameMapping(mapping)](#PLYLoader+setCustomPropertyNameMapping)
    * [.parse(data)](#PLYLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_PLYLoader_new"></a>

### new PLYLoader([manager])
Constructs a new PLY loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="PLYLoader+load"></a>

### plyLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded PLY asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>PLYLoader</code>](#PLYLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="PLYLoader+setPropertyNameMapping"></a>

### plyLoader.setPropertyNameMapping(mapping)
Sets a property name mapping that maps default property names
to custom ones. For example, the following maps the properties
“diffuse_(red|green|blue)” in the file to standard color names.

```js
loader.setPropertyNameMapping( {
	diffuse_red: 'red',
	diffuse_green: 'green',
	diffuse_blue: 'blue'
} );
```

**Kind**: instance method of [<code>PLYLoader</code>](#PLYLoader)  

| Param | Type | Description |
| --- | --- | --- |
| mapping | <code>Object</code> | The mapping dictionary. |

<a name="PLYLoader+setCustomPropertyNameMapping"></a>

### plyLoader.setCustomPropertyNameMapping(mapping)
Custom properties outside of the defaults for position, uv, normal
and color attributes can be added using the setCustomPropertyNameMapping method.
For example, the following maps the element properties “custom_property_a”
and “custom_property_b” to an attribute “customAttribute” with an item size of 2.
Attribute item sizes are set from the number of element properties in the property array.

```js
loader.setCustomPropertyNameMapping( {
	customAttribute: ['custom_property_a', 'custom_property_b'],
} );
```

**Kind**: instance method of [<code>PLYLoader</code>](#PLYLoader)  

| Param | Type | Description |
| --- | --- | --- |
| mapping | <code>Object</code> | The mapping dictionary. |

<a name="PLYLoader+parse"></a>

### plyLoader.parse(data) ⇒ <code>BufferGeometry</code>
Parses the given PLY data and returns the resulting geometry.

**Kind**: instance method of [<code>PLYLoader</code>](#PLYLoader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw PLY data as an array buffer. |

<a name="PVRLoader"></a>

## PVRLoader ⇐ <code>CompressedTextureLoader</code>
A loader for the PVRTC texture compression format.

```js
const loader = new PVRLoader();

const map = loader.load( 'textures/compressed/disturb_4bpp_rgb.pvr' );
map.colorSpace = THREE.SRGBColorSpace; // only for color textures
```

**Kind**: global class  
**Extends**: <code>CompressedTextureLoader</code>  

* [PVRLoader](#PVRLoader) ⇐ <code>CompressedTextureLoader</code>
    * [new PVRLoader([manager])](#new_PVRLoader_new)
    * [.parse(buffer, loadMipmaps)](#PVRLoader+parse) ⇒ <code>CompressedTextureLoader~TexData</code>

<a name="new_PVRLoader_new"></a>

### new PVRLoader([manager])
Constructs a new PVR loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="PVRLoader+parse"></a>

### pvrLoader.parse(buffer, loadMipmaps) ⇒ <code>CompressedTextureLoader~TexData</code>
Parses the given PVRTC texture data.

**Kind**: instance method of [<code>PVRLoader</code>](#PVRLoader)  
**Returns**: <code>CompressedTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |
| loadMipmaps | <code>boolean</code> | Whether to load mipmaps or not. This option is not yet supported by the loader. |

<a name="RGBELoader"></a>

## RGBELoader ⇐ <code>DataTextureLoader</code>
A loader for the RGBE HDR texture format.

```js
const loader = new RGBELoader();
const envMap = await loader.loadAsync( 'textures/equirectangular/blouberg_sunrise_2_1k.hdr' );
envMap.mapping = THREE.EquirectangularReflectionMapping;

scene.environment = envMap;
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [RGBELoader](#RGBELoader) ⇐ <code>DataTextureLoader</code>
    * [new RGBELoader([manager])](#new_RGBELoader_new)
    * [.type](#RGBELoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.parse(buffer)](#RGBELoader+parse) ⇒ <code>DataTextureLoader~TexData</code>
    * [.setDataType(value)](#RGBELoader+setDataType) ⇒ [<code>RGBELoader</code>](#RGBELoader)

<a name="new_RGBELoader_new"></a>

### new RGBELoader([manager])
Constructs a new RGBE loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="RGBELoader+type"></a>

### rgbeLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>RGBELoader</code>](#RGBELoader)  
**Default**: <code>HalfFloatType</code>  
<a name="RGBELoader+parse"></a>

### rgbeLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given RGBE texture data.

**Kind**: instance method of [<code>RGBELoader</code>](#RGBELoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="RGBELoader+setDataType"></a>

### rgbeLoader.setDataType(value) ⇒ [<code>RGBELoader</code>](#RGBELoader)
Sets the texture type.

**Kind**: instance method of [<code>RGBELoader</code>](#RGBELoader)  
**Returns**: [<code>RGBELoader</code>](#RGBELoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="RGBMLoader"></a>

## RGBMLoader ⇐ <code>DataTextureLoader</code>
A loader for the RGBM HDR texture format.

```js
const loader = new RGBMLoader();
loader.setMaxRange( 16 );

const texture = await loader.loadAsync( 'textures/memorial.png' );
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [RGBMLoader](#RGBMLoader) ⇐ <code>DataTextureLoader</code>
    * [new RGBMLoader([manager])](#new_RGBMLoader_new)
    * [.type](#RGBMLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.maxRange](#RGBMLoader+maxRange) : <code>7</code> \| <code>16</code>
    * [.setDataType(value)](#RGBMLoader+setDataType) ⇒ [<code>RGBMLoader</code>](#RGBMLoader)
    * [.setMaxRange(value)](#RGBMLoader+setMaxRange) ⇒ [<code>RGBMLoader</code>](#RGBMLoader)
    * [.loadCubemap(urls, onLoad, onProgress, onError)](#RGBMLoader+loadCubemap) ⇒ <code>CubeTexture</code>
    * [.loadCubemapAsync(urls, onProgress)](#RGBMLoader+loadCubemapAsync) ⇒ <code>Promise.&lt;CubeTexture&gt;</code>
    * [.parse(buffer)](#RGBMLoader+parse) ⇒ <code>DataTextureLoader~TexData</code>

<a name="new_RGBMLoader_new"></a>

### new RGBMLoader([manager])
Constructs a new RGBM loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="RGBMLoader+type"></a>

### rgbmLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>RGBMLoader</code>](#RGBMLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="RGBMLoader+maxRange"></a>

### rgbmLoader.maxRange : <code>7</code> \| <code>16</code>
More information about this property at [The difference between RGBM and RGBD](https://iwasbeingirony.blogspot.com/2010/06/difference-between-rgbm-and-rgbd.html)

**Kind**: instance property of [<code>RGBMLoader</code>](#RGBMLoader)  
**Default**: <code>7</code>  
<a name="RGBMLoader+setDataType"></a>

### rgbmLoader.setDataType(value) ⇒ [<code>RGBMLoader</code>](#RGBMLoader)
Sets the texture type.

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: [<code>RGBMLoader</code>](#RGBMLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="RGBMLoader+setMaxRange"></a>

### rgbmLoader.setMaxRange(value) ⇒ [<code>RGBMLoader</code>](#RGBMLoader)
Sets the maximum range.

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: [<code>RGBMLoader</code>](#RGBMLoader) - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>7</code> \| <code>16</code> | The maximum range to set. |

<a name="RGBMLoader+loadCubemap"></a>

### rgbmLoader.loadCubemap(urls, onLoad, onProgress, onError) ⇒ <code>CubeTexture</code>
Starts loading from the given URLs and passes the loaded RGBM cube map
to the `onLoad()` callback.

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: <code>CubeTexture</code> - The cube texture.  

| Param | Type | Description |
| --- | --- | --- |
| urls | <code>Array.&lt;string&gt;</code> | The paths/URLs of the files to be loaded. This can also be a data URIs. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="RGBMLoader+loadCubemapAsync"></a>

### rgbmLoader.loadCubemapAsync(urls, onProgress) ⇒ <code>Promise.&lt;CubeTexture&gt;</code>
Async version of [loadCubemap](#RGBMLoader+loadCubemap).

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: <code>Promise.&lt;CubeTexture&gt;</code> - A Promise that resolves with the loaded cube map.  

| Param | Type | Description |
| --- | --- | --- |
| urls | <code>Array.&lt;string&gt;</code> | The paths/URLs of the files to be loaded. This can also be a data URIs. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |

<a name="RGBMLoader+parse"></a>

### rgbmLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given RGBM texture data.

**Kind**: instance method of [<code>RGBMLoader</code>](#RGBMLoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="STLLoader"></a>

## STLLoader ⇐ <code>Loader</code>
A loader for the STL format, as created by Solidworks and other CAD programs.

Supports both binary and ASCII encoded files. The loader returns a non-indexed buffer geometry.

Limitations:
- Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
- There is perhaps some question as to how valid it is to always assume little-endian-ness.
- ASCII decoding assumes file is UTF-8.

```js
const loader = new STLLoader();
const geometry = await loader.loadAsync( './models/stl/slotted_disk.stl' )
scene.add( new THREE.Mesh( geometry ) );
```
For binary STLs geometry might contain colors for vertices. To use it:
```js
// use the same code to load STL as above
if ( geometry.hasColors ) {
	material = new THREE.MeshPhongMaterial( { opacity: geometry.alpha, vertexColors: true } );
}
const mesh = new THREE.Mesh( geometry, material );
```
For ASCII STLs containing multiple solids, each solid is assigned to a different group.
Groups can be used to assign a different color by defining an array of materials with the same length of
geometry.groups and passing it to the Mesh constructor:

```js
const materials = [];
const nGeometryGroups = geometry.groups.length;

for ( let i = 0; i < nGeometryGroups; i ++ ) {
	const material = new THREE.MeshPhongMaterial( { color: colorMap[ i ], wireframe: false } );
	materials.push( material );
}

const mesh = new THREE.Mesh(geometry, materials);
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [STLLoader](#STLLoader) ⇐ <code>Loader</code>
    * [new STLLoader([manager])](#new_STLLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#STLLoader+load)
    * [.parse(data)](#STLLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_STLLoader_new"></a>

### new STLLoader([manager])
Constructs a new STL loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="STLLoader+load"></a>

### stlLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded STL asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>STLLoader</code>](#STLLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="STLLoader+parse"></a>

### stlLoader.parse(data) ⇒ <code>BufferGeometry</code>
Parses the given STL data and returns the resulting geometry.

**Kind**: instance method of [<code>STLLoader</code>](#STLLoader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw STL data as an array buffer. |

<a name="SVGLoader"></a>

## SVGLoader ⇐ <code>Loader</code>
A loader for the SVG format.

Scalable Vector Graphics is an XML-based vector image format for two-dimensional graphics
with support for interactivity and animation.

```js
const loader = new SVGLoader();
const data = await loader.loadAsync( 'data/svgSample.svg' );

const paths = data.paths;
const group = new THREE.Group();

for ( let i = 0; i < paths.length; i ++ ) {

	const path = paths[ i ];
	const material = new THREE.MeshBasicMaterial( {
		color: path.color,
		side: THREE.DoubleSide,
		depthWrite: false
	} );

	const shapes = SVGLoader.createShapes( path );

	for ( let j = 0; j < shapes.length; j ++ ) {

		const shape = shapes[ j ];
		const geometry = new THREE.ShapeGeometry( shape );
		const mesh = new THREE.Mesh( geometry, material );
		group.add( mesh );

	}

}

scene.add( group );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [SVGLoader](#SVGLoader) ⇐ <code>Loader</code>
    * [new SVGLoader([manager])](#new_SVGLoader_new)
    * _instance_
        * [.defaultDPI](#SVGLoader+defaultDPI) : <code>number</code>
        * [.defaultUnit](#SVGLoader+defaultUnit) : <code>&#x27;mm&#x27;</code> \| <code>&#x27;cm&#x27;</code> \| <code>&#x27;in&#x27;</code> \| <code>&#x27;pt&#x27;</code> \| <code>&#x27;pc&#x27;</code> \| <code>&#x27;px&#x27;</code>
        * [.load(url, onLoad, onProgress, onError)](#SVGLoader+load)
        * [.parse(text)](#SVGLoader+parse) ⇒ <code>Object</code>
    * _static_
        * [.createShapes(shapePath)](#SVGLoader.createShapes) ⇒ <code>Array.&lt;Shape&gt;</code>
        * [.getStrokeStyle([width], [color], [lineJoin], [lineCap], [miterLimit])](#SVGLoader.getStrokeStyle) ⇒ <code>Object</code>
        * [.pointsToStroke(points, style, [arcDivisions], [minDistance])](#SVGLoader.pointsToStroke) ⇒ <code>BufferGeometry</code>
        * [.pointsToStrokeWithBuffers(points, style, [arcDivisions], [minDistance], vertices, normals, uvs, [vertexOffset])](#SVGLoader.pointsToStrokeWithBuffers) ⇒ <code>number</code>

<a name="new_SVGLoader_new"></a>

### new SVGLoader([manager])
Constructs a new SVG loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="SVGLoader+defaultDPI"></a>

### svgLoader.defaultDPI : <code>number</code>
Default dots per inch.

**Kind**: instance property of [<code>SVGLoader</code>](#SVGLoader)  
**Default**: <code>90</code>  
<a name="SVGLoader+defaultUnit"></a>

### svgLoader.defaultUnit : <code>&#x27;mm&#x27;</code> \| <code>&#x27;cm&#x27;</code> \| <code>&#x27;in&#x27;</code> \| <code>&#x27;pt&#x27;</code> \| <code>&#x27;pc&#x27;</code> \| <code>&#x27;px&#x27;</code>
Default unit.

**Kind**: instance property of [<code>SVGLoader</code>](#SVGLoader)  
**Default**: <code>&#x27;px&#x27;</code>  
<a name="SVGLoader+load"></a>

### svgLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded SVG asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>SVGLoader</code>](#SVGLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="SVGLoader+parse"></a>

### svgLoader.parse(text) ⇒ <code>Object</code>
Parses the given SVG data and returns the resulting data.

**Kind**: instance method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>Object</code> - An object holding an array of shape paths and the
SVG XML document.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw SVG data as a string. |

<a name="SVGLoader.createShapes"></a>

### SVGLoader.createShapes(shapePath) ⇒ <code>Array.&lt;Shape&gt;</code>
Creates from the given shape path and array of shapes.

**Kind**: static method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>Array.&lt;Shape&gt;</code> - An array of shapes.  

| Param | Type | Description |
| --- | --- | --- |
| shapePath | <code>ShapePath</code> | The shape path. |

<a name="SVGLoader.getStrokeStyle"></a>

### SVGLoader.getStrokeStyle([width], [color], [lineJoin], [lineCap], [miterLimit]) ⇒ <code>Object</code>
Returns a stroke style object from the given parameters.

**Kind**: static method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>Object</code> - The style object.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>1</code> | The stroke width. |
| [color] | <code>string</code> | <code>&quot;&#x27;#000&#x27;&quot;</code> | The stroke color, as  returned by [Color#getStyle](Color#getStyle). |
| [lineJoin] | <code>&#x27;round&#x27;</code> \| <code>&#x27;bevel&#x27;</code> \| <code>&#x27;miter&#x27;</code> \| <code>&#x27;miter-limit&#x27;</code> | <code>&#x27;miter&#x27;</code> | The line join style. |
| [lineCap] | <code>&#x27;round&#x27;</code> \| <code>&#x27;square&#x27;</code> \| <code>&#x27;butt&#x27;</code> | <code>&#x27;butt&#x27;</code> | The line cap style. |
| [miterLimit] | <code>number</code> | <code>4</code> | Maximum join length, in multiples of the `width` parameter (join is truncated if it exceeds that distance). |

<a name="SVGLoader.pointsToStroke"></a>

### SVGLoader.pointsToStroke(points, style, [arcDivisions], [minDistance]) ⇒ <code>BufferGeometry</code>
Creates a stroke from an array of points.

**Kind**: static method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>BufferGeometry</code> - The stroke geometry. UV coordinates are generated ('u' along path. 'v' across it, from left to right).
Returns `null` if not geometry was generated.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| points | <code>Array.&lt;Vector2&gt;</code> |  | The points in 2D space. Minimum 2 points. The path can be open or closed (last point equals to first point). |
| style | <code>Object</code> |  | Object with SVG properties as returned by `SVGLoader.getStrokeStyle()`, or `SVGLoader.parse()` in the `path.userData.style` object. |
| [arcDivisions] | <code>number</code> | <code>12</code> | Arc divisions for round joins and endcaps. |
| [minDistance] | <code>number</code> | <code>0.001</code> | Points closer to this distance will be merged. |

<a name="SVGLoader.pointsToStrokeWithBuffers"></a>

### SVGLoader.pointsToStrokeWithBuffers(points, style, [arcDivisions], [minDistance], vertices, normals, uvs, [vertexOffset]) ⇒ <code>number</code>
Creates a stroke from an array of points.

**Kind**: static method of [<code>SVGLoader</code>](#SVGLoader)  
**Returns**: <code>number</code> - The number of vertices.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| points | <code>Array.&lt;Vector2&gt;</code> |  | The points in 2D space. Minimum 2 points. |
| style | <code>Object</code> |  | Object with SVG properties as returned by `SVGLoader.getStrokeStyle()`, or `SVGLoader.parse()` in the `path.userData.style` object. |
| [arcDivisions] | <code>number</code> | <code>12</code> | Arc divisions for round joins and endcaps. |
| [minDistance] | <code>number</code> | <code>0.001</code> | Points closer to this distance will be merged. |
| vertices | <code>Array.&lt;number&gt;</code> |  | An array holding vertices. |
| normals | <code>Array.&lt;number&gt;</code> |  | An array holding normals. |
| uvs | <code>Array.&lt;number&gt;</code> |  | An array holding uvs. |
| [vertexOffset] | <code>number</code> | <code>0</code> | The vertex offset. |

<a name="TDSLoader"></a>

## TDSLoader ⇐ <code>Loader</code>
A loader for the 3DS format, based on lib3ds.

Loads geometry with uv and materials basic properties with texture support.

```js
const loader = new TDSLoader();
loader.setResourcePath( 'models/3ds/portalgun/textures/' );
const object = await loader.loadAsync( 'models/3ds/portalgun/portalgun.3ds' );
scene.add( object );

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [TDSLoader](#TDSLoader) ⇐ <code>Loader</code>
    * [new TDSLoader([manager])](#new_TDSLoader_new)
    * [.debug](#TDSLoader+debug) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#TDSLoader+load)
    * [.parse(arraybuffer, path)](#TDSLoader+parse) ⇒ <code>Group</code>

<a name="new_TDSLoader_new"></a>

### new TDSLoader([manager])
Constructs a new 3DS loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TDSLoader+debug"></a>

### tdsLoader.debug : <code>boolean</code>
Whether debug mode should be enabled or not.

**Kind**: instance property of [<code>TDSLoader</code>](#TDSLoader)  
**Default**: <code>false</code>  
<a name="TDSLoader+load"></a>

### tdsLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded 3DS asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>TDSLoader</code>](#TDSLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="TDSLoader+parse"></a>

### tdsLoader.parse(arraybuffer, path) ⇒ <code>Group</code>
Parses the given 3DS data and returns the resulting data.

**Kind**: instance method of [<code>TDSLoader</code>](#TDSLoader)  
**Returns**: <code>Group</code> - The parsed asset represented as a group.  

| Param | Type | Description |
| --- | --- | --- |
| arraybuffer | <code>ArrayBuffer</code> | The raw 3DS data as an array buffer. |
| path | <code>string</code> | The asset path. |

<a name="TGALoader"></a>

## TGALoader ⇐ <code>DataTextureLoader</code>
A loader for the TGA texture format.

```js
const loader = new TGALoader();
const texture = await loader.loadAsync( 'textures/crate_color8.tga' );
texture.colorSpace = THREE.SRGBColorSpace; // only for color textures
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [TGALoader](#TGALoader) ⇐ <code>DataTextureLoader</code>
    * [new TGALoader([manager])](#new_TGALoader_new)
    * [.parse(buffer)](#TGALoader+parse) ⇒ <code>DataTextureLoader~TexData</code>

<a name="new_TGALoader_new"></a>

### new TGALoader([manager])
Constructs a new TGA loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TGALoader+parse"></a>

### tgaLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given TGA texture data.

**Kind**: instance method of [<code>TGALoader</code>](#TGALoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="TIFFLoader"></a>

## TIFFLoader ⇐ <code>DataTextureLoader</code>
A loader for the TIFF texture format.

```js
const loader = new TIFFLoader();
const texture = await loader.loadAsync( 'textures/tiff/crate_lzw.tif' );
texture.colorSpace = THREE.SRGBColorSpace;
```

**Kind**: global class  
**Extends**: <code>DataTextureLoader</code>  

* [TIFFLoader](#TIFFLoader) ⇐ <code>DataTextureLoader</code>
    * [new TIFFLoader([manager])](#new_TIFFLoader_new)
    * [.parse(buffer)](#TIFFLoader+parse) ⇒ <code>DataTextureLoader~TexData</code>

<a name="new_TIFFLoader_new"></a>

### new TIFFLoader([manager])
Constructs a new TIFF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TIFFLoader+parse"></a>

### tiffLoader.parse(buffer) ⇒ <code>DataTextureLoader~TexData</code>
Parses the given TIFF texture data.

**Kind**: instance method of [<code>TIFFLoader</code>](#TIFFLoader)  
**Returns**: <code>DataTextureLoader~TexData</code> - An object representing the parsed texture data.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |

<a name="TTFLoader"></a>

## TTFLoader ⇐ <code>Loader</code>
A loader for the TTF format.

Loads TTF files and converts them into typeface JSON that can be used directly
to create THREE.Font objects.

```js
const loader = new TTFLoader();
const json = await loader.loadAsync( 'fonts/ttf/kenpixel.ttf' );
const font = new Font( json );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [TTFLoader](#TTFLoader) ⇐ <code>Loader</code>
    * [new TTFLoader([manager])](#new_TTFLoader_new)
    * [.reversed](#TTFLoader+reversed) : <code>boolean</code>
    * [.load(url, onLoad, onProgress, onError)](#TTFLoader+load)
    * [.parse(arraybuffer)](#TTFLoader+parse) ⇒ <code>Object</code>

<a name="new_TTFLoader_new"></a>

### new TTFLoader([manager])
Constructs a new TTF loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="TTFLoader+reversed"></a>

### ttfLoader.reversed : <code>boolean</code>
Whether the TTF commands should be reversed or not.

**Kind**: instance property of [<code>TTFLoader</code>](#TTFLoader)  
**Default**: <code>false</code>  
<a name="TTFLoader+load"></a>

### ttfLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded TTF asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>TTFLoader</code>](#TTFLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="TTFLoader+parse"></a>

### ttfLoader.parse(arraybuffer) ⇒ <code>Object</code>
Parses the given TTF data and returns a JSON for creating a font.

**Kind**: instance method of [<code>TTFLoader</code>](#TTFLoader)  
**Returns**: <code>Object</code> - The result JSON.  

| Param | Type | Description |
| --- | --- | --- |
| arraybuffer | <code>ArrayBuffer</code> | The raw TTF data as an array buffer. |

<a name="USDZLoader"></a>

## USDZLoader ⇐ <code>Loader</code>
A loader for the USDZ format.

USDZ files that use USDC internally are not yet supported, only USDA.

```js
const loader = new USDZLoader();
const model = await loader.loadAsync( 'saeukkang.usdz' );
scene.add( model );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [USDZLoader](#USDZLoader) ⇐ <code>Loader</code>
    * [new USDZLoader([manager])](#new_USDZLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#USDZLoader+load)
    * [.parse(buffer)](#USDZLoader+parse) ⇒ <code>Group</code>

<a name="new_USDZLoader_new"></a>

### new USDZLoader([manager])
Constructs a new USDZ loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="USDZLoader+load"></a>

### usdzLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded USDZ asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>USDZLoader</code>](#USDZLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="USDZLoader+parse"></a>

### usdzLoader.parse(buffer) ⇒ <code>Group</code>
Parses the given USDZ data and returns the resulting group.

**Kind**: instance method of [<code>USDZLoader</code>](#USDZLoader)  
**Returns**: <code>Group</code> - The parsed asset as a group.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw USDZ data as an array buffer. |

## Classes

<dl>
<dt><a href="#UltraHDRLoader">UltraHDRLoader</a> ⇐ <code>Loader</code></dt>
<dd><p>A loader for the Ultra HDR Image Format.</p>
<p>Existing HDR or EXR textures can be converted to Ultra HDR with this <a href="https://gainmap-creator.monogrid.com/">tool</a>.</p>
<p>Current feature set:</p>
<ul>
<li>JPEG headers (required)</li>
<li>XMP metadata (required)</li>
<li>XMP validation (not implemented)</li>
<li>EXIF profile (not implemented)</li>
<li>ICC profile (not implemented)</li>
<li>Binary storage for SDR &amp; HDR images (required)</li>
<li>Gainmap metadata (required)</li>
<li>Non-JPEG image formats (not implemented)</li>
<li>Primary image as an HDR image (not implemented)</li>
</ul>
<pre><code class="language-js">const loader = new UltraHDRLoader();
const texture = await loader.loadAsync( &#39;textures/equirectangular/ice_planet_close.jpg&#39; );
texture.mapping = THREE.EquirectangularReflectionMapping;

scene.background = texture;
scene.environment = texture;
</code></pre>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#SRGB_TO_LINEAR">SRGB_TO_LINEAR</a></dt>
<dd><p>UltraHDR Image Format - <a href="https://developer.android.com/media/platform/hdr-image-format">https://developer.android.com/media/platform/hdr-image-format</a></p>
<p>Short format brief:</p>
<p> [JPEG headers]
 [XMP metadata describing the MPF container and <em>both</em> SDR and gainmap images]
 [Optional metadata] [EXIF] [ICC Profile]
 [SDR image]
 [XMP metadata describing only the gainmap image]
 [Gainmap image]</p>
<p>Each section is separated by a 0xFFXX byte followed by a descriptor byte (0xFFE0, 0xFFE1, 0xFFE2.)
Binary image storages are prefixed with a unique 0xFFD8 16-bit descriptor.</p>
</dd>
</dl>

<a name="UltraHDRLoader"></a>

## UltraHDRLoader ⇐ <code>Loader</code>
A loader for the Ultra HDR Image Format.

Existing HDR or EXR textures can be converted to Ultra HDR with this [tool](https://gainmap-creator.monogrid.com/).

Current feature set:
- JPEG headers (required)
- XMP metadata (required)
- XMP validation (not implemented)
- EXIF profile (not implemented)
- ICC profile (not implemented)
- Binary storage for SDR & HDR images (required)
- Gainmap metadata (required)
- Non-JPEG image formats (not implemented)
- Primary image as an HDR image (not implemented)

```js
const loader = new UltraHDRLoader();
const texture = await loader.loadAsync( 'textures/equirectangular/ice_planet_close.jpg' );
texture.mapping = THREE.EquirectangularReflectionMapping;

scene.background = texture;
scene.environment = texture;
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [UltraHDRLoader](#UltraHDRLoader) ⇐ <code>Loader</code>
    * [new UltraHDRLoader([manager])](#new_UltraHDRLoader_new)
    * [.type](#UltraHDRLoader+type) : <code>HalfFloatType</code> \| <code>FloatType</code>
    * [.setDataType(value)](#UltraHDRLoader+setDataType) ⇒ <code>RGBELoader</code>
    * [.parse(buffer, onLoad)](#UltraHDRLoader+parse)
    * [.load(url, onLoad, onProgress, onError)](#UltraHDRLoader+load) ⇒ <code>DataTexture</code>

<a name="new_UltraHDRLoader_new"></a>

### new UltraHDRLoader([manager])
Constructs a new Ultra HDR loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="UltraHDRLoader+type"></a>

### ultraHDRLoader.type : <code>HalfFloatType</code> \| <code>FloatType</code>
The texture type.

**Kind**: instance property of [<code>UltraHDRLoader</code>](#UltraHDRLoader)  
**Default**: <code>HalfFloatType</code>  
<a name="UltraHDRLoader+setDataType"></a>

### ultraHDRLoader.setDataType(value) ⇒ <code>RGBELoader</code>
Sets the texture type.

**Kind**: instance method of [<code>UltraHDRLoader</code>](#UltraHDRLoader)  
**Returns**: <code>RGBELoader</code> - A reference to this loader.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>HalfFloatType</code> \| <code>FloatType</code> | The texture type to set. |

<a name="UltraHDRLoader+parse"></a>

### ultraHDRLoader.parse(buffer, onLoad)
Parses the given Ultra HDR texture data.

**Kind**: instance method of [<code>UltraHDRLoader</code>](#UltraHDRLoader)  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw texture data. |
| onLoad | <code>function</code> | The `onLoad` callback. |

<a name="UltraHDRLoader+load"></a>

### ultraHDRLoader.load(url, onLoad, onProgress, onError) ⇒ <code>DataTexture</code>
Starts loading from the given URL and passes the loaded Ultra HDR texture
to the `onLoad()` callback.

**Kind**: instance method of [<code>UltraHDRLoader</code>](#UltraHDRLoader)  
**Returns**: <code>DataTexture</code> - The Ultra HDR texture.  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the files to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="SRGB_TO_LINEAR"></a>

## SRGB\_TO\_LINEAR
UltraHDR Image Format - https://developer.android.com/media/platform/hdr-image-format

Short format brief:

 [JPEG headers]
 [XMP metadata describing the MPF container and *both* SDR and gainmap images]
 [Optional metadata] [EXIF] [ICC Profile]
 [SDR image]
 [XMP metadata describing only the gainmap image]
 [Gainmap image]

Each section is separated by a 0xFFXX byte followed by a descriptor byte (0xFFE0, 0xFFE1, 0xFFE2.)
Binary image storages are prefixed with a unique 0xFFD8 16-bit descriptor.

**Kind**: global constant  
## Classes

<dl>
<dt><a href="#VOXLoader">VOXLoader</a> ⇐ <code>Loader</code></dt>
<dd><p>A loader for the VOX format.</p>
<pre><code class="language-js">const loader = new VOXLoader();
const chunks = await loader.loadAsync( &#39;models/vox/monu10.vox&#39; );

for ( let i = 0; i &lt; chunks.length; i ++ ) {

    const chunk = chunks[ i ];
    const mesh = new VOXMesh( chunk );
    mesh.scale.setScalar( 0.0015 );
    scene.add( mesh );

}
</code></pre>
</dd>
<dt><a href="#VOXMesh">VOXMesh</a> ⇐ <code>Mesh</code></dt>
<dd><p>A VOX mesh.</p>
<p>Instances of this class are created from the loaded chunks of <a href="#VOXLoader">VOXLoader</a>.</p>
</dd>
<dt><a href="#VOXData3DTexture">VOXData3DTexture</a> ⇐ <code>Data3DTexture</code></dt>
<dd><p>A VOX 3D texture.</p>
<p>Instances of this class are created from the loaded chunks of <a href="#VOXLoader">VOXLoader</a>.</p>
</dd>
</dl>

<a name="VOXLoader"></a>

## VOXLoader ⇐ <code>Loader</code>
A loader for the VOX format.

```js
const loader = new VOXLoader();
const chunks = await loader.loadAsync( 'models/vox/monu10.vox' );

for ( let i = 0; i < chunks.length; i ++ ) {

	const chunk = chunks[ i ];
	const mesh = new VOXMesh( chunk );
	mesh.scale.setScalar( 0.0015 );
	scene.add( mesh );

}
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [VOXLoader](#VOXLoader) ⇐ <code>Loader</code>
    * [.load(url, onLoad, onProgress, onError)](#VOXLoader+load)
    * [.parse(buffer)](#VOXLoader+parse) ⇒ <code>Array.&lt;Object&gt;</code>

<a name="VOXLoader+load"></a>

### voxLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded VOX asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>VOXLoader</code>](#VOXLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="VOXLoader+parse"></a>

### voxLoader.parse(buffer) ⇒ <code>Array.&lt;Object&gt;</code>
Parses the given VOX data and returns the resulting chunks.

**Kind**: instance method of [<code>VOXLoader</code>](#VOXLoader)  
**Returns**: <code>Array.&lt;Object&gt;</code> - The parsed chunks.  

| Param | Type | Description |
| --- | --- | --- |
| buffer | <code>ArrayBuffer</code> | The raw VOX data as an array buffer. |

<a name="VOXMesh"></a>

## VOXMesh ⇐ <code>Mesh</code>
A VOX mesh.

Instances of this class are created from the loaded chunks of [VOXLoader](#VOXLoader).

**Kind**: global class  
**Extends**: <code>Mesh</code>  
<a name="new_VOXMesh_new"></a>

### new VOXMesh(chunk)
Constructs a new VOX mesh.


| Param | Type | Description |
| --- | --- | --- |
| chunk | <code>Object</code> | A VOX chunk loaded via [VOXLoader](#VOXLoader). |

<a name="VOXData3DTexture"></a>

## VOXData3DTexture ⇐ <code>Data3DTexture</code>
A VOX 3D texture.

Instances of this class are created from the loaded chunks of [VOXLoader](#VOXLoader).

**Kind**: global class  
**Extends**: <code>Data3DTexture</code>  
<a name="new_VOXData3DTexture_new"></a>

### new VOXData3DTexture(chunk)
Constructs a new VOX 3D texture.


| Param | Type | Description |
| --- | --- | --- |
| chunk | <code>Object</code> | A VOX chunk loaded via [VOXLoader](#VOXLoader). |

<a name="VRMLLoader"></a>

## VRMLLoader ⇐ <code>Loader</code>
A loader for the VRML format.

```js
const loader = new VRMLLoader();
const object = await loader.loadAsync( 'models/vrml/house.wrl' );
scene.add( object );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [VRMLLoader](#VRMLLoader) ⇐ <code>Loader</code>
    * [new VRMLLoader([manager])](#new_VRMLLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#VRMLLoader+load)
    * [.parse(data, path)](#VRMLLoader+parse) ⇒ <code>Scene</code>

<a name="new_VRMLLoader_new"></a>

### new VRMLLoader([manager])
Constructs a new VRML loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="VRMLLoader+load"></a>

### vrmlLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded VRML asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>VRMLLoader</code>](#VRMLLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="VRMLLoader+parse"></a>

### vrmlLoader.parse(data, path) ⇒ <code>Scene</code>
Parses the given VRML data and returns the resulting scene.

**Kind**: instance method of [<code>VRMLLoader</code>](#VRMLLoader)  
**Returns**: <code>Scene</code> - The parsed scene.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>string</code> | The raw VRML data as a string. |
| path | <code>string</code> | The URL base path. |

<a name="VTKLoader"></a>

## VTKLoader ⇐ <code>Loader</code>
A loader for the VTK format.

This loader only supports the `POLYDATA` dataset format so far. Other formats
(structured points, structured grid, rectilinear grid, unstructured grid, appended)
are not supported.

```js
const loader = new VTKLoader();
const geometry = await loader.loadAsync( 'models/vtk/liver.vtk' );
geometry.computeVertexNormals();

const mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial() );
scene.add( mesh );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [VTKLoader](#VTKLoader) ⇐ <code>Loader</code>
    * [new VTKLoader([manager])](#new_VTKLoader_new)
    * [.load(url, onLoad, onProgress, onError)](#VTKLoader+load)
    * [.parse(data)](#VTKLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="new_VTKLoader_new"></a>

### new VTKLoader([manager])
Constructs a new VTK loader.


| Param | Type | Description |
| --- | --- | --- |
| [manager] | <code>LoadingManager</code> | The loading manager. |

<a name="VTKLoader+load"></a>

### vtkLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded VRML asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>VTKLoader</code>](#VTKLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="VTKLoader+parse"></a>

### vtkLoader.parse(data) ⇒ <code>BufferGeometry</code>
Parses the given VTK data and returns the resulting geometry.

**Kind**: instance method of [<code>VTKLoader</code>](#VTKLoader)  
**Returns**: <code>BufferGeometry</code> - The parsed geometry.  

| Param | Type | Description |
| --- | --- | --- |
| data | <code>ArrayBuffer</code> | The raw VTK data as an array buffer |

<a name="XYZLoader"></a>

## XYZLoader ⇐ <code>Loader</code>
A loader for the XYZ format.

XYZ is a very simple format for storing point clouds. The layouts
`XYZ` (points) and `XYZRGB` (points + colors) are supported.

```js
const loader = new XYZLoader();
const geometry = await loader.loadAsync( 'models/xyz/helix_201.xyz' );
geometry.center();

const vertexColors = ( geometry.hasAttribute( 'color' ) === true );
const material = new THREE.PointsMaterial( { size: 0.1, vertexColors: vertexColors } );

const points = new THREE.Points( geometry, material );
scene.add( points );
```

**Kind**: global class  
**Extends**: <code>Loader</code>  

* [XYZLoader](#XYZLoader) ⇐ <code>Loader</code>
    * [.load(url, onLoad, onProgress, onError)](#XYZLoader+load)
    * [.parse(text)](#XYZLoader+parse) ⇒ <code>BufferGeometry</code>

<a name="XYZLoader+load"></a>

### xyzLoader.load(url, onLoad, onProgress, onError)
Starts loading from the given URL and passes the loaded XYZ asset
to the `onLoad()` callback.

**Kind**: instance method of [<code>XYZLoader</code>](#XYZLoader)  

| Param | Type | Description |
| --- | --- | --- |
| url | <code>string</code> | The path/URL of the file to be loaded. This can also be a data URI. |
| onLoad | <code>function</code> | Executed when the loading process has been finished. |
| onProgress | <code>onProgressCallback</code> | Executed while the loading is in progress. |
| onError | <code>onErrorCallback</code> | Executed when errors occur. |

<a name="XYZLoader+parse"></a>

### xyzLoader.parse(text) ⇒ <code>BufferGeometry</code>
Parses the given XYZ data and returns the resulting geometry.

**Kind**: instance method of [<code>XYZLoader</code>](#XYZLoader)  
**Returns**: <code>BufferGeometry</code> - The geometry representing the point cloud.  

| Param | Type | Description |
| --- | --- | --- |
| text | <code>string</code> | The raw XYZ data as a string. |

<a name="LDrawConditionalLineMaterial"></a>

## LDrawConditionalLineMaterial ⇐ <code>ShaderMaterial</code>
A special line material for meshes loaded via [LDrawLoader](LDrawLoader).

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
import the class from `LDrawConditionalLineNodeMaterial.js`.

**Kind**: global class  
**Extends**: <code>ShaderMaterial</code>  

* [LDrawConditionalLineMaterial](#LDrawConditionalLineMaterial) ⇐ <code>ShaderMaterial</code>
    * [new LDrawConditionalLineMaterial([parameters])](#new_LDrawConditionalLineMaterial_new)
    * [.opacity](#LDrawConditionalLineMaterial+opacity) : <code>number</code>
    * [.color](#LDrawConditionalLineMaterial+color) : <code>Color</code>
    * [.isLDrawConditionalLineMaterial](#LDrawConditionalLineMaterial+isLDrawConditionalLineMaterial) : <code>boolean</code>

<a name="new_LDrawConditionalLineMaterial_new"></a>

### new LDrawConditionalLineMaterial([parameters])
Constructs a new conditional line material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="LDrawConditionalLineMaterial+opacity"></a>

### lDrawConditionalLineMaterial.opacity : <code>number</code>
The material's opacity.

**Kind**: instance property of [<code>LDrawConditionalLineMaterial</code>](#LDrawConditionalLineMaterial)  
**Default**: <code>1</code>  
<a name="LDrawConditionalLineMaterial+color"></a>

### lDrawConditionalLineMaterial.color : <code>Color</code>
The material's color.

**Kind**: instance property of [<code>LDrawConditionalLineMaterial</code>](#LDrawConditionalLineMaterial)  
**Default**: <code>(1,1,1)</code>  
<a name="LDrawConditionalLineMaterial+isLDrawConditionalLineMaterial"></a>

### lDrawConditionalLineMaterial.isLDrawConditionalLineMaterial : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LDrawConditionalLineMaterial</code>](#LDrawConditionalLineMaterial)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MeshPostProcessingMaterial"></a>

## MeshPostProcessingMaterial ⇐ <code>MeshPhysicalMaterial</code>
The aim of this mesh material is to use information from a post processing pass in the diffuse color pass.
This material is based on the MeshPhysicalMaterial.

In the current state, only the information of a screen space AO pass can be used in the material.
Actually, the output of any screen space AO (SSAO, GTAO) can be used,
as it is only necessary to provide the AO in one color channel of a texture,
however the AO pass must be rendered prior to the color pass,
which makes the post-processing pass somewhat of a pre-processing pass.
Fot this purpose a new map (`aoPassMap`) is added to the material.
The value of the map is used the same way as the `aoMap` value.

Motivation to use the outputs AO pass directly in the material:
The incident light of a fragment is composed of ambient light, direct light and indirect light
Ambient Occlusion only occludes ambient light and environment light, but not direct light.
Direct light is only occluded by geometry that casts shadows.
And of course the emitted light should not be darkened by ambient occlusion either.
This cannot be achieved if the AO post processing pass is simply blended with the diffuse render pass.

Further extension work might be to use the output of an SSR pass or an HBIL pass from a previous frame.
This would then create the possibility of SSR and IR depending on material properties such as `roughness`, `metalness` and `reflectivity`.

**Kind**: global class  
**Extends**: <code>MeshPhysicalMaterial</code>  

* [MeshPostProcessingMaterial](#MeshPostProcessingMaterial) ⇐ <code>MeshPhysicalMaterial</code>
    * [new MeshPostProcessingMaterial([parameters])](#new_MeshPostProcessingMaterial_new)
    * [.aoPassMapScale](#MeshPostProcessingMaterial+aoPassMapScale) : <code>number</code>
    * [.aoPassMap](#MeshPostProcessingMaterial+aoPassMap) : <code>Texture</code>

<a name="new_MeshPostProcessingMaterial_new"></a>

### new MeshPostProcessingMaterial([parameters])
Constructs a new conditional line material.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | <code>Object</code> | An object with one or more properties defining the material's appearance. Any property of the material (including any property from inherited materials) can be passed in here. Color values can be passed any type of value accepted by [Color#set](Color#set). |

<a name="MeshPostProcessingMaterial+aoPassMapScale"></a>

### meshPostProcessingMaterial.aoPassMapScale : <code>number</code>
The scale of the AO pass.

**Kind**: instance property of [<code>MeshPostProcessingMaterial</code>](#MeshPostProcessingMaterial)  
**Default**: <code>1</code>  
<a name="MeshPostProcessingMaterial+aoPassMap"></a>

### meshPostProcessingMaterial.aoPassMap : <code>Texture</code>
A texture representing the AO pass.

**Kind**: instance property of [<code>MeshPostProcessingMaterial</code>](#MeshPostProcessingMaterial)  
<a name="Capsule"></a>

## Capsule
A capsule is essentially a cylinder with hemispherical caps at both ends.
It can be thought of as a swept sphere, where a sphere is moved along a line segment.

Capsules are often used as bounding volumes (next to AABBs and bounding spheres).

**Kind**: global class  

* [Capsule](#Capsule)
    * [new Capsule([start], [end], [radius])](#new_Capsule_new)
    * [.start](#Capsule+start) : <code>Vector3</code>
    * [.end](#Capsule+end) : <code>Vector3</code>
    * [.radius](#Capsule+radius) : <code>number</code>
    * [.clone()](#Capsule+clone) ⇒ [<code>Capsule</code>](#Capsule)
    * [.set(start, end, radius)](#Capsule+set) ⇒ [<code>Capsule</code>](#Capsule)
    * [.copy(capsule)](#Capsule+copy) ⇒ [<code>Capsule</code>](#Capsule)
    * [.getCenter(target)](#Capsule+getCenter) ⇒ <code>Vector3</code>
    * [.translate(v)](#Capsule+translate) ⇒ [<code>Capsule</code>](#Capsule)
    * [.intersectsBox(box)](#Capsule+intersectsBox) ⇒ <code>boolean</code>

<a name="new_Capsule_new"></a>

### new Capsule([start], [end], [radius])
Constructs a new capsule.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [start] | <code>Vector3</code> |  | The start vector. |
| [end] | <code>Vector3</code> |  | The end vector. |
| [radius] | <code>number</code> | <code>1</code> | The capsule's radius. |

<a name="Capsule+start"></a>

### capsule.start : <code>Vector3</code>
The start vector.

**Kind**: instance property of [<code>Capsule</code>](#Capsule)  
<a name="Capsule+end"></a>

### capsule.end : <code>Vector3</code>
The end vector.

**Kind**: instance property of [<code>Capsule</code>](#Capsule)  
<a name="Capsule+radius"></a>

### capsule.radius : <code>number</code>
The capsule's radius.

**Kind**: instance property of [<code>Capsule</code>](#Capsule)  
**Default**: <code>1</code>  
<a name="Capsule+clone"></a>

### capsule.clone() ⇒ [<code>Capsule</code>](#Capsule)
Returns a new capsule with copied values from this instance.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: [<code>Capsule</code>](#Capsule) - A clone of this instance.  
<a name="Capsule+set"></a>

### capsule.set(start, end, radius) ⇒ [<code>Capsule</code>](#Capsule)
Sets the capsule components to the given values.
Please note that this method only copies the values from the given objects.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: [<code>Capsule</code>](#Capsule) - A reference to this capsule.  

| Param | Type | Description |
| --- | --- | --- |
| start | <code>Vector3</code> | The start vector. |
| end | <code>Vector3</code> | The end vector |
| radius | <code>number</code> | The capsule's radius. |

<a name="Capsule+copy"></a>

### capsule.copy(capsule) ⇒ [<code>Capsule</code>](#Capsule)
Copies the values of the given capsule to this instance.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: [<code>Capsule</code>](#Capsule) - A reference to this capsule.  

| Param | Type | Description |
| --- | --- | --- |
| capsule | [<code>Capsule</code>](#Capsule) | The capsule to copy. |

<a name="Capsule+getCenter"></a>

### capsule.getCenter(target) ⇒ <code>Vector3</code>
Returns the center point of this capsule.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: <code>Vector3</code> - The center point.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="Capsule+translate"></a>

### capsule.translate(v) ⇒ [<code>Capsule</code>](#Capsule)
Adds the given offset to this capsule, effectively moving it in 3D space.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: [<code>Capsule</code>](#Capsule) - A reference to this capsule.  

| Param | Type | Description |
| --- | --- | --- |
| v | <code>Vector3</code> | The offset that should be used to translate the capsule. |

<a name="Capsule+intersectsBox"></a>

### capsule.intersectsBox(box) ⇒ <code>boolean</code>
Returns `true` if the given bounding box intersects with this capsule.

**Kind**: instance method of [<code>Capsule</code>](#Capsule)  
**Returns**: <code>boolean</code> - Whether the given bounding box intersects with this capsule.  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The bounding box to test. |

<a name="ColorConverter"></a>

## ColorConverter
A utility class with helper functions for color conversion.

**Kind**: global class  

* [ColorConverter](#ColorConverter)
    * [.setHSV(color, h, s, v)](#ColorConverter.setHSV) ⇒ <code>Color</code>
    * [.getHSV(color, target)](#ColorConverter.getHSV) ⇒ <code>Object</code>

<a name="ColorConverter.setHSV"></a>

### ColorConverter.setHSV(color, h, s, v) ⇒ <code>Color</code>
Sets the given HSV color definition to the given color object.

**Kind**: static method of [<code>ColorConverter</code>](#ColorConverter)  
**Returns**: <code>Color</code> - The update color.  

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Color</code> | The color to set. |
| h | <code>number</code> | The hue. |
| s | <code>number</code> | The saturation. |
| v | <code>number</code> | The value. |

<a name="ColorConverter.getHSV"></a>

### ColorConverter.getHSV(color, target) ⇒ <code>Object</code>
Returns a HSV color representation of the given color object.

**Kind**: static method of [<code>ColorConverter</code>](#ColorConverter)  
**Returns**: <code>Object</code> - The HSV color.  

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Color</code> | The color to get HSV values from. |
| target | <code>Object</code> | The target object that is used to store the method's result. |

<a name="module_ColorSpaces"></a>

## ColorSpaces

* [ColorSpaces](#module_ColorSpaces)
    * _static_
        * [.DisplayP3ColorSpace](#module_ColorSpaces.DisplayP3ColorSpace) : <code>string</code>
        * [.LinearDisplayP3ColorSpace](#module_ColorSpaces.LinearDisplayP3ColorSpace) : <code>string</code>
        * [.DisplayP3ColorSpaceImpl](#module_ColorSpaces.DisplayP3ColorSpaceImpl) : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
        * [.LinearDisplayP3ColorSpaceImpl](#module_ColorSpaces.LinearDisplayP3ColorSpaceImpl) : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
        * [.LinearRec2020ColorSpace](#module_ColorSpaces.LinearRec2020ColorSpace) : <code>string</code>
        * [.LinearRec2020ColorSpaceImpl](#module_ColorSpaces.LinearRec2020ColorSpaceImpl) : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
    * _inner_
        * [~ColorSpaceImpl](#module_ColorSpaces..ColorSpaceImpl) : <code>Object</code>

<a name="module_ColorSpaces.DisplayP3ColorSpace"></a>

### ColorSpaces.DisplayP3ColorSpace : <code>string</code>
Display-P3 color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.LinearDisplayP3ColorSpace"></a>

### ColorSpaces.LinearDisplayP3ColorSpace : <code>string</code>
Display-P3-Linear color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.DisplayP3ColorSpaceImpl"></a>

### ColorSpaces.DisplayP3ColorSpaceImpl : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
Implementation object for the Display-P3 color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.LinearDisplayP3ColorSpaceImpl"></a>

### ColorSpaces.LinearDisplayP3ColorSpaceImpl : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
Implementation object for the Display-P3-Linear color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.LinearRec2020ColorSpace"></a>

### ColorSpaces.LinearRec2020ColorSpace : <code>string</code>
Rec2020-Linear color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces.LinearRec2020ColorSpaceImpl"></a>

### ColorSpaces.LinearRec2020ColorSpaceImpl : [<code>ColorSpaceImpl</code>](#module_ColorSpaces..ColorSpaceImpl)
Implementation object for the Rec2020-Linear color space.

**Kind**: static constant of [<code>ColorSpaces</code>](#module_ColorSpaces)  
<a name="module_ColorSpaces..ColorSpaceImpl"></a>

### ColorSpaces~ColorSpaceImpl : <code>Object</code>
An object holding the color space implementation.

**Kind**: inner typedef of [<code>ColorSpaces</code>](#module_ColorSpaces)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| primaries | <code>Array.&lt;number&gt;</code> | The primaries. |
| whitePoint | <code>Array.&lt;number&gt;</code> | The white point. |
| toXYZ | <code>Matrix3</code> | A color space conversion matrix, converting to CIE XYZ. |
| fromXYZ | <code>Matrix3</code> | A color space conversion matrix, converting from CIE XYZ. |
| luminanceCoefficients | <code>Array.&lt;number&gt;</code> | The luminance coefficients. |
| [workingColorSpaceConfig] | <code>Object</code> | The working color space config. |
| [outputColorSpaceConfig] | <code>Object</code> | The drawing buffer color space config. |

<a name="ConvexHull"></a>

## ConvexHull
Can be used to compute the convex hull in 3D space for a given set of points. It
is primarily intended for [ConvexGeometry](ConvexGeometry).

This Quickhull 3D implementation is a port of [quickhull3d](https://github.com/maurizzzio/quickhull3d/)
by Mauricio Poppe.

**Kind**: global class  

* [ConvexHull](#ConvexHull)
    * [new ConvexHull()](#new_ConvexHull_new)
    * [.setFromPoints(points)](#ConvexHull+setFromPoints) ⇒ [<code>ConvexHull</code>](#ConvexHull)
    * [.setFromObject(object)](#ConvexHull+setFromObject) ⇒ [<code>ConvexHull</code>](#ConvexHull)
    * [.containsPoint(point)](#ConvexHull+containsPoint) ⇒ <code>boolean</code>
    * [.intersectRay(ray, target)](#ConvexHull+intersectRay) ⇒ <code>Vector3</code> \| <code>null</code>
    * [.intersectsRay(ray)](#ConvexHull+intersectsRay) ⇒ <code>boolean</code>
    * [.makeEmpty()](#ConvexHull+makeEmpty) ⇒ [<code>ConvexHull</code>](#ConvexHull)

<a name="new_ConvexHull_new"></a>

### new ConvexHull()
Constructs a new convex hull.

<a name="ConvexHull+setFromPoints"></a>

### convexHull.setFromPoints(points) ⇒ [<code>ConvexHull</code>](#ConvexHull)
Computes to convex hull for the given array of points.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: [<code>ConvexHull</code>](#ConvexHull) - A reference to this convex hull.  

| Param | Type | Description |
| --- | --- | --- |
| points | <code>Array.&lt;Vector3&gt;</code> | The array of points in 3D space. |

<a name="ConvexHull+setFromObject"></a>

### convexHull.setFromObject(object) ⇒ [<code>ConvexHull</code>](#ConvexHull)
Computes the convex hull of the given 3D object (including its descendants),
accounting for the world transforms of both the 3D object and its descendants.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: [<code>ConvexHull</code>](#ConvexHull) - A reference to this convex hull.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to compute the convex hull for. |

<a name="ConvexHull+containsPoint"></a>

### convexHull.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies in the convex hull.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: <code>boolean</code> - Whether the given point lies in the convex hull or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to test. |

<a name="ConvexHull+intersectRay"></a>

### convexHull.intersectRay(ray, target) ⇒ <code>Vector3</code> \| <code>null</code>
Computes the intersections point of the given ray and this convex hull.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: <code>Vector3</code> \| <code>null</code> - The intersection point. Returns `null` if not intersection was detected.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="ConvexHull+intersectsRay"></a>

### convexHull.intersectsRay(ray) ⇒ <code>boolean</code>
Returns `true` if the given ray intersects with this convex hull.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: <code>boolean</code> - Whether the given ray intersects with this convex hull or not.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |

<a name="ConvexHull+makeEmpty"></a>

### convexHull.makeEmpty() ⇒ [<code>ConvexHull</code>](#ConvexHull)
Makes the convex hull empty.

**Kind**: instance method of [<code>ConvexHull</code>](#ConvexHull)  
**Returns**: [<code>ConvexHull</code>](#ConvexHull) - A reference to this convex hull.  
<a name="ImprovedNoise"></a>

## ImprovedNoise
A utility class providing a 3D noise function.

The code is based on [IMPROVED NOISE](https://cs.nyu.edu/~perlin/noise/)
by Ken Perlin, 2002.

**Kind**: global class  
<a name="ImprovedNoise+noise"></a>

### improvedNoise.noise(x, y, z) ⇒ <code>number</code>
Returns a noise value for the given parameters.

**Kind**: instance method of [<code>ImprovedNoise</code>](#ImprovedNoise)  
**Returns**: <code>number</code> - The noise value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate. |
| y | <code>number</code> | The y coordinate. |
| z | <code>number</code> | The z coordinate. |

<a name="Lut"></a>

## Lut
Represents a lookup table for colormaps. It is used to determine the color
values from a range of data values.

```js
const lut = new Lut( 'rainbow', 512 );
const color = lut.getColor( 0.5 );
```

**Kind**: global class  

* [Lut](#Lut)
    * [new Lut([colormap], [count])](#new_Lut_new)
    * [.isLut](#Lut+isLut) : <code>boolean</code>
    * [.lut](#Lut+lut) : <code>Array.&lt;Color&gt;</code>
    * [.map](#Lut+map) : <code>Array</code>
    * [.n](#Lut+n) : <code>number</code>
    * [.minV](#Lut+minV) : <code>number</code>
    * [.maxV](#Lut+maxV) : <code>number</code>
    * [.set(value)](#Lut+set) ⇒ [<code>Lut</code>](#Lut)
    * [.setMin(min)](#Lut+setMin) ⇒ [<code>Lut</code>](#Lut)
    * [.setMax(max)](#Lut+setMax) ⇒ [<code>Lut</code>](#Lut)
    * [.setColorMap(colormap, [count])](#Lut+setColorMap) ⇒ [<code>Lut</code>](#Lut)
    * [.copy(lut)](#Lut+copy) ⇒ [<code>Lut</code>](#Lut)
    * [.getColor(alpha)](#Lut+getColor) ⇒ <code>Color</code>
    * [.addColorMap(name, arrayOfColors)](#Lut+addColorMap) ⇒ [<code>Lut</code>](#Lut)
    * [.createCanvas()](#Lut+createCanvas) ⇒ <code>HTMLCanvasElement</code>
    * [.updateCanvas(canvas)](#Lut+updateCanvas) ⇒ <code>HTMLCanvasElement</code>

<a name="new_Lut_new"></a>

### new Lut([colormap], [count])
Constructs a new Lut.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [colormap] | <code>&#x27;rainbow&#x27;</code> \| <code>&#x27;cooltowarm&#x27;</code> \| <code>&#x27;blackbody&#x27;</code> \| <code>&#x27;grayscale&#x27;</code> | <code>&#x27;rainbow&#x27;</code> | Sets a colormap from predefined list of colormaps. |
| [count] | <code>number</code> | <code>32</code> | Sets the number of colors used to represent the data array. |

<a name="Lut+isLut"></a>

### lut.isLut : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Lut+lut"></a>

### lut.lut : <code>Array.&lt;Color&gt;</code>
The lookup table for the selected color map

**Kind**: instance property of [<code>Lut</code>](#Lut)  
<a name="Lut+map"></a>

### lut.map : <code>Array</code>
The currently selected color map.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
<a name="Lut+n"></a>

### lut.n : <code>number</code>
The number of colors of the current selected color map.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
**Default**: <code>32</code>  
<a name="Lut+minV"></a>

### lut.minV : <code>number</code>
The minimum value to be represented with the lookup table.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
**Default**: <code>0</code>  
<a name="Lut+maxV"></a>

### lut.maxV : <code>number</code>
The maximum value to be represented with the lookup table.

**Kind**: instance property of [<code>Lut</code>](#Lut)  
**Default**: <code>1</code>  
<a name="Lut+set"></a>

### lut.set(value) ⇒ [<code>Lut</code>](#Lut)
Sets the given LUT.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| value | [<code>Lut</code>](#Lut) | The LUT to set. |

<a name="Lut+setMin"></a>

### lut.setMin(min) ⇒ [<code>Lut</code>](#Lut)
Sets the minimum value to be represented with this LUT.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>number</code> | The minimum value to be represented with the lookup table. |

<a name="Lut+setMax"></a>

### lut.setMax(max) ⇒ [<code>Lut</code>](#Lut)
Sets the maximum value to be represented with this LUT.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| max | <code>number</code> | The maximum value to be represented with the lookup table. |

<a name="Lut+setColorMap"></a>

### lut.setColorMap(colormap, [count]) ⇒ [<code>Lut</code>](#Lut)
Configure the lookup table for the given color map and number of colors.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| colormap | <code>string</code> |  | The name of the color map. |
| [count] | <code>number</code> | <code>32</code> | The number of colors. |

<a name="Lut+copy"></a>

### lut.copy(lut) ⇒ [<code>Lut</code>](#Lut)
Copies the given lut.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| lut | [<code>Lut</code>](#Lut) | The LUT to copy. |

<a name="Lut+getColor"></a>

### lut.getColor(alpha) ⇒ <code>Color</code>
Returns an instance of Color for the given data value.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: <code>Color</code> - The color from the LUT.  

| Param | Type | Description |
| --- | --- | --- |
| alpha | <code>number</code> | The value to lookup. |

<a name="Lut+addColorMap"></a>

### lut.addColorMap(name, arrayOfColors) ⇒ [<code>Lut</code>](#Lut)
Adds a color map to this Lut instance.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: [<code>Lut</code>](#Lut) - A reference to this LUT.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the color map. |
| arrayOfColors | <code>Array</code> | An array of color values. Each value is an array holding a threshold and the actual color value as a hexadecimal number. |

<a name="Lut+createCanvas"></a>

### lut.createCanvas() ⇒ <code>HTMLCanvasElement</code>
Creates a canvas in order to visualize the lookup table as a texture.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: <code>HTMLCanvasElement</code> - The created canvas.  
<a name="Lut+updateCanvas"></a>

### lut.updateCanvas(canvas) ⇒ <code>HTMLCanvasElement</code>
Updates the given canvas with the Lut's data.

**Kind**: instance method of [<code>Lut</code>](#Lut)  
**Returns**: <code>HTMLCanvasElement</code> - The updated canvas.  

| Param | Type | Description |
| --- | --- | --- |
| canvas | <code>HTMLCanvasElement</code> | The canvas to update. |

<a name="MeshSurfaceSampler"></a>

## MeshSurfaceSampler
Utility class for sampling weighted random points on the surface of a mesh.

Building the sampler is a one-time O(n) operation. Once built, any number of
random samples may be selected in O(logn) time. Memory usage is O(n).

References:
- [http://www.joesfer.com/?p=84](http://www.joesfer.com/?p=84)
- [https://stackoverflow.com/a/4322940/1314762](https://stackoverflow.com/a/4322940/1314762)

```js
const sampler = new MeshSurfaceSampler( surfaceMesh )
	.setWeightAttribute( 'color' )
	.build();

const mesh = new THREE.InstancedMesh( sampleGeometry, sampleMaterial, 100 );

const position = new THREE.Vector3();
const matrix = new THREE.Matrix4();

// Sample randomly from the surface, creating an instance of the sample geometry at each sample point.

for ( let i = 0; i < 100; i ++ ) {

	sampler.sample( position );
	matrix.makeTranslation( position.x, position.y, position.z );
	mesh.setMatrixAt( i, matrix );

}

scene.add( mesh );
```

**Kind**: global class  

* [MeshSurfaceSampler](#MeshSurfaceSampler)
    * [new MeshSurfaceSampler(mesh)](#new_MeshSurfaceSampler_new)
    * [.setWeightAttribute(name)](#MeshSurfaceSampler+setWeightAttribute) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
    * [.build()](#MeshSurfaceSampler+build) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
    * [.setRandomGenerator(randomFunction)](#MeshSurfaceSampler+setRandomGenerator) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
    * [.sample(targetPosition, targetNormal, targetColor, targetUV)](#MeshSurfaceSampler+sample) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)

<a name="new_MeshSurfaceSampler_new"></a>

### new MeshSurfaceSampler(mesh)
Constructs a mesh surface sampler.


| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | Surface mesh from which to sample. |

<a name="MeshSurfaceSampler+setWeightAttribute"></a>

### meshSurfaceSampler.setWeightAttribute(name) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
Specifies a vertex attribute to be used as a weight when sampling from the surface.
Faces with higher weights are more likely to be sampled, and those with weights of
zero will not be sampled at all. For vector attributes, only .x is used in sampling.

If no weight attribute is selected, sampling is randomly distributed by area.

**Kind**: instance method of [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)  
**Returns**: [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler) - A reference to this sampler.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute name. |

<a name="MeshSurfaceSampler+build"></a>

### meshSurfaceSampler.build() ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
Processes the input geometry and prepares to return samples. Any configuration of the
geometry or sampler must occur before this method is called. Time complexity is O(n)
for a surface with n faces.

**Kind**: instance method of [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)  
**Returns**: [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler) - A reference to this sampler.  
<a name="MeshSurfaceSampler+setRandomGenerator"></a>

### meshSurfaceSampler.setRandomGenerator(randomFunction) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
Allows to set a custom random number generator. Default is `Math.random()`.

**Kind**: instance method of [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)  
**Returns**: [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler) - A reference to this sampler.  

| Param | Type | Description |
| --- | --- | --- |
| randomFunction | <code>function</code> | A random number generator. |

<a name="MeshSurfaceSampler+sample"></a>

### meshSurfaceSampler.sample(targetPosition, targetNormal, targetColor, targetUV) ⇒ [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)
Selects a random point on the surface of the input geometry, returning the
position and optionally the normal vector, color and UV Coordinate at that point.
Time complexity is O(log n) for a surface with n faces.

**Kind**: instance method of [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler)  
**Returns**: [<code>MeshSurfaceSampler</code>](#MeshSurfaceSampler) - A reference to this sampler.  

| Param | Type | Description |
| --- | --- | --- |
| targetPosition | <code>Vector3</code> | The target object holding the sampled position. |
| targetNormal | <code>Vector3</code> | The target object holding the sampled normal. |
| targetColor | <code>Color</code> | The target object holding the sampled color. |
| targetUV | <code>Vector2</code> | The target object holding the sampled uv coordinates. |

<a name="OBB"></a>

## OBB
Represents an oriented bounding box (OBB) in 3D space.

**Kind**: global class  

* [OBB](#OBB)
    * [new OBB([center], [halfSize], [rotation])](#new_OBB_new)
    * [.center](#OBB+center) : <code>Vector3</code>
    * [.halfSize](#OBB+halfSize) : <code>Vector3</code>
    * [.rotation](#OBB+rotation) : <code>Matrix3</code>
    * [.set([center], [halfSize], [rotation])](#OBB+set) ⇒ [<code>OBB</code>](#OBB)
    * [.copy(obb)](#OBB+copy) ⇒ [<code>OBB</code>](#OBB)
    * [.clone()](#OBB+clone) ⇒ [<code>OBB</code>](#OBB)
    * [.getSize(target)](#OBB+getSize) ⇒ <code>Vector3</code>
    * [.clampPoint(point, target)](#OBB+clampPoint) ⇒ <code>Vector3</code>
    * [.containsPoint(point)](#OBB+containsPoint) ⇒ <code>boolean</code>
    * [.intersectsBox3(box3)](#OBB+intersectsBox3) ⇒ <code>boolean</code>
    * [.intersectsSphere(sphere)](#OBB+intersectsSphere) ⇒ <code>boolean</code>
    * [.intersectsOBB(obb, [epsilon])](#OBB+intersectsOBB) ⇒ <code>boolean</code>
    * [.intersectsPlane(plane)](#OBB+intersectsPlane) ⇒ <code>boolean</code>
    * [.intersectRay(ray, target)](#OBB+intersectRay) ⇒ <code>Vector3</code>
    * [.intersectsRay(ray)](#OBB+intersectsRay) ⇒ <code>boolean</code>
    * [.fromBox3(box3)](#OBB+fromBox3) ⇒ [<code>OBB</code>](#OBB)
    * [.equals(obb)](#OBB+equals) ⇒ <code>boolean</code>
    * [.applyMatrix4(matrix)](#OBB+applyMatrix4) ⇒ [<code>OBB</code>](#OBB)

<a name="new_OBB_new"></a>

### new OBB([center], [halfSize], [rotation])
Constructs a new OBB.


| Param | Type | Description |
| --- | --- | --- |
| [center] | <code>Vector3</code> | The center of the OBB. |
| [halfSize] | <code>Vector3</code> | Positive halfwidth extents of the OBB along each axis. |
| [rotation] | <code>Matrix3</code> | The rotation of the OBB. |

<a name="OBB+center"></a>

### obB.center : <code>Vector3</code>
The center of the OBB.

**Kind**: instance property of [<code>OBB</code>](#OBB)  
<a name="OBB+halfSize"></a>

### obB.halfSize : <code>Vector3</code>
Positive halfwidth extents of the OBB along each axis.

**Kind**: instance property of [<code>OBB</code>](#OBB)  
<a name="OBB+rotation"></a>

### obB.rotation : <code>Matrix3</code>
The rotation of the OBB.

**Kind**: instance property of [<code>OBB</code>](#OBB)  
<a name="OBB+set"></a>

### obB.set([center], [halfSize], [rotation]) ⇒ [<code>OBB</code>](#OBB)
Sets the OBBs components to the given values.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A reference to this OBB.  

| Param | Type | Description |
| --- | --- | --- |
| [center] | <code>Vector3</code> | The center of the OBB. |
| [halfSize] | <code>Vector3</code> | Positive halfwidth extents of the OBB along each axis. |
| [rotation] | <code>Matrix3</code> | The rotation of the OBB. |

<a name="OBB+copy"></a>

### obB.copy(obb) ⇒ [<code>OBB</code>](#OBB)
Copies the values of the given OBB to this instance.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A reference to this OBB.  

| Param | Type | Description |
| --- | --- | --- |
| obb | [<code>OBB</code>](#OBB) | The OBB to copy. |

<a name="OBB+clone"></a>

### obB.clone() ⇒ [<code>OBB</code>](#OBB)
Returns a new OBB with copied values from this instance.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A clone of this instance.  
<a name="OBB+getSize"></a>

### obB.getSize(target) ⇒ <code>Vector3</code>
Returns the size of this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>Vector3</code> - The size.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="OBB+clampPoint"></a>

### obB.clampPoint(point, target) ⇒ <code>Vector3</code>
Clamps the given point within the bounds of this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>Vector3</code> - - The clamped point.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point that should be clamped within the bounds of this OBB. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="OBB+containsPoint"></a>

### obB.containsPoint(point) ⇒ <code>boolean</code>
Returns `true` if the given point lies within this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - - Whether the given point lies within this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| point | <code>Vector3</code> | The point to test. |

<a name="OBB+intersectsBox3"></a>

### obB.intersectsBox3(box3) ⇒ <code>boolean</code>
Returns `true` if the given AABB intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - - Whether the given AABB intersects this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| box3 | <code>Box3</code> | The AABB to test. |

<a name="OBB+intersectsSphere"></a>

### obB.intersectsSphere(sphere) ⇒ <code>boolean</code>
Returns `true` if the given bounding sphere intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - - Whether the given bounding sphere intersects this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="OBB+intersectsOBB"></a>

### obB.intersectsOBB(obb, [epsilon]) ⇒ <code>boolean</code>
Returns `true` if the given OBB intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - - Whether the given OBB intersects this OBB or not.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| obb | [<code>OBB</code>](#OBB) |  | The OBB to test. |
| [epsilon] | <code>number</code> | <code>Number.EPSILON</code> | A small value to prevent arithmetic errors. |

<a name="OBB+intersectsPlane"></a>

### obB.intersectsPlane(plane) ⇒ <code>boolean</code>
Returns `true` if the given plane intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - Whether the given plane intersects this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane to test. |

<a name="OBB+intersectRay"></a>

### obB.intersectRay(ray, target) ⇒ <code>Vector3</code>
Performs a ray/OBB intersection test and stores the intersection point
in the given 3D vector.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>Vector3</code> - The intersection point. If no intersection is detected, `null` is returned.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |
| target | <code>Vector3</code> | The target vector that is used to store the method's result. |

<a name="OBB+intersectsRay"></a>

### obB.intersectsRay(ray) ⇒ <code>boolean</code>
Returns `true` if the given ray intersects this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - Whether the given ray intersects this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |

<a name="OBB+fromBox3"></a>

### obB.fromBox3(box3) ⇒ [<code>OBB</code>](#OBB)
Defines an OBB based on the given AABB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A reference of this OBB.  

| Param | Type | Description |
| --- | --- | --- |
| box3 | <code>Box3</code> | The AABB to setup the OBB from. |

<a name="OBB+equals"></a>

### obB.equals(obb) ⇒ <code>boolean</code>
Returns `true` if the given OBB is equal to this OBB.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: <code>boolean</code> - Whether the given OBB is equal to this OBB or not.  

| Param | Type | Description |
| --- | --- | --- |
| obb | [<code>OBB</code>](#OBB) | The OBB to test. |

<a name="OBB+applyMatrix4"></a>

### obB.applyMatrix4(matrix) ⇒ [<code>OBB</code>](#OBB)
Applies the given transformation matrix to this OBB. This method can be
used to transform the bounding volume with the world matrix of a 3D object
in order to keep both entities in sync.

**Kind**: instance method of [<code>OBB</code>](#OBB)  
**Returns**: [<code>OBB</code>](#OBB) - A reference of this OBB.  

| Param | Type | Description |
| --- | --- | --- |
| matrix | <code>Matrix4</code> | The matrix to apply. |

<a name="Octree"></a>

## Octree
An octree is a hierarchical tree data structure used to partition a three-dimensional
space by recursively subdividing it into eight octants.

This particular implementation can have up to sixteen levels and stores up to eight triangles
in leaf nodes.

`Octree` can be used in games to compute collision between the game world and colliders from
the player or other dynamic 3D objects.


```js
const octree = new Octree().fromGraphNode( scene );
const result = octree.capsuleIntersect( playerCollider ); // collision detection
```

**Kind**: global class  

* [Octree](#Octree)
    * [new Octree([box])](#new_Octree_new)
    * [.box](#Octree+box) : <code>Box3</code>
    * [.bounds](#Octree+bounds) : <code>Box3</code>
    * [.layers](#Octree+layers) : <code>Layers</code>
    * [.addTriangle(triangle)](#Octree+addTriangle) ⇒ [<code>Octree</code>](#Octree)
    * [.calcBox()](#Octree+calcBox) ⇒ [<code>Octree</code>](#Octree)
    * [.split(level)](#Octree+split) ⇒ [<code>Octree</code>](#Octree)
    * [.build()](#Octree+build) ⇒ [<code>Octree</code>](#Octree)
    * [.getRayTriangles(ray, triangles)](#Octree+getRayTriangles)
    * [.triangleCapsuleIntersect(capsule, triangle)](#Octree+triangleCapsuleIntersect) ⇒ <code>Object</code> \| <code>false</code>
    * [.triangleSphereIntersect(sphere, triangle)](#Octree+triangleSphereIntersect) ⇒ <code>Object</code> \| <code>false</code>
    * [.getSphereTriangles(sphere, triangles)](#Octree+getSphereTriangles)
    * [.getCapsuleTriangles(capsule, triangles)](#Octree+getCapsuleTriangles)
    * [.sphereIntersect(sphere)](#Octree+sphereIntersect) ⇒ <code>Object</code> \| <code>boolean</code>
    * [.capsuleIntersect(capsule)](#Octree+capsuleIntersect) ⇒ <code>Object</code> \| <code>boolean</code>
    * [.rayIntersect(ray)](#Octree+rayIntersect) ⇒ <code>Object</code> \| <code>boolean</code>
    * [.fromGraphNode(group)](#Octree+fromGraphNode) ⇒ [<code>Octree</code>](#Octree)
    * [.clear()](#Octree+clear) ⇒ [<code>Octree</code>](#Octree)

<a name="new_Octree_new"></a>

### new Octree([box])
Constructs a new Octree.


| Param | Type | Description |
| --- | --- | --- |
| [box] | <code>Box3</code> | The base box with enclose the entire Octree. |

<a name="Octree+box"></a>

### octree.box : <code>Box3</code>
The base box with enclose the entire Octree.

**Kind**: instance property of [<code>Octree</code>](#Octree)  
<a name="Octree+bounds"></a>

### octree.bounds : <code>Box3</code>
The bounds of the Octree. Compared to [box](#Octree+box), no
margin is applied.

**Kind**: instance property of [<code>Octree</code>](#Octree)  
<a name="Octree+layers"></a>

### octree.layers : <code>Layers</code>
Can by used for layers configuration for refine testing.

**Kind**: instance property of [<code>Octree</code>](#Octree)  
<a name="Octree+addTriangle"></a>

### octree.addTriangle(triangle) ⇒ [<code>Octree</code>](#Octree)
Adds the given triangle to the Octree. The triangle vertices are clamped if they exceed
the bounds of the Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  

| Param | Type | Description |
| --- | --- | --- |
| triangle | <code>Triangle</code> | The triangle to add. |

<a name="Octree+calcBox"></a>

### octree.calcBox() ⇒ [<code>Octree</code>](#Octree)
Prepares [box](#Octree+box) for the build.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  
<a name="Octree+split"></a>

### octree.split(level) ⇒ [<code>Octree</code>](#Octree)
Splits the Octree. This method is used recursively when
building the Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  

| Param | Type | Description |
| --- | --- | --- |
| level | <code>number</code> | The current level. |

<a name="Octree+build"></a>

### octree.build() ⇒ [<code>Octree</code>](#Octree)
Builds the Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  
<a name="Octree+getRayTriangles"></a>

### octree.getRayTriangles(ray, triangles)
Computes the triangles that potentially intersect with the given ray.

**Kind**: instance method of [<code>Octree</code>](#Octree)  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |
| triangles | <code>Array.&lt;Triangle&gt;</code> | The target array that holds the triangles. |

<a name="Octree+triangleCapsuleIntersect"></a>

### octree.triangleCapsuleIntersect(capsule, triangle) ⇒ <code>Object</code> \| <code>false</code>
Computes the intersection between the given capsule and triangle.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>false</code> - The intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| capsule | <code>Capsule</code> | The capsule to test. |
| triangle | <code>Triangle</code> | The triangle to test. |

<a name="Octree+triangleSphereIntersect"></a>

### octree.triangleSphereIntersect(sphere, triangle) ⇒ <code>Object</code> \| <code>false</code>
Computes the intersection between the given sphere and triangle.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>false</code> - The intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to test. |
| triangle | <code>Triangle</code> | The triangle to test. |

<a name="Octree+getSphereTriangles"></a>

### octree.getSphereTriangles(sphere, triangles)
Computes the triangles that potentially intersect with the given bounding sphere.

**Kind**: instance method of [<code>Octree</code>](#Octree)  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The sphere to test. |
| triangles | <code>Array.&lt;Triangle&gt;</code> | The target array that holds the triangles. |

<a name="Octree+getCapsuleTriangles"></a>

### octree.getCapsuleTriangles(capsule, triangles)
Computes the triangles that potentially intersect with the given capsule.

**Kind**: instance method of [<code>Octree</code>](#Octree)  

| Param | Type | Description |
| --- | --- | --- |
| capsule | <code>Capsule</code> | The capsule to test. |
| triangles | <code>Array.&lt;Triangle&gt;</code> | The target array that holds the triangles. |

<a name="Octree+sphereIntersect"></a>

### octree.sphereIntersect(sphere) ⇒ <code>Object</code> \| <code>boolean</code>
Performs a bounding sphere intersection test with this Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>boolean</code> - The intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| sphere | <code>Sphere</code> | The bounding sphere to test. |

<a name="Octree+capsuleIntersect"></a>

### octree.capsuleIntersect(capsule) ⇒ <code>Object</code> \| <code>boolean</code>
Performs a capsule intersection test with this Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>boolean</code> - The intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| capsule | <code>Capsule</code> | The capsule to test. |

<a name="Octree+rayIntersect"></a>

### octree.rayIntersect(ray) ⇒ <code>Object</code> \| <code>boolean</code>
Performs a ray intersection test with this Octree.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: <code>Object</code> \| <code>boolean</code> - The nearest intersection object. If no intersection
is detected, the method returns `false`.  

| Param | Type | Description |
| --- | --- | --- |
| ray | <code>Ray</code> | The ray to test. |

<a name="Octree+fromGraphNode"></a>

### octree.fromGraphNode(group) ⇒ [<code>Octree</code>](#Octree)
Constructs the Octree from the given 3D object.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  

| Param | Type | Description |
| --- | --- | --- |
| group | <code>Object3D</code> | The scene graph node. |

<a name="Octree+clear"></a>

### octree.clear() ⇒ [<code>Octree</code>](#Octree)
Clears the Octree by making it empty.

**Kind**: instance method of [<code>Octree</code>](#Octree)  
**Returns**: [<code>Octree</code>](#Octree) - A reference to this Octree.  
<a name="SimplexNoise"></a>

## SimplexNoise
A utility class providing noise functions.

The code is based on [Simplex noise demystified](https://web.archive.org/web/20210210162332/http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf)
by Stefan Gustavson, 2005.

**Kind**: global class  

* [SimplexNoise](#SimplexNoise)
    * [new SimplexNoise([r])](#new_SimplexNoise_new)
    * [.noise(xin, yin)](#SimplexNoise+noise) ⇒ <code>number</code>
    * [.noise3d(xin, yin, zin)](#SimplexNoise+noise3d) ⇒ <code>number</code>
    * [.noise4d(x, y, z, w)](#SimplexNoise+noise4d) ⇒ <code>number</code>

<a name="new_SimplexNoise_new"></a>

### new SimplexNoise([r])
Constructs a new simplex noise object.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [r] | <code>Object</code> | <code>Math</code> | A math utility class that holds a `random()` method. This makes it possible to pass in custom random number generator. |

<a name="SimplexNoise+noise"></a>

### simplexNoise.noise(xin, yin) ⇒ <code>number</code>
A 2D simplex noise method.

**Kind**: instance method of [<code>SimplexNoise</code>](#SimplexNoise)  
**Returns**: <code>number</code> - The noise value.  

| Param | Type | Description |
| --- | --- | --- |
| xin | <code>number</code> | The x coordinate. |
| yin | <code>number</code> | The y coordinate. |

<a name="SimplexNoise+noise3d"></a>

### simplexNoise.noise3d(xin, yin, zin) ⇒ <code>number</code>
A 3D simplex noise method.

**Kind**: instance method of [<code>SimplexNoise</code>](#SimplexNoise)  
**Returns**: <code>number</code> - The noise value.  

| Param | Type | Description |
| --- | --- | --- |
| xin | <code>number</code> | The x coordinate. |
| yin | <code>number</code> | The y coordinate. |
| zin | <code>number</code> | The z coordinate. |

<a name="SimplexNoise+noise4d"></a>

### simplexNoise.noise4d(x, y, z, w) ⇒ <code>number</code>
A 4D simplex noise method.

**Kind**: instance method of [<code>SimplexNoise</code>](#SimplexNoise)  
**Returns**: <code>number</code> - The noise value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x coordinate. |
| y | <code>number</code> | The y coordinate. |
| z | <code>number</code> | The z coordinate. |
| w | <code>number</code> | The w coordinate. |

<a name="ConvexObjectBreaker"></a>

## ConvexObjectBreaker
This class can be used to subdivide a convex Geometry object into pieces.

Use the function prepareBreakableObject to prepare a Mesh object to be broken.
Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane).
Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.

Requisites for the object:
- Mesh object must have a buffer geometry and a material.
- Vertex normals must be planar (not smoothed).
- The geometry must be convex (this is not checked in the library). You can create convex
geometries with [ConvexGeometry](ConvexGeometry). The [BoxGeometry](BoxGeometry), [SphereGeometry](SphereGeometry) and other
convex primitives can also be used.

Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)
Use with caution and read the code when using with other libs.

**Kind**: global class  

* [ConvexObjectBreaker](#ConvexObjectBreaker)
    * [new ConvexObjectBreaker([minSizeForBreak], [smallDelta])](#new_ConvexObjectBreaker_new)
    * [.prepareBreakableObject(object, mass, velocity, angularVelocity, breakable)](#ConvexObjectBreaker+prepareBreakableObject)
    * [.subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations)](#ConvexObjectBreaker+subdivideByImpact) ⇒ <code>Array.&lt;Object3D&gt;</code>
    * [.cutByPlane(object, plane, output)](#ConvexObjectBreaker+cutByPlane) ⇒ <code>number</code>

<a name="new_ConvexObjectBreaker_new"></a>

### new ConvexObjectBreaker([minSizeForBreak], [smallDelta])
Constructs a new convex object breaker.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [minSizeForBreak] | <code>number</code> | <code>1.4</code> | Min size a debris can have to break. |
| [smallDelta] | <code>number</code> | <code>0.0001</code> | Max distance to consider that a point belongs to a plane. |

<a name="ConvexObjectBreaker+prepareBreakableObject"></a>

### convexObjectBreaker.prepareBreakableObject(object, mass, velocity, angularVelocity, breakable)
Must be called for all 3D objects that should be breakable.

**Kind**: instance method of [<code>ConvexObjectBreaker</code>](#ConvexObjectBreaker)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object. It must have a convex geometry. |
| mass | <code>number</code> | The 3D object's mass in kg. Must be greater than `0`. |
| velocity | <code>Vector3</code> | The 3D object's velocity. |
| angularVelocity | <code>Vector3</code> | The 3D object's angular velocity. |
| breakable | <code>boolean</code> | Whether the 3D object is breakable or not. |

<a name="ConvexObjectBreaker+subdivideByImpact"></a>

### convexObjectBreaker.subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) ⇒ <code>Array.&lt;Object3D&gt;</code>
Subdivides the given 3D object into pieces by an impact (meaning another object hits
the given 3D object at a certain surface point).

**Kind**: instance method of [<code>ConvexObjectBreaker</code>](#ConvexObjectBreaker)  
**Returns**: <code>Array.&lt;Object3D&gt;</code> - The array of pieces.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to subdivide. |
| pointOfImpact | <code>Vector3</code> | The point of impact. |
| normal | <code>Vector3</code> | The impact normal. |
| maxRadialIterations | <code>number</code> | Iterations for radial cuts. |
| maxRandomIterations | <code>number</code> | Max random iterations for not-radial cuts. |

<a name="ConvexObjectBreaker+cutByPlane"></a>

### convexObjectBreaker.cutByPlane(object, plane, output) ⇒ <code>number</code>
Subdivides the given 3D object into pieces by a plane.

**Kind**: instance method of [<code>ConvexObjectBreaker</code>](#ConvexObjectBreaker)  
**Returns**: <code>number</code> - The number of pieces.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to subdivide. |
| plane | <code>Plane</code> | The plane to cut the 3D object. |
| output | <code>Object</code> | An object that stores the pieces. |

<a name="GPUComputationRenderer"></a>

## GPUComputationRenderer
GPUComputationRenderer, based on SimulationRenderer by @zz85.

The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats
for each compute element (texel).

Each variable has a fragment shader that defines the computation made to obtain the variable in question.
You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader
(the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.

The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used
as inputs to render the textures of the next frame.

The render targets of the variables can be used as input textures for your visualization shaders.

Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.
a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...

The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:
```
#DEFINE resolution vec2( 1024.0, 1024.0 )
```
Basic use:
```js
// Initialization...

// Create computation renderer
const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );

// Create initial state float textures
const pos0 = gpuCompute.createTexture();
const vel0 = gpuCompute.createTexture();
// and fill in here the texture data...

// Add texture variables
const velVar = gpuCompute.addVariable( "textureVelocity", fragmentShaderVel, vel0 );
const posVar = gpuCompute.addVariable( "texturePosition", fragmentShaderPos, pos0 );

// Add variable dependencies
gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );
gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );

// Add custom uniforms
velVar.material.uniforms.time = { value: 0.0 };

// Check for completeness
const error = gpuCompute.init();
if ( error !== null ) {
		console.error( error );
}

// In each frame...

// Compute!
gpuCompute.compute();

// Update texture uniforms in your visualization materials with the gpu renderer output
myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;

// Do your rendering
renderer.render( myScene, myCamera );
```

Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)
Note that the shaders can have multiple input textures.

```js
const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );
const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );

const inputTexture = gpuCompute.createTexture();

// Fill in here inputTexture...

myFilter1.uniforms.theTexture.value = inputTexture;

const myRenderTarget = gpuCompute.createRenderTarget();
myFilter2.uniforms.theTexture.value = myRenderTarget.texture;

const outputRenderTarget = gpuCompute.createRenderTarget();

// Now use the output texture where you want:
myMaterial.uniforms.map.value = outputRenderTarget.texture;

// And compute each frame, before rendering to screen:
gpuCompute.doRenderTarget( myFilter1, myRenderTarget );
gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );
```

**Kind**: global class  

* [GPUComputationRenderer](#GPUComputationRenderer)
    * [new GPUComputationRenderer(sizeX, sizeY, renderer)](#new_GPUComputationRenderer_new)
    * [.addResolutionDefine](#GPUComputationRenderer+addResolutionDefine)
    * [.setDataType(type)](#GPUComputationRenderer+setDataType) ⇒ [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)
    * [.addVariable(variableName, computeFragmentShader, initialValueTexture)](#GPUComputationRenderer+addVariable) ⇒ <code>Object</code>
    * [.setVariableDependencies(variable, dependencies)](#GPUComputationRenderer+setVariableDependencies)
    * [.init()](#GPUComputationRenderer+init) ⇒ <code>string</code>
    * [.compute()](#GPUComputationRenderer+compute)
    * [.getCurrentRenderTarget(variable)](#GPUComputationRenderer+getCurrentRenderTarget) ⇒ <code>WebGLRenderTarget</code>
    * [.getAlternateRenderTarget(variable)](#GPUComputationRenderer+getAlternateRenderTarget) ⇒ <code>WebGLRenderTarget</code>
    * [.dispose()](#GPUComputationRenderer+dispose)
    * [.createRenderTarget(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter)](#GPUComputationRenderer+createRenderTarget) ⇒ <code>WebGLRenderTarget</code>
    * [.createTexture()](#GPUComputationRenderer+createTexture) ⇒ <code>DataTexture</code>
    * [.renderTexture(input, output)](#GPUComputationRenderer+renderTexture)
    * [.doRenderTarget(material, output)](#GPUComputationRenderer+doRenderTarget)

<a name="new_GPUComputationRenderer_new"></a>

### new GPUComputationRenderer(sizeX, sizeY, renderer)
Constructs a new GPU computation renderer.


| Param | Type | Description |
| --- | --- | --- |
| sizeX | <code>number</code> | Computation problem size is always 2d: sizeX * sizeY elements. |
| sizeY | <code>number</code> | Computation problem size is always 2d: sizeX * sizeY elements. |
| renderer | <code>WebGLRenderer</code> | The renderer. |

<a name="GPUComputationRenderer+addResolutionDefine"></a>

### gpuComputationRenderer.addResolutionDefine
Adds a resolution defined for the given material shader.

**Kind**: instance property of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| materialShader | <code>Object</code> | The material shader. |

<a name="GPUComputationRenderer+setDataType"></a>

### gpuComputationRenderer.setDataType(type) ⇒ [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)
Sets the data type of the internal textures.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: [<code>GPUComputationRenderer</code>](#GPUComputationRenderer) - A reference to this renderer.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>FloatType</code> \| <code>HalfFloatType</code> | The type to set. |

<a name="GPUComputationRenderer+addVariable"></a>

### gpuComputationRenderer.addVariable(variableName, computeFragmentShader, initialValueTexture) ⇒ <code>Object</code>
Adds a compute variable to the renderer.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>Object</code> - The compute variable.  

| Param | Type | Description |
| --- | --- | --- |
| variableName | <code>string</code> | The variable name. |
| computeFragmentShader | <code>string</code> | The compute (fragment) shader source. |
| initialValueTexture | <code>Texture</code> | The initial value texture. |

<a name="GPUComputationRenderer+setVariableDependencies"></a>

### gpuComputationRenderer.setVariableDependencies(variable, dependencies)
Sets variable dependencies.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| variable | <code>Object</code> | The compute variable. |
| dependencies | <code>Array.&lt;Object&gt;</code> | Other compute variables that represents the dependencies. |

<a name="GPUComputationRenderer+init"></a>

### gpuComputationRenderer.init() ⇒ <code>string</code>
Initializes the renderer.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>string</code> - Returns `null` if no errors are detected. Otherwise returns the error message.  
<a name="GPUComputationRenderer+compute"></a>

### gpuComputationRenderer.compute()
Executes the compute. This method is usually called in the animation loop.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
<a name="GPUComputationRenderer+getCurrentRenderTarget"></a>

### gpuComputationRenderer.getCurrentRenderTarget(variable) ⇒ <code>WebGLRenderTarget</code>
Returns the current render target for the given compute variable.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>WebGLRenderTarget</code> - The current render target.  

| Param | Type | Description |
| --- | --- | --- |
| variable | <code>Object</code> | The compute variable. |

<a name="GPUComputationRenderer+getAlternateRenderTarget"></a>

### gpuComputationRenderer.getAlternateRenderTarget(variable) ⇒ <code>WebGLRenderTarget</code>
Returns the alternate render target for the given compute variable.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>WebGLRenderTarget</code> - The alternate render target.  

| Param | Type | Description |
| --- | --- | --- |
| variable | <code>Object</code> | The compute variable. |

<a name="GPUComputationRenderer+dispose"></a>

### gpuComputationRenderer.dispose()
Frees all internal resources. Call this method if you don't need the
renderer anymore.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
<a name="GPUComputationRenderer+createRenderTarget"></a>

### gpuComputationRenderer.createRenderTarget(sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) ⇒ <code>WebGLRenderTarget</code>
Creates a new render target from the given parameters.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>WebGLRenderTarget</code> - The new render target.  

| Param | Type | Description |
| --- | --- | --- |
| sizeXTexture | <code>number</code> | The width of the render target. |
| sizeYTexture | <code>number</code> | The height of the render target. |
| wrapS | <code>number</code> | The wrapS value. |
| wrapT | <code>number</code> | The wrapS value. |
| minFilter | <code>number</code> | The minFilter value. |
| magFilter | <code>number</code> | The magFilter value. |

<a name="GPUComputationRenderer+createTexture"></a>

### gpuComputationRenderer.createTexture() ⇒ <code>DataTexture</code>
Creates a new data texture.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  
**Returns**: <code>DataTexture</code> - The new data texture.  
<a name="GPUComputationRenderer+renderTexture"></a>

### gpuComputationRenderer.renderTexture(input, output)
Renders the given texture into the given render target.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Texture</code> | The input. |
| output | <code>WebGLRenderTarget</code> | The output. |

<a name="GPUComputationRenderer+doRenderTarget"></a>

### gpuComputationRenderer.doRenderTarget(material, output)
Renders the given material into the given render target
with a full-screen pass.

**Kind**: instance method of [<code>GPUComputationRenderer</code>](#GPUComputationRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| material | <code>Material</code> | The material. |
| output | <code>WebGLRenderTarget</code> | The output. |

<a name="Gyroscope"></a>

## Gyroscope ⇐ <code>Object3D</code>
A special type of 3D object that takes a position from the scene graph hierarchy
but uses its local rotation as world rotation. It works like real-world gyroscope -
you can move it around using hierarchy while its orientation stays fixed with
respect to the world.

**Kind**: global class  
**Extends**: <code>Object3D</code>  
<a name="new_Gyroscope_new"></a>

### new Gyroscope()
Constructs a new gyroscope.

<a name="MD2Character"></a>

## MD2Character
This class represents a management component for animated MD2
character assets.

**Kind**: global class  

* [MD2Character](#MD2Character)
    * [new MD2Character()](#new_MD2Character_new)
    * [.scale](#MD2Character+scale) : <code>number</code>
    * [.animationFPS](#MD2Character+animationFPS) : <code>number</code>
    * [.root](#MD2Character+root) : <code>Object3D</code>
    * [.meshBody](#MD2Character+meshBody) : <code>Mesh</code>
    * [.meshWeapon](#MD2Character+meshWeapon) : <code>Mesh</code>
    * [.skinsBody](#MD2Character+skinsBody) : <code>Array.&lt;Texture&gt;</code>
    * [.skinsWeapon](#MD2Character+skinsWeapon) : <code>Array.&lt;Texture&gt;</code>
    * [.weapons](#MD2Character+weapons) : <code>Array.&lt;Mesh&gt;</code>
    * [.activeAnimationClipName](#MD2Character+activeAnimationClipName) : <code>string</code>
    * [.mixer](#MD2Character+mixer) : <code>AnimationMixer</code>
    * [.onLoadComplete()](#MD2Character+onLoadComplete) : <code>function</code>
    * [.loadParts(config)](#MD2Character+loadParts)
    * [.setPlaybackRate(rate)](#MD2Character+setPlaybackRate)
    * [.setWireframe(wireframeEnabled)](#MD2Character+setWireframe)
    * [.setSkin(index)](#MD2Character+setSkin)
    * [.setWeapon(index)](#MD2Character+setWeapon)
    * [.setAnimation(clipName)](#MD2Character+setAnimation)
    * [.syncWeaponAnimation()](#MD2Character+syncWeaponAnimation)
    * [.update(delta)](#MD2Character+update)

<a name="new_MD2Character_new"></a>

### new MD2Character()
Constructs a new MD2 character.

<a name="MD2Character+scale"></a>

### mD2Character.scale : <code>number</code>
The mesh scale.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>1</code>  
<a name="MD2Character+animationFPS"></a>

### mD2Character.animationFPS : <code>number</code>
The FPS

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>6</code>  
<a name="MD2Character+root"></a>

### mD2Character.root : <code>Object3D</code>
The root 3D object

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+meshBody"></a>

### mD2Character.meshBody : <code>Mesh</code>
The body mesh.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>null</code>  
<a name="MD2Character+meshWeapon"></a>

### mD2Character.meshWeapon : <code>Mesh</code>
The weapon mesh.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>null</code>  
<a name="MD2Character+skinsBody"></a>

### mD2Character.skinsBody : <code>Array.&lt;Texture&gt;</code>
The body skins.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+skinsWeapon"></a>

### mD2Character.skinsWeapon : <code>Array.&lt;Texture&gt;</code>
The weapon skins.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+weapons"></a>

### mD2Character.weapons : <code>Array.&lt;Mesh&gt;</code>
The weapon meshes.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+activeAnimationClipName"></a>

### mD2Character.activeAnimationClipName : <code>string</code>
The name of the active animation clip.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>&quot;null&quot;</code>  
<a name="MD2Character+mixer"></a>

### mD2Character.mixer : <code>AnimationMixer</code>
The animation mixer.

**Kind**: instance property of [<code>MD2Character</code>](#MD2Character)  
**Default**: <code>null</code>  
<a name="MD2Character+onLoadComplete"></a>

### mD2Character.onLoadComplete() : <code>function</code>
The `onLoad` callback function.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+loadParts"></a>

### mD2Character.loadParts(config)
Loads the character model for the given config.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| config | <code>Object</code> | The config which defines the model and textures paths. |

<a name="MD2Character+setPlaybackRate"></a>

### mD2Character.setPlaybackRate(rate)
Sets the animation playback rate.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| rate | <code>number</code> | The playback rate to set. |

<a name="MD2Character+setWireframe"></a>

### mD2Character.setWireframe(wireframeEnabled)
Sets the wireframe material flag.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| wireframeEnabled | <code>boolean</code> | Whether to enable wireframe rendering or not. |

<a name="MD2Character+setSkin"></a>

### mD2Character.setSkin(index)
Sets the skin defined by the given skin index. This will result in a different texture
for the body mesh.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The skin index. |

<a name="MD2Character+setWeapon"></a>

### mD2Character.setWeapon(index)
Sets the weapon defined by the given weapon index. This will result in a different weapon
hold by the character.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The weapon index. |

<a name="MD2Character+setAnimation"></a>

### mD2Character.setAnimation(clipName)
Sets the defined animation clip as the active animation.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| clipName | <code>string</code> | The name of the animation clip. |

<a name="MD2Character+syncWeaponAnimation"></a>

### mD2Character.syncWeaponAnimation()
Synchronizes the weapon with the body animation.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  
<a name="MD2Character+update"></a>

### mD2Character.update(delta)
Updates the animations of the mesh. Must be called inside the animation loop.

**Kind**: instance method of [<code>MD2Character</code>](#MD2Character)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="MD2CharacterComplex"></a>

## MD2CharacterComplex
This class represents a management component for animated MD2
character assets. It provides a larger API compared to [MD2Character](MD2Character).

**Kind**: global class  

* [MD2CharacterComplex](#MD2CharacterComplex)
    * [new MD2CharacterComplex()](#new_MD2CharacterComplex_new)
    * [.scale](#MD2CharacterComplex+scale) : <code>number</code>
    * [.animationFPS](#MD2CharacterComplex+animationFPS) : <code>number</code>
    * [.transitionFrames](#MD2CharacterComplex+transitionFrames) : <code>number</code>
    * [.maxSpeed](#MD2CharacterComplex+maxSpeed) : <code>number</code>
    * [.maxReverseSpeed](#MD2CharacterComplex+maxReverseSpeed) : <code>number</code>
    * [.frontAcceleration](#MD2CharacterComplex+frontAcceleration) : <code>number</code>
    * [.backAcceleration](#MD2CharacterComplex+backAcceleration) : <code>number</code>
    * [.frontDecceleration](#MD2CharacterComplex+frontDecceleration) : <code>number</code>
    * [.angularSpeed](#MD2CharacterComplex+angularSpeed) : <code>number</code>
    * [.root](#MD2CharacterComplex+root) : <code>Object3D</code>
    * [.meshBody](#MD2CharacterComplex+meshBody) : <code>Mesh</code>
    * [.meshWeapon](#MD2CharacterComplex+meshWeapon) : <code>Mesh</code>
    * [.controls](#MD2CharacterComplex+controls) : <code>Object</code>
    * [.skinsBody](#MD2CharacterComplex+skinsBody) : <code>Array.&lt;Texture&gt;</code>
    * [.skinsWeapon](#MD2CharacterComplex+skinsWeapon) : <code>Array.&lt;Texture&gt;</code>
    * [.weapons](#MD2CharacterComplex+weapons) : <code>Array.&lt;Mesh&gt;</code>
    * [.currentSkin](#MD2CharacterComplex+currentSkin) : <code>Texture</code>
    * [.enableShadows(enable)](#MD2CharacterComplex+enableShadows)
    * [.setVisible(enable)](#MD2CharacterComplex+setVisible)
    * [.shareParts(original)](#MD2CharacterComplex+shareParts)
    * [.loadParts(config)](#MD2CharacterComplex+loadParts)
    * [.setPlaybackRate(rate)](#MD2CharacterComplex+setPlaybackRate)
    * [.setWireframe(wireframeEnabled)](#MD2CharacterComplex+setWireframe)
    * [.setSkin(index)](#MD2CharacterComplex+setSkin)
    * [.setWeapon(index)](#MD2CharacterComplex+setWeapon)
    * [.setAnimation(animationName)](#MD2CharacterComplex+setAnimation)
    * [.updateAnimations(delta)](#MD2CharacterComplex+updateAnimations)
    * [.updateBehaviors()](#MD2CharacterComplex+updateBehaviors)
    * [.updateMovementModel(delta)](#MD2CharacterComplex+updateMovementModel)

<a name="new_MD2CharacterComplex_new"></a>

### new MD2CharacterComplex()
Constructs a new MD2 character.

<a name="MD2CharacterComplex+scale"></a>

### mD2CharacterComplex.scale : <code>number</code>
The mesh scale.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>1</code>  
<a name="MD2CharacterComplex+animationFPS"></a>

### mD2CharacterComplex.animationFPS : <code>number</code>
The FPS

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>6</code>  
<a name="MD2CharacterComplex+transitionFrames"></a>

### mD2CharacterComplex.transitionFrames : <code>number</code>
The transition frames.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>15</code>  
<a name="MD2CharacterComplex+maxSpeed"></a>

### mD2CharacterComplex.maxSpeed : <code>number</code>
The character's maximum speed.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>275</code>  
<a name="MD2CharacterComplex+maxReverseSpeed"></a>

### mD2CharacterComplex.maxReverseSpeed : <code>number</code>
The character's maximum reverse speed.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>- 275</code>  
<a name="MD2CharacterComplex+frontAcceleration"></a>

### mD2CharacterComplex.frontAcceleration : <code>number</code>
The character's front acceleration.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>600</code>  
<a name="MD2CharacterComplex+backAcceleration"></a>

### mD2CharacterComplex.backAcceleration : <code>number</code>
The character's back acceleration.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>600</code>  
<a name="MD2CharacterComplex+frontDecceleration"></a>

### mD2CharacterComplex.frontDecceleration : <code>number</code>
The character's front decceleration.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>600</code>  
<a name="MD2CharacterComplex+angularSpeed"></a>

### mD2CharacterComplex.angularSpeed : <code>number</code>
The character's angular speed.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>2.5</code>  
<a name="MD2CharacterComplex+root"></a>

### mD2CharacterComplex.root : <code>Object3D</code>
The root 3D object

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+meshBody"></a>

### mD2CharacterComplex.meshBody : <code>Mesh</code>
The body mesh.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>null</code>  
<a name="MD2CharacterComplex+meshWeapon"></a>

### mD2CharacterComplex.meshWeapon : <code>Mesh</code>
The weapon mesh.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>null</code>  
<a name="MD2CharacterComplex+controls"></a>

### mD2CharacterComplex.controls : <code>Object</code>
The movement controls.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>null</code>  
<a name="MD2CharacterComplex+skinsBody"></a>

### mD2CharacterComplex.skinsBody : <code>Array.&lt;Texture&gt;</code>
The body skins.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+skinsWeapon"></a>

### mD2CharacterComplex.skinsWeapon : <code>Array.&lt;Texture&gt;</code>
The weapon skins.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+weapons"></a>

### mD2CharacterComplex.weapons : <code>Array.&lt;Mesh&gt;</code>
The weapon meshes.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+currentSkin"></a>

### mD2CharacterComplex.currentSkin : <code>Texture</code>
The current skin.

**Kind**: instance property of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
**Default**: <code>undefined</code>  
<a name="MD2CharacterComplex+enableShadows"></a>

### mD2CharacterComplex.enableShadows(enable)
Toggles shadow casting and receiving on the character's meshes.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| enable | <code>boolean</code> | Whether to enable shadows or not. |

<a name="MD2CharacterComplex+setVisible"></a>

### mD2CharacterComplex.setVisible(enable)
Toggles visibility on the character's meshes.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| enable | <code>boolean</code> | Whether the character is visible or not. |

<a name="MD2CharacterComplex+shareParts"></a>

### mD2CharacterComplex.shareParts(original)
Shares certain resources from a different character model.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| original | [<code>MD2CharacterComplex</code>](#MD2CharacterComplex) | The original MD2 character. |

<a name="MD2CharacterComplex+loadParts"></a>

### mD2CharacterComplex.loadParts(config)
Loads the character model for the given config.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| config | <code>Object</code> | The config which defines the model and textures paths. |

<a name="MD2CharacterComplex+setPlaybackRate"></a>

### mD2CharacterComplex.setPlaybackRate(rate)
Sets the animation playback rate.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| rate | <code>number</code> | The playback rate to set. |

<a name="MD2CharacterComplex+setWireframe"></a>

### mD2CharacterComplex.setWireframe(wireframeEnabled)
Sets the wireframe material flag.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| wireframeEnabled | <code>boolean</code> | Whether to enable wireframe rendering or not. |

<a name="MD2CharacterComplex+setSkin"></a>

### mD2CharacterComplex.setSkin(index)
Sets the skin defined by the given skin index. This will result in a different texture
for the body mesh.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The skin index. |

<a name="MD2CharacterComplex+setWeapon"></a>

### mD2CharacterComplex.setWeapon(index)
Sets the weapon defined by the given weapon index. This will result in a different weapon
hold by the character.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The weapon index. |

<a name="MD2CharacterComplex+setAnimation"></a>

### mD2CharacterComplex.setAnimation(animationName)
Sets the defined animation clip as the active animation.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| animationName | <code>string</code> | The name of the animation clip. |

<a name="MD2CharacterComplex+updateAnimations"></a>

### mD2CharacterComplex.updateAnimations(delta)
Updates the animations of the mesh. Must be called inside the animation loop.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="MD2CharacterComplex+updateBehaviors"></a>

### mD2CharacterComplex.updateBehaviors()
Updates the animation state based on the control inputs.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  
<a name="MD2CharacterComplex+updateMovementModel"></a>

### mD2CharacterComplex.updateMovementModel(delta)
Transforms the character model based on the control input.

**Kind**: instance method of [<code>MD2CharacterComplex</code>](#MD2CharacterComplex)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="MorphAnimMesh"></a>

## MorphAnimMesh ⇐ <code>Mesh</code>
A special type of an animated mesh with a simple interface
for animation playback. It allows to playback just one animation
without any transitions or fading between animation changes.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [MorphAnimMesh](#MorphAnimMesh) ⇐ <code>Mesh</code>
    * [new MorphAnimMesh([geometry], [material])](#new_MorphAnimMesh_new)
    * [.mixer](#MorphAnimMesh+mixer) : <code>AnimationMixer</code>
    * [.activeAction](#MorphAnimMesh+activeAction) : <code>AnimationAction</code>
    * [.setDirectionForward()](#MorphAnimMesh+setDirectionForward)
    * [.setDirectionBackward()](#MorphAnimMesh+setDirectionBackward)
    * [.playAnimation(label, fps)](#MorphAnimMesh+playAnimation)
    * [.updateAnimation(delta)](#MorphAnimMesh+updateAnimation)

<a name="new_MorphAnimMesh_new"></a>

### new MorphAnimMesh([geometry], [material])
Constructs a new morph anim mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |

<a name="MorphAnimMesh+mixer"></a>

### morphAnimMesh.mixer : <code>AnimationMixer</code>
The internal animation mixer.

**Kind**: instance property of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  
<a name="MorphAnimMesh+activeAction"></a>

### morphAnimMesh.activeAction : <code>AnimationAction</code>
The current active animation action.

**Kind**: instance property of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  
**Default**: <code>null</code>  
<a name="MorphAnimMesh+setDirectionForward"></a>

### morphAnimMesh.setDirectionForward()
Sets the animation playback direction to "forward".

**Kind**: instance method of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  
<a name="MorphAnimMesh+setDirectionBackward"></a>

### morphAnimMesh.setDirectionBackward()
Sets the animation playback direction to "backward".

**Kind**: instance method of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  
<a name="MorphAnimMesh+playAnimation"></a>

### morphAnimMesh.playAnimation(label, fps)
Plays the defined animation clip. The implementation assumes the animation
clips are stored in [Object3D#animations](Object3D#animations) or the geometry.

**Kind**: instance method of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  

| Param | Type | Description |
| --- | --- | --- |
| label | <code>string</code> | The name of the animation clip. |
| fps | <code>number</code> | The FPS of the animation clip. |

<a name="MorphAnimMesh+updateAnimation"></a>

### morphAnimMesh.updateAnimation(delta)
Updates the animations of the mesh. Must be called inside the animation loop.

**Kind**: instance method of [<code>MorphAnimMesh</code>](#MorphAnimMesh)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="MorphBlendMesh"></a>

## MorphBlendMesh ⇐ <code>Mesh</code>
A special type of an animated mesh with a more advanced interface
for animation playback. Unlike [MorphAnimMesh](MorphAnimMesh). It allows to
playback more than one morph animation at the same time but without
fading options.

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [MorphBlendMesh](#MorphBlendMesh) ⇐ <code>Mesh</code>
    * [new MorphBlendMesh([geometry], [material])](#new_MorphBlendMesh_new)
    * [.animationsMap](#MorphBlendMesh+animationsMap) : <code>Object.&lt;string, Object&gt;</code>
    * [.animationsList](#MorphBlendMesh+animationsList) : <code>Array.&lt;Object&gt;</code>
    * [.createAnimation(name, start, end, fps)](#MorphBlendMesh+createAnimation)
    * [.autoCreateAnimations(fps)](#MorphBlendMesh+autoCreateAnimations)
    * [.setAnimationDirectionForward(name)](#MorphBlendMesh+setAnimationDirectionForward)
    * [.setAnimationDirectionBackward(name)](#MorphBlendMesh+setAnimationDirectionBackward)
    * [.setAnimationFPS(name, fps)](#MorphBlendMesh+setAnimationFPS)
    * [.setAnimationDuration(name, duration)](#MorphBlendMesh+setAnimationDuration)
    * [.setAnimationWeight(name, weight)](#MorphBlendMesh+setAnimationWeight)
    * [.setAnimationTime(name, time)](#MorphBlendMesh+setAnimationTime)
    * [.getAnimationTime(name)](#MorphBlendMesh+getAnimationTime) ⇒ <code>number</code>
    * [.getAnimationDuration(name)](#MorphBlendMesh+getAnimationDuration) ⇒ <code>number</code>
    * [.playAnimation(name)](#MorphBlendMesh+playAnimation)
    * [.stopAnimation(name)](#MorphBlendMesh+stopAnimation)
    * [.update(delta)](#MorphBlendMesh+update)

<a name="new_MorphBlendMesh_new"></a>

### new MorphBlendMesh([geometry], [material])
Constructs a new morph blend mesh.


| Param | Type | Description |
| --- | --- | --- |
| [geometry] | <code>BufferGeometry</code> | The mesh geometry. |
| [material] | <code>Material</code> \| <code>Array.&lt;Material&gt;</code> | The mesh material. |

<a name="MorphBlendMesh+animationsMap"></a>

### morphBlendMesh.animationsMap : <code>Object.&lt;string, Object&gt;</code>
A dictionary of animations.

**Kind**: instance property of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  
<a name="MorphBlendMesh+animationsList"></a>

### morphBlendMesh.animationsList : <code>Array.&lt;Object&gt;</code>
A list of animations.

**Kind**: instance property of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  
<a name="MorphBlendMesh+createAnimation"></a>

### morphBlendMesh.createAnimation(name, start, end, fps)
Creates a new animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| start | <code>number</code> | The start time. |
| end | <code>number</code> | The end time. |
| fps | <code>number</code> | The FPS. |

<a name="MorphBlendMesh+autoCreateAnimations"></a>

### morphBlendMesh.autoCreateAnimations(fps)
Automatically creates animations based on the values in
[Mesh#morphTargetDictionary](Mesh#morphTargetDictionary).

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| fps | <code>number</code> | The FPS of all animations. |

<a name="MorphBlendMesh+setAnimationDirectionForward"></a>

### morphBlendMesh.setAnimationDirectionForward(name)
Sets the animation playback direction to "forward" for the
defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+setAnimationDirectionBackward"></a>

### morphBlendMesh.setAnimationDirectionBackward(name)
Sets the animation playback direction to "backward" for the
defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+setAnimationFPS"></a>

### morphBlendMesh.setAnimationFPS(name, fps)
Sets the FPS to the given value for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| fps | <code>number</code> | The FPS to set. |

<a name="MorphBlendMesh+setAnimationDuration"></a>

### morphBlendMesh.setAnimationDuration(name, duration)
Sets the duration to the given value for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| duration | <code>number</code> | The duration to set. |

<a name="MorphBlendMesh+setAnimationWeight"></a>

### morphBlendMesh.setAnimationWeight(name, weight)
Sets the weight to the given value for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| weight | <code>number</code> | The weight to set. |

<a name="MorphBlendMesh+setAnimationTime"></a>

### morphBlendMesh.setAnimationTime(name, time)
Sets the time to the given value for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |
| time | <code>number</code> | The time to set. |

<a name="MorphBlendMesh+getAnimationTime"></a>

### morphBlendMesh.getAnimationTime(name) ⇒ <code>number</code>
Returns the time for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  
**Returns**: <code>number</code> - The time.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+getAnimationDuration"></a>

### morphBlendMesh.getAnimationDuration(name) ⇒ <code>number</code>
Returns the duration for the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  
**Returns**: <code>number</code> - The duration.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+playAnimation"></a>

### morphBlendMesh.playAnimation(name)
Plays the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+stopAnimation"></a>

### morphBlendMesh.stopAnimation(name)
Stops the defined animation.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The animation name. |

<a name="MorphBlendMesh+update"></a>

### morphBlendMesh.update(delta)
Updates the animations of the mesh.

**Kind**: instance method of [<code>MorphBlendMesh</code>](#MorphBlendMesh)  

| Param | Type | Description |
| --- | --- | --- |
| delta | <code>number</code> | The delta time in seconds. |

<a name="ProgressiveLightMap"></a>

## ProgressiveLightMap
Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/).

To use, simply construct a `ProgressiveLightMap` object,
`plmap.addObjectsToLightMap(object)` an array of semi-static
objects and lights to the class once, and then call
`plmap.update(camera)` every frame to begin accumulating
lighting samples.

This should begin accumulating lightmaps which apply to
your objects, so you can start jittering lighting to achieve
the texture-space effect you're looking for.

This class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), import from `ProgressiveLightMapGPU.js`.

**Kind**: global class  

* [ProgressiveLightMap](#ProgressiveLightMap)
    * [new ProgressiveLightMap(renderer, [res])](#new_ProgressiveLightMap_new)
    * [.renderer](#ProgressiveLightMap+renderer) : <code>WebGLRenderer</code>
    * [.res](#ProgressiveLightMap+res) : <code>number</code>
    * [.addObjectsToLightMap(objects)](#ProgressiveLightMap+addObjectsToLightMap)
    * [.update(camera, [blendWindow], [blurEdges])](#ProgressiveLightMap+update)
    * [.showDebugLightmap(visible, [position])](#ProgressiveLightMap+showDebugLightmap)
    * [.dispose()](#ProgressiveLightMap+dispose)

<a name="new_ProgressiveLightMap_new"></a>

### new ProgressiveLightMap(renderer, [res])
Constructs a new progressive light map.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>WebGLRenderer</code> |  | The renderer. |
| [res] | <code>number</code> | <code>1024</code> | The side-long dimension of the total lightmap. |

<a name="ProgressiveLightMap+renderer"></a>

### progressiveLightMap.renderer : <code>WebGLRenderer</code>
The renderer.

**Kind**: instance property of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  
<a name="ProgressiveLightMap+res"></a>

### progressiveLightMap.res : <code>number</code>
The side-long dimension of the total lightmap.

**Kind**: instance property of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  
**Default**: <code>1024</code>  
<a name="ProgressiveLightMap+addObjectsToLightMap"></a>

### progressiveLightMap.addObjectsToLightMap(objects)
Sets these objects' materials' lightmaps and modifies their uv1's.

**Kind**: instance method of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  

| Param | Type | Description |
| --- | --- | --- |
| objects | <code>Array.&lt;Object3D&gt;</code> | An array of objects and lights to set up your lightmap. |

<a name="ProgressiveLightMap+update"></a>

### progressiveLightMap.update(camera, [blendWindow], [blurEdges])
This function renders each mesh one at a time into their respective surface maps.

**Kind**: instance method of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>Camera</code> |  | The camera the scene is rendered with. |
| [blendWindow] | <code>number</code> | <code>100</code> | When >1, samples will accumulate over time. |
| [blurEdges] | <code>boolean</code> | <code>true</code> | Whether to fix UV Edges via blurring. |

<a name="ProgressiveLightMap+showDebugLightmap"></a>

### progressiveLightMap.showDebugLightmap(visible, [position])
Draws the lightmap in the main scene. Call this after adding the objects to it.

**Kind**: instance method of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  

| Param | Type | Description |
| --- | --- | --- |
| visible | <code>boolean</code> | Whether the debug plane should be visible |
| [position] | <code>Vector3</code> | Where the debug plane should be drawn |

<a name="ProgressiveLightMap+dispose"></a>

### progressiveLightMap.dispose()
Frees all internal resources.

**Kind**: instance method of [<code>ProgressiveLightMap</code>](#ProgressiveLightMap)  
## Classes

<dl>
<dt><a href="#RollerCoasterGeometry">RollerCoasterGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural roller coaster geometry.</p>
</dd>
<dt><a href="#RollerCoasterLiftersGeometry">RollerCoasterLiftersGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural roller coaster lifters geometry.</p>
</dd>
<dt><a href="#RollerCoasterShadowGeometry">RollerCoasterShadowGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural roller coaster shadow geometry.</p>
</dd>
<dt><a href="#SkyGeometry">SkyGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural sky geometry.</p>
</dd>
<dt><a href="#TreesGeometry">TreesGeometry</a> ⇐ <code>BufferGeometry</code></dt>
<dd><p>A procedural trees geometry.</p>
</dd>
</dl>

<a name="RollerCoasterGeometry"></a>

## RollerCoasterGeometry ⇐ <code>BufferGeometry</code>
A procedural roller coaster geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_RollerCoasterGeometry_new"></a>

### new RollerCoasterGeometry(curve, divisions)
Constructs a new geometry.


| Param | Type | Description |
| --- | --- | --- |
| curve | <code>Curve</code> | The curve to generate the geometry along. |
| divisions | <code>number</code> | The number of divisions which defines the detail of the geometry. |

<a name="RollerCoasterLiftersGeometry"></a>

## RollerCoasterLiftersGeometry ⇐ <code>BufferGeometry</code>
A procedural roller coaster lifters geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_RollerCoasterLiftersGeometry_new"></a>

### new RollerCoasterLiftersGeometry(curve, divisions)
Constructs a new geometry.


| Param | Type | Description |
| --- | --- | --- |
| curve | <code>Curve</code> | The curve to generate the geometry along. |
| divisions | <code>number</code> | The number of divisions which defines the detail of the geometry. |

<a name="RollerCoasterShadowGeometry"></a>

## RollerCoasterShadowGeometry ⇐ <code>BufferGeometry</code>
A procedural roller coaster shadow geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_RollerCoasterShadowGeometry_new"></a>

### new RollerCoasterShadowGeometry(curve, divisions)
Constructs a new geometry.


| Param | Type | Description |
| --- | --- | --- |
| curve | <code>Curve</code> | The curve to generate the geometry along. |
| divisions | <code>number</code> | The number of divisions which defines the detail of the geometry. |

<a name="SkyGeometry"></a>

## SkyGeometry ⇐ <code>BufferGeometry</code>
A procedural sky geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_SkyGeometry_new"></a>

### new SkyGeometry()
Constructs a new geometry.

<a name="TreesGeometry"></a>

## TreesGeometry ⇐ <code>BufferGeometry</code>
A procedural trees geometry.

**Kind**: global class  
**Extends**: <code>BufferGeometry</code>  
<a name="new_TreesGeometry_new"></a>

### new TreesGeometry(landscape)
Constructs a new geometry.


| Param | Type | Description |
| --- | --- | --- |
| landscape | <code>Mesh</code> | A mesh representing the landscape. Trees will be positioned randomly on the landscape's surface. |

## Classes

<dl>
<dt><a href="#Timer">Timer</a></dt>
<dd><p>This class is an alternative to <a href="Clock">Clock</a> with a different API design and behavior.
The goal is to avoid the conceptual flaws that became apparent in <code>Clock</code> over time.</p>
<ul>
<li><code>Timer</code> has an <code>update()</code> method that updates its internal state. That makes it possible to
call <code>getDelta()</code> and <code>getElapsed()</code> multiple times per simulation step without getting different values.</li>
<li>The class can make use of the Page Visibility API to avoid large time delta values when the app
is inactive (e.g. tab switched or browser hidden).</li>
</ul>
<pre><code class="language-js">const timer = new Timer();
timer.connect( document ); // use Page Visibility API
</code></pre>
</dd>
<dt><a href="#FixedTimer">FixedTimer</a> ⇐ <code><a href="#Timer">Timer</a></code></dt>
<dd><p>A special version of a timer with a fixed time delta value.
Can be useful for testing and debugging purposes.</p>
</dd>
</dl>

<a name="Timer"></a>

## Timer
This class is an alternative to [Clock](Clock) with a different API design and behavior.
The goal is to avoid the conceptual flaws that became apparent in `Clock` over time.

- `Timer` has an `update()` method that updates its internal state. That makes it possible to
call `getDelta()` and `getElapsed()` multiple times per simulation step without getting different values.
- The class can make use of the Page Visibility API to avoid large time delta values when the app
is inactive (e.g. tab switched or browser hidden).

```js
const timer = new Timer();
timer.connect( document ); // use Page Visibility API
```

**Kind**: global class  

* [Timer](#Timer)
    * [new Timer()](#new_Timer_new)
    * [.connect(document)](#Timer+connect)
    * [.disconnect()](#Timer+disconnect)
    * [.getDelta()](#Timer+getDelta) ⇒ <code>number</code>
    * [.getElapsed()](#Timer+getElapsed) ⇒ <code>number</code>
    * [.getTimescale()](#Timer+getTimescale) ⇒ <code>number</code>
    * [.setTimescale(timescale)](#Timer+setTimescale) ⇒ [<code>Timer</code>](#Timer)
    * [.reset()](#Timer+reset) ⇒ [<code>Timer</code>](#Timer)
    * [.dispose()](#Timer+dispose)
    * [.update(timestamp)](#Timer+update) ⇒ [<code>Timer</code>](#Timer)

<a name="new_Timer_new"></a>

### new Timer()
Constructs a new timer.

<a name="Timer+connect"></a>

### timer.connect(document)
Connect the timer to the given document.Calling this method is not mandatory to
use the timer but enables the usage of the Page Visibility API to avoid large time
delta values.

**Kind**: instance method of [<code>Timer</code>](#Timer)  

| Param | Type | Description |
| --- | --- | --- |
| document | <code>Document</code> | The document. |

<a name="Timer+disconnect"></a>

### timer.disconnect()
Disconnects the timer from the DOM and also disables the usage of the Page Visibility API.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
<a name="Timer+getDelta"></a>

### timer.getDelta() ⇒ <code>number</code>
Returns the time delta in seconds.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: <code>number</code> - The time delta in second.  
<a name="Timer+getElapsed"></a>

### timer.getElapsed() ⇒ <code>number</code>
Returns the elapsed time in seconds.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: <code>number</code> - The elapsed time in second.  
<a name="Timer+getTimescale"></a>

### timer.getTimescale() ⇒ <code>number</code>
Returns the timescale.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: <code>number</code> - The timescale.  
<a name="Timer+setTimescale"></a>

### timer.setTimescale(timescale) ⇒ [<code>Timer</code>](#Timer)
Sets the given timescale which scale the time delta computation
in `update()`.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  

| Param | Type | Description |
| --- | --- | --- |
| timescale | <code>number</code> | The timescale to set. |

<a name="Timer+reset"></a>

### timer.reset() ⇒ [<code>Timer</code>](#Timer)
Resets the time computation for the current simulation step.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  
<a name="Timer+dispose"></a>

### timer.dispose()
Can be used to free all internal resources. Usually called when
the timer instance isn't required anymore.

**Kind**: instance method of [<code>Timer</code>](#Timer)  
<a name="Timer+update"></a>

### timer.update(timestamp) ⇒ [<code>Timer</code>](#Timer)
Updates the internal state of the timer. This method should be called
once per simulation step and before you perform queries against the timer
(e.g. via `getDelta()`).

**Kind**: instance method of [<code>Timer</code>](#Timer)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  

| Param | Type | Description |
| --- | --- | --- |
| timestamp | <code>number</code> | The current time in milliseconds. Can be obtained from the `requestAnimationFrame` callback argument. If not provided, the current time will be determined with `performance.now`. |

<a name="FixedTimer"></a>

## FixedTimer ⇐ [<code>Timer</code>](#Timer)
A special version of a timer with a fixed time delta value.
Can be useful for testing and debugging purposes.

**Kind**: global class  
**Extends**: [<code>Timer</code>](#Timer)  

* [FixedTimer](#FixedTimer) ⇐ [<code>Timer</code>](#Timer)
    * [new FixedTimer([fps])](#new_FixedTimer_new)
    * [.connect(document)](#Timer+connect)
    * [.disconnect()](#Timer+disconnect)
    * [.getDelta()](#Timer+getDelta) ⇒ <code>number</code>
    * [.getElapsed()](#Timer+getElapsed) ⇒ <code>number</code>
    * [.getTimescale()](#Timer+getTimescale) ⇒ <code>number</code>
    * [.setTimescale(timescale)](#Timer+setTimescale) ⇒ [<code>Timer</code>](#Timer)
    * [.reset()](#Timer+reset) ⇒ [<code>Timer</code>](#Timer)
    * [.dispose()](#Timer+dispose)
    * [.update(timestamp)](#Timer+update) ⇒ [<code>Timer</code>](#Timer)

<a name="new_FixedTimer_new"></a>

### new FixedTimer([fps])
Constructs a new timer.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [fps] | <code>number</code> | <code>60</code> | The fixed FPS of this timer. |

<a name="Timer+connect"></a>

### fixedTimer.connect(document)
Connect the timer to the given document.Calling this method is not mandatory to
use the timer but enables the usage of the Page Visibility API to avoid large time
delta values.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>connect</code>](#Timer+connect)  

| Param | Type | Description |
| --- | --- | --- |
| document | <code>Document</code> | The document. |

<a name="Timer+disconnect"></a>

### fixedTimer.disconnect()
Disconnects the timer from the DOM and also disables the usage of the Page Visibility API.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>disconnect</code>](#Timer+disconnect)  
<a name="Timer+getDelta"></a>

### fixedTimer.getDelta() ⇒ <code>number</code>
Returns the time delta in seconds.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>getDelta</code>](#Timer+getDelta)  
**Returns**: <code>number</code> - The time delta in second.  
<a name="Timer+getElapsed"></a>

### fixedTimer.getElapsed() ⇒ <code>number</code>
Returns the elapsed time in seconds.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>getElapsed</code>](#Timer+getElapsed)  
**Returns**: <code>number</code> - The elapsed time in second.  
<a name="Timer+getTimescale"></a>

### fixedTimer.getTimescale() ⇒ <code>number</code>
Returns the timescale.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>getTimescale</code>](#Timer+getTimescale)  
**Returns**: <code>number</code> - The timescale.  
<a name="Timer+setTimescale"></a>

### fixedTimer.setTimescale(timescale) ⇒ [<code>Timer</code>](#Timer)
Sets the given timescale which scale the time delta computation
in `update()`.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>setTimescale</code>](#Timer+setTimescale)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  

| Param | Type | Description |
| --- | --- | --- |
| timescale | <code>number</code> | The timescale to set. |

<a name="Timer+reset"></a>

### fixedTimer.reset() ⇒ [<code>Timer</code>](#Timer)
Resets the time computation for the current simulation step.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>reset</code>](#Timer+reset)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  
<a name="Timer+dispose"></a>

### fixedTimer.dispose()
Can be used to free all internal resources. Usually called when
the timer instance isn't required anymore.

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>dispose</code>](#Timer+dispose)  
<a name="Timer+update"></a>

### fixedTimer.update(timestamp) ⇒ [<code>Timer</code>](#Timer)
Updates the internal state of the timer. This method should be called
once per simulation step and before you perform queries against the timer
(e.g. via `getDelta()`).

**Kind**: instance method of [<code>FixedTimer</code>](#FixedTimer)  
**Overrides**: [<code>update</code>](#Timer+update)  
**Returns**: [<code>Timer</code>](#Timer) - A reference to this timer.  

| Param | Type | Description |
| --- | --- | --- |
| timestamp | <code>number</code> | The current time in milliseconds. Can be obtained from the `requestAnimationFrame` callback argument. If not provided, the current time will be determined with `performance.now`. |

<a name="TubePainter"></a>

## TubePainter
This module can be used to paint tube-like meshes
along a sequence of points. This module is used in a XR
painter demo.

```js
const painter = new TubePainter();
scene.add( painter.mesh );
```

**Kind**: global class  

* [TubePainter](#TubePainter)
    * [.mesh](#TubePainter+mesh) : <code>Mesh</code>
    * [.moveTo(position)](#TubePainter+moveTo)
    * [.lineTo(position)](#TubePainter+lineTo)
    * [.setSize(size)](#TubePainter+setSize)
    * [.update()](#TubePainter+update)

<a name="TubePainter+mesh"></a>

### tubePainter.mesh : <code>Mesh</code>
The "painted" tube mesh. Must be added to the scene.

**Kind**: instance property of [<code>TubePainter</code>](#TubePainter)  
<a name="TubePainter+moveTo"></a>

### tubePainter.moveTo(position)
Moves the current painting position to the given value.

**Kind**: instance method of [<code>TubePainter</code>](#TubePainter)  

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Vector3</code> | The new painting position. |

<a name="TubePainter+lineTo"></a>

### tubePainter.lineTo(position)
Draw a stroke from the current position to the given one.
This method extends the tube while drawing with the XR
controllers.

**Kind**: instance method of [<code>TubePainter</code>](#TubePainter)  

| Param | Type | Description |
| --- | --- | --- |
| position | <code>Vector3</code> | The destination position. |

<a name="TubePainter+setSize"></a>

### tubePainter.setSize(size)
Sets the size of newly rendered tube segments.

**Kind**: instance method of [<code>TubePainter</code>](#TubePainter)  

| Param | Type | Description |
| --- | --- | --- |
| size | <code>number</code> | The size. |

<a name="TubePainter+update"></a>

### tubePainter.update()
Updates the internal geometry buffers so the new painted
segments are rendered.

**Kind**: instance method of [<code>TubePainter</code>](#TubePainter)  
<a name="Volume"></a>

## Volume
This class had been written to handle the output of the [NRRDLoader](NRRDLoader).
It contains a volume of data and information about it. For now it only handles 3 dimensional data.

**Kind**: global class  

* [Volume](#Volume)
    * [new Volume([xLength], [yLength], [zLength], [type], [arrayBuffer])](#new_Volume_new)
    * [.xLength](#Volume+xLength) : <code>number</code>
    * [.yLength](#Volume+yLength) : <code>number</code>
    * [.zLength](#Volume+zLength) : <code>number</code>
    * [.axisOrder](#Volume+axisOrder) : <code>Array.&lt;string&gt;</code>
    * [.data](#Volume+data) : <code>TypedArray</code>
    * [.spacing](#Volume+spacing) : <code>Array.&lt;number&gt;</code>
    * [.offset](#Volume+offset) : <code>Array.&lt;number&gt;</code>
    * [.matrix](#Volume+matrix) : <code>Martrix3</code>
    * [.inverseMatrix](#Volume+inverseMatrix) : <code>Martrix3</code>
    * [.lowerThreshold](#Volume+lowerThreshold) : <code>number</code>
    * [.upperThreshold](#Volume+upperThreshold) : <code>number</code>
    * [.sliceList](#Volume+sliceList) : <code>Array</code>
    * [.segmentation](#Volume+segmentation) : <code>boolean</code>
    * [.RASDimensions](#Volume+RASDimensions) : <code>Array.&lt;number&gt;</code>
    * [.getData(i, j, k)](#Volume+getData) ⇒ <code>number</code>
    * [.access(i, j, k)](#Volume+access) ⇒ <code>number</code>
    * [.reverseAccess(index)](#Volume+reverseAccess) ⇒ <code>Array.&lt;number&gt;</code>
    * [.map(functionToMap, context)](#Volume+map) ⇒ [<code>Volume</code>](#Volume)
    * [.extractPerpendicularPlane(axis, RASIndex)](#Volume+extractPerpendicularPlane) ⇒ <code>Object</code>
    * [.extractSlice(axis, index)](#Volume+extractSlice) ⇒ <code>VolumeSlice</code>
    * [.repaintAllSlices()](#Volume+repaintAllSlices) ⇒ [<code>Volume</code>](#Volume)
    * [.computeMinMax()](#Volume+computeMinMax) ⇒ <code>Array.&lt;number&gt;</code>

<a name="new_Volume_new"></a>

### new Volume([xLength], [yLength], [zLength], [type], [arrayBuffer])
Constructs a new volume.


| Param | Type | Description |
| --- | --- | --- |
| [xLength] | <code>number</code> | Width of the volume. |
| [yLength] | <code>number</code> | Length of the volume. |
| [zLength] | <code>number</code> | Depth of the volume. |
| [type] | <code>string</code> | The type of data (uint8, uint16, ...). |
| [arrayBuffer] | <code>ArrayBuffer</code> | The buffer with volume data. |

<a name="Volume+xLength"></a>

### volume.xLength : <code>number</code>
Width of the volume in the IJK coordinate system.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
**Default**: <code>1</code>  
<a name="Volume+yLength"></a>

### volume.yLength : <code>number</code>
Height of the volume in the IJK coordinate system.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
**Default**: <code>1</code>  
<a name="Volume+zLength"></a>

### volume.zLength : <code>number</code>
Depth of the volume in the IJK coordinate system.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
**Default**: <code>1</code>  
<a name="Volume+axisOrder"></a>

### volume.axisOrder : <code>Array.&lt;string&gt;</code>
The order of the Axis dictated by the NRRD header

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+data"></a>

### volume.data : <code>TypedArray</code>
The data of the volume.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+spacing"></a>

### volume.spacing : <code>Array.&lt;number&gt;</code>
Spacing to apply to the volume from IJK to RAS coordinate system

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+offset"></a>

### volume.offset : <code>Array.&lt;number&gt;</code>
Offset of the volume in the RAS coordinate system

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+matrix"></a>

### volume.matrix : <code>Martrix3</code>
The IJK to RAS matrix.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+inverseMatrix"></a>

### volume.inverseMatrix : <code>Martrix3</code>
The RAS to IJK matrix.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+lowerThreshold"></a>

### volume.lowerThreshold : <code>number</code>
The voxels with values under this threshold won't appear in the slices.
If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume.

**Kind**: instance property of [<code>Volume</code>](#Volume)  

| Param | Type |
| --- | --- |
| value | <code>number</code> | 

<a name="Volume+upperThreshold"></a>

### volume.upperThreshold : <code>number</code>
The voxels with values over this threshold won't appear in the slices.
If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume

**Kind**: instance property of [<code>Volume</code>](#Volume)  

| Param | Type |
| --- | --- |
| value | <code>number</code> | 

<a name="Volume+sliceList"></a>

### volume.sliceList : <code>Array</code>
The list of all the slices associated to this volume

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+segmentation"></a>

### volume.segmentation : <code>boolean</code>
Whether to use segmentation mode or not.
It can load 16-bits nrrds correctly.

**Kind**: instance property of [<code>Volume</code>](#Volume)  
**Default**: <code>false</code>  
<a name="Volume+RASDimensions"></a>

### volume.RASDimensions : <code>Array.&lt;number&gt;</code>
This array holds the dimensions of the volume in the RAS space

**Kind**: instance property of [<code>Volume</code>](#Volume)  
<a name="Volume+getData"></a>

### volume.getData(i, j, k) ⇒ <code>number</code>
Shortcut for data[access(i,j,k)].

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>number</code> - The value in the data array.  

| Param | Type | Description |
| --- | --- | --- |
| i | <code>number</code> | First coordinate. |
| j | <code>number</code> | Second coordinate. |
| k | <code>number</code> | Third coordinate. |

<a name="Volume+access"></a>

### volume.access(i, j, k) ⇒ <code>number</code>
Compute the index in the data array corresponding to the given coordinates in IJK system.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>number</code> - The index.  

| Param | Type | Description |
| --- | --- | --- |
| i | <code>number</code> | First coordinate. |
| j | <code>number</code> | Second coordinate. |
| k | <code>number</code> | Third coordinate. |

<a name="Volume+reverseAccess"></a>

### volume.reverseAccess(index) ⇒ <code>Array.&lt;number&gt;</code>
Retrieve the IJK coordinates of the voxel corresponding of the given index in the data.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>Array.&lt;number&gt;</code> - The IJK coordinates as `[x,y,z]`.  

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | Index of the voxel. |

<a name="Volume+map"></a>

### volume.map(functionToMap, context) ⇒ [<code>Volume</code>](#Volume)
Apply a function to all the voxels, be careful, the value will be replaced.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: [<code>Volume</code>](#Volume) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| functionToMap | <code>function</code> | A function to apply to every voxel, will be called with the following parameters: value of the voxel, index of the voxel, the data (TypedArray). |
| context | <code>Object</code> | You can specify a context in which call the function, default if this Volume. |

<a name="Volume+extractPerpendicularPlane"></a>

### volume.extractPerpendicularPlane(axis, RASIndex) ⇒ <code>Object</code>
Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess,
the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>Object</code> - An object containing all the useful information on the geometry of the slice.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code> | The normal axis to the slice. |
| RASIndex | <code>number</code> | The index of the slice. |

<a name="Volume+extractSlice"></a>

### volume.extractSlice(axis, index) ⇒ <code>VolumeSlice</code>
Returns a slice corresponding to the given axis and index.
The coordinate are given in the Right Anterior Superior coordinate format.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>VolumeSlice</code> - The extracted slice.  

| Param | Type | Description |
| --- | --- | --- |
| axis | <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code> | The normal axis to the slice. |
| index | <code>number</code> | The index of the slice. |

<a name="Volume+repaintAllSlices"></a>

### volume.repaintAllSlices() ⇒ [<code>Volume</code>](#Volume)
Call repaint on all the slices extracted from this volume.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: [<code>Volume</code>](#Volume) - A reference to this volume.  
**See**: [VolumeSlice#repaint](VolumeSlice#repaint)  
<a name="Volume+computeMinMax"></a>

### volume.computeMinMax() ⇒ <code>Array.&lt;number&gt;</code>
Compute the minimum and the maximum of the data in the volume.

**Kind**: instance method of [<code>Volume</code>](#Volume)  
**Returns**: <code>Array.&lt;number&gt;</code> - The min/max data as `[min,max]`.  
<a name="VolumeSlice"></a>

## VolumeSlice
This class has been made to hold a slice of a volume data.

**Kind**: global class  
**See**: [Volume](Volume)  

* [VolumeSlice](#VolumeSlice)
    * [new VolumeSlice(volume, [index], [axis])](#new_VolumeSlice_new)
    * [.volume](#VolumeSlice+volume) : <code>Volume</code>
    * [.index](#VolumeSlice+index) ⇒ <code>number</code>
    * [.axis](#VolumeSlice+axis) : <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code>
    * [.canvas](#VolumeSlice+canvas) : <code>HTMLCanvasElement</code>
    * [.ctx](#VolumeSlice+ctx) : <code>CanvasRenderingContext2D</code>
    * [.canvasBuffer](#VolumeSlice+canvasBuffer) : <code>HTMLCanvasElement</code>
    * [.ctxBuffer](#VolumeSlice+ctxBuffer) : <code>CanvasRenderingContext2D</code>
    * [.mesh](#VolumeSlice+mesh) : <code>Mesh</code>
    * [.geometryNeedsUpdate](#VolumeSlice+geometryNeedsUpdate) : <code>boolean</code>
    * [.iLength](#VolumeSlice+iLength) : <code>number</code>
    * [.jLength](#VolumeSlice+jLength) : <code>number</code>
    * [.sliceAccess](#VolumeSlice+sliceAccess) : <code>function</code>
    * [.repaint()](#VolumeSlice+repaint)
    * [.updateGeometry()](#VolumeSlice+updateGeometry)

<a name="new_VolumeSlice_new"></a>

### new VolumeSlice(volume, [index], [axis])
Constructs a new volume slice.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| volume | <code>Volume</code> |  | The associated volume. |
| [index] | <code>number</code> | <code>0</code> | The index of the slice. |
| [axis] | <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code> | <code>&#x27;z&#x27;</code> | For now only 'x', 'y' or 'z' but later it will change to a normal vector. |

<a name="VolumeSlice+volume"></a>

### volumeSlice.volume : <code>Volume</code>
The associated volume.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+index"></a>

### volumeSlice.index ⇒ <code>number</code>
The index of the slice, if changed, will automatically call updateGeometry at the next repaint.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**Default**: <code>0</code>  

| Param | Type |
| --- | --- |
| value | <code>number</code> | 

<a name="VolumeSlice+axis"></a>

### volumeSlice.axis : <code>&#x27;x&#x27;</code> \| <code>&#x27;y&#x27;</code> \| <code>&#x27;z&#x27;</code>
The normal axis.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+canvas"></a>

### volumeSlice.canvas : <code>HTMLCanvasElement</code>
The final canvas used for the texture.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+ctx"></a>

### volumeSlice.ctx : <code>CanvasRenderingContext2D</code>
The rendering context of the canvas.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+canvasBuffer"></a>

### volumeSlice.canvasBuffer : <code>HTMLCanvasElement</code>
The intermediary canvas used to paint the data.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+ctxBuffer"></a>

### volumeSlice.ctxBuffer : <code>CanvasRenderingContext2D</code>
The rendering context of the canvas buffer,

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+mesh"></a>

### volumeSlice.mesh : <code>Mesh</code>
The mesh ready to get used in the scene.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+geometryNeedsUpdate"></a>

### volumeSlice.geometryNeedsUpdate : <code>boolean</code>
If set to `true`, `updateGeometry()` will be triggered at the next repaint.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**Default**: <code>true</code>  
<a name="VolumeSlice+iLength"></a>

### volumeSlice.iLength : <code>number</code>
Width of slice in the original coordinate system, corresponds to the width of the buffer canvas.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**Default**: <code>0</code>  
<a name="VolumeSlice+jLength"></a>

### volumeSlice.jLength : <code>number</code>
Height of slice in the original coordinate system, corresponds to the height of the buffer canvas.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**Default**: <code>0</code>  
<a name="VolumeSlice+sliceAccess"></a>

### volumeSlice.sliceAccess : <code>function</code>
Function that allow the slice to access right data.

**Kind**: instance property of [<code>VolumeSlice</code>](#VolumeSlice)  
**See**: [Volume#extractPerpendicularPlane](Volume#extractPerpendicularPlane)  
<a name="VolumeSlice+repaint"></a>

### volumeSlice.repaint()
Refresh the texture and the geometry if geometryNeedsUpdate is set to `true`.

**Kind**: instance method of [<code>VolumeSlice</code>](#VolumeSlice)  
<a name="VolumeSlice+updateGeometry"></a>

### volumeSlice.updateGeometry()
Refresh the geometry according to axis and index.

**Kind**: instance method of [<code>VolumeSlice</code>](#VolumeSlice)  
**See**: [Volume#extractPerpendicularPlane](Volume#extractPerpendicularPlane)  
<a name="getUniforms"></a>

## getUniforms(splineTexture) ⇒ <code>Object</code>
Create a new set of uniforms for describing the curve modifier.

**Kind**: global function  
**Returns**: <code>Object</code> - The uniforms object to be used in the shader.  

| Param | Type | Description |
| --- | --- | --- |
| splineTexture | <code>DataTexture</code> | Which holds the curve description. |

<a name="EdgeSplitModifier"></a>

## EdgeSplitModifier
The modifier can be used to split faces at sharp edges. This allows to compute
normals without smoothing the edges which can lead to an improved visual result.

```js
const modifier = new EdgeSplitModifier();
geometry = modifier.modify( geometry, Math.PI * 0.4 );
```

**Kind**: global class  
<a name="EdgeSplitModifier+modify"></a>

### edgeSplitModifier.modify(geometry, cutOffAngle, [tryKeepNormals]) ⇒ <code>BufferGeometry</code>
Returns a new, modified version of the given geometry by applying an edge-split operation.
Please note that the resulting geometry is always indexed.

**Kind**: instance method of [<code>EdgeSplitModifier</code>](#EdgeSplitModifier)  
**Returns**: <code>BufferGeometry</code> - A new, modified geometry.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to modify. |
| cutOffAngle | <code>number</code> |  | The cut off angle in radians. |
| [tryKeepNormals] | <code>boolean</code> | <code>true</code> | Whether to try to keep normals or not. |

<a name="SimplifyModifier"></a>

## SimplifyModifier
This class can be used to modify a geometry by simplifying it. A typical use
case for such a modifier is automatic LOD generation.

The implementation is based on [Progressive Mesh type Polygon Reduction Algorithm](https://web.archive.org/web/20230610044040/http://www.melax.com/polychop/)
by Stan Melax in 1998.

```js
const modifier = new SimplifyModifier();
geometry = modifier.modify( geometry );
```

**Kind**: global class  
<a name="SimplifyModifier+modify"></a>

### simplifyModifier.modify(geometry, count) ⇒ <code>BufferGeometry</code>
Returns a new, modified version of the given geometry by applying a simplification.
Please note that the resulting geometry is always non-indexed.

**Kind**: instance method of [<code>SimplifyModifier</code>](#SimplifyModifier)  
**Returns**: <code>BufferGeometry</code> - A new, modified geometry.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to modify. |
| count | <code>number</code> | The number of vertices to remove. |

<a name="TessellateModifier"></a>

## TessellateModifier
This class can be used to modify a geometry by breaking its edges if they
are longer than maximum length.

```js
const modifier = new TessellateModifier( 8, 6 );
geometry = modifier.modify( geometry );
```

**Kind**: global class  

* [TessellateModifier](#TessellateModifier)
    * [new TessellateModifier([maxEdgeLength], [maxIterations])](#new_TessellateModifier_new)
    * [.maxEdgeLength](#TessellateModifier+maxEdgeLength) : <code>number</code>
    * [.maxIterations](#TessellateModifier+maxIterations) : <code>number</code>
    * [.modify(geometry)](#TessellateModifier+modify) ⇒ <code>BufferGeometry</code>

<a name="new_TessellateModifier_new"></a>

### new TessellateModifier([maxEdgeLength], [maxIterations])
Constructs a new Tessellate modifier.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [maxEdgeLength] | <code>number</code> | <code>0.1</code> | The maximum edge length. |
| [maxIterations] | <code>number</code> | <code>6</code> | The number of iterations. |

<a name="TessellateModifier+maxEdgeLength"></a>

### tessellateModifier.maxEdgeLength : <code>number</code>
The maximum edge length.

**Kind**: instance property of [<code>TessellateModifier</code>](#TessellateModifier)  
**Default**: <code>0.1</code>  
<a name="TessellateModifier+maxIterations"></a>

### tessellateModifier.maxIterations : <code>number</code>
The maximum edge length.

**Kind**: instance property of [<code>TessellateModifier</code>](#TessellateModifier)  
**Default**: <code>0.1</code>  
<a name="TessellateModifier+modify"></a>

### tessellateModifier.modify(geometry) ⇒ <code>BufferGeometry</code>
Returns a new, modified version of the given geometry by applying a tesselation.
Please note that the resulting geometry is always non-indexed.

**Kind**: instance method of [<code>TessellateModifier</code>](#TessellateModifier)  
**Returns**: <code>BufferGeometry</code> - A new, modified geometry.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to modify. |

<a name="GroundedSkybox"></a>

## GroundedSkybox ⇐ <code>Mesh</code>
A ground-projected skybox.

By default the object is centered at the camera, so it is often helpful to set
`skybox.position.y = height` to put the ground at the origin.

```js
const height = 15, radius = 100;

const skybox = new GroundedSkybox( envMap, height, radius );
skybox.position.y = height;
scene.add( skybox );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  
<a name="new_GroundedSkybox_new"></a>

### new GroundedSkybox(map, height, radius, [resolution])
Constructs a new ground-projected skybox.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| map | <code>Texture</code> |  | The environment map to use. |
| height | <code>number</code> |  | The height is how far the camera that took the photo was above the ground. A larger value will magnify the downward part of the image. |
| radius | <code>number</code> |  | The radius of the skybox. Must be large enough to ensure the scene's camera stays inside. |
| [resolution] | <code>number</code> | <code>128</code> | The geometry resolution of the skybox. |

## Classes

<dl>
<dt><a href="#Lensflare">Lensflare</a> ⇐ <code>Mesh</code></dt>
<dd><p>Creates a simulated lens flare that tracks a light.</p>
<p>Note that this class can only be used with <a href="WebGLRenderer">WebGLRenderer</a>.
When using <a href="WebGPURenderer">WebGPURenderer</a>, use <a href="LensflareMesh">LensflareMesh</a>.</p>
<pre><code class="language-js">const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );

const lensflare = new Lensflare();
lensflare.addElement( new LensflareElement( textureFlare0, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare1, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare2, 60, 0.6 ) );

light.add( lensflare );
</code></pre>
</dd>
<dt><a href="#LensflareElement">LensflareElement</a></dt>
<dd><p>Represents a single flare that can be added to a <a href="#Lensflare">Lensflare</a> container.</p>
</dd>
</dl>

<a name="Lensflare"></a>

## Lensflare ⇐ <code>Mesh</code>
Creates a simulated lens flare that tracks a light.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [LensflareMesh](LensflareMesh).

```js
const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );

const lensflare = new Lensflare();
lensflare.addElement( new LensflareElement( textureFlare0, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare1, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare2, 60, 0.6 ) );

light.add( lensflare );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Lensflare](#Lensflare) ⇐ <code>Mesh</code>
    * [new Lensflare()](#new_Lensflare_new)
    * [.isLensflare](#Lensflare+isLensflare) : <code>boolean</code>
    * [.frustumCulled](#Lensflare+frustumCulled) : <code>boolean</code>
    * [.renderOrder](#Lensflare+renderOrder) : <code>number</code>
    * [.addElement(element)](#Lensflare+addElement)
    * [.dispose()](#Lensflare+dispose)

<a name="new_Lensflare_new"></a>

### new Lensflare()
Constructs a new lensflare.

<a name="Lensflare+isLensflare"></a>

### lensflare.isLensflare : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Lensflare</code>](#Lensflare)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Lensflare+frustumCulled"></a>

### lensflare.frustumCulled : <code>boolean</code>
Overwritten to disable view-frustum culling by default.

**Kind**: instance property of [<code>Lensflare</code>](#Lensflare)  
**Default**: <code>false</code>  
<a name="Lensflare+renderOrder"></a>

### lensflare.renderOrder : <code>number</code>
Overwritten to make sure lensflares a rendered last.

**Kind**: instance property of [<code>Lensflare</code>](#Lensflare)  
**Default**: <code>Infinity</code>  
<a name="Lensflare+addElement"></a>

### lensflare.addElement(element)
Adds the given lensflare element to this instance.

**Kind**: instance method of [<code>Lensflare</code>](#Lensflare)  

| Param | Type | Description |
| --- | --- | --- |
| element | [<code>LensflareElement</code>](#LensflareElement) | The element to add. |

<a name="Lensflare+dispose"></a>

### lensflare.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Lensflare</code>](#Lensflare)  
<a name="LensflareElement"></a>

## LensflareElement
Represents a single flare that can be added to a [Lensflare](#Lensflare) container.

**Kind**: global class  

* [LensflareElement](#LensflareElement)
    * [new LensflareElement(texture, [size], [distance], [color])](#new_LensflareElement_new)
    * [.texture](#LensflareElement+texture) : <code>Texture</code>
    * [.size](#LensflareElement+size) : <code>number</code>
    * [.distance](#LensflareElement+distance) : <code>number</code>
    * [.color](#LensflareElement+color) : <code>Color</code>

<a name="new_LensflareElement_new"></a>

### new LensflareElement(texture, [size], [distance], [color])
Constructs a new lensflare element.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>Texture</code> |  | The flare's texture. |
| [size] | <code>number</code> | <code>1</code> | The size in pixels. |
| [distance] | <code>number</code> | <code>0</code> | The normalized distance (`[0,1]`) from the light source. A value of `0` means the flare is located at light source. |
| [color] | <code>Color</code> |  | The flare's color |

<a name="LensflareElement+texture"></a>

### lensflareElement.texture : <code>Texture</code>
The flare's texture.

**Kind**: instance property of [<code>LensflareElement</code>](#LensflareElement)  
<a name="LensflareElement+size"></a>

### lensflareElement.size : <code>number</code>
The size in pixels.

**Kind**: instance property of [<code>LensflareElement</code>](#LensflareElement)  
**Default**: <code>1</code>  
<a name="LensflareElement+distance"></a>

### lensflareElement.distance : <code>number</code>
The normalized distance (`[0,1]`) from the light source.
A value of `0` means the flare is located at light source.

**Kind**: instance property of [<code>LensflareElement</code>](#LensflareElement)  
**Default**: <code>0</code>  
<a name="LensflareElement+color"></a>

### lensflareElement.color : <code>Color</code>
The flare's color

**Kind**: instance property of [<code>LensflareElement</code>](#LensflareElement)  
**Default**: <code>(1,1,1)</code>  
<a name="LensflareMesh"></a>

## LensflareMesh ⇐ <code>Mesh</code>
Creates a simulated lens flare that tracks a light.

Note that this class can only be used with [WebGPURenderer](WebGPURenderer).
When using [WebGLRenderer](WebGLRenderer), use [Lensflare](Lensflare).

```js
const light = new THREE.PointLight( 0xffffff, 1.5, 2000 );

const lensflare = new LensflareMesh();
lensflare.addElement( new LensflareElement( textureFlare0, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare1, 512, 0 ) );
lensflare.addElement( new LensflareElement( textureFlare2, 60, 0.6 ) );

light.add( lensflare );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [LensflareMesh](#LensflareMesh) ⇐ <code>Mesh</code>
    * [new LensflareMesh()](#new_LensflareMesh_new)
    * [.isLensflareMesh](#LensflareMesh+isLensflareMesh) : <code>boolean</code>
    * [.frustumCulled](#LensflareMesh+frustumCulled) : <code>boolean</code>
    * [.renderOrder](#LensflareMesh+renderOrder) : <code>number</code>
    * [.addElement(element)](#LensflareMesh+addElement)
    * [.dispose()](#LensflareMesh+dispose)

<a name="new_LensflareMesh_new"></a>

### new LensflareMesh()
Constructs a new lensflare mesh.

<a name="LensflareMesh+isLensflareMesh"></a>

### lensflareMesh.isLensflareMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LensflareMesh</code>](#LensflareMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="LensflareMesh+frustumCulled"></a>

### lensflareMesh.frustumCulled : <code>boolean</code>
Overwritten to disable view-frustum culling by default.

**Kind**: instance property of [<code>LensflareMesh</code>](#LensflareMesh)  
**Default**: <code>false</code>  
<a name="LensflareMesh+renderOrder"></a>

### lensflareMesh.renderOrder : <code>number</code>
Overwritten to make sure lensflares a rendered last.

**Kind**: instance property of [<code>LensflareMesh</code>](#LensflareMesh)  
**Default**: <code>Infinity</code>  
<a name="LensflareMesh+addElement"></a>

### lensflareMesh.addElement(element)
Adds the given lensflare element to this instance.

**Kind**: instance method of [<code>LensflareMesh</code>](#LensflareMesh)  

| Param | Type | Description |
| --- | --- | --- |
| element | <code>LensflareElement</code> | The element to add. |

<a name="LensflareMesh+dispose"></a>

### lensflareMesh.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>LensflareMesh</code>](#LensflareMesh)  
<a name="MarchingCubes"></a>

## MarchingCubes
A marching cubes implementation.

Port of: [http://webglsamples.org/blob/blob.html](http://webglsamples.org/blob/blob.html)

**Kind**: global class  

* [MarchingCubes](#MarchingCubes)
    * [new MarchingCubes(resolution, material, [enableUvs], [enableColors], [maxPolyCount])](#new_MarchingCubes_new)
    * [.isMarchingCubes](#MarchingCubes+isMarchingCubes) : <code>boolean</code>
    * [.enableUvs](#MarchingCubes+enableUvs) : <code>boolean</code>
    * [.enableColors](#MarchingCubes+enableColors) : <code>boolean</code>
    * [.addBall(ballx, bally, ballz, strength, subtract, colors)](#MarchingCubes+addBall)
    * [.addPlaneX(strength, subtract)](#MarchingCubes+addPlaneX)
    * [.addPlaneY(strength, subtract)](#MarchingCubes+addPlaneY)
    * [.addPlaneZ(strength, subtract)](#MarchingCubes+addPlaneZ)
    * [.setCell(x, y, z, value)](#MarchingCubes+setCell)
    * [.getCell(x, y, z)](#MarchingCubes+getCell) ⇒ <code>number</code>
    * [.blur([intensity])](#MarchingCubes+blur)
    * [.reset()](#MarchingCubes+reset)
    * [.update()](#MarchingCubes+update)

<a name="new_MarchingCubes_new"></a>

### new MarchingCubes(resolution, material, [enableUvs], [enableColors], [maxPolyCount])
Constructs a new marching cubes instance.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| resolution | <code>number</code> |  | The effect's resolution. |
| material | <code>Material</code> |  | The cube's material. |
| [enableUvs] | <code>boolean</code> | <code>false</code> | Whether texture coordinates should be animated or not. |
| [enableColors] | <code>boolean</code> | <code>false</code> | Whether colors should be animated or not. |
| [maxPolyCount] | <code>number</code> | <code>10000</code> | The maximum size of the geometry buffers. |

<a name="MarchingCubes+isMarchingCubes"></a>

### marchingCubes.isMarchingCubes : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MarchingCubes</code>](#MarchingCubes)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MarchingCubes+enableUvs"></a>

### marchingCubes.enableUvs : <code>boolean</code>
Whether texture coordinates should be animated or not.

**Kind**: instance property of [<code>MarchingCubes</code>](#MarchingCubes)  
**Default**: <code>false</code>  
<a name="MarchingCubes+enableColors"></a>

### marchingCubes.enableColors : <code>boolean</code>
Whether colors should be animated or not.

**Kind**: instance property of [<code>MarchingCubes</code>](#MarchingCubes)  
**Default**: <code>false</code>  
<a name="MarchingCubes+addBall"></a>

### marchingCubes.addBall(ballx, bally, ballz, strength, subtract, colors)
Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after
a fixed distance, determined by strength and subtract.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| ballx | <code>number</code> | The x-coordinate of the ball. |
| bally | <code>number</code> | The y-coordinate of the ball. |
| ballz | <code>number</code> | The z-coordinate of the ball. |
| strength | <code>number</code> | The strength factor. |
| subtract | <code>number</code> | The subtract factor. |
| colors | <code>Color</code> | The color. |

<a name="MarchingCubes+addPlaneX"></a>

### marchingCubes.addPlaneX(strength, subtract)
Adds a plane along the x-axis.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| strength | <code>number</code> | The strength factor. |
| subtract | <code>number</code> | The subtract factor. |

<a name="MarchingCubes+addPlaneY"></a>

### marchingCubes.addPlaneY(strength, subtract)
Adds a plane along the y-axis.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| strength | <code>number</code> | The strength factor. |
| subtract | <code>number</code> | The subtract factor. |

<a name="MarchingCubes+addPlaneZ"></a>

### marchingCubes.addPlaneZ(strength, subtract)
Adds a plane along the z-axis.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| strength | <code>number</code> | The strength factor. |
| subtract | <code>number</code> | The subtract factor. |

<a name="MarchingCubes+setCell"></a>

### marchingCubes.setCell(x, y, z, value)
Sets the cell value for the given coordinates.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value. |
| y | <code>number</code> | The y value. |
| z | <code>number</code> | The z value. |
| value | <code>number</code> | The value to set. |

<a name="MarchingCubes+getCell"></a>

### marchingCubes.getCell(x, y, z) ⇒ <code>number</code>
Returns the cell value for the given coordinates.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  
**Returns**: <code>number</code> - The value.  

| Param | Type | Description |
| --- | --- | --- |
| x | <code>number</code> | The x value. |
| y | <code>number</code> | The y value. |
| z | <code>number</code> | The z value. |

<a name="MarchingCubes+blur"></a>

### marchingCubes.blur([intensity])
Applies a blur with the given intensity.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [intensity] | <code>number</code> | <code>1</code> | The intensity of the blur. |

<a name="MarchingCubes+reset"></a>

### marchingCubes.reset()
Resets the effect.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  
<a name="MarchingCubes+update"></a>

### marchingCubes.update()
Updates the effect.

**Kind**: instance method of [<code>MarchingCubes</code>](#MarchingCubes)  
<a name="Reflector"></a>

## Reflector ⇐ <code>Mesh</code>
Can be used to create a flat, reflective surface like a mirror.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [ReflectorNode](ReflectorNode).

```js
const geometry = new THREE.PlaneGeometry( 100, 100 );

const reflector = new Reflector( geometry, {
	clipBias: 0.003,
	textureWidth: window.innerWidth * window.devicePixelRatio,
	textureHeight: window.innerHeight * window.devicePixelRatio,
	color: 0xc1cbcb
} );

scene.add( reflector );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Reflector](#Reflector) ⇐ <code>Mesh</code>
    * [new Reflector(geometry, [options])](#new_Reflector_new)
    * _instance_
        * [.isReflector](#Reflector+isReflector) : <code>boolean</code>
        * [.forceUpdate](#Reflector+forceUpdate) : <code>boolean</code>
        * [.camera](#Reflector+camera) : <code>PerspectiveCamera</code>
        * [.getRenderTarget()](#Reflector+getRenderTarget) ⇒ <code>WebGLRenderTarget</code>
        * [.dispose()](#Reflector+dispose)
    * _inner_
        * [~Options](#Reflector..Options) : <code>Object</code>

<a name="new_Reflector_new"></a>

### new Reflector(geometry, [options])
Constructs a new reflector.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The reflector's geometry. |
| [options] | [<code>Options</code>](#Reflector..Options) | The configuration options. |

<a name="Reflector+isReflector"></a>

### reflector.isReflector : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Reflector</code>](#Reflector)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Reflector+forceUpdate"></a>

### reflector.forceUpdate : <code>boolean</code>
Whether to force an update, no matter if the reflector
is in view or not.

**Kind**: instance property of [<code>Reflector</code>](#Reflector)  
**Default**: <code>false</code>  
<a name="Reflector+camera"></a>

### reflector.camera : <code>PerspectiveCamera</code>
The reflector's virtual camera. This is used to render
the scene from the mirror's point of view.

**Kind**: instance property of [<code>Reflector</code>](#Reflector)  
<a name="Reflector+getRenderTarget"></a>

### reflector.getRenderTarget() ⇒ <code>WebGLRenderTarget</code>
Returns the reflector's internal render target.

**Kind**: instance method of [<code>Reflector</code>](#Reflector)  
**Returns**: <code>WebGLRenderTarget</code> - The internal render target  
<a name="Reflector+dispose"></a>

### reflector.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Reflector</code>](#Reflector)  
<a name="Reflector..Options"></a>

### Reflector~Options : <code>Object</code>
Constructor options of `Reflector`.

**Kind**: inner typedef of [<code>Reflector</code>](#Reflector)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The reflector's color. |
| [textureWidth] | <code>number</code> | <code>512</code> | The texture width. A higher value results in more clear reflections but is also more expensive. |
| [textureHeight] | <code>number</code> | <code>512</code> | The texture height. A higher value results in more clear reflections but is also more expensive. |
| [clipBias] | <code>number</code> | <code>0</code> | The clip bias. |
| [shader] | <code>Object</code> |  | Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry. |
| [multisample] | <code>number</code> | <code>4</code> | How many samples to use for MSAA. `0` disables MSAA. |

<a name="ReflectorForSSRPass"></a>

## ReflectorForSSRPass ⇐ <code>Mesh</code>
A special version of [Reflector](Reflector) for usage with [SSRPass](SSRPass).

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [ReflectorForSSRPass](#ReflectorForSSRPass) ⇐ <code>Mesh</code>
    * [new ReflectorForSSRPass(geometry, [options])](#new_ReflectorForSSRPass_new)
    * _instance_
        * [.getRenderTarget()](#ReflectorForSSRPass+getRenderTarget) ⇒ <code>WebGLRenderTarget</code>
        * [.dispose()](#ReflectorForSSRPass+dispose)
    * _inner_
        * [~Options](#ReflectorForSSRPass..Options) : <code>Object</code>

<a name="new_ReflectorForSSRPass_new"></a>

### new ReflectorForSSRPass(geometry, [options])
Constructs a new reflector.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The reflector's geometry. |
| [options] | [<code>Options</code>](#ReflectorForSSRPass..Options) | The configuration options. |

<a name="ReflectorForSSRPass+getRenderTarget"></a>

### reflectorForSSRPass.getRenderTarget() ⇒ <code>WebGLRenderTarget</code>
Returns the reflector's internal render target.

**Kind**: instance method of [<code>ReflectorForSSRPass</code>](#ReflectorForSSRPass)  
**Returns**: <code>WebGLRenderTarget</code> - The internal render target  
<a name="ReflectorForSSRPass+dispose"></a>

### reflectorForSSRPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>ReflectorForSSRPass</code>](#ReflectorForSSRPass)  
<a name="ReflectorForSSRPass..Options"></a>

### ReflectorForSSRPass~Options : <code>Object</code>
Constructor options of `ReflectorForSSRPass`.

**Kind**: inner typedef of [<code>ReflectorForSSRPass</code>](#ReflectorForSSRPass)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The reflector's color. |
| [textureWidth] | <code>number</code> | <code>512</code> | The texture width. A higher value results in more clear reflections but is also more expensive. |
| [textureHeight] | <code>number</code> | <code>512</code> | The texture height. A higher value results in more clear reflections but is also more expensive. |
| [clipBias] | <code>number</code> | <code>0</code> | The clip bias. |
| [shader] | <code>Object</code> |  | Can be used to pass in a custom shader that defines how the reflective view is projected onto the reflector's geometry. |
| [useDepthTexture] | <code>boolean</code> | <code>true</code> | Whether to store depth values in a texture or not. |

<a name="Refractor"></a>

## Refractor ⇐ <code>Mesh</code>
Can be used to create a flat, refractive surface like for special
windows or water effects.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [viewportSharedTexture](viewportSharedTexture).

```js
const geometry = new THREE.PlaneGeometry( 100, 100 );

const refractor = new Refractor( refractorGeometry, {
	color: 0xcbcbcb,
	textureWidth: 1024,
	textureHeight: 1024
} );

scene.add( refractor );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Refractor](#Refractor) ⇐ <code>Mesh</code>
    * [new Refractor(geometry, [options])](#new_Refractor_new)
    * _instance_
        * [.isRefractor](#Refractor+isRefractor) : <code>boolean</code>
        * [.camera](#Refractor+camera) : <code>PerspectiveCamera</code>
        * [.getRenderTarget()](#Refractor+getRenderTarget) ⇒ <code>WebGLRenderTarget</code>
        * [.dispose()](#Refractor+dispose)
    * _inner_
        * [~Options](#Refractor..Options) : <code>Object</code>

<a name="new_Refractor_new"></a>

### new Refractor(geometry, [options])
Constructs a new refractor.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The refractor's geometry. |
| [options] | [<code>Options</code>](#Refractor..Options) | The configuration options. |

<a name="Refractor+isRefractor"></a>

### refractor.isRefractor : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Refractor</code>](#Refractor)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Refractor+camera"></a>

### refractor.camera : <code>PerspectiveCamera</code>
The reflector's virtual camera.

**Kind**: instance property of [<code>Refractor</code>](#Refractor)  
<a name="Refractor+getRenderTarget"></a>

### refractor.getRenderTarget() ⇒ <code>WebGLRenderTarget</code>
Returns the reflector's internal render target.

**Kind**: instance method of [<code>Refractor</code>](#Refractor)  
**Returns**: <code>WebGLRenderTarget</code> - The internal render target  
<a name="Refractor+dispose"></a>

### refractor.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>Refractor</code>](#Refractor)  
<a name="Refractor..Options"></a>

### Refractor~Options : <code>Object</code>
Constructor options of `Refractor`.

**Kind**: inner typedef of [<code>Refractor</code>](#Refractor)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [color] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The refractor's color. |
| [textureWidth] | <code>number</code> | <code>512</code> | The texture width. A higher value results in more clear refractions but is also more expensive. |
| [textureHeight] | <code>number</code> | <code>512</code> | The texture height. A higher value results in more clear refractions but is also more expensive. |
| [clipBias] | <code>number</code> | <code>0</code> | The clip bias. |
| [shader] | <code>Object</code> |  | Can be used to pass in a custom shader that defines how the refractive view is projected onto the reflector's geometry. |
| [multisample] | <code>number</code> | <code>4</code> | How many samples to use for MSAA. `0` disables MSAA. |

<a name="ShadowMesh"></a>

## ShadowMesh ⇐ <code>Mesh</code>
A Shadow Mesh that follows a shadow-casting mesh in the scene,
but is confined to a single plane. This technique can be used as
a very performant alternative to classic shadow mapping. However,
it has serious limitations like:

- Shadows can only be casted on flat planes.
- No soft shadows support.

```js
const cubeShadow = new ShadowMesh( cube );
scene.add( cubeShadow );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [ShadowMesh](#ShadowMesh) ⇐ <code>Mesh</code>
    * [new ShadowMesh(mesh)](#new_ShadowMesh_new)
    * [.isShadowMesh](#ShadowMesh+isShadowMesh) : <code>boolean</code>
    * [.meshMatrix](#ShadowMesh+meshMatrix) : <code>Matrix4</code>
    * [.frustumCulled](#ShadowMesh+frustumCulled) : <code>boolean</code>
    * [.matrixAutoUpdate](#ShadowMesh+matrixAutoUpdate) : <code>boolean</code>
    * [.update(plane, lightPosition4D)](#ShadowMesh+update)

<a name="new_ShadowMesh_new"></a>

### new ShadowMesh(mesh)
Constructs a new shadow mesh.


| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | The shadow-casting reference mesh. |

<a name="ShadowMesh+isShadowMesh"></a>

### shadowMesh.isShadowMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowMesh</code>](#ShadowMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowMesh+meshMatrix"></a>

### shadowMesh.meshMatrix : <code>Matrix4</code>
Represent the world matrix of the reference mesh.

**Kind**: instance property of [<code>ShadowMesh</code>](#ShadowMesh)  
<a name="ShadowMesh+frustumCulled"></a>

### shadowMesh.frustumCulled : <code>boolean</code>
Overwritten to disable view-frustum culling by default.

**Kind**: instance property of [<code>ShadowMesh</code>](#ShadowMesh)  
**Default**: <code>false</code>  
<a name="ShadowMesh+matrixAutoUpdate"></a>

### shadowMesh.matrixAutoUpdate : <code>boolean</code>
Overwritten to disable automatic matrix update. The local
matrix is computed manually in [update](#ShadowMesh+update).

**Kind**: instance property of [<code>ShadowMesh</code>](#ShadowMesh)  
**Default**: <code>false</code>  
<a name="ShadowMesh+update"></a>

### shadowMesh.update(plane, lightPosition4D)
Updates the shadow mesh so it follows its shadow-casting reference mesh.

**Kind**: instance method of [<code>ShadowMesh</code>](#ShadowMesh)  

| Param | Type | Description |
| --- | --- | --- |
| plane | <code>Plane</code> | The plane onto the shadow mesh is projected. |
| lightPosition4D | <code>Vector4</code> | The light position. |

<a name="Sky"></a>

## Sky ⇐ <code>Mesh</code>
Represents a skydome for scene backgrounds. Based on [A Practical Analytic Model for Daylight](https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight)
aka The Preetham Model, the de facto standard for analytical skydomes.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [SkyMesh](SkyMesh).

More references:

- [http://simonwallner.at/project/atmospheric-scattering/](http://simonwallner.at/project/atmospheric-scattering/)
- [http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR](http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR)


```js
const sky = new Sky();
sky.scale.setScalar( 10000 );
scene.add( sky );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Sky](#Sky) ⇐ <code>Mesh</code>
    * [new Sky()](#new_Sky_new)
    * [.isSky](#Sky+isSky) : <code>boolean</code>

<a name="new_Sky_new"></a>

### new Sky()
Constructs a new skydome.

<a name="Sky+isSky"></a>

### sky.isSky : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Sky</code>](#Sky)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SkyMesh"></a>

## SkyMesh ⇐ <code>Mesh</code>
Represents a skydome for scene backgrounds. Based on [A Practical Analytic Model for Daylight](https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight)
aka The Preetham Model, the de facto standard for analytical skydomes.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [SkyMesh](#SkyMesh).

More references:

- [http://simonwallner.at/project/atmospheric-scattering/](http://simonwallner.at/project/atmospheric-scattering/)
- [http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR](http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR)

```js
const sky = new SkyMesh();
sky.scale.setScalar( 10000 );
scene.add( sky );
```

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [SkyMesh](#SkyMesh) ⇐ <code>Mesh</code>
    * [new SkyMesh()](#new_SkyMesh_new)
    * [.turbidity](#SkyMesh+turbidity) : <code>UniformNode.&lt;float&gt;</code>
    * [.rayleigh](#SkyMesh+rayleigh) : <code>UniformNode.&lt;float&gt;</code>
    * [.mieCoefficient](#SkyMesh+mieCoefficient) : <code>UniformNode.&lt;float&gt;</code>
    * [.mieDirectionalG](#SkyMesh+mieDirectionalG) : <code>UniformNode.&lt;float&gt;</code>
    * [.sunPosition](#SkyMesh+sunPosition) : <code>UniformNode.&lt;vec3&gt;</code>
    * [.upUniform](#SkyMesh+upUniform) : <code>UniformNode.&lt;vec3&gt;</code>
    * [.isSky](#SkyMesh+isSky) : <code>boolean</code>

<a name="new_SkyMesh_new"></a>

### new SkyMesh()
Constructs a new skydome.

<a name="SkyMesh+turbidity"></a>

### skyMesh.turbidity : <code>UniformNode.&lt;float&gt;</code>
The turbidity uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+rayleigh"></a>

### skyMesh.rayleigh : <code>UniformNode.&lt;float&gt;</code>
The rayleigh uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+mieCoefficient"></a>

### skyMesh.mieCoefficient : <code>UniformNode.&lt;float&gt;</code>
The mieCoefficient uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+mieDirectionalG"></a>

### skyMesh.mieDirectionalG : <code>UniformNode.&lt;float&gt;</code>
The mieDirectionalG uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+sunPosition"></a>

### skyMesh.sunPosition : <code>UniformNode.&lt;vec3&gt;</code>
The sun position uniform.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+upUniform"></a>

### skyMesh.upUniform : <code>UniformNode.&lt;vec3&gt;</code>
The up position.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
<a name="SkyMesh+isSky"></a>

### skyMesh.isSky : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SkyMesh</code>](#SkyMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Water"></a>

## Water ⇐ <code>Mesh</code>
A basic flat, reflective water effect.

Note that this class can only be used with [WebGLRenderer](WebGLRenderer).
When using [WebGPURenderer](WebGPURenderer), use [WaterMesh](WaterMesh).

References:

- [Flat mirror for three.js](https://github.com/Slayvin)
- [An implementation of water shader based on the flat mirror](https://home.adelphi.edu/~stemkoski/)
- [Water shader explanations in WebGL](http://29a.ch/slides/2012/webglwater/)

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [Water](#Water) ⇐ <code>Mesh</code>
    * [new Water(geometry, [options])](#new_Water_new)
    * _instance_
        * [.isWater](#Water+isWater) : <code>boolean</code>
    * _inner_
        * [~Options](#Water..Options) : <code>Object</code>

<a name="new_Water_new"></a>

### new Water(geometry, [options])
Constructs a new water instance.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The water's geometry. |
| [options] | [<code>Options</code>](#Water..Options) | The configuration options. |

<a name="Water+isWater"></a>

### water.isWater : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Water</code>](#Water)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Water..Options"></a>

### Water~Options : <code>Object</code>
Constructor options of `Water`.

**Kind**: inner typedef of [<code>Water</code>](#Water)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [textureWidth] | <code>number</code> | <code>512</code> | The texture width. A higher value results in more clear reflections but is also more expensive. |
| [textureHeight] | <code>number</code> | <code>512</code> | The texture height. A higher value results in more clear reflections but is also more expensive. |
| [clipBias] | <code>number</code> | <code>0</code> | The clip bias. |
| [alpha] | <code>number</code> | <code>1</code> | The alpha value. |
| [time] | <code>number</code> | <code>0</code> | The time value. |
| [waterNormals] | <code>Texture</code> | <code></code> | The water's normal map. |
| [sunDirection] | <code>Vector3</code> | <code>(0.70707,0.70707,0.0)</code> | The sun direction. |
| [sunColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The sun color. |
| [waterColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The water color. |
| [eye] | <code>Vector3</code> |  | The eye vector. |
| [distortionScale] | <code>number</code> | <code>20</code> | The distortion scale. |
| [side] | <code>FrontSide</code> \| <code>BackSide</code> \| <code>DoubleSide</code> | <code>FrontSide</code> | The water material's `side` property. |
| [fog] | <code>boolean</code> | <code>false</code> | Whether the water should be affected by fog or not. |

<a name="WaterMesh"></a>

## WaterMesh ⇐ <code>Mesh</code>
A basic flat, reflective water effect.

Note that this class can only be used with [WebGPURenderer](WebGPURenderer).
When using [WebGLRenderer](WebGLRenderer), use [Water](Water).

References:

- [Flat mirror for three.js](https://github.com/Slayvin)
- [An implementation of water shader based on the flat mirror](https://home.adelphi.edu/~stemkoski/)
- [Water shader explanations in WebGL](http://29a.ch/slides/2012/webglwater/)

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [WaterMesh](#WaterMesh) ⇐ <code>Mesh</code>
    * [new WaterMesh(geometry, [options])](#new_WaterMesh_new)
    * _instance_
        * [.isWaterMesh](#WaterMesh+isWaterMesh) : <code>boolean</code>
        * [.resolution](#WaterMesh+resolution) : <code>number</code>
        * [.waterNormals](#WaterMesh+waterNormals) : <code>TextureNode</code>
        * [.alpha](#WaterMesh+alpha) : <code>UniformNode.&lt;float&gt;</code>
        * [.size](#WaterMesh+size) : <code>UniformNode.&lt;float&gt;</code>
        * [.sunColor](#WaterMesh+sunColor) : <code>UniformNode.&lt;color&gt;</code>
        * [.sunDirection](#WaterMesh+sunDirection) : <code>UniformNode.&lt;vec3&gt;</code>
        * [.waterColor](#WaterMesh+waterColor) : <code>UniformNode.&lt;color&gt;</code>
        * [.distortionScale](#WaterMesh+distortionScale) : <code>UniformNode.&lt;float&gt;</code>
    * _inner_
        * [~Options](#WaterMesh..Options) : <code>Object</code>

<a name="new_WaterMesh_new"></a>

### new WaterMesh(geometry, [options])
Constructs a new water mesh.


| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The water mesh's geometry. |
| [options] | [<code>Options</code>](#WaterMesh..Options) | The configuration options. |

<a name="WaterMesh+isWaterMesh"></a>

### waterMesh.isWaterMesh : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WaterMesh+resolution"></a>

### waterMesh.resolution : <code>number</code>
The effect's resolution scale.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>0.5</code>  
<a name="WaterMesh+waterNormals"></a>

### waterMesh.waterNormals : <code>TextureNode</code>
The water's normal map.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
<a name="WaterMesh+alpha"></a>

### waterMesh.alpha : <code>UniformNode.&lt;float&gt;</code>
The alpha value.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>1</code>  
<a name="WaterMesh+size"></a>

### waterMesh.size : <code>UniformNode.&lt;float&gt;</code>
The size value.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>1</code>  
<a name="WaterMesh+sunColor"></a>

### waterMesh.sunColor : <code>UniformNode.&lt;color&gt;</code>
The sun color.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>0xffffff</code>  
<a name="WaterMesh+sunDirection"></a>

### waterMesh.sunDirection : <code>UniformNode.&lt;vec3&gt;</code>
The sun direction.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>(0.70707,0.70707,0.0)</code>  
<a name="WaterMesh+waterColor"></a>

### waterMesh.waterColor : <code>UniformNode.&lt;color&gt;</code>
The water color.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>0x7f7f7f</code>  
<a name="WaterMesh+distortionScale"></a>

### waterMesh.distortionScale : <code>UniformNode.&lt;float&gt;</code>
The distortion scale.

**Kind**: instance property of [<code>WaterMesh</code>](#WaterMesh)  
**Default**: <code>20</code>  
<a name="WaterMesh..Options"></a>

### WaterMesh~Options : <code>Object</code>
Constructor options of `WaterMesh`.

**Kind**: inner typedef of [<code>WaterMesh</code>](#WaterMesh)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [resolution] | <code>number</code> | <code>0.5</code> | The resolution scale. |
| [waterNormals] | <code>Texture</code> | <code></code> | The water's normal map. |
| [alpha] | <code>number</code> | <code>1</code> | The alpha value. |
| [size] | <code>number</code> | <code>1</code> | The size value. |
| [sunColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0xffffff</code> | The sun color. |
| [sunDirection] | <code>Vector3</code> | <code>(0.70707,0.70707,0.0)</code> | The sun direction. |
| [waterColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x7F7F7F</code> | The water color. |
| [distortionScale] | <code>number</code> | <code>20</code> | The distortion scale. |

<a name="AmmoPhysics"></a>

## AmmoPhysics
Can be used to include Ammo.js as a Physics engine into
`three.js` apps. Make sure to include `ammo.wasm.js` first:
```
<script src="jsm/libs/ammo.wasm.js"></script>
```
It is then possible to initialize the API via:
```js
const physics = await AmmoPhysics();
```

**Kind**: global class  

* [AmmoPhysics](#AmmoPhysics)
    * [.addScene(scene)](#AmmoPhysics+addScene)
    * [.addMesh(mesh, [mass])](#AmmoPhysics+addMesh)
    * [.setMeshPosition(mesh, position, [index])](#AmmoPhysics+setMeshPosition)

<a name="AmmoPhysics+addScene"></a>

### ammoPhysics.addScene(scene)
Adds the given scene to this physics simulation. Only meshes with a
`physics` object in their [Object3D#userData](Object3D#userData) field will be honored.
The object can be used to store the mass of the mesh. E.g.:
```js
box.userData.physics = { mass: 1 };
```

**Kind**: instance method of [<code>AmmoPhysics</code>](#AmmoPhysics)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or any type of 3D object to add. |

<a name="AmmoPhysics+addMesh"></a>

### ammoPhysics.addMesh(mesh, [mass])
Adds the given mesh to this physics simulation.

**Kind**: instance method of [<code>AmmoPhysics</code>](#AmmoPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to add. |
| [mass] | <code>number</code> | <code>0</code> | The mass in kg of the mesh. |

<a name="AmmoPhysics+setMeshPosition"></a>

### ammoPhysics.setMeshPosition(mesh, position, [index])
Set the position of the given mesh which is part of the physics simulation. Calling this
method will reset the current simulated velocity of the mesh.

**Kind**: instance method of [<code>AmmoPhysics</code>](#AmmoPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to update the position for. |
| position | <code>Vector3</code> |  | The new position. |
| [index] | <code>number</code> | <code>0</code> | If the mesh is instanced, the index represents the instanced ID. |

<a name="JoltPhysics"></a>

## JoltPhysics
Can be used to include Jolt as a Physics engine into
`three.js` apps. The API can be initialized via:
```js
const physics = await JoltPhysics();
```
The component automatically imports Jolt from a CDN so make sure
to use the component with an active Internet connection.

**Kind**: global class  

* [JoltPhysics](#JoltPhysics)
    * [.addScene(scene)](#JoltPhysics+addScene)
    * [.addMesh(mesh, [mass], [restitution])](#JoltPhysics+addMesh)
    * [.setMeshPosition(mesh, position, [index])](#JoltPhysics+setMeshPosition)

<a name="JoltPhysics+addScene"></a>

### joltPhysics.addScene(scene)
Adds the given scene to this physics simulation. Only meshes with a
`physics` object in their [Object3D#userData](Object3D#userData) field will be honored.
The object can be used to store the mass and restitution of the mesh. E.g.:
```js
box.userData.physics = { mass: 1, restitution: 0 };
```

**Kind**: instance method of [<code>JoltPhysics</code>](#JoltPhysics)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or any type of 3D object to add. |

<a name="JoltPhysics+addMesh"></a>

### joltPhysics.addMesh(mesh, [mass], [restitution])
Adds the given mesh to this physics simulation.

**Kind**: instance method of [<code>JoltPhysics</code>](#JoltPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to add. |
| [mass] | <code>number</code> | <code>0</code> | The mass in kg of the mesh. |
| [restitution] | <code>number</code> | <code>0</code> | The restitution/friction of the mesh. |

<a name="JoltPhysics+setMeshPosition"></a>

### joltPhysics.setMeshPosition(mesh, position, [index])
Set the position of the given mesh which is part of the physics simulation. Calling this
method will reset the current simulated velocity of the mesh.

**Kind**: instance method of [<code>JoltPhysics</code>](#JoltPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to update the position for. |
| position | <code>Vector3</code> |  | The new position. |
| [index] | <code>number</code> | <code>0</code> | If the mesh is instanced, the index represents the instanced ID. |

<a name="RapierPhysics"></a>

## RapierPhysics
Can be used to include Rapier as a Physics engine into
`three.js` apps. The API can be initialized via:
```js
const physics = await RapierPhysics();
```
The component automatically imports Rapier from a CDN so make sure
to use the component with an active Internet connection.

**Kind**: global class  

* [RapierPhysics](#RapierPhysics)
    * [.addScene(scene)](#RapierPhysics+addScene)
    * [.addMesh(mesh, [mass], [restitution])](#RapierPhysics+addMesh)
    * [.setMeshPosition(mesh, position, [index])](#RapierPhysics+setMeshPosition)
    * [.setMeshVelocity(mesh, velocity, [index])](#RapierPhysics+setMeshVelocity)

<a name="RapierPhysics+addScene"></a>

### rapierPhysics.addScene(scene)
Adds the given scene to this physics simulation. Only meshes with a
`physics` object in their [Object3D#userData](Object3D#userData) field will be honored.
The object can be used to store the mass and restitution of the mesh. E.g.:
```js
box.userData.physics = { mass: 1, restitution: 0 };
```

**Kind**: instance method of [<code>RapierPhysics</code>](#RapierPhysics)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | The scene or any type of 3D object to add. |

<a name="RapierPhysics+addMesh"></a>

### rapierPhysics.addMesh(mesh, [mass], [restitution])
Adds the given mesh to this physics simulation.

**Kind**: instance method of [<code>RapierPhysics</code>](#RapierPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to add. |
| [mass] | <code>number</code> | <code>0</code> | The mass in kg of the mesh. |
| [restitution] | <code>number</code> | <code>0</code> | The restitution/friction of the mesh. |

<a name="RapierPhysics+setMeshPosition"></a>

### rapierPhysics.setMeshPosition(mesh, position, [index])
Set the position of the given mesh which is part of the physics simulation. Calling this
method will reset the current simulated velocity of the mesh.

**Kind**: instance method of [<code>RapierPhysics</code>](#RapierPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to update the position for. |
| position | <code>Vector3</code> |  | The new position. |
| [index] | <code>number</code> | <code>0</code> | If the mesh is instanced, the index represents the instanced ID. |

<a name="RapierPhysics+setMeshVelocity"></a>

### rapierPhysics.setMeshVelocity(mesh, velocity, [index])
Set the velocity of the given mesh which is part of the physics simulation.

**Kind**: instance method of [<code>RapierPhysics</code>](#RapierPhysics)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| mesh | <code>Mesh</code> |  | The mesh to update the velocity for. |
| velocity | <code>Vector3</code> |  | The new velocity. |
| [index] | <code>number</code> | <code>0</code> | If the mesh is instanced, the index represents the instanced ID. |

<a name="AfterimagePass"></a>

## AfterimagePass ⇐ <code>Pass</code>
Pass for a basic after image effect.

```js
const afterimagePass = new AfterimagePass( 0.9 );
composer.addPass( afterimagePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [AfterimagePass](#AfterimagePass) ⇐ <code>Pass</code>
    * [new AfterimagePass([damp])](#new_AfterimagePass_new)
    * [.uniforms](#AfterimagePass+uniforms) : <code>Object</code>
    * [.compFsMaterial](#AfterimagePass+compFsMaterial) : <code>ShaderMaterial</code>
    * [.copyFsMaterial](#AfterimagePass+copyFsMaterial) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#AfterimagePass+render)
    * [.setSize(width, height)](#AfterimagePass+setSize)
    * [.dispose()](#AfterimagePass+dispose)

<a name="new_AfterimagePass_new"></a>

### new AfterimagePass([damp])
Constructs a new after image pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [damp] | <code>number</code> | <code>0.96</code> | The damping intensity. A higher value means a stronger after image effect. |

<a name="AfterimagePass+uniforms"></a>

### afterimagePass.uniforms : <code>Object</code>
The pass uniforms. Use this object if you want to update the
`damp` value at runtime.
```js
pass.uniforms.damp.value = 0.9;
```

**Kind**: instance property of [<code>AfterimagePass</code>](#AfterimagePass)  
<a name="AfterimagePass+compFsMaterial"></a>

### afterimagePass.compFsMaterial : <code>ShaderMaterial</code>
The composition material.

**Kind**: instance property of [<code>AfterimagePass</code>](#AfterimagePass)  
<a name="AfterimagePass+copyFsMaterial"></a>

### afterimagePass.copyFsMaterial : <code>ShaderMaterial</code>
The copy material.

**Kind**: instance property of [<code>AfterimagePass</code>](#AfterimagePass)  
<a name="AfterimagePass+render"></a>

### afterimagePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the after image pass.

**Kind**: instance method of [<code>AfterimagePass</code>](#AfterimagePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="AfterimagePass+setSize"></a>

### afterimagePass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>AfterimagePass</code>](#AfterimagePass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="AfterimagePass+dispose"></a>

### afterimagePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>AfterimagePass</code>](#AfterimagePass)  
<a name="BloomPass"></a>

## BloomPass ⇐ <code>Pass</code>
A pass for a basic Bloom effect.

[UnrealBloomPass](UnrealBloomPass) produces a more advanced Bloom but is also
more expensive.

```js
const effectBloom = new BloomPass( 0.75 );
composer.addPass( effectBloom );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [BloomPass](#BloomPass) ⇐ <code>Pass</code>
    * [new BloomPass([strength], [kernelSize], [sigma])](#new_BloomPass_new)
    * [.combineUniforms](#BloomPass+combineUniforms) : <code>Object</code>
    * [.materialCombine](#BloomPass+materialCombine) : <code>ShaderMaterial</code>
    * [.convolutionUniforms](#BloomPass+convolutionUniforms) : <code>Object</code>
    * [.materialConvolution](#BloomPass+materialConvolution) : <code>ShaderMaterial</code>
    * [.needsSwap](#BloomPass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#BloomPass+render)
    * [.setSize(width, height)](#BloomPass+setSize)
    * [.dispose()](#BloomPass+dispose)

<a name="new_BloomPass_new"></a>

### new BloomPass([strength], [kernelSize], [sigma])
Constructs a new Bloom pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [strength] | <code>number</code> | <code>1</code> | The Bloom strength. |
| [kernelSize] | <code>number</code> | <code>25</code> | The kernel size. |
| [sigma] | <code>number</code> | <code>4</code> | The sigma. |

<a name="BloomPass+combineUniforms"></a>

### bloomPass.combineUniforms : <code>Object</code>
