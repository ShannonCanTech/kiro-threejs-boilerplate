# three.js 

> JavaScript 3D Library. 

<a name="AnimationClipCreator"></a>


### vector4.multiplyScalar(scalar) ⇒ [<code>Vector4</code>](#Vector4)
Multiplies the given scalar value with all components of this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to multiply. |

<a name="Vector4+applyMatrix4"></a>

### vector4.applyMatrix4(m) ⇒ [<code>Vector4</code>](#Vector4)
Multiplies this vector with the given 4x4 matrix.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Vector4+divide"></a>

### vector4.divide(v) ⇒ [<code>Vector4</code>](#Vector4)
Divides this instance by the given vector.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to divide. |

<a name="Vector4+divideScalar"></a>

### vector4.divideScalar(scalar) ⇒ [<code>Vector4</code>](#Vector4)
Divides this vector by the given scalar.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| scalar | <code>number</code> | The scalar to divide. |

<a name="Vector4+setAxisAngleFromQuaternion"></a>

### vector4.setAxisAngleFromQuaternion(q) ⇒ [<code>Vector4</code>](#Vector4)
Sets the x, y and z components of this
vector to the quaternion's axis and w to the angle.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| q | <code>Quaternion</code> | The Quaternion to set. |

<a name="Vector4+setAxisAngleFromRotationMatrix"></a>

### vector4.setAxisAngleFromRotationMatrix(m) ⇒ [<code>Vector4</code>](#Vector4)
Sets the x, y and z components of this
vector to the axis of rotation and w to the angle.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix. |

<a name="Vector4+setFromMatrixPosition"></a>

### vector4.setFromMatrixPosition(m) ⇒ [<code>Vector4</code>](#Vector4)
Sets the vector components to the position elements of the
given transformation matrix.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| m | <code>Matrix4</code> | The 4x4 matrix. |

<a name="Vector4+min"></a>

### vector4.min(v) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
value, replace that value with the corresponding min value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector. |

<a name="Vector4+max"></a>

### vector4.max(v) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's x, y, z or w value is less than the given vector's x, y, z or w
value, replace that value with the corresponding max value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector. |

<a name="Vector4+clamp"></a>

### vector4.clamp(min, max) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
value, it is replaced by the corresponding value.
If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
it is replaced by the corresponding value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | [<code>Vector4</code>](#Vector4) | The minimum x, y and z values. |
| max | [<code>Vector4</code>](#Vector4) | The maximum x, y and z values in the desired range. |

<a name="Vector4+clampScalar"></a>

### vector4.clampScalar(minVal, maxVal) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's x, y, z or w values are greater than the max value, they are
replaced by the max value.
If this vector's x, y, z or w values are less than the min value, they are
replaced by the min value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| minVal | <code>number</code> | The minimum value the components will be clamped to. |
| maxVal | <code>number</code> | The maximum value the components will be clamped to. |

<a name="Vector4+clampLength"></a>

### vector4.clampLength(min, max) ⇒ [<code>Vector4</code>](#Vector4)
If this vector's length is greater than the max value, it is replaced by
the max value.
If this vector's length is less than the min value, it is replaced by the
min value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| min | <code>number</code> | The minimum value the vector length will be clamped to. |
| max | <code>number</code> | The maximum value the vector length will be clamped to. |

<a name="Vector4+floor"></a>

### vector4.floor() ⇒ [<code>Vector4</code>](#Vector4)
The components of this vector are rounded down to the nearest integer value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+ceil"></a>

### vector4.ceil() ⇒ [<code>Vector4</code>](#Vector4)
The components of this vector are rounded up to the nearest integer value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+round"></a>

### vector4.round() ⇒ [<code>Vector4</code>](#Vector4)
The components of this vector are rounded to the nearest integer value

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+roundToZero"></a>

### vector4.roundToZero() ⇒ [<code>Vector4</code>](#Vector4)
The components of this vector are rounded towards zero (up if negative,
down if positive) to an integer value.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+negate"></a>

### vector4.negate() ⇒ [<code>Vector4</code>](#Vector4)
Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+dot"></a>

### vector4.dot(v) ⇒ <code>number</code>
Calculates the dot product of the given vector with this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - The result of the dot product.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to compute the dot product with. |

<a name="Vector4+lengthSq"></a>

### vector4.lengthSq() ⇒ <code>number</code>
Computes the square of the Euclidean length (straight-line length) from
(0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
compare the length squared instead as it is slightly more efficient to calculate.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - The square length of this vector.  
<a name="Vector4+length"></a>

### vector4.length() ⇒ <code>number</code>
Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector4+manhattanLength"></a>

### vector4.manhattanLength() ⇒ <code>number</code>
Computes the Manhattan length of this vector.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>number</code> - The length of this vector.  
<a name="Vector4+normalize"></a>

### vector4.normalize() ⇒ [<code>Vector4</code>](#Vector4)
Converts this vector to a unit vector - that is, sets it equal to a vector
with the same direction as this one, but with a vector length of `1`.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="Vector4+setLength"></a>

### vector4.setLength(length) ⇒ [<code>Vector4</code>](#Vector4)
Sets this vector to a vector with the same direction as this one, but
with the specified length.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| length | <code>number</code> | The new length of this vector. |

<a name="Vector4+lerp"></a>

### vector4.lerp(v, alpha) ⇒ [<code>Vector4</code>](#Vector4)
Linearly interpolates between the given vector and this instance, where
alpha is the percent distance along the line - alpha = 0 will be this
vector, and alpha = 1 will be the given one.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to interpolate towards. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector4+lerpVectors"></a>

### vector4.lerpVectors(v1, v2, alpha) ⇒ [<code>Vector4</code>](#Vector4)
Linearly interpolates between the given vectors, where alpha is the percent
distance along the line - alpha = 0 will be first vector, and alpha = 1 will
be the second one. The result is stored in this instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| v1 | [<code>Vector4</code>](#Vector4) | The first vector. |
| v2 | [<code>Vector4</code>](#Vector4) | The second vector. |
| alpha | <code>number</code> | The interpolation factor, typically in the closed interval `[0, 1]`. |

<a name="Vector4+equals"></a>

### vector4.equals(v) ⇒ <code>boolean</code>
Returns `true` if this vector is equal with the given one.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>boolean</code> - Whether this vector is equal with the given one.  

| Param | Type | Description |
| --- | --- | --- |
| v | [<code>Vector4</code>](#Vector4) | The vector to test for equality. |

<a name="Vector4+fromArray"></a>

### vector4.fromArray(array, [offset]) ⇒ [<code>Vector4</code>](#Vector4)
Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> |  | An array holding the vector component values. |
| [offset] | <code>number</code> | <code>0</code> | The offset into the array. |

<a name="Vector4+toArray"></a>

### vector4.toArray([array], [offset]) ⇒ <code>Array.&lt;number&gt;</code>
Writes the components of this vector to the given array. If no array is provided,
the method returns a new instance.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: <code>Array.&lt;number&gt;</code> - The vector components.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [array] | <code>Array.&lt;number&gt;</code> | <code>[]</code> | The target array holding the vector components. |
| [offset] | <code>number</code> | <code>0</code> | Index of the first element in the array. |

<a name="Vector4+fromBufferAttribute"></a>

### vector4.fromBufferAttribute(attribute, index) ⇒ [<code>Vector4</code>](#Vector4)
Sets the components of this vector from the given buffer attribute.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute holding vector data. |
| index | <code>number</code> | The index into the attribute. |

<a name="Vector4+random"></a>

### vector4.random() ⇒ [<code>Vector4</code>](#Vector4)
Sets each component of this vector to a pseudo-random value between `0` and
`1`, excluding `1`.

**Kind**: instance method of [<code>Vector4</code>](#Vector4)  
**Returns**: [<code>Vector4</code>](#Vector4) - A reference to this vector.  
<a name="CubicInterpolant"></a>

## CubicInterpolant ⇐ <code>Interpolant</code>
Fast and simple cubic spline interpolant.

It was derived from a Hermitian construction setting the first derivative
at each sample position to the linear slope between neighboring positions
over their parameter interval.

**Kind**: global class  
**Extends**: <code>Interpolant</code>  
<a name="new_CubicInterpolant_new"></a>

### new CubicInterpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])
Constructs a new cubic interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

<a name="DiscreteInterpolant"></a>

## DiscreteInterpolant ⇐ <code>Interpolant</code>
Interpolant that evaluates to the sample value at the position preceding
the parameter.

**Kind**: global class  
**Extends**: <code>Interpolant</code>  
<a name="new_DiscreteInterpolant_new"></a>

### new DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])
Constructs a new discrete interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

<a name="LinearInterpolant"></a>

## LinearInterpolant ⇐ <code>Interpolant</code>
A basic linear interpolant.

**Kind**: global class  
**Extends**: <code>Interpolant</code>  
<a name="new_LinearInterpolant_new"></a>

### new LinearInterpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])
Constructs a new linear interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

<a name="QuaternionLinearInterpolant"></a>

## QuaternionLinearInterpolant ⇐ <code>Interpolant</code>
Spherical linear unit quaternion interpolant.

**Kind**: global class  
**Extends**: <code>Interpolant</code>  
<a name="new_QuaternionLinearInterpolant_new"></a>

### new QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, [resultBuffer])
Constructs a new SLERP interpolant.


| Param | Type | Description |
| --- | --- | --- |
| parameterPositions | <code>TypedArray</code> | The parameter positions hold the interpolation factors. |
| sampleValues | <code>TypedArray</code> | The sample values. |
| sampleSize | <code>number</code> | The sample size |
| [resultBuffer] | <code>TypedArray</code> | The result buffer. |

## Constants

<dl>
<dt><a href="#TBNViewMatrix">TBNViewMatrix</a> : <code>Node.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the TBN matrix in view space.</p>
</dd>
<dt><a href="#parallaxDirection">parallaxDirection</a> : <code>Node.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the parallax direction.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#parallaxUV">parallaxUV(uv, scale)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>TSL function for computing parallax uv coordinates.</p>
</dd>
<dt><a href="#transformedBentNormalView">transformedBentNormalView()</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for computing bent normals.</p>
</dd>
</dl>

<a name="TBNViewMatrix"></a>

## TBNViewMatrix : <code>Node.&lt;mat3&gt;</code>
TSL object that represents the TBN matrix in view space.

**Kind**: global constant  
**Tsl**:   
<a name="parallaxDirection"></a>

## parallaxDirection : <code>Node.&lt;mat3&gt;</code>
TSL object that represents the parallax direction.

**Kind**: global constant  
**Tsl**:   
<a name="parallaxUV"></a>

## parallaxUV(uv, scale) ⇒ <code>Node.&lt;vec2&gt;</code>
TSL function for computing parallax uv coordinates.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - Parallax uv coordinates.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | A uv node. |
| scale | <code>Node.&lt;vec2&gt;</code> | A scale node. |

<a name="transformedBentNormalView"></a>

## transformedBentNormalView() ⇒ <code>Node.&lt;vec3&gt;</code>
TSL function for computing bent normals.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - Bent normals.  
**Tsl**:   
## Functions

<dl>
<dt><a href="#attributeArray">attributeArray(count, [type])</a> ⇒ <code>StorageBufferNode</code></dt>
<dd><p>TSL function for creating a storage buffer node with a configured <code>StorageBufferAttribute</code>.</p>
</dd>
<dt><a href="#instancedArray">instancedArray(count, [type])</a> ⇒ <code>StorageBufferNode</code></dt>
<dd><p>TSL function for creating a storage buffer node with a configured <code>StorageInstancedBufferAttribute</code>.</p>
</dd>
</dl>

<a name="attributeArray"></a>

## attributeArray(count, [type]) ⇒ <code>StorageBufferNode</code>
TSL function for creating a storage buffer node with a configured `StorageBufferAttribute`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> \| <code>TypedArray</code> |  | The data count. It is also valid to pass a typed array as an argument. |
| [type] | <code>string</code> \| <code>Struct</code> | <code>&quot;&#x27;float&#x27;&quot;</code> | The data type. |

<a name="instancedArray"></a>

## instancedArray(count, [type]) ⇒ <code>StorageBufferNode</code>
TSL function for creating a storage buffer node with a configured `StorageInstancedBufferAttribute`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| count | <code>number</code> \| <code>TypedArray</code> |  | The data count. It is also valid to pass a typed array as an argument. |
| [type] | <code>string</code> \| <code>Struct</code> | <code>&quot;&#x27;float&#x27;&quot;</code> | The data type. |

## Classes

<dl>
<dt><a href="#BatchNode">BatchNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node implements the vertex shader logic which is required
when rendering 3D objects via batching. <code>BatchNode</code> must be used
with instances of <a href="BatchedMesh">BatchedMesh</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#batch">batch(batchMesh)</a> ⇒ <code><a href="#BatchNode">BatchNode</a></code></dt>
<dd><p>TSL function for creating a batch node.</p>
</dd>
</dl>

<a name="BatchNode"></a>

## BatchNode ⇐ <code>Node</code>
This node implements the vertex shader logic which is required
when rendering 3D objects via batching. `BatchNode` must be used
with instances of [BatchedMesh](BatchedMesh).

**Kind**: global class  
**Extends**: <code>Node</code>  

* [BatchNode](#BatchNode) ⇐ <code>Node</code>
    * [new BatchNode(batchMesh)](#new_BatchNode_new)
    * [.batchMesh](#BatchNode+batchMesh) : <code>BatchedMesh</code>
    * [.batchingIdNode](#BatchNode+batchingIdNode) : <code>IndexNode</code>
    * [.setup(builder)](#BatchNode+setup)

<a name="new_BatchNode_new"></a>

### new BatchNode(batchMesh)
Constructs a new batch node.


| Param | Type | Description |
| --- | --- | --- |
| batchMesh | <code>BatchedMesh</code> | A reference to batched mesh. |

<a name="BatchNode+batchMesh"></a>

### batchNode.batchMesh : <code>BatchedMesh</code>
A reference to batched mesh.

**Kind**: instance property of [<code>BatchNode</code>](#BatchNode)  
<a name="BatchNode+batchingIdNode"></a>

### batchNode.batchingIdNode : <code>IndexNode</code>
The batching index node.

**Kind**: instance property of [<code>BatchNode</code>](#BatchNode)  
**Default**: <code>null</code>  
<a name="BatchNode+setup"></a>

### batchNode.setup(builder)
Setups the internal buffers and nodes and assigns the transformed vertex data
to predefined node variables for accumulation. That follows the same patterns
like with morph and skinning nodes.

**Kind**: instance method of [<code>BatchNode</code>](#BatchNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="batch"></a>

## batch(batchMesh) ⇒ [<code>BatchNode</code>](#BatchNode)
TSL function for creating a batch node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| batchMesh | <code>BatchedMesh</code> | A reference to batched mesh. |

## Constants

<dl>
<dt><a href="#bitangentGeometry">bitangentGeometry</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the bitangent attribute of the current rendered object.</p>
</dd>
<dt><a href="#bitangentLocal">bitangentLocal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex bitangent in local space of the current rendered object.</p>
</dd>
<dt><a href="#bitangentView">bitangentView</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the vertex bitangent in view space of the current rendered object.</p>
</dd>
<dt><a href="#bitangentWorld">bitangentWorld</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the vertex bitangent in world space of the current rendered object.</p>
</dd>
<dt><a href="#transformedBitangentView">transformedBitangentView</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex bitangent in view space of the current rendered object.</p>
</dd>
<dt><a href="#transformedBitangentWorld">transformedBitangentWorld</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex bitangent in world space of the current rendered object.</p>
</dd>
</dl>

<a name="bitangentGeometry"></a>

## bitangentGeometry : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the bitangent attribute of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="bitangentLocal"></a>

## bitangentLocal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex bitangent in local space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="bitangentView"></a>

## bitangentView : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the vertex bitangent in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="bitangentWorld"></a>

## bitangentWorld : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the vertex bitangent in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedBitangentView"></a>

## transformedBitangentView : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the transformed vertex bitangent in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedBitangentWorld"></a>

## transformedBitangentWorld : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the transformed vertex bitangent in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#BufferAttributeNode">BufferAttributeNode</a> ⇐ <code>InputNode</code></dt>
<dd><p>In earlier <code>three.js</code> versions it was only possible to define attribute data
on geometry level. With <code>BufferAttributeNode</code>, it is also possible to do this
on the node level.</p>
<pre><code class="language-js">const geometry = new THREE.PlaneGeometry();
const positionAttribute = geometry.getAttribute( &#39;position&#39; );

const colors = [];
for ( let i = 0; i &lt; position.count; i ++ ) {
    colors.push( 1, 0, 0 );
}

material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );
</code></pre>
<p>This new approach is especially interesting when geometry data are generated via
compute shaders. The below line converts a storage buffer into an attribute node.</p>
<pre><code class="language-js">material.positionNode = positionBuffer.toAttribute();
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#bufferAttribute">bufferAttribute(array, [type], [stride], [offset])</a> ⇒ <code><a href="#BufferAttributeNode">BufferAttributeNode</a></code></dt>
<dd><p>TSL function for creating a buffer attribute node.</p>
</dd>
<dt><a href="#dynamicBufferAttribute">dynamicBufferAttribute(array, [type], [stride], [offset])</a> ⇒ <code><a href="#BufferAttributeNode">BufferAttributeNode</a></code></dt>
<dd><p>TSL function for creating a buffer attribute node but with dynamic draw usage.
Use this function if attribute data are updated per frame.</p>
</dd>
<dt><a href="#instancedBufferAttribute">instancedBufferAttribute(array, [type], [stride], [offset])</a> ⇒ <code><a href="#BufferAttributeNode">BufferAttributeNode</a></code></dt>
<dd><p>TSL function for creating a buffer attribute node but with enabled instancing</p>
</dd>
<dt><a href="#instancedDynamicBufferAttribute">instancedDynamicBufferAttribute(array, [type], [stride], [offset])</a> ⇒ <code><a href="#BufferAttributeNode">BufferAttributeNode</a></code></dt>
<dd><p>TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing</p>
</dd>
</dl>

<a name="BufferAttributeNode"></a>

## BufferAttributeNode ⇐ <code>InputNode</code>
In earlier `three.js` versions it was only possible to define attribute data
on geometry level. With `BufferAttributeNode`, it is also possible to do this
on the node level.
```js
const geometry = new THREE.PlaneGeometry();
const positionAttribute = geometry.getAttribute( 'position' );

const colors = [];
for ( let i = 0; i < position.count; i ++ ) {
	colors.push( 1, 0, 0 );
}

material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );
```
This new approach is especially interesting when geometry data are generated via
compute shaders. The below line converts a storage buffer into an attribute node.
```js
material.positionNode = positionBuffer.toAttribute();
```

**Kind**: global class  
**Extends**: <code>InputNode</code>  

* [BufferAttributeNode](#BufferAttributeNode) ⇐ <code>InputNode</code>
    * [new BufferAttributeNode(value, [bufferType], [bufferStride], [bufferOffset])](#new_BufferAttributeNode_new)
    * [.isBufferNode](#BufferAttributeNode+isBufferNode) : <code>boolean</code>
    * [.bufferType](#BufferAttributeNode+bufferType) : <code>string</code>
    * [.bufferStride](#BufferAttributeNode+bufferStride) : <code>number</code>
    * [.bufferOffset](#BufferAttributeNode+bufferOffset) : <code>number</code>
    * [.usage](#BufferAttributeNode+usage) : <code>number</code>
    * [.instanced](#BufferAttributeNode+instanced) : <code>boolean</code>
    * [.attribute](#BufferAttributeNode+attribute) : <code>BufferAttribute</code>
    * [.global](#BufferAttributeNode+global) : <code>boolean</code>
    * [.getHash(builder)](#BufferAttributeNode+getHash) ⇒ <code>string</code>
    * [.getNodeType(builder)](#BufferAttributeNode+getNodeType) ⇒ <code>string</code>
    * [.setup(builder)](#BufferAttributeNode+setup)
    * [.generate(builder)](#BufferAttributeNode+generate) ⇒ <code>string</code>
    * [.getInputType(builder)](#BufferAttributeNode+getInputType) ⇒ <code>string</code>
    * [.setUsage(value)](#BufferAttributeNode+setUsage) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
    * [.setInstanced(value)](#BufferAttributeNode+setInstanced) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)

<a name="new_BufferAttributeNode_new"></a>

### new BufferAttributeNode(value, [bufferType], [bufferStride], [bufferOffset])
Constructs a new buffer attribute node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [bufferType] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [bufferStride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [bufferOffset] | <code>number</code> | <code>0</code> | The buffer offset. |

<a name="BufferAttributeNode+isBufferNode"></a>

### bufferAttributeNode.isBufferNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BufferAttributeNode+bufferType"></a>

### bufferAttributeNode.bufferType : <code>string</code>
The buffer type (e.g. `'vec3'`).

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="BufferAttributeNode+bufferStride"></a>

### bufferAttributeNode.bufferStride : <code>number</code>
The buffer stride.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>0</code>  
<a name="BufferAttributeNode+bufferOffset"></a>

### bufferAttributeNode.bufferOffset : <code>number</code>
The buffer offset.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>0</code>  
<a name="BufferAttributeNode+usage"></a>

### bufferAttributeNode.usage : <code>number</code>
The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,
if you are planning to update the attribute data per frame.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>StaticDrawUsage</code>  
<a name="BufferAttributeNode+instanced"></a>

### bufferAttributeNode.instanced : <code>boolean</code>
Whether the attribute is instanced or not.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>false</code>  
<a name="BufferAttributeNode+attribute"></a>

### bufferAttributeNode.attribute : <code>BufferAttribute</code>
A reference to the buffer attribute.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>null</code>  
<a name="BufferAttributeNode+global"></a>

### bufferAttributeNode.global : <code>boolean</code>
`BufferAttributeNode` sets this property to `true` by default.

**Kind**: instance property of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Default**: <code>true</code>  
<a name="BufferAttributeNode+getHash"></a>

### bufferAttributeNode.getHash(builder) ⇒ <code>string</code>
This method is overwritten since the attribute data might be shared
and thus the hash should be shared as well.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: <code>string</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+getNodeType"></a>

### bufferAttributeNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the buffer attribute.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+setup"></a>

### bufferAttributeNode.setup(builder)
Depending on which value was passed to the node, `setup()` behaves
differently. If no instance of `BufferAttribute` was passed, the method
creates an internal attribute and configures it respectively.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+generate"></a>

### bufferAttributeNode.generate(builder) ⇒ <code>string</code>
Generates the code snippet of the buffer attribute node.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+getInputType"></a>

### bufferAttributeNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'bufferAttribute'`.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferAttributeNode+setUsage"></a>

### bufferAttributeNode.setUsage(value) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
Sets the `usage` property to the given value.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: [<code>BufferAttributeNode</code>](#BufferAttributeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>number</code> | The usage to set. |

<a name="BufferAttributeNode+setInstanced"></a>

### bufferAttributeNode.setInstanced(value) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
Sets the `instanced` property to the given value.

**Kind**: instance method of [<code>BufferAttributeNode</code>](#BufferAttributeNode)  
**Returns**: [<code>BufferAttributeNode</code>](#BufferAttributeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The value to set. |

<a name="bufferAttribute"></a>

## bufferAttribute(array, [type], [stride], [offset]) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
TSL function for creating a buffer attribute node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [type] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [stride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [offset] | <code>number</code> | <code>0</code> | The buffer offset. |

<a name="dynamicBufferAttribute"></a>

## dynamicBufferAttribute(array, [type], [stride], [offset]) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
TSL function for creating a buffer attribute node but with dynamic draw usage.
Use this function if attribute data are updated per frame.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [type] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [stride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [offset] | <code>number</code> | <code>0</code> | The buffer offset. |

<a name="instancedBufferAttribute"></a>

## instancedBufferAttribute(array, [type], [stride], [offset]) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
TSL function for creating a buffer attribute node but with enabled instancing

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [type] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [stride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [offset] | <code>number</code> | <code>0</code> | The buffer offset. |

<a name="instancedDynamicBufferAttribute"></a>

## instancedDynamicBufferAttribute(array, [type], [stride], [offset]) ⇒ [<code>BufferAttributeNode</code>](#BufferAttributeNode)
TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| array | <code>BufferAttribute</code> \| <code>InterleavedBuffer</code> \| <code>TypedArray</code> |  | The attribute data. |
| [type] | <code>string</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [stride] | <code>number</code> | <code>0</code> | The buffer stride. |
| [offset] | <code>number</code> | <code>0</code> | The buffer offset. |

## Classes

<dl>
<dt><a href="#BufferNode">BufferNode</a> ⇐ <code>UniformNode</code></dt>
<dd><p>A special type of uniform node which represents array-like data
as uniform buffers. The access usually happens via <code>element()</code>
which returns an instance of <a href="ArrayElementNode">ArrayElementNode</a>. For example:</p>
<pre><code class="language-js">const bufferNode = buffer( array, &#39;mat4&#39;, count );
const matrixNode = bufferNode.element( index ); // access a matrix from the buffer
</code></pre>
<p>In general, it is recommended to use the more managed <a href="UniformArrayNode">UniformArrayNode</a>
since it handles more input types and automatically cares about buffer paddings.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#buffer">buffer(value, type, count)</a> ⇒ <code><a href="#BufferNode">BufferNode</a></code></dt>
<dd><p>TSL function for creating a buffer node.</p>
</dd>
</dl>

<a name="BufferNode"></a>

## BufferNode ⇐ <code>UniformNode</code>
A special type of uniform node which represents array-like data
as uniform buffers. The access usually happens via `element()`
which returns an instance of [ArrayElementNode](ArrayElementNode). For example:

```js
const bufferNode = buffer( array, 'mat4', count );
const matrixNode = bufferNode.element( index ); // access a matrix from the buffer
```
In general, it is recommended to use the more managed [UniformArrayNode](UniformArrayNode)
since it handles more input types and automatically cares about buffer paddings.

**Kind**: global class  
**Extends**: <code>UniformNode</code>  

* [BufferNode](#BufferNode) ⇐ <code>UniformNode</code>
    * [new BufferNode(value, bufferType, [bufferCount])](#new_BufferNode_new)
    * [.isBufferNode](#BufferNode+isBufferNode) : <code>boolean</code>
    * [.bufferType](#BufferNode+bufferType) : <code>string</code>
    * [.bufferCount](#BufferNode+bufferCount) : <code>number</code>
    * [.getElementType(builder)](#BufferNode+getElementType) ⇒ <code>string</code>
    * [.getInputType(builder)](#BufferNode+getInputType) ⇒ <code>string</code>

<a name="new_BufferNode_new"></a>

### new BufferNode(value, bufferType, [bufferCount])
Constructs a new buffer node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Array.&lt;number&gt;</code> |  | Array-like buffer data. |
| bufferType | <code>string</code> |  | The data type of the buffer. |
| [bufferCount] | <code>number</code> | <code>0</code> | The count of buffer elements. |

<a name="BufferNode+isBufferNode"></a>

### bufferNode.isBufferNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BufferNode</code>](#BufferNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BufferNode+bufferType"></a>

### bufferNode.bufferType : <code>string</code>
The data type of the buffer.

**Kind**: instance property of [<code>BufferNode</code>](#BufferNode)  
<a name="BufferNode+bufferCount"></a>

### bufferNode.bufferCount : <code>number</code>
The uniform node that holds the value of the reference node.

**Kind**: instance property of [<code>BufferNode</code>](#BufferNode)  
**Default**: <code>0</code>  
<a name="BufferNode+getElementType"></a>

### bufferNode.getElementType(builder) ⇒ <code>string</code>
The data type of the buffer elements.

**Kind**: instance method of [<code>BufferNode</code>](#BufferNode)  
**Returns**: <code>string</code> - The element type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BufferNode+getInputType"></a>

### bufferNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'buffer'`.

**Kind**: instance method of [<code>BufferNode</code>](#BufferNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="buffer"></a>

## buffer(value, type, count) ⇒ [<code>BufferNode</code>](#BufferNode)
TSL function for creating a buffer node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Array</code> | Array-like buffer data. |
| type | <code>string</code> | The data type of a buffer element. |
| count | <code>number</code> | The count of buffer elements. |

## Classes

<dl>
<dt><a href="#BuiltinNode">BuiltinNode</a> ⇐ <code>Node</code></dt>
<dd><p>The node allows to set values for built-in shader variables. That is
required for features like hardware-accelerated vertex clipping.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#builtin">builtin(name)</a> ⇒ <code><a href="#BuiltinNode">BuiltinNode</a></code></dt>
<dd><p>TSL function for creating a builtin node.</p>
</dd>
</dl>

<a name="BuiltinNode"></a>

## BuiltinNode ⇐ <code>Node</code>
The node allows to set values for built-in shader variables. That is
required for features like hardware-accelerated vertex clipping.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [BuiltinNode](#BuiltinNode) ⇐ <code>Node</code>
    * [new BuiltinNode(name)](#new_BuiltinNode_new)
    * [.name](#BuiltinNode+name) : <code>string</code>
    * [.isBuiltinNode](#BuiltinNode+isBuiltinNode) : <code>boolean</code>
    * [.generate(builder)](#BuiltinNode+generate) ⇒ <code>string</code>

<a name="new_BuiltinNode_new"></a>

### new BuiltinNode(name)
Constructs a new builtin node.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the built-in shader variable. |

<a name="BuiltinNode+name"></a>

### builtinNode.name : <code>string</code>
The name of the built-in shader variable.

**Kind**: instance property of [<code>BuiltinNode</code>](#BuiltinNode)  
<a name="BuiltinNode+isBuiltinNode"></a>

### builtinNode.isBuiltinNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BuiltinNode</code>](#BuiltinNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BuiltinNode+generate"></a>

### builtinNode.generate(builder) ⇒ <code>string</code>
Generates the code snippet of the builtin node.

**Kind**: instance method of [<code>BuiltinNode</code>](#BuiltinNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="builtin"></a>

## builtin(name) ⇒ [<code>BuiltinNode</code>](#BuiltinNode)
TSL function for creating a builtin node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the built-in shader variable. |

## Constants

<dl>
<dt><a href="#cameraIndex">cameraIndex</a> : <code>UniformNode.&lt;uint&gt;</code></dt>
<dd><p>TSL object that represents the current <code>index</code> value of the camera if used ArrayCamera.</p>
</dd>
<dt><a href="#cameraNear">cameraNear</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the <code>near</code> value of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraFar">cameraFar</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the <code>far</code> value of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraProjectionMatrix">cameraProjectionMatrix</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the projection matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraProjectionMatrixInverse">cameraProjectionMatrixInverse</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the inverse projection matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraViewMatrix">cameraViewMatrix</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the view matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraWorldMatrix">cameraWorldMatrix</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the world matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraNormalMatrix">cameraNormalMatrix</a> : <code>UniformNode.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the normal matrix of the camera used for the current render.</p>
</dd>
<dt><a href="#cameraPosition">cameraPosition</a> : <code>UniformNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the position in world space of the camera used for the current render.</p>
</dd>
</dl>

<a name="cameraIndex"></a>

## cameraIndex : <code>UniformNode.&lt;uint&gt;</code>
TSL object that represents the current `index` value of the camera if used ArrayCamera.

**Kind**: global constant  
**Tsl**:   
<a name="cameraNear"></a>

## cameraNear : <code>UniformNode.&lt;float&gt;</code>
TSL object that represents the `near` value of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraFar"></a>

## cameraFar : <code>UniformNode.&lt;float&gt;</code>
TSL object that represents the `far` value of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraProjectionMatrix"></a>

## cameraProjectionMatrix : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the projection matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraProjectionMatrixInverse"></a>

## cameraProjectionMatrixInverse : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the inverse projection matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraViewMatrix"></a>

## cameraViewMatrix : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the view matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraWorldMatrix"></a>

## cameraWorldMatrix : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the world matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraNormalMatrix"></a>

## cameraNormalMatrix : <code>UniformNode.&lt;mat3&gt;</code>
TSL object that represents the normal matrix of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
<a name="cameraPosition"></a>

## cameraPosition : <code>UniformNode.&lt;vec3&gt;</code>
TSL object that represents the position in world space of the camera used for the current render.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#ClippingNode">ClippingNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node is used in <a href="NodeMaterial">NodeMaterial</a> to setup the clipping
which can happen hardware-accelerated (if supported) and optionally
use alpha-to-coverage for anti-aliasing clipped edges.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#clipping">clipping()</a> ⇒ <code><a href="#ClippingNode">ClippingNode</a></code></dt>
<dd><p>TSL function for setting up the default clipping logic.</p>
</dd>
<dt><a href="#clippingAlpha">clippingAlpha()</a> ⇒ <code><a href="#ClippingNode">ClippingNode</a></code></dt>
<dd><p>TSL function for setting up alpha to coverage.</p>
</dd>
<dt><a href="#hardwareClipping">hardwareClipping()</a> ⇒ <code><a href="#ClippingNode">ClippingNode</a></code></dt>
<dd><p>TSL function for setting up hardware-based clipping.</p>
</dd>
</dl>

<a name="ClippingNode"></a>

## ClippingNode ⇐ <code>Node</code>
This node is used in [NodeMaterial](NodeMaterial) to setup the clipping
which can happen hardware-accelerated (if supported) and optionally
use alpha-to-coverage for anti-aliasing clipped edges.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ClippingNode](#ClippingNode) ⇐ <code>Node</code>
    * [new ClippingNode([scope])](#new_ClippingNode_new)
    * [.scope](#ClippingNode+scope) : <code>&#x27;default&#x27;</code> \| <code>&#x27;hardware&#x27;</code> \| <code>&#x27;alphaToCoverage&#x27;</code>
    * [.setup(builder)](#ClippingNode+setup) ⇒ <code>Node</code>
    * [.setupAlphaToCoverage(intersectionPlanes, unionPlanes)](#ClippingNode+setupAlphaToCoverage) ⇒ <code>Node</code>
    * [.setupDefault(intersectionPlanes, unionPlanes)](#ClippingNode+setupDefault) ⇒ <code>Node</code>
    * [.setupHardwareClipping(unionPlanes, builder)](#ClippingNode+setupHardwareClipping) ⇒ <code>Node</code>

<a name="new_ClippingNode_new"></a>

### new ClippingNode([scope])
Constructs a new clipping node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [scope] | <code>&#x27;default&#x27;</code> \| <code>&#x27;hardware&#x27;</code> \| <code>&#x27;alphaToCoverage&#x27;</code> | <code>&#x27;default&#x27;</code> | The node's scope. Similar to other nodes, the selected scope influences the behavior of the node and what type of code is generated. |

<a name="ClippingNode+scope"></a>

### clippingNode.scope : <code>&#x27;default&#x27;</code> \| <code>&#x27;hardware&#x27;</code> \| <code>&#x27;alphaToCoverage&#x27;</code>
The node's scope. Similar to other nodes, the selected scope influences
the behavior of the node and what type of code is generated.

**Kind**: instance property of [<code>ClippingNode</code>](#ClippingNode)  
<a name="ClippingNode+setup"></a>

### clippingNode.setup(builder) ⇒ <code>Node</code>
Setups the node depending on the selected scope.

**Kind**: instance method of [<code>ClippingNode</code>](#ClippingNode)  
**Returns**: <code>Node</code> - The result node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ClippingNode+setupAlphaToCoverage"></a>

### clippingNode.setupAlphaToCoverage(intersectionPlanes, unionPlanes) ⇒ <code>Node</code>
Setups alpha to coverage.

**Kind**: instance method of [<code>ClippingNode</code>](#ClippingNode)  
**Returns**: <code>Node</code> - The result node.  

| Param | Type | Description |
| --- | --- | --- |
| intersectionPlanes | <code>Array.&lt;Vector4&gt;</code> | The intersection planes. |
| unionPlanes | <code>Array.&lt;Vector4&gt;</code> | The union planes. |

<a name="ClippingNode+setupDefault"></a>

### clippingNode.setupDefault(intersectionPlanes, unionPlanes) ⇒ <code>Node</code>
Setups the default clipping.

**Kind**: instance method of [<code>ClippingNode</code>](#ClippingNode)  
**Returns**: <code>Node</code> - The result node.  

| Param | Type | Description |
| --- | --- | --- |
| intersectionPlanes | <code>Array.&lt;Vector4&gt;</code> | The intersection planes. |
| unionPlanes | <code>Array.&lt;Vector4&gt;</code> | The union planes. |

<a name="ClippingNode+setupHardwareClipping"></a>

### clippingNode.setupHardwareClipping(unionPlanes, builder) ⇒ <code>Node</code>
Setups hardware clipping.

**Kind**: instance method of [<code>ClippingNode</code>](#ClippingNode)  
**Returns**: <code>Node</code> - The result node.  

| Param | Type | Description |
| --- | --- | --- |
| unionPlanes | <code>Array.&lt;Vector4&gt;</code> | The union planes. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="clipping"></a>

## clipping() ⇒ [<code>ClippingNode</code>](#ClippingNode)
TSL function for setting up the default clipping logic.

**Kind**: global function  
**Tsl**:   
<a name="clippingAlpha"></a>

## clippingAlpha() ⇒ [<code>ClippingNode</code>](#ClippingNode)
TSL function for setting up alpha to coverage.

**Kind**: global function  
**Tsl**:   
<a name="hardwareClipping"></a>

## hardwareClipping() ⇒ [<code>ClippingNode</code>](#ClippingNode)
TSL function for setting up hardware-based clipping.

**Kind**: global function  
**Tsl**:   
## Classes

<dl>
<dt><a href="#CubeTextureNode">CubeTextureNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>This type of uniform node represents a cube texture.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#cubeTexture">cubeTexture(value, [uvNode], [levelNode], [biasNode])</a> ⇒ <code><a href="#CubeTextureNode">CubeTextureNode</a></code></dt>
<dd><p>TSL function for creating a cube texture node.</p>
</dd>
</dl>

<a name="CubeTextureNode"></a>

## CubeTextureNode ⇐ <code>TextureNode</code>
This type of uniform node represents a cube texture.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [CubeTextureNode](#CubeTextureNode) ⇐ <code>TextureNode</code>
    * [new CubeTextureNode(value, [uvNode], [levelNode], [biasNode])](#new_CubeTextureNode_new)
    * [.isCubeTextureNode](#CubeTextureNode+isCubeTextureNode) : <code>boolean</code>
    * [.getInputType(builder)](#CubeTextureNode+getInputType) ⇒ <code>string</code>
    * [.getDefaultUV()](#CubeTextureNode+getDefaultUV) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setUpdateMatrix(value)](#CubeTextureNode+setUpdateMatrix)
    * [.setupUV(builder, uvNode)](#CubeTextureNode+setupUV) ⇒ <code>Node</code>
    * [.generateUV(builder, cubeUV)](#CubeTextureNode+generateUV) ⇒ <code>string</code>

<a name="new_CubeTextureNode_new"></a>

### new CubeTextureNode(value, [uvNode], [levelNode], [biasNode])
Constructs a new cube texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>CubeTexture</code> |  | The cube texture. |
| [uvNode] | <code>Node.&lt;vec3&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

<a name="CubeTextureNode+isCubeTextureNode"></a>

### cubeTextureNode.isCubeTextureNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CubeTextureNode+getInputType"></a>

### cubeTextureNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'cubeTexture'`.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="CubeTextureNode+getDefaultUV"></a>

### cubeTextureNode.getDefaultUV() ⇒ <code>Node.&lt;vec3&gt;</code>
Returns a default uvs based on the mapping type of the cube texture.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The default uv attribute.  
<a name="CubeTextureNode+setUpdateMatrix"></a>

### cubeTextureNode.setUpdateMatrix(value)
Overwritten with an empty implementation since the `updateMatrix` flag is ignored
for cube textures. The uv transformation matrix is not applied to cube textures.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The update toggle. |

<a name="CubeTextureNode+setupUV"></a>

### cubeTextureNode.setupUV(builder, uvNode) ⇒ <code>Node</code>
Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
to modify the uv node for correct sampling.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Returns**: <code>Node</code> - The updated uv node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to setup. |

<a name="CubeTextureNode+generateUV"></a>

### cubeTextureNode.generateUV(builder, cubeUV) ⇒ <code>string</code>
Generates the uv code snippet.

**Kind**: instance method of [<code>CubeTextureNode</code>](#CubeTextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| cubeUV | <code>Node</code> | The uv node to generate code for. |

<a name="cubeTexture"></a>

## cubeTexture(value, [uvNode], [levelNode], [biasNode]) ⇒ [<code>CubeTextureNode</code>](#CubeTextureNode)
TSL function for creating a cube texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>CubeTexture</code> |  | The cube texture. |
| [uvNode] | <code>Node.&lt;vec3&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

## Classes

<dl>
<dt><a href="#InstanceNode">InstanceNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node implements the vertex shader logic which is required
when rendering 3D objects via instancing. The code makes sure
vertex positions, normals and colors can be modified via instanced
data.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#instance">instance(count, instanceMatrix, instanceColor)</a> ⇒ <code><a href="#InstanceNode">InstanceNode</a></code></dt>
<dd><p>TSL function for creating an instance node.</p>
</dd>
</dl>

<a name="InstanceNode"></a>

## InstanceNode ⇐ <code>Node</code>
This node implements the vertex shader logic which is required
when rendering 3D objects via instancing. The code makes sure
vertex positions, normals and colors can be modified via instanced
data.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [InstanceNode](#InstanceNode) ⇐ <code>Node</code>
    * [new InstanceNode(count, instanceMatrix, instanceColor)](#new_InstanceNode_new)
    * [.count](#InstanceNode+count) : <code>number</code>
    * [.instanceMatrix](#InstanceNode+instanceMatrix) : <code>InstancedBufferAttribute</code>
    * [.instanceColor](#InstanceNode+instanceColor) : <code>InstancedBufferAttribute</code>
    * [.instanceMatrixNode](#InstanceNode+instanceMatrixNode) : <code>Node</code>
    * [.instanceColorNode](#InstanceNode+instanceColorNode) : <code>Node</code>
    * [.updateType](#InstanceNode+updateType) : <code>string</code>
    * [.buffer](#InstanceNode+buffer) : <code>InstancedInterleavedBuffer</code>
    * [.bufferColor](#InstanceNode+bufferColor) : <code>InstancedBufferAttribute</code>
    * [.setup(builder)](#InstanceNode+setup)
    * [.update(frame)](#InstanceNode+update)

<a name="new_InstanceNode_new"></a>

### new InstanceNode(count, instanceMatrix, instanceColor)
Constructs a new instance node.


| Param | Type | Description |
| --- | --- | --- |
| count | <code>number</code> | The number of instances. |
| instanceMatrix | <code>InstancedBufferAttribute</code> | Instanced buffer attribute representing the instance transformations. |
| instanceColor | <code>InstancedBufferAttribute</code> | Instanced buffer attribute representing the instance colors. |

<a name="InstanceNode+count"></a>

### instanceNode.count : <code>number</code>
The number of instances.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+instanceMatrix"></a>

### instanceNode.instanceMatrix : <code>InstancedBufferAttribute</code>
Instanced buffer attribute representing the transformation of instances.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+instanceColor"></a>

### instanceNode.instanceColor : <code>InstancedBufferAttribute</code>
Instanced buffer attribute representing the color of instances.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+instanceMatrixNode"></a>

### instanceNode.instanceMatrixNode : <code>Node</code>
The node that represents the instance matrix data.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+instanceColorNode"></a>

### instanceNode.instanceColorNode : <code>Node</code>
The node that represents the instance color data.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+updateType"></a>

### instanceNode.updateType : <code>string</code>
The update type is set to `frame` since an update
of instanced buffer data must be checked per frame.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="InstanceNode+buffer"></a>

### instanceNode.buffer : <code>InstancedInterleavedBuffer</code>
A reference to a buffer that is used by `instanceMatrixNode`.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+bufferColor"></a>

### instanceNode.bufferColor : <code>InstancedBufferAttribute</code>
A reference to a buffer that is used by `instanceColorNode`.

**Kind**: instance property of [<code>InstanceNode</code>](#InstanceNode)  
<a name="InstanceNode+setup"></a>

### instanceNode.setup(builder)
Setups the internal buffers and nodes and assigns the transformed vertex data
to predefined node variables for accumulation. That follows the same patterns
like with morph and skinning nodes.

**Kind**: instance method of [<code>InstanceNode</code>](#InstanceNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="InstanceNode+update"></a>

### instanceNode.update(frame)
Checks if the internal buffers required an update.

**Kind**: instance method of [<code>InstanceNode</code>](#InstanceNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="instance"></a>

## instance(count, instanceMatrix, instanceColor) ⇒ [<code>InstanceNode</code>](#InstanceNode)
TSL function for creating an instance node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| count | <code>number</code> | The number of instances. |
| instanceMatrix | <code>InstancedBufferAttribute</code> | Instanced buffer attribute representing the instance transformations. |
| instanceColor | <code>InstancedBufferAttribute</code> | Instanced buffer attribute representing the instance colors. |

## Classes

<dl>
<dt><a href="#InstancedMeshNode">InstancedMeshNode</a> ⇐ <code>InstanceNode</code></dt>
<dd><p>This is a special version of <code>InstanceNode</code> which requires the usage of <a href="InstancedMesh">InstancedMesh</a>.
It allows an easier setup of the instance node.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#instancedMesh">instancedMesh(instancedMesh)</a> ⇒ <code><a href="#InstancedMeshNode">InstancedMeshNode</a></code></dt>
<dd><p>TSL function for creating an instanced mesh node.</p>
</dd>
</dl>

<a name="InstancedMeshNode"></a>

## InstancedMeshNode ⇐ <code>InstanceNode</code>
This is a special version of `InstanceNode` which requires the usage of [InstancedMesh](InstancedMesh).
It allows an easier setup of the instance node.

**Kind**: global class  
**Extends**: <code>InstanceNode</code>  

* [InstancedMeshNode](#InstancedMeshNode) ⇐ <code>InstanceNode</code>
    * [new InstancedMeshNode(instancedMesh)](#new_InstancedMeshNode_new)
    * [.instancedMesh](#InstancedMeshNode+instancedMesh) : <code>InstancedMesh</code>

<a name="new_InstancedMeshNode_new"></a>

### new InstancedMeshNode(instancedMesh)
Constructs a new instanced mesh node.


| Param | Type | Description |
| --- | --- | --- |
| instancedMesh | <code>InstancedMesh</code> | The instanced mesh. |

<a name="InstancedMeshNode+instancedMesh"></a>

### instancedMeshNode.instancedMesh : <code>InstancedMesh</code>
A reference to the instanced mesh.

**Kind**: instance property of [<code>InstancedMeshNode</code>](#InstancedMeshNode)  
<a name="instancedMesh"></a>

## instancedMesh(instancedMesh) ⇒ [<code>InstancedMeshNode</code>](#InstancedMeshNode)
TSL function for creating an instanced mesh node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| instancedMesh | <code>InstancedMesh</code> | The instancedMesh. |

## Functions

<dl>
<dt><a href="#lightShadowMatrix">lightShadowMatrix(light)</a> ⇒ <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL function for getting a shadow matrix uniform node for the given light.</p>
</dd>
<dt><a href="#lightProjectionUV">lightProjectionUV(light, [position])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting projected uv coordinates for the given light.
Relevant when using maps with spot lights.</p>
</dd>
<dt><a href="#lightPosition">lightPosition(light)</a> ⇒ <code>UniformNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting the position in world space for the given light.</p>
</dd>
<dt><a href="#lightTargetPosition">lightTargetPosition(light)</a> ⇒ <code>UniformNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting the light target position in world space for the given light.</p>
</dd>
<dt><a href="#lightViewPosition">lightViewPosition(light)</a> ⇒ <code>UniformNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting the position in view space for the given light.</p>
</dd>
<dt><a href="#lightTargetDirection">lightTargetDirection(light)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for getting the light target direction for the given light.</p>
</dd>
</dl>

<a name="lightShadowMatrix"></a>

## lightShadowMatrix(light) ⇒ <code>UniformNode.&lt;mat4&gt;</code>
TSL function for getting a shadow matrix uniform node for the given light.

**Kind**: global function  
**Returns**: <code>UniformNode.&lt;mat4&gt;</code> - The shadow matrix uniform node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

<a name="lightProjectionUV"></a>

## lightProjectionUV(light, [position]) ⇒ <code>Node.&lt;vec3&gt;</code>
TSL function for getting projected uv coordinates for the given light.
Relevant when using maps with spot lights.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The projected uvs.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>Light</code> |  | The light source. |
| [position] | <code>Node.&lt;vec3&gt;</code> | <code>positionWorld</code> | The position to project. |

<a name="lightPosition"></a>

## lightPosition(light) ⇒ <code>UniformNode.&lt;vec3&gt;</code>
TSL function for getting the position in world space for the given light.

**Kind**: global function  
**Returns**: <code>UniformNode.&lt;vec3&gt;</code> - The light's position in world space.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

<a name="lightTargetPosition"></a>

## lightTargetPosition(light) ⇒ <code>UniformNode.&lt;vec3&gt;</code>
TSL function for getting the light target position in world space for the given light.

**Kind**: global function  
**Returns**: <code>UniformNode.&lt;vec3&gt;</code> - The light target position in world space.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

<a name="lightViewPosition"></a>

## lightViewPosition(light) ⇒ <code>UniformNode.&lt;vec3&gt;</code>
TSL function for getting the position in view space for the given light.

**Kind**: global function  
**Returns**: <code>UniformNode.&lt;vec3&gt;</code> - The light's position in view space.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

<a name="lightTargetDirection"></a>

## lightTargetDirection(light) ⇒ <code>Node.&lt;vec3&gt;</code>
TSL function for getting the light target direction for the given light.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The light's target direction.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The light source. |

## Classes

<dl>
<dt><a href="#MaterialNode">MaterialNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class should simplify the node access to material properties.
It internal uses reference nodes to make sure  changes to material
properties are automatically reflected to predefined TSL objects
like e.g. <code>materialColor</code>.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#materialAlphaTest">materialAlphaTest</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents alpha test of the current material.</p>
</dd>
<dt><a href="#materialColor">materialColor</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the diffuse color of the current material.
The value is composed via <code>color</code> * <code>map</code>.</p>
</dd>
<dt><a href="#materialShininess">materialShininess</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shininess of the current material.</p>
</dd>
<dt><a href="#materialEmissive">materialEmissive</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the emissive color of the current material.
The value is composed via <code>emissive</code> * <code>emissiveIntensity</code> * <code>emissiveMap</code>.</p>
</dd>
<dt><a href="#materialOpacity">materialOpacity</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the opacity of the current material.
The value is composed via <code>opacity</code> * <code>alphaMap</code>.</p>
</dd>
<dt><a href="#materialSpecular">materialSpecular</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the specular of the current material.</p>
</dd>
<dt><a href="#materialSpecularIntensity">materialSpecularIntensity</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the specular intensity of the current material.
The value is composed via <code>specularIntensity</code> * <code>specularMap.a</code>.</p>
</dd>
<dt><a href="#materialSpecularColor">materialSpecularColor</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the specular color of the current material.
The value is composed via <code>specularColor</code> * <code>specularMap.rgb</code>.</p>
</dd>
<dt><a href="#materialSpecularStrength">materialSpecularStrength</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the specular strength of the current material.
The value is composed via <code>specularMap.r</code>.</p>
</dd>
<dt><a href="#materialReflectivity">materialReflectivity</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the reflectivity of the current material.</p>
</dd>
<dt><a href="#materialRoughness">materialRoughness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the roughness of the current material.
The value is composed via <code>roughness</code> * <code>roughnessMap.g</code>.</p>
</dd>
<dt><a href="#materialMetalness">materialMetalness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the metalness of the current material.
The value is composed via <code>metalness</code> * <code>metalnessMap.b</code>.</p>
</dd>
<dt><a href="#materialNormal">materialNormal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the normal of the current material.
The value will be either <code>normalMap</code> * <code>normalScale</code>, <code>bumpMap</code> * <code>bumpScale</code> or <code>normalView</code>.</p>
</dd>
<dt><a href="#materialClearcoat">materialClearcoat</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the clearcoat of the current material.
The value is composed via <code>clearcoat</code> * <code>clearcoatMap.r</code></p>
</dd>
<dt><a href="#materialClearcoatRoughness">materialClearcoatRoughness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the clearcoat roughness of the current material.
The value is composed via <code>clearcoatRoughness</code> * <code>clearcoatRoughnessMap.r</code>.</p>
</dd>
<dt><a href="#materialClearcoatNormal">materialClearcoatNormal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the clearcoat normal of the current material.
The value will be either <code>clearcoatNormalMap</code> or <code>normalView</code>.</p>
</dd>
<dt><a href="#materialRotation">materialRotation</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the rotation of the current sprite material.</p>
</dd>
<dt><a href="#materialSheen">materialSheen</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the sheen color of the current material.
The value is composed via <code>sheen</code> * <code>sheenColor</code> * <code>sheenColorMap</code>.</p>
</dd>
<dt><a href="#materialSheenRoughness">materialSheenRoughness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the sheen roughness of the current material.
The value is composed via <code>sheenRoughness</code> * <code>sheenRoughnessMap.a</code>.</p>
</dd>
<dt><a href="#materialAnisotropy">materialAnisotropy</a> : <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the anisotropy of the current material.</p>
</dd>
<dt><a href="#materialIridescence">materialIridescence</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the iridescence of the current material.</p>
</dd>
<dt><a href="#materialIridescenceIOR">materialIridescenceIOR</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the iridescence IOR of the current material.</p>
</dd>
<dt><a href="#materialIridescenceThickness">materialIridescenceThickness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the iridescence thickness of the current material.</p>
</dd>
<dt><a href="#materialTransmission">materialTransmission</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the transmission of the current material.
The value is composed via <code>transmission</code> * <code>transmissionMap.r</code>.</p>
</dd>
<dt><a href="#materialThickness">materialThickness</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the thickness of the current material.
The value is composed via <code>thickness</code> * <code>thicknessMap.g</code>.</p>
</dd>
<dt><a href="#materialIOR">materialIOR</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the IOR of the current material.</p>
</dd>
<dt><a href="#materialAttenuationDistance">materialAttenuationDistance</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the attenuation distance of the current material.</p>
</dd>
<dt><a href="#materialAttenuationColor">materialAttenuationColor</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the attenuation color of the current material.</p>
</dd>
<dt><a href="#materialLineScale">materialLineScale</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the scale of the current dashed line material.</p>
</dd>
<dt><a href="#materialLineDashSize">materialLineDashSize</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the dash size of the current dashed line material.</p>
</dd>
<dt><a href="#materialLineGapSize">materialLineGapSize</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the gap size of the current dashed line material.</p>
</dd>
<dt><a href="#materialLineWidth">materialLineWidth</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the line width of the current line material.</p>
</dd>
<dt><a href="#materialLineDashOffset">materialLineDashOffset</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the dash offset of the current line material.</p>
</dd>
<dt><a href="#materialPointSize">materialPointSize</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the point size of the current points material.</p>
</dd>
<dt><a href="#materialDispersion">materialDispersion</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the dispersion of the current material.</p>
</dd>
<dt><a href="#materialLightMap">materialLightMap</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the light map of the current material.
The value is composed via <code>lightMapIntensity</code> * <code>lightMap.rgb</code>.</p>
</dd>
<dt><a href="#materialAO">materialAO</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the ambient occlusion map of the current material.
The value is composed via <code>aoMap.r</code> - 1 * <code>aoMapIntensity</code> + 1.</p>
</dd>
<dt><a href="#materialAnisotropyVector">materialAnisotropyVector</a> : <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the anisotropy vector of the current material.</p>
</dd>
</dl>

<a name="MaterialNode"></a>

## MaterialNode ⇐ <code>Node</code>
This class should simplify the node access to material properties.
It internal uses reference nodes to make sure  changes to material
properties are automatically reflected to predefined TSL objects
like e.g. `materialColor`.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [MaterialNode](#MaterialNode) ⇐ <code>Node</code>
    * [new MaterialNode(scope)](#new_MaterialNode_new)
    * [.scope](#MaterialNode+scope) : <code>string</code>
    * [.getCache(property, type)](#MaterialNode+getCache) ⇒ <code>MaterialReferenceNode</code>
    * [.getFloat(property)](#MaterialNode+getFloat) ⇒ <code>MaterialReferenceNode.&lt;float&gt;</code>
    * [.getColor(property)](#MaterialNode+getColor) ⇒ <code>MaterialReferenceNode.&lt;color&gt;</code>
    * [.getTexture(property)](#MaterialNode+getTexture) ⇒ <code>MaterialReferenceNode</code>
    * [.setup(builder)](#MaterialNode+setup) ⇒ <code>Node</code>

<a name="new_MaterialNode_new"></a>

### new MaterialNode(scope)
Constructs a new material node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>string</code> | The scope defines what kind of material property is referred by the node. |

<a name="MaterialNode+scope"></a>

### materialNode.scope : <code>string</code>
The scope defines what material property is referred by the node.

**Kind**: instance property of [<code>MaterialNode</code>](#MaterialNode)  
<a name="MaterialNode+getCache"></a>

### materialNode.getCache(property, type) ⇒ <code>MaterialReferenceNode</code>
Returns a cached reference node for the given property and type.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>MaterialReferenceNode</code> - A material reference node representing the property access.  

| Param | Type | Description |
| --- | --- | --- |
| property | <code>string</code> | The name of the material property. |
| type | <code>string</code> | The uniform type of the property. |

<a name="MaterialNode+getFloat"></a>

### materialNode.getFloat(property) ⇒ <code>MaterialReferenceNode.&lt;float&gt;</code>
Returns a float-typed material reference node for the given property name.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>MaterialReferenceNode.&lt;float&gt;</code> - A material reference node representing the property access.  

| Param | Type | Description |
| --- | --- | --- |
| property | <code>string</code> | The name of the material property. |

<a name="MaterialNode+getColor"></a>

### materialNode.getColor(property) ⇒ <code>MaterialReferenceNode.&lt;color&gt;</code>
Returns a color-typed material reference node for the given property name.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>MaterialReferenceNode.&lt;color&gt;</code> - A material reference node representing the property access.  

| Param | Type | Description |
| --- | --- | --- |
| property | <code>string</code> | The name of the material property. |

<a name="MaterialNode+getTexture"></a>

### materialNode.getTexture(property) ⇒ <code>MaterialReferenceNode</code>
Returns a texture-typed material reference node for the given property name.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>MaterialReferenceNode</code> - A material reference node representing the property access.  

| Param | Type | Description |
| --- | --- | --- |
| property | <code>string</code> | The name of the material property. |

<a name="MaterialNode+setup"></a>

### materialNode.setup(builder) ⇒ <code>Node</code>
The node setup is done depending on the selected scope. Multiple material properties
might be grouped into a single node composition if they logically belong together.

**Kind**: instance method of [<code>MaterialNode</code>](#MaterialNode)  
**Returns**: <code>Node</code> - The node representing the selected scope.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="materialAlphaTest"></a>

## materialAlphaTest : <code>Node.&lt;float&gt;</code>
TSL object that represents alpha test of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialColor"></a>

## materialColor : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the diffuse color of the current material.
The value is composed via `color` * `map`.

**Kind**: global constant  
**Tsl**:   
<a name="materialShininess"></a>

## materialShininess : <code>Node.&lt;float&gt;</code>
TSL object that represents the shininess of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialEmissive"></a>

## materialEmissive : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the emissive color of the current material.
The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.

**Kind**: global constant  
**Tsl**:   
<a name="materialOpacity"></a>

## materialOpacity : <code>Node.&lt;float&gt;</code>
TSL object that represents the opacity of the current material.
The value is composed via `opacity` * `alphaMap`.

**Kind**: global constant  
**Tsl**:   
<a name="materialSpecular"></a>

## materialSpecular : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the specular of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialSpecularIntensity"></a>

## materialSpecularIntensity : <code>Node.&lt;float&gt;</code>
TSL object that represents the specular intensity of the current material.
The value is composed via `specularIntensity` * `specularMap.a`.

**Kind**: global constant  
**Tsl**:   
<a name="materialSpecularColor"></a>

## materialSpecularColor : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the specular color of the current material.
The value is composed via `specularColor` * `specularMap.rgb`.

**Kind**: global constant  
**Tsl**:   
<a name="materialSpecularStrength"></a>

## materialSpecularStrength : <code>Node.&lt;float&gt;</code>
TSL object that represents the specular strength of the current material.
The value is composed via `specularMap.r`.

**Kind**: global constant  
**Tsl**:   
<a name="materialReflectivity"></a>

## materialReflectivity : <code>Node.&lt;float&gt;</code>
TSL object that represents the reflectivity of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialRoughness"></a>

## materialRoughness : <code>Node.&lt;float&gt;</code>
TSL object that represents the roughness of the current material.
The value is composed via `roughness` * `roughnessMap.g`.

**Kind**: global constant  
**Tsl**:   
<a name="materialMetalness"></a>

## materialMetalness : <code>Node.&lt;float&gt;</code>
TSL object that represents the metalness of the current material.
The value is composed via `metalness` * `metalnessMap.b`.

**Kind**: global constant  
**Tsl**:   
<a name="materialNormal"></a>

## materialNormal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the normal of the current material.
The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.

**Kind**: global constant  
**Tsl**:   
<a name="materialClearcoat"></a>

## materialClearcoat : <code>Node.&lt;float&gt;</code>
TSL object that represents the clearcoat of the current material.
The value is composed via `clearcoat` * `clearcoatMap.r`

**Kind**: global constant  
**Tsl**:   
<a name="materialClearcoatRoughness"></a>

## materialClearcoatRoughness : <code>Node.&lt;float&gt;</code>
TSL object that represents the clearcoat roughness of the current material.
The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`.

**Kind**: global constant  
**Tsl**:   
<a name="materialClearcoatNormal"></a>

## materialClearcoatNormal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the clearcoat normal of the current material.
The value will be either `clearcoatNormalMap` or `normalView`.

**Kind**: global constant  
**Tsl**:   
<a name="materialRotation"></a>

## materialRotation : <code>Node.&lt;float&gt;</code>
TSL object that represents the rotation of the current sprite material.

**Kind**: global constant  
**Tsl**:   
<a name="materialSheen"></a>

## materialSheen : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the sheen color of the current material.
The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.

**Kind**: global constant  
**Tsl**:   
<a name="materialSheenRoughness"></a>

## materialSheenRoughness : <code>Node.&lt;float&gt;</code>
TSL object that represents the sheen roughness of the current material.
The value is composed via `sheenRoughness` * `sheenRoughnessMap.a`.

**Kind**: global constant  
**Tsl**:   
<a name="materialAnisotropy"></a>

## materialAnisotropy : <code>Node.&lt;vec2&gt;</code>
TSL object that represents the anisotropy of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialIridescence"></a>

## materialIridescence : <code>Node.&lt;float&gt;</code>
TSL object that represents the iridescence of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialIridescenceIOR"></a>

## materialIridescenceIOR : <code>Node.&lt;float&gt;</code>
TSL object that represents the iridescence IOR of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialIridescenceThickness"></a>

## materialIridescenceThickness : <code>Node.&lt;float&gt;</code>
TSL object that represents the iridescence thickness of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialTransmission"></a>

## materialTransmission : <code>Node.&lt;float&gt;</code>
TSL object that represents the transmission of the current material.
The value is composed via `transmission` * `transmissionMap.r`.

**Kind**: global constant  
**Tsl**:   
<a name="materialThickness"></a>

## materialThickness : <code>Node.&lt;float&gt;</code>
TSL object that represents the thickness of the current material.
The value is composed via `thickness` * `thicknessMap.g`.

**Kind**: global constant  
**Tsl**:   
<a name="materialIOR"></a>

## materialIOR : <code>Node.&lt;float&gt;</code>
TSL object that represents the IOR of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialAttenuationDistance"></a>

## materialAttenuationDistance : <code>Node.&lt;float&gt;</code>
TSL object that represents the attenuation distance of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialAttenuationColor"></a>

## materialAttenuationColor : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the attenuation color of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineScale"></a>

## materialLineScale : <code>Node.&lt;float&gt;</code>
TSL object that represents the scale of the current dashed line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineDashSize"></a>

## materialLineDashSize : <code>Node.&lt;float&gt;</code>
TSL object that represents the dash size of the current dashed line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineGapSize"></a>

## materialLineGapSize : <code>Node.&lt;float&gt;</code>
TSL object that represents the gap size of the current dashed line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineWidth"></a>

## materialLineWidth : <code>Node.&lt;float&gt;</code>
TSL object that represents the line width of the current line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLineDashOffset"></a>

## materialLineDashOffset : <code>Node.&lt;float&gt;</code>
TSL object that represents the dash offset of the current line material.

**Kind**: global constant  
**Tsl**:   
<a name="materialPointSize"></a>

## materialPointSize : <code>Node.&lt;float&gt;</code>
TSL object that represents the point size of the current points material.

**Kind**: global constant  
**Tsl**:   
<a name="materialDispersion"></a>

## materialDispersion : <code>Node.&lt;float&gt;</code>
TSL object that represents the dispersion of the current material.

**Kind**: global constant  
**Tsl**:   
<a name="materialLightMap"></a>

## materialLightMap : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the light map of the current material.
The value is composed via `lightMapIntensity` * `lightMap.rgb`.

**Kind**: global constant  
**Tsl**:   
<a name="materialAO"></a>

## materialAO : <code>Node.&lt;float&gt;</code>
TSL object that represents the ambient occlusion map of the current material.
The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.

**Kind**: global constant  
**Tsl**:   
<a name="materialAnisotropyVector"></a>

## materialAnisotropyVector : <code>Node.&lt;vec2&gt;</code>
TSL object that represents the anisotropy vector of the current material.

**Kind**: global constant  
**Tsl**:   
## Constants

<dl>
<dt><a href="#materialRefractionRatio">materialRefractionRatio</a> : <code>UniformNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the refraction ratio of the material used for rendering the current object.</p>
</dd>
<dt><a href="#materialEnvIntensity">materialEnvIntensity</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the intensity of environment maps of PBR materials.
When <code>material.envMap</code> is set, the value is <code>material.envMapIntensity</code> otherwise <code>scene.environmentIntensity</code>.</p>
</dd>
<dt><a href="#materialEnvRotation">materialEnvRotation</a> : <code>Node.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the rotation of environment maps.
When <code>material.envMap</code> is set, the value is <code>material.envMapRotation</code>. <code>scene.environmentRotation</code> controls the
rotation of <code>scene.environment</code> instead.</p>
</dd>
</dl>

<a name="materialRefractionRatio"></a>

## materialRefractionRatio : <code>UniformNode.&lt;float&gt;</code>
TSL object that represents the refraction ratio of the material used for rendering the current object.

**Kind**: global constant  
**Tsl**:   
<a name="materialEnvIntensity"></a>

## materialEnvIntensity : <code>Node.&lt;float&gt;</code>
TSL object that represents the intensity of environment maps of PBR materials.
When `material.envMap` is set, the value is `material.envMapIntensity` otherwise `scene.environmentIntensity`.

**Kind**: global constant  
**Tsl**:   
<a name="materialEnvRotation"></a>

## materialEnvRotation : <code>Node.&lt;mat4&gt;</code>
TSL object that represents the rotation of environment maps.
When `material.envMap` is set, the value is `material.envMapRotation`. `scene.environmentRotation` controls the
rotation of `scene.environment` instead.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#MaterialReferenceNode">MaterialReferenceNode</a> ⇐ <code>ReferenceNode</code></dt>
<dd><p>This node is a special type of reference node which is intended
for linking material properties with node values.</p>
<pre><code class="language-js">const opacityNode = materialReference( &#39;opacity&#39;, &#39;float&#39;, material );
</code></pre>
<p>When changing <code>material.opacity</code>, the node value of <code>opacityNode</code> will
automatically be updated.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#materialReference">materialReference(name, type, [material])</a> ⇒ <code><a href="#MaterialReferenceNode">MaterialReferenceNode</a></code></dt>
<dd><p>TSL function for creating a material reference node.</p>
</dd>
</dl>

<a name="MaterialReferenceNode"></a>

## MaterialReferenceNode ⇐ <code>ReferenceNode</code>
This node is a special type of reference node which is intended
for linking material properties with node values.
```js
const opacityNode = materialReference( 'opacity', 'float', material );
```
When changing `material.opacity`, the node value of `opacityNode` will
automatically be updated.

**Kind**: global class  
**Extends**: <code>ReferenceNode</code>  

* [MaterialReferenceNode](#MaterialReferenceNode) ⇐ <code>ReferenceNode</code>
    * [new MaterialReferenceNode(property, inputType, [material])](#new_MaterialReferenceNode_new)
    * [.material](#MaterialReferenceNode+material) : <code>Material</code>
    * [.isMaterialReferenceNode](#MaterialReferenceNode+isMaterialReferenceNode) : <code>boolean</code>
    * [.updateReference(state)](#MaterialReferenceNode+updateReference) ⇒ <code>Object</code>

<a name="new_MaterialReferenceNode_new"></a>

### new MaterialReferenceNode(property, inputType, [material])
Constructs a new material reference node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The name of the property the node refers to. |
| inputType | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [material] | <code>Material</code> | <code></code> | The material the property belongs to. When no material is set, the node refers to the material of the current rendered object. |

<a name="MaterialReferenceNode+material"></a>

### materialReferenceNode.material : <code>Material</code>
The material the property belongs to. When no material is set,
the node refers to the material of the current rendered object.

**Kind**: instance property of [<code>MaterialReferenceNode</code>](#MaterialReferenceNode)  
**Default**: <code>null</code>  
<a name="MaterialReferenceNode+isMaterialReferenceNode"></a>

### materialReferenceNode.isMaterialReferenceNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MaterialReferenceNode</code>](#MaterialReferenceNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MaterialReferenceNode+updateReference"></a>

### materialReferenceNode.updateReference(state) ⇒ <code>Object</code>
Updates the reference based on the given state. The state is only evaluated
[material](#MaterialReferenceNode+material) is not set.

**Kind**: instance method of [<code>MaterialReferenceNode</code>](#MaterialReferenceNode)  
**Returns**: <code>Object</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state. |

<a name="materialReference"></a>

## materialReference(name, type, [material]) ⇒ [<code>MaterialReferenceNode</code>](#MaterialReferenceNode)
TSL function for creating a material reference node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the property the node refers to. |
| type | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [material] | <code>Material</code> | <code></code> | The material the property belongs to. When no material is set, the node refers to the material of the current rendered object. |

## Classes

<dl>
<dt><a href="#ModelNode">ModelNode</a> ⇐ <code>Object3DNode</code></dt>
<dd><p>This type of node is a specialized version of <code>Object3DNode</code>
with larger set of model related metrics. Unlike <code>Object3DNode</code>,
<code>ModelNode</code> extracts the reference to the 3D object from the
current node frame state.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#modelDirection">modelDirection</a> : <code>ModelNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s direction in world space.</p>
</dd>
<dt><a href="#modelWorldMatrix">modelWorldMatrix</a> : <code>ModelNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s world matrix.</p>
</dd>
<dt><a href="#modelPosition">modelPosition</a> : <code>ModelNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s position in world space.</p>
</dd>
<dt><a href="#modelScale">modelScale</a> : <code>ModelNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s scale in world space.</p>
</dd>
<dt><a href="#modelViewPosition">modelViewPosition</a> : <code>ModelNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s position in view/camera space.</p>
</dd>
<dt><a href="#modelRadius">modelRadius</a> : <code>ModelNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s radius.</p>
</dd>
<dt><a href="#modelNormalMatrix">modelNormalMatrix</a> : <code>UniformNode.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s normal matrix.</p>
</dd>
<dt><a href="#modelWorldMatrixInverse">modelWorldMatrixInverse</a> : <code>UniformNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s inverse world matrix.</p>
</dd>
<dt><a href="#modelViewMatrix">modelViewMatrix</a> : <code>Node.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s model view matrix.</p>
</dd>
<dt><a href="#mediumpModelViewMatrix">mediumpModelViewMatrix</a> : <code>Node.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s model view in <code>mediump</code> precision.</p>
</dd>
<dt><a href="#highpModelViewMatrix">highpModelViewMatrix</a> : <code>Node.&lt;mat4&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s model view in <code>highp</code> precision
which is achieved by computing the matrix in JS and not in the shader.</p>
</dd>
<dt><a href="#highpModelNormalViewMatrix">highpModelNormalViewMatrix</a> : <code>Node.&lt;mat3&gt;</code></dt>
<dd><p>TSL object that represents the object&#39;s model normal view in <code>highp</code> precision
which is achieved by computing the matrix in JS and not in the shader.</p>
</dd>
</dl>

<a name="ModelNode"></a>

## ModelNode ⇐ <code>Object3DNode</code>
This type of node is a specialized version of `Object3DNode`
with larger set of model related metrics. Unlike `Object3DNode`,
`ModelNode` extracts the reference to the 3D object from the
current node frame state.

**Kind**: global class  
**Extends**: <code>Object3DNode</code>  

* [ModelNode](#ModelNode) ⇐ <code>Object3DNode</code>
    * [new ModelNode(scope)](#new_ModelNode_new)
    * [.update(frame)](#ModelNode+update)

<a name="new_ModelNode_new"></a>

### new ModelNode(scope)
Constructs a new object model node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>&#x27;position&#x27;</code> \| <code>&#x27;viewPosition&#x27;</code> \| <code>&#x27;direction&#x27;</code> \| <code>&#x27;scale&#x27;</code> \| <code>&#x27;worldMatrix&#x27;</code> | The node represents a different type of transformation depending on the scope. |

<a name="ModelNode+update"></a>

### modelNode.update(frame)
Extracts the model reference from the frame state and then
updates the uniform value depending on the scope.

**Kind**: instance method of [<code>ModelNode</code>](#ModelNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="modelDirection"></a>

## modelDirection : <code>ModelNode.&lt;vec3&gt;</code>
TSL object that represents the object's direction in world space.

**Kind**: global constant  
**Tsl**:   
<a name="modelWorldMatrix"></a>

## modelWorldMatrix : <code>ModelNode.&lt;mat4&gt;</code>
TSL object that represents the object's world matrix.

**Kind**: global constant  
**Tsl**:   
<a name="modelPosition"></a>

## modelPosition : <code>ModelNode.&lt;vec3&gt;</code>
TSL object that represents the object's position in world space.

**Kind**: global constant  
**Tsl**:   
<a name="modelScale"></a>

## modelScale : <code>ModelNode.&lt;vec3&gt;</code>
TSL object that represents the object's scale in world space.

**Kind**: global constant  
**Tsl**:   
<a name="modelViewPosition"></a>

## modelViewPosition : <code>ModelNode.&lt;vec3&gt;</code>
TSL object that represents the object's position in view/camera space.

**Kind**: global constant  
**Tsl**:   
<a name="modelRadius"></a>

## modelRadius : <code>ModelNode.&lt;float&gt;</code>
TSL object that represents the object's radius.

**Kind**: global constant  
**Tsl**:   
<a name="modelNormalMatrix"></a>

## modelNormalMatrix : <code>UniformNode.&lt;mat3&gt;</code>
TSL object that represents the object's normal matrix.

**Kind**: global constant  
**Tsl**:   
<a name="modelWorldMatrixInverse"></a>

## modelWorldMatrixInverse : <code>UniformNode.&lt;mat4&gt;</code>
TSL object that represents the object's inverse world matrix.

**Kind**: global constant  
**Tsl**:   
<a name="modelViewMatrix"></a>

## modelViewMatrix : <code>Node.&lt;mat4&gt;</code>
TSL object that represents the object's model view matrix.

**Kind**: global constant  
**Tsl**:   
<a name="mediumpModelViewMatrix"></a>

## mediumpModelViewMatrix : <code>Node.&lt;mat4&gt;</code>
TSL object that represents the object's model view in `mediump` precision.

**Kind**: global constant  
**Tsl**:   
<a name="highpModelViewMatrix"></a>

## highpModelViewMatrix : <code>Node.&lt;mat4&gt;</code>
TSL object that represents the object's model view in `highp` precision
which is achieved by computing the matrix in JS and not in the shader.

**Kind**: global constant  
**Tsl**:   
<a name="highpModelNormalViewMatrix"></a>

## highpModelNormalViewMatrix : <code>Node.&lt;mat3&gt;</code>
TSL object that represents the object's model normal view in `highp` precision
which is achieved by computing the matrix in JS and not in the shader.

**Kind**: global constant  
**Tsl**:   
<a name="modelViewProjection"></a>

## modelViewProjection : <code>VaryingNode.&lt;vec4&gt;</code>
TSL object that represents the position in clip space after the model-view-projection transform of the current rendered object.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#MorphNode">MorphNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node implements the vertex transformation shader logic which is required
for morph target animation.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#morphReference">morphReference(mesh)</a> ⇒ <code><a href="#MorphNode">MorphNode</a></code></dt>
<dd><p>TSL function for creating a morph node.</p>
</dd>
</dl>

<a name="MorphNode"></a>

## MorphNode ⇐ <code>Node</code>
This node implements the vertex transformation shader logic which is required
for morph target animation.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [MorphNode](#MorphNode) ⇐ <code>Node</code>
    * [new MorphNode(mesh)](#new_MorphNode_new)
    * [.mesh](#MorphNode+mesh) : <code>Mesh</code>
    * [.morphBaseInfluence](#MorphNode+morphBaseInfluence) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateType](#MorphNode+updateType) : <code>string</code>
    * [.setup(builder)](#MorphNode+setup)
    * [.update(frame)](#MorphNode+update)

<a name="new_MorphNode_new"></a>

### new MorphNode(mesh)
Constructs a new morph node.


| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | The mesh holding the morph targets. |

<a name="MorphNode+mesh"></a>

### morphNode.mesh : <code>Mesh</code>
The mesh holding the morph targets.

**Kind**: instance property of [<code>MorphNode</code>](#MorphNode)  
<a name="MorphNode+morphBaseInfluence"></a>

### morphNode.morphBaseInfluence : <code>UniformNode.&lt;float&gt;</code>
A uniform node which represents the morph base influence value.

**Kind**: instance property of [<code>MorphNode</code>](#MorphNode)  
<a name="MorphNode+updateType"></a>

### morphNode.updateType : <code>string</code>
The update type overwritten since morph nodes are updated per object.

**Kind**: instance property of [<code>MorphNode</code>](#MorphNode)  
<a name="MorphNode+setup"></a>

### morphNode.setup(builder)
Setups the morph node by assigning the transformed vertex data to predefined node variables.

**Kind**: instance method of [<code>MorphNode</code>](#MorphNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MorphNode+update"></a>

### morphNode.update(frame)
Updates the state of the morphed mesh by updating the base influence.

**Kind**: instance method of [<code>MorphNode</code>](#MorphNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="morphReference"></a>

## morphReference(mesh) ⇒ [<code>MorphNode</code>](#MorphNode)
TSL function for creating a morph node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | The mesh holding the morph targets. |

## Constants

<dl>
<dt><a href="#normalGeometry">normalGeometry</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the normal attribute of the current rendered object.</p>
</dd>
<dt><a href="#normalLocal">normalLocal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex normal in local space of the current rendered object.</p>
</dd>
<dt><a href="#normalFlat">normalFlat</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the flat vertex normal in view space of the current rendered object.</p>
</dd>
<dt><a href="#normalView">normalView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex normal in view space of the current rendered object.</p>
</dd>
<dt><a href="#normalWorld">normalWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex normal in world space of the current rendered object.</p>
</dd>
<dt><a href="#transformedNormalView">transformedNormalView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex normal in view space of the current rendered object.</p>
</dd>
<dt><a href="#transformedNormalWorld">transformedNormalWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex normal in world space of the current rendered object.</p>
</dd>
<dt><a href="#transformedClearcoatNormalView">transformedClearcoatNormalView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#transformNormal">transformNormal(normal, [matrix])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Transforms the normal with the given matrix.</p>
</dd>
<dt><a href="#transformNormalToView">transformNormalToView(normal, builder)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Transforms the given normal from local to view space.</p>
</dd>
</dl>

<a name="normalGeometry"></a>

## normalGeometry : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the normal attribute of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="normalLocal"></a>

## normalLocal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex normal in local space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="normalFlat"></a>

## normalFlat : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the flat vertex normal in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="normalView"></a>

## normalView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex normal in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="normalWorld"></a>

## normalWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex normal in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedNormalView"></a>

## transformedNormalView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed vertex normal in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedNormalWorld"></a>

## transformedNormalWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed vertex normal in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedClearcoatNormalView"></a>

## transformedClearcoatNormalView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformNormal"></a>

## transformNormal(normal, [matrix]) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the normal with the given matrix.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed normal.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| normal | <code>Node.&lt;vec3&gt;</code> |  | The normal. |
| [matrix] | <code>Node.&lt;mat3&gt;</code> | <code>modelWorldMatrix</code> | The matrix. |

<a name="transformNormalToView"></a>

## transformNormalToView(normal, builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the given normal from local to view space.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed normal.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Node.&lt;vec3&gt;</code> | The normal. |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#Object3DNode">Object3DNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used to access transformation related metrics of 3D objects.
Depending on the selected scope, a different metric is represented as a uniform
in the shader. The following scopes are supported:</p>
<ul>
<li><code>POSITION</code>: The object&#39;s position in world space.</li>
<li><code>VIEW_POSITION</code>: The object&#39;s position in view/camera space.</li>
<li><code>DIRECTION</code>: The object&#39;s direction in world space.</li>
<li><code>SCALE</code>: The object&#39;s scale in world space.</li>
<li><code>WORLD_MATRIX</code>: The object&#39;s matrix in world space.</li>
</ul>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#objectDirection">objectDirection([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s direction in world space.</p>
</dd>
<dt><a href="#objectWorldMatrix">objectWorldMatrix([object3d])</a> ⇒ <code>Object3DNode.&lt;mat4&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s world matrix.</p>
</dd>
<dt><a href="#objectPosition">objectPosition([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s position in world space.</p>
</dd>
<dt><a href="#objectScale">objectScale([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s scale in world space.</p>
</dd>
<dt><a href="#objectViewPosition">objectViewPosition([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s position in view/camera space.</p>
</dd>
<dt><a href="#objectRadius">objectRadius([object3d])</a> ⇒ <code>Object3DNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating an object 3D node that represents the object&#39;s radius.</p>
</dd>
</dl>

<a name="Object3DNode"></a>

## Object3DNode ⇐ <code>Node</code>
This node can be used to access transformation related metrics of 3D objects.
Depending on the selected scope, a different metric is represented as a uniform
in the shader. The following scopes are supported:

- `POSITION`: The object's position in world space.
- `VIEW_POSITION`: The object's position in view/camera space.
- `DIRECTION`: The object's direction in world space.
- `SCALE`: The object's scale in world space.
- `WORLD_MATRIX`: The object's matrix in world space.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [Object3DNode](#Object3DNode) ⇐ <code>Node</code>
    * [new Object3DNode(scope, [object3d])](#new_Object3DNode_new)
    * [.scope](#Object3DNode+scope) : <code>&#x27;position&#x27;</code> \| <code>&#x27;viewPosition&#x27;</code> \| <code>&#x27;direction&#x27;</code> \| <code>&#x27;scale&#x27;</code> \| <code>&#x27;worldMatrix&#x27;</code>
    * [.object3d](#Object3DNode+object3d) : <code>Object3D</code>
    * [.updateType](#Object3DNode+updateType) : <code>string</code>
    * [.getNodeType()](#Object3DNode+getNodeType) ⇒ <code>string</code>
    * [.update(frame)](#Object3DNode+update)
    * [.generate(builder)](#Object3DNode+generate) ⇒ <code>string</code>

<a name="new_Object3DNode_new"></a>

### new Object3DNode(scope, [object3d])
Constructs a new object 3D node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scope | <code>&#x27;position&#x27;</code> \| <code>&#x27;viewPosition&#x27;</code> \| <code>&#x27;direction&#x27;</code> \| <code>&#x27;scale&#x27;</code> \| <code>&#x27;worldMatrix&#x27;</code> |  | The node represents a different type of transformation depending on the scope. |
| [object3d] | <code>Object3D</code> | <code></code> | The 3D object. |

<a name="Object3DNode+scope"></a>

### object3DNode.scope : <code>&#x27;position&#x27;</code> \| <code>&#x27;viewPosition&#x27;</code> \| <code>&#x27;direction&#x27;</code> \| <code>&#x27;scale&#x27;</code> \| <code>&#x27;worldMatrix&#x27;</code>
The node reports a different type of transformation depending on the scope.

**Kind**: instance property of [<code>Object3DNode</code>](#Object3DNode)  
<a name="Object3DNode+object3d"></a>

### object3DNode.object3d : <code>Object3D</code>
The 3D object.

**Kind**: instance property of [<code>Object3DNode</code>](#Object3DNode)  
**Default**: <code>null</code>  
<a name="Object3DNode+updateType"></a>

### object3DNode.updateType : <code>string</code>
Overwritten since this type of node is updated per object.

**Kind**: instance property of [<code>Object3DNode</code>](#Object3DNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="Object3DNode+getNodeType"></a>

### object3DNode.getNodeType() ⇒ <code>string</code>
Overwritten since the node type is inferred from the scope.

**Kind**: instance method of [<code>Object3DNode</code>](#Object3DNode)  
**Returns**: <code>string</code> - The node type.  
<a name="Object3DNode+update"></a>

### object3DNode.update(frame)
Updates the uniform value depending on the scope.

**Kind**: instance method of [<code>Object3DNode</code>](#Object3DNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="Object3DNode+generate"></a>

### object3DNode.generate(builder) ⇒ <code>string</code>
Generates the code snippet of the uniform node. The node type of the uniform
node also depends on the selected scope.

**Kind**: instance method of [<code>Object3DNode</code>](#Object3DNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="objectDirection"></a>

## objectDirection([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's direction in world space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectWorldMatrix"></a>

## objectWorldMatrix([object3d]) ⇒ <code>Object3DNode.&lt;mat4&gt;</code>
TSL function for creating an object 3D node that represents the object's world matrix.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectPosition"></a>

## objectPosition([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's position in world space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectScale"></a>

## objectScale([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's scale in world space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectViewPosition"></a>

## objectViewPosition([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's position in view/camera space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

<a name="objectRadius"></a>

## objectRadius([object3d]) ⇒ <code>Object3DNode.&lt;vec3&gt;</code>
TSL function for creating an object 3D node that represents the object's radius.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [object3d] | <code>Object3D</code> | The 3D object. |

## Classes

<dl>
<dt><a href="#PointUVNode">PointUVNode</a> ⇐ <code>Node</code></dt>
<dd><p>A node for representing the uv coordinates of points.</p>
<p>Can only be used with a WebGL backend. In WebGPU, point
primitives always have the size of one pixel and can thus
can&#39;t be used as sprite-like objects that display textures.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#pointUV">pointUV</a> : <code><a href="#PointUVNode">PointUVNode</a></code></dt>
<dd><p>TSL object that represents the uv coordinates of points.</p>
</dd>
</dl>

<a name="PointUVNode"></a>

## PointUVNode ⇐ <code>Node</code>
A node for representing the uv coordinates of points.

Can only be used with a WebGL backend. In WebGPU, point
primitives always have the size of one pixel and can thus
can't be used as sprite-like objects that display textures.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [PointUVNode](#PointUVNode) ⇐ <code>Node</code>
    * [new PointUVNode()](#new_PointUVNode_new)
    * [.isPointUVNode](#PointUVNode+isPointUVNode) : <code>boolean</code>

<a name="new_PointUVNode_new"></a>

### new PointUVNode()
Constructs a new point uv node.

<a name="PointUVNode+isPointUVNode"></a>

### pointUVNode.isPointUVNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PointUVNode</code>](#PointUVNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="pointUV"></a>

## pointUV : [<code>PointUVNode</code>](#PointUVNode)
TSL object that represents the uv coordinates of points.

**Kind**: global constant  
**Tsl**:   
## Constants

<dl>
<dt><a href="#positionGeometry">positionGeometry</a> : <code>AttributeNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the position attribute of the current rendered object.</p>
</dd>
<dt><a href="#positionLocal">positionLocal</a> : <code>AttributeNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex position in local space of the current rendered object.</p>
</dd>
<dt><a href="#positionPrevious">positionPrevious</a> : <code>AttributeNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the previous vertex position in local space of the current rendered object.
Used in context of <a href="VelocityNode">VelocityNode</a> for rendering motion vectors.</p>
</dd>
<dt><a href="#positionWorld">positionWorld</a> : <code>VaryingNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex position in world space of the current rendered object.</p>
</dd>
<dt><a href="#positionWorldDirection">positionWorldDirection</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the position world direction of the current rendered object.</p>
</dd>
<dt><a href="#positionView">positionView</a> : <code>VaryingNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex position in view space of the current rendered object.</p>
</dd>
<dt><a href="#positionViewDirection">positionViewDirection</a> : <code>VaryingNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the position view direction of the current rendered object.</p>
</dd>
</dl>

<a name="positionGeometry"></a>

## positionGeometry : <code>AttributeNode.&lt;vec3&gt;</code>
TSL object that represents the position attribute of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionLocal"></a>

## positionLocal : <code>AttributeNode.&lt;vec3&gt;</code>
TSL object that represents the vertex position in local space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionPrevious"></a>

## positionPrevious : <code>AttributeNode.&lt;vec3&gt;</code>
TSL object that represents the previous vertex position in local space of the current rendered object.
Used in context of [VelocityNode](VelocityNode) for rendering motion vectors.

**Kind**: global constant  
**Tsl**:   
<a name="positionWorld"></a>

## positionWorld : <code>VaryingNode.&lt;vec3&gt;</code>
TSL object that represents the vertex position in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionWorldDirection"></a>

## positionWorldDirection : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the position world direction of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionView"></a>

## positionView : <code>VaryingNode.&lt;vec3&gt;</code>
TSL object that represents the vertex position in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="positionViewDirection"></a>

## positionViewDirection : <code>VaryingNode.&lt;vec3&gt;</code>
TSL object that represents the position view direction of the current rendered object.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#ReferenceElementNode">ReferenceElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>This class is only relevant if the referenced property is array-like.
In this case, <code>ReferenceElementNode</code> allows to refer to a specific
element inside the data structure via an index.</p>
</dd>
<dt><a href="#ReferenceBaseNode">ReferenceBaseNode</a> ⇐ <code>Node</code></dt>
<dd><p>Base class for nodes which establishes a reference to a property of another object.
In this way, the value of the node is automatically linked to the value of
referenced object. Reference nodes internally represent the linked value
as a uniform.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#reference">reference(name, type, object)</a> ⇒ <code><a href="#ReferenceBaseNode">ReferenceBaseNode</a></code></dt>
<dd><p>TSL function for creating a reference base node.</p>
</dd>
<dt><a href="#referenceBuffer">referenceBuffer(name, type, count, [object])</a> ⇒ <code><a href="#ReferenceBaseNode">ReferenceBaseNode</a></code></dt>
<dd><p>TSL function for creating a reference base node. Use this function if you want need a reference
to an array-like property that should be represented as a uniform buffer.</p>
</dd>
</dl>

<a name="ReferenceElementNode"></a>

## ReferenceElementNode ⇐ <code>ArrayElementNode</code>
This class is only relevant if the referenced property is array-like.
In this case, `ReferenceElementNode` allows to refer to a specific
element inside the data structure via an index.

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [ReferenceElementNode](#ReferenceElementNode) ⇐ <code>ArrayElementNode</code>
    * [new ReferenceElementNode(referenceNode, indexNode)](#new_ReferenceElementNode_new)
    * [.referenceNode](#ReferenceElementNode+referenceNode) : [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
    * [.isReferenceElementNode](#ReferenceElementNode+isReferenceElementNode) : <code>boolean</code>
    * [.getNodeType()](#ReferenceElementNode+getNodeType) ⇒ <code>string</code>

<a name="new_ReferenceElementNode_new"></a>

### new ReferenceElementNode(referenceNode, indexNode)
Constructs a new reference element node.


| Param | Type | Description |
| --- | --- | --- |
| referenceNode | [<code>ReferenceBaseNode</code>](#ReferenceBaseNode) | The reference node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="ReferenceElementNode+referenceNode"></a>

### referenceElementNode.referenceNode : [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
Similar to [reference](#ReferenceBaseNode+reference), an additional
property references to the current node.

**Kind**: instance property of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Default**: <code>null</code>  
<a name="ReferenceElementNode+isReferenceElementNode"></a>

### referenceElementNode.isReferenceElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ReferenceElementNode+getNodeType"></a>

### referenceElementNode.getNodeType() ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the uniform type of the reference node.

**Kind**: instance method of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Returns**: <code>string</code> - The node type.  
<a name="ReferenceBaseNode"></a>

## ReferenceBaseNode ⇐ <code>Node</code>
Base class for nodes which establishes a reference to a property of another object.
In this way, the value of the node is automatically linked to the value of
referenced object. Reference nodes internally represent the linked value
as a uniform.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ReferenceBaseNode](#ReferenceBaseNode) ⇐ <code>Node</code>
    * [new ReferenceBaseNode(property, uniformType, [object], [count])](#new_ReferenceBaseNode_new)
    * [.property](#ReferenceBaseNode+property) : <code>string</code>
    * [.uniformType](#ReferenceBaseNode+uniformType) : <code>string</code>
    * [.object](#ReferenceBaseNode+object) : <code>Object</code>
    * [.count](#ReferenceBaseNode+count) : <code>number</code>
    * [.properties](#ReferenceBaseNode+properties) : <code>Array.&lt;string&gt;</code>
    * [.reference](#ReferenceBaseNode+reference) : <code>Object</code>
    * [.node](#ReferenceBaseNode+node) : <code>UniformNode</code>
    * [.group](#ReferenceBaseNode+group) : <code>UniformGroupNode</code>
    * [.updateType](#ReferenceBaseNode+updateType) : <code>string</code>
    * [.setGroup(group)](#ReferenceBaseNode+setGroup) ⇒ [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
    * [.element(indexNode)](#ReferenceBaseNode+element) ⇒ [<code>ReferenceElementNode</code>](#ReferenceElementNode)
    * [.setNodeType(uniformType)](#ReferenceBaseNode+setNodeType)
    * [.getNodeType(builder)](#ReferenceBaseNode+getNodeType) ⇒ <code>string</code>
    * [.getValueFromReference([object])](#ReferenceBaseNode+getValueFromReference) ⇒ <code>any</code>
    * [.updateReference(state)](#ReferenceBaseNode+updateReference) ⇒ <code>Object</code>
    * [.setup()](#ReferenceBaseNode+setup) ⇒ <code>UniformNode</code>
    * [.update(frame)](#ReferenceBaseNode+update)
    * [.updateValue()](#ReferenceBaseNode+updateValue)

<a name="new_ReferenceBaseNode_new"></a>

### new ReferenceBaseNode(property, uniformType, [object], [count])
Constructs a new reference base node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The name of the property the node refers to. |
| uniformType | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [object] | <code>Object</code> | <code></code> | The object the property belongs to. |
| [count] | <code>number</code> | <code></code> | When the linked property is an array-like, this parameter defines its length. |

<a name="ReferenceBaseNode+property"></a>

### referenceBaseNode.property : <code>string</code>
The name of the property the node refers to.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
<a name="ReferenceBaseNode+uniformType"></a>

### referenceBaseNode.uniformType : <code>string</code>
The uniform type that should be used to represent the property value.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
<a name="ReferenceBaseNode+object"></a>

### referenceBaseNode.object : <code>Object</code>
The object the property belongs to.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+count"></a>

### referenceBaseNode.count : <code>number</code>
When the linked property is an array, this parameter defines its length.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+properties"></a>

### referenceBaseNode.properties : <code>Array.&lt;string&gt;</code>
The property name might have dots so nested properties can be referred.
The hierarchy of the names is stored inside this array.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
<a name="ReferenceBaseNode+reference"></a>

### referenceBaseNode.reference : <code>Object</code>
Points to the current referred object. This property exists next to [ReferenceNode#object](ReferenceNode#object)
since the final reference might be updated from calling code.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+node"></a>

### referenceBaseNode.node : <code>UniformNode</code>
The uniform node that holds the value of the reference node.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+group"></a>

### referenceBaseNode.group : <code>UniformGroupNode</code>
The uniform group of the internal uniform.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>null</code>  
<a name="ReferenceBaseNode+updateType"></a>

### referenceBaseNode.updateType : <code>string</code>
Overwritten since reference nodes are updated per object.

**Kind**: instance property of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="ReferenceBaseNode+setGroup"></a>

### referenceBaseNode.setGroup(group) ⇒ [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
Sets the uniform group for this reference node.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: [<code>ReferenceBaseNode</code>](#ReferenceBaseNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| group | <code>UniformGroupNode</code> | The uniform group to set. |

<a name="ReferenceBaseNode+element"></a>

### referenceBaseNode.element(indexNode) ⇒ [<code>ReferenceElementNode</code>](#ReferenceElementNode)
When the referred property is array-like, this method can be used
to access elements via an index node.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: [<code>ReferenceElementNode</code>](#ReferenceElementNode) - A reference to an element.  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | indexNode. |

<a name="ReferenceBaseNode+setNodeType"></a>

### referenceBaseNode.setNodeType(uniformType)
Sets the node type which automatically defines the internal
uniform type.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  

| Param | Type | Description |
| --- | --- | --- |
| uniformType | <code>string</code> | The type to set. |

<a name="ReferenceBaseNode+getNodeType"></a>

### referenceBaseNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the type of the reference node.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ReferenceBaseNode+getValueFromReference"></a>

### referenceBaseNode.getValueFromReference([object]) ⇒ <code>any</code>
Returns the property value from the given referred object.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: <code>any</code> - The value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [object] | <code>Object</code> | <code>this.reference</code> | The object to retrieve the property value from. |

<a name="ReferenceBaseNode+updateReference"></a>

### referenceBaseNode.updateReference(state) ⇒ <code>Object</code>
Allows to update the reference based on the given state. The state is only
evaluated [object](#ReferenceBaseNode+object) is not set.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: <code>Object</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state. |

<a name="ReferenceBaseNode+setup"></a>

### referenceBaseNode.setup() ⇒ <code>UniformNode</code>
The output of the reference node is the internal uniform node.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
**Returns**: <code>UniformNode</code> - The output node.  
<a name="ReferenceBaseNode+update"></a>

### referenceBaseNode.update(frame)
Overwritten to to update the internal uniform value.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="ReferenceBaseNode+updateValue"></a>

### referenceBaseNode.updateValue()
Retrieves the value from the referred object property and uses it
to updated the internal uniform.

**Kind**: instance method of [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)  
<a name="reference"></a>

## reference(name, type, object) ⇒ [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
TSL function for creating a reference base node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property the node refers to. |
| type | <code>string</code> | The uniform type that should be used to represent the property value. |
| object | <code>Object</code> | The object the property belongs to. |

<a name="referenceBuffer"></a>

## referenceBuffer(name, type, count, [object]) ⇒ [<code>ReferenceBaseNode</code>](#ReferenceBaseNode)
TSL function for creating a reference base node. Use this function if you want need a reference
to an array-like property that should be represented as a uniform buffer.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property the node refers to. |
| type | <code>string</code> | The uniform type that should be used to represent the property value. |
| count | <code>number</code> | The number of value inside the array-like object. |
| [object] | <code>Object</code> | An array-like object the property belongs to. |

## Classes

<dl>
<dt><a href="#ReferenceElementNode">ReferenceElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>This class is only relevant if the referenced property is array-like.
In this case, <code>ReferenceElementNode</code> allows to refer to a specific
element inside the data structure via an index.</p>
</dd>
<dt><a href="#ReferenceNode">ReferenceNode</a> ⇐ <code>Node</code></dt>
<dd><p>This type of node establishes a reference to a property of another object.
In this way, the value of the node is automatically linked to the value of
referenced object. Reference nodes internally represent the linked value
as a uniform.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#reference">reference(name, type, [object])</a> ⇒ <code><a href="#ReferenceNode">ReferenceNode</a></code></dt>
<dd><p>TSL function for creating a reference node.</p>
</dd>
<dt><a href="#referenceBuffer">referenceBuffer(name, type, count, object)</a> ⇒ <code><a href="#ReferenceNode">ReferenceNode</a></code></dt>
<dd><p>TSL function for creating a reference node. Use this function if you want need a reference
to an array-like property that should be represented as a uniform buffer.</p>
</dd>
</dl>

<a name="ReferenceElementNode"></a>

## ReferenceElementNode ⇐ <code>ArrayElementNode</code>
This class is only relevant if the referenced property is array-like.
In this case, `ReferenceElementNode` allows to refer to a specific
element inside the data structure via an index.

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [ReferenceElementNode](#ReferenceElementNode) ⇐ <code>ArrayElementNode</code>
    * [new ReferenceElementNode(referenceNode, indexNode)](#new_ReferenceElementNode_new)
    * [.referenceNode](#ReferenceElementNode+referenceNode) : [<code>ReferenceNode</code>](#ReferenceNode)
    * [.isReferenceElementNode](#ReferenceElementNode+isReferenceElementNode) : <code>boolean</code>
    * [.getNodeType()](#ReferenceElementNode+getNodeType) ⇒ <code>string</code>

<a name="new_ReferenceElementNode_new"></a>

### new ReferenceElementNode(referenceNode, indexNode)
Constructs a new reference element node.


| Param | Type | Description |
| --- | --- | --- |
| referenceNode | [<code>ReferenceNode</code>](#ReferenceNode) | The reference node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="ReferenceElementNode+referenceNode"></a>

### referenceElementNode.referenceNode : [<code>ReferenceNode</code>](#ReferenceNode)
Similar to [reference](#ReferenceNode+reference), an additional
property references to the current node.

**Kind**: instance property of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Default**: <code>null</code>  
<a name="ReferenceElementNode+isReferenceElementNode"></a>

### referenceElementNode.isReferenceElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ReferenceElementNode+getNodeType"></a>

### referenceElementNode.getNodeType() ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the uniform type of the reference node.

**Kind**: instance method of [<code>ReferenceElementNode</code>](#ReferenceElementNode)  
**Returns**: <code>string</code> - The node type.  
<a name="ReferenceNode"></a>

## ReferenceNode ⇐ <code>Node</code>
This type of node establishes a reference to a property of another object.
In this way, the value of the node is automatically linked to the value of
referenced object. Reference nodes internally represent the linked value
as a uniform.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ReferenceNode](#ReferenceNode) ⇐ <code>Node</code>
    * [new ReferenceNode(property, uniformType, [object], [count])](#new_ReferenceNode_new)
    * [.property](#ReferenceNode+property) : <code>string</code>
    * [.uniformType](#ReferenceNode+uniformType) : <code>string</code>
    * [.object](#ReferenceNode+object) : <code>Object</code>
    * [.count](#ReferenceNode+count) : <code>number</code>
    * [.properties](#ReferenceNode+properties) : <code>Array.&lt;string&gt;</code>
    * [.reference](#ReferenceNode+reference) : <code>Object</code>
    * [.node](#ReferenceNode+node) : <code>UniformNode</code>
    * [.group](#ReferenceNode+group) : <code>UniformGroupNode</code>
    * [.name](#ReferenceNode+name) : <code>string</code>
    * [.updateType](#ReferenceNode+updateType) : <code>string</code>
    * [.element(indexNode)](#ReferenceNode+element) ⇒ [<code>ReferenceElementNode</code>](#ReferenceElementNode)
    * [.setGroup(group)](#ReferenceNode+setGroup) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
    * [.label(name)](#ReferenceNode+label) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
    * [.setNodeType(uniformType)](#ReferenceNode+setNodeType)
    * [.getNodeType(builder)](#ReferenceNode+getNodeType) ⇒ <code>string</code>
    * [.getValueFromReference([object])](#ReferenceNode+getValueFromReference) ⇒ <code>any</code>
    * [.updateReference(state)](#ReferenceNode+updateReference) ⇒ <code>Object</code>
    * [.setup(builder)](#ReferenceNode+setup) ⇒ <code>UniformNode</code>
    * [.update(frame)](#ReferenceNode+update)
    * [.updateValue()](#ReferenceNode+updateValue)

<a name="new_ReferenceNode_new"></a>

### new ReferenceNode(property, uniformType, [object], [count])
Constructs a new reference node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The name of the property the node refers to. |
| uniformType | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [object] | <code>Object</code> | <code></code> | The object the property belongs to. |
| [count] | <code>number</code> | <code></code> | When the linked property is an array-like, this parameter defines its length. |

<a name="ReferenceNode+property"></a>

### referenceNode.property : <code>string</code>
The name of the property the node refers to.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
<a name="ReferenceNode+uniformType"></a>

### referenceNode.uniformType : <code>string</code>
The uniform type that should be used to represent the property value.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
<a name="ReferenceNode+object"></a>

### referenceNode.object : <code>Object</code>
The object the property belongs to.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+count"></a>

### referenceNode.count : <code>number</code>
When the linked property is an array, this parameter defines its length.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+properties"></a>

### referenceNode.properties : <code>Array.&lt;string&gt;</code>
The property name might have dots so nested properties can be referred.
The hierarchy of the names is stored inside this array.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
<a name="ReferenceNode+reference"></a>

### referenceNode.reference : <code>Object</code>
Points to the current referred object. This property exists next to [object](#ReferenceNode+object)
since the final reference might be updated from calling code.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+node"></a>

### referenceNode.node : <code>UniformNode</code>
The uniform node that holds the value of the reference node.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+group"></a>

### referenceNode.group : <code>UniformGroupNode</code>
The uniform group of the internal uniform.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>null</code>  
<a name="ReferenceNode+name"></a>

### referenceNode.name : <code>string</code>
An optional label of the internal uniform node.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="ReferenceNode+updateType"></a>

### referenceNode.updateType : <code>string</code>
Overwritten since reference nodes are updated per object.

**Kind**: instance property of [<code>ReferenceNode</code>](#ReferenceNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="ReferenceNode+element"></a>

### referenceNode.element(indexNode) ⇒ [<code>ReferenceElementNode</code>](#ReferenceElementNode)
When the referred property is array-like, this method can be used
to access elements via an index node.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: [<code>ReferenceElementNode</code>](#ReferenceElementNode) - A reference to an element.  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | indexNode. |

<a name="ReferenceNode+setGroup"></a>

### referenceNode.setGroup(group) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
Sets the uniform group for this reference node.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: [<code>ReferenceNode</code>](#ReferenceNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| group | <code>UniformGroupNode</code> | The uniform group to set. |

<a name="ReferenceNode+label"></a>

### referenceNode.label(name) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
Sets the label for the internal uniform.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: [<code>ReferenceNode</code>](#ReferenceNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The label to set. |

<a name="ReferenceNode+setNodeType"></a>

### referenceNode.setNodeType(uniformType)
Sets the node type which automatically defines the internal
uniform type.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  

| Param | Type | Description |
| --- | --- | --- |
| uniformType | <code>string</code> | The type to set. |

<a name="ReferenceNode+getNodeType"></a>

### referenceNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from
the type of the reference node.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ReferenceNode+getValueFromReference"></a>

### referenceNode.getValueFromReference([object]) ⇒ <code>any</code>
Returns the property value from the given referred object.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: <code>any</code> - The value.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [object] | <code>Object</code> | <code>this.reference</code> | The object to retrieve the property value from. |

<a name="ReferenceNode+updateReference"></a>

### referenceNode.updateReference(state) ⇒ <code>Object</code>
Allows to update the reference based on the given state. The state is only
evaluated [object](#ReferenceNode+object) is not set.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: <code>Object</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state. |

<a name="ReferenceNode+setup"></a>

### referenceNode.setup(builder) ⇒ <code>UniformNode</code>
The output of the reference node is the internal uniform node.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
**Returns**: <code>UniformNode</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ReferenceNode+update"></a>

### referenceNode.update(frame)
Overwritten to to update the internal uniform value.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="ReferenceNode+updateValue"></a>

### referenceNode.updateValue()
Retrieves the value from the referred object property and uses it
to updated the internal uniform.

**Kind**: instance method of [<code>ReferenceNode</code>](#ReferenceNode)  
<a name="reference"></a>

## reference(name, type, [object]) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
TSL function for creating a reference node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property the node refers to. |
| type | <code>string</code> | The uniform type that should be used to represent the property value. |
| [object] | <code>Object</code> | The object the property belongs to. |

<a name="referenceBuffer"></a>

## referenceBuffer(name, type, count, object) ⇒ [<code>ReferenceNode</code>](#ReferenceNode)
TSL function for creating a reference node. Use this function if you want need a reference
to an array-like property that should be represented as a uniform buffer.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the property the node refers to. |
| type | <code>string</code> | The uniform type that should be used to represent the property value. |
| count | <code>number</code> | The number of value inside the array-like object. |
| object | <code>Object</code> | An array-like object the property belongs to. |

## Constants

<dl>
<dt><a href="#reflectView">reflectView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>The reflect vector in view space.</p>
</dd>
<dt><a href="#refractView">refractView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>The refract vector in view space.</p>
</dd>
<dt><a href="#reflectVector">reflectVector</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Used for sampling cube maps when using cube reflection mapping.</p>
</dd>
<dt><a href="#refractVector">refractVector</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Used for sampling cube maps when using cube refraction mapping.</p>
</dd>
</dl>

<a name="reflectView"></a>

## reflectView : <code>Node.&lt;vec3&gt;</code>
The reflect vector in view space.

**Kind**: global constant  
**Tsl**:   
<a name="refractView"></a>

## refractView : <code>Node.&lt;vec3&gt;</code>
The refract vector in view space.

**Kind**: global constant  
**Tsl**:   
<a name="reflectVector"></a>

## reflectVector : <code>Node.&lt;vec3&gt;</code>
Used for sampling cube maps when using cube reflection mapping.

**Kind**: global constant  
**Tsl**:   
<a name="refractVector"></a>

## refractVector : <code>Node.&lt;vec3&gt;</code>
Used for sampling cube maps when using cube refraction mapping.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#RendererReferenceNode">RendererReferenceNode</a> ⇐ <code>ReferenceBaseNode</code></dt>
<dd><p>This node is a special type of reference node which is intended
for linking renderer properties with node values.</p>
<pre><code class="language-js">const exposureNode = rendererReference( &#39;toneMappingExposure&#39;, &#39;float&#39;, renderer );
</code></pre>
<p>When changing <code>renderer.toneMappingExposure</code>, the node value of <code>exposureNode</code> will
automatically be updated.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#rendererReference">rendererReference(name, type, [renderer])</a> ⇒ <code><a href="#RendererReferenceNode">RendererReferenceNode</a></code></dt>
<dd><p>TSL function for creating a renderer reference node.</p>
</dd>
</dl>

<a name="RendererReferenceNode"></a>

## RendererReferenceNode ⇐ <code>ReferenceBaseNode</code>
This node is a special type of reference node which is intended
for linking renderer properties with node values.
```js
const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );
```
When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will
automatically be updated.

**Kind**: global class  
**Extends**: <code>ReferenceBaseNode</code>  

* [RendererReferenceNode](#RendererReferenceNode) ⇐ <code>ReferenceBaseNode</code>
    * [new RendererReferenceNode(property, inputType, [renderer])](#new_RendererReferenceNode_new)
    * [.renderer](#RendererReferenceNode+renderer) : <code>Renderer</code>
    * [.updateReference(state)](#RendererReferenceNode+updateReference) ⇒ <code>Object</code>

<a name="new_RendererReferenceNode_new"></a>

### new RendererReferenceNode(property, inputType, [renderer])
Constructs a new renderer reference node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The name of the property the node refers to. |
| inputType | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [renderer] | <code>Renderer</code> | <code></code> | The renderer the property belongs to. When no renderer is set, the node refers to the renderer of the current state. |

<a name="RendererReferenceNode+renderer"></a>

### rendererReferenceNode.renderer : <code>Renderer</code>
The renderer the property belongs to. When no renderer is set,
the node refers to the renderer of the current state.

**Kind**: instance property of [<code>RendererReferenceNode</code>](#RendererReferenceNode)  
**Default**: <code>null</code>  
<a name="RendererReferenceNode+updateReference"></a>

### rendererReferenceNode.updateReference(state) ⇒ <code>Object</code>
Updates the reference based on the given state. The state is only evaluated
[renderer](#RendererReferenceNode+renderer) is not set.

**Kind**: instance method of [<code>RendererReferenceNode</code>](#RendererReferenceNode)  
**Returns**: <code>Object</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state. |

<a name="rendererReference"></a>

## rendererReference(name, type, [renderer]) ⇒ [<code>RendererReferenceNode</code>](#RendererReferenceNode)
TSL function for creating a renderer reference node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the property the node refers to. |
| type | <code>string</code> |  | The uniform type that should be used to represent the property value. |
| [renderer] | <code>Renderer</code> | <code></code> | The renderer the property belongs to. When no renderer is set, the node refers to the renderer of the current state. |

## Classes

<dl>
<dt><a href="#SceneNode">SceneNode</a> ⇐ <code>Node</code></dt>
<dd><p>This module allows access to a collection of scene properties. The following predefined TSL objects
are available for easier use:</p>
<ul>
<li><code>backgroundBlurriness</code>: A node that represents the scene&#39;s background blurriness.</li>
<li><code>backgroundIntensity</code>: A node that represents the scene&#39;s background intensity.</li>
<li><code>backgroundRotation</code>: A node that represents the scene&#39;s background rotation.</li>
</ul>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#backgroundBlurriness">backgroundBlurriness</a> : <code><a href="#SceneNode">SceneNode</a></code></dt>
<dd><p>TSL object that represents the scene&#39;s background blurriness.</p>
</dd>
<dt><a href="#backgroundIntensity">backgroundIntensity</a> : <code><a href="#SceneNode">SceneNode</a></code></dt>
<dd><p>TSL object that represents the scene&#39;s background intensity.</p>
</dd>
<dt><a href="#backgroundRotation">backgroundRotation</a> : <code><a href="#SceneNode">SceneNode</a></code></dt>
<dd><p>TSL object that represents the scene&#39;s background rotation.</p>
</dd>
</dl>

<a name="SceneNode"></a>

## SceneNode ⇐ <code>Node</code>
This module allows access to a collection of scene properties. The following predefined TSL objects
are available for easier use:

- `backgroundBlurriness`: A node that represents the scene's background blurriness.
- `backgroundIntensity`: A node that represents the scene's background intensity.
- `backgroundRotation`: A node that represents the scene's background rotation.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [SceneNode](#SceneNode) ⇐ <code>Node</code>
    * [new SceneNode(scope, [scene])](#new_SceneNode_new)
    * [.scope](#SceneNode+scope) : <code>&#x27;backgroundBlurriness&#x27;</code> \| <code>&#x27;backgroundIntensity&#x27;</code> \| <code>&#x27;backgroundRotation&#x27;</code>
    * [.scene](#SceneNode+scene) : <code>Scene</code>
    * [.setup(builder)](#SceneNode+setup) ⇒ <code>Node</code>

<a name="new_SceneNode_new"></a>

### new SceneNode(scope, [scene])
Constructs a new scene node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scope | <code>&#x27;backgroundBlurriness&#x27;</code> \| <code>&#x27;backgroundIntensity&#x27;</code> \| <code>&#x27;backgroundRotation&#x27;</code> |  | The scope defines the type of scene property that is accessed. |
| [scene] | <code>Scene</code> | <code></code> | A reference to the scene. |

<a name="SceneNode+scope"></a>

### sceneNode.scope : <code>&#x27;backgroundBlurriness&#x27;</code> \| <code>&#x27;backgroundIntensity&#x27;</code> \| <code>&#x27;backgroundRotation&#x27;</code>
The scope defines the type of scene property that is accessed.

**Kind**: instance property of [<code>SceneNode</code>](#SceneNode)  
<a name="SceneNode+scene"></a>

### sceneNode.scene : <code>Scene</code>
A reference to the scene that is going to be accessed.

**Kind**: instance property of [<code>SceneNode</code>](#SceneNode)  
**Default**: <code>null</code>  
<a name="SceneNode+setup"></a>

### sceneNode.setup(builder) ⇒ <code>Node</code>
Depending on the scope, the method returns a different type of node that represents
the respective scene property.

**Kind**: instance method of [<code>SceneNode</code>](#SceneNode)  
**Returns**: <code>Node</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="backgroundBlurriness"></a>

## backgroundBlurriness : [<code>SceneNode</code>](#SceneNode)
TSL object that represents the scene's background blurriness.

**Kind**: global constant  
**Tsl**:   
<a name="backgroundIntensity"></a>

## backgroundIntensity : [<code>SceneNode</code>](#SceneNode)
TSL object that represents the scene's background intensity.

**Kind**: global constant  
**Tsl**:   
<a name="backgroundRotation"></a>

## backgroundRotation : [<code>SceneNode</code>](#SceneNode)
TSL object that represents the scene's background rotation.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#SkinningNode">SkinningNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node implements the vertex transformation shader logic which is required
for skinning/skeletal animation.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#skinning">skinning(skinnedMesh)</a> ⇒ <code><a href="#SkinningNode">SkinningNode</a></code></dt>
<dd><p>TSL function for creating a skinning node.</p>
</dd>
<dt><a href="#computeSkinning">computeSkinning(skinnedMesh, [toPosition])</a> ⇒ <code><a href="#SkinningNode">SkinningNode</a></code></dt>
<dd><p>TSL function for computing skinning.</p>
</dd>
</dl>

<a name="SkinningNode"></a>

## SkinningNode ⇐ <code>Node</code>
This node implements the vertex transformation shader logic which is required
for skinning/skeletal animation.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [SkinningNode](#SkinningNode) ⇐ <code>Node</code>
    * [new SkinningNode(skinnedMesh)](#new_SkinningNode_new)
    * [.skinnedMesh](#SkinningNode+skinnedMesh) : <code>SkinnedMesh</code>
    * [.updateType](#SkinningNode+updateType) : <code>string</code>
    * [.skinIndexNode](#SkinningNode+skinIndexNode) : <code>AttributeNode</code>
    * [.skinWeightNode](#SkinningNode+skinWeightNode) : <code>AttributeNode</code>
    * [.bindMatrixNode](#SkinningNode+bindMatrixNode) : <code>Node.&lt;mat4&gt;</code>
    * [.bindMatrixInverseNode](#SkinningNode+bindMatrixInverseNode) : <code>Node.&lt;mat4&gt;</code>
    * [.boneMatricesNode](#SkinningNode+boneMatricesNode) : <code>Node</code>
    * [.positionNode](#SkinningNode+positionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.toPositionNode](#SkinningNode+toPositionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.previousBoneMatricesNode](#SkinningNode+previousBoneMatricesNode) : <code>Node</code>
    * [.getSkinnedPosition([boneMatrices], [position])](#SkinningNode+getSkinnedPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.getSkinnedNormal([boneMatrices], [normal])](#SkinningNode+getSkinnedNormal) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.getPreviousSkinnedPosition(builder)](#SkinningNode+getPreviousSkinnedPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.needsPreviousBoneMatrices(builder)](#SkinningNode+needsPreviousBoneMatrices) ⇒ <code>boolean</code>
    * [.setup(builder)](#SkinningNode+setup) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.generate(builder, output)](#SkinningNode+generate) ⇒ <code>string</code>
    * [.update(frame)](#SkinningNode+update)

<a name="new_SkinningNode_new"></a>

### new SkinningNode(skinnedMesh)
Constructs a new skinning node.


| Param | Type | Description |
| --- | --- | --- |
| skinnedMesh | <code>SkinnedMesh</code> | The skinned mesh. |

<a name="SkinningNode+skinnedMesh"></a>

### skinningNode.skinnedMesh : <code>SkinnedMesh</code>
The skinned mesh.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+updateType"></a>

### skinningNode.updateType : <code>string</code>
The update type overwritten since skinning nodes are updated per object.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+skinIndexNode"></a>

### skinningNode.skinIndexNode : <code>AttributeNode</code>
The skin index attribute.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+skinWeightNode"></a>

### skinningNode.skinWeightNode : <code>AttributeNode</code>
The skin weight attribute.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+bindMatrixNode"></a>

### skinningNode.bindMatrixNode : <code>Node.&lt;mat4&gt;</code>
The bind matrix node.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+bindMatrixInverseNode"></a>

### skinningNode.bindMatrixInverseNode : <code>Node.&lt;mat4&gt;</code>
The bind matrix inverse node.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+boneMatricesNode"></a>

### skinningNode.boneMatricesNode : <code>Node</code>
The bind matrices as a uniform buffer node.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+positionNode"></a>

### skinningNode.positionNode : <code>Node.&lt;vec3&gt;</code>
The current vertex position in local space.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+toPositionNode"></a>

### skinningNode.toPositionNode : <code>Node.&lt;vec3&gt;</code>
The result of vertex position in local space.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
<a name="SkinningNode+previousBoneMatricesNode"></a>

### skinningNode.previousBoneMatricesNode : <code>Node</code>
The previous bind matrices as a uniform buffer node.
Required for computing motion vectors.

**Kind**: instance property of [<code>SkinningNode</code>](#SkinningNode)  
**Default**: <code>null</code>  
<a name="SkinningNode+getSkinnedPosition"></a>

### skinningNode.getSkinnedPosition([boneMatrices], [position]) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the given vertex position via skinning.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed vertex position.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [boneMatrices] | <code>Node</code> | <code>this.boneMatricesNode</code> | The bone matrices |
| [position] | <code>Node.&lt;vec3&gt;</code> | <code>this.positionNode</code> | The vertex position in local space. |

<a name="SkinningNode+getSkinnedNormal"></a>

### skinningNode.getSkinnedNormal([boneMatrices], [normal]) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the given vertex normal via skinning.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed vertex normal.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [boneMatrices] | <code>Node</code> | <code>this.boneMatricesNode</code> | The bone matrices |
| [normal] | <code>Node.&lt;vec3&gt;</code> | <code>normalLocal</code> | The vertex normal in local space. |

<a name="SkinningNode+getPreviousSkinnedPosition"></a>

### skinningNode.getPreviousSkinnedPosition(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Transforms the given vertex normal via skinning.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The skinned position from the previous frame.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SkinningNode+needsPreviousBoneMatrices"></a>

### skinningNode.needsPreviousBoneMatrices(builder) ⇒ <code>boolean</code>
Returns `true` if bone matrices from the previous frame are required.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>boolean</code> - Whether bone matrices from the previous frame are required or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SkinningNode+setup"></a>

### skinningNode.setup(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the skinning node by assigning the transformed vertex data to predefined node variables.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The transformed vertex position.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SkinningNode+generate"></a>

### skinningNode.generate(builder, output) ⇒ <code>string</code>
Generates the code snippet of the skinning node.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | The current output. |

<a name="SkinningNode+update"></a>

### skinningNode.update(frame)
Updates the state of the skinned mesh by updating the skeleton once per frame.

**Kind**: instance method of [<code>SkinningNode</code>](#SkinningNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="skinning"></a>

## skinning(skinnedMesh) ⇒ [<code>SkinningNode</code>](#SkinningNode)
TSL function for creating a skinning node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| skinnedMesh | <code>SkinnedMesh</code> | The skinned mesh. |

<a name="computeSkinning"></a>

## computeSkinning(skinnedMesh, [toPosition]) ⇒ [<code>SkinningNode</code>](#SkinningNode)
TSL function for computing skinning.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| skinnedMesh | <code>SkinnedMesh</code> |  | The skinned mesh. |
| [toPosition] | <code>Node.&lt;vec3&gt;</code> | <code></code> | The target position. |

## Classes

<dl>
<dt><a href="#StorageBufferNode">StorageBufferNode</a> ⇐ <code>BufferNode</code></dt>
<dd><p>This node is used in context of compute shaders and allows to define a
storage buffer for data. A typical workflow is to create instances of
this node with the convenience functions <code>attributeArray()</code> or <code>instancedArray()</code>,
setup up a compute shader that writes into the buffers and then convert
the storage buffers to attribute nodes for rendering.</p>
<pre><code class="language-js">const positionBuffer = instancedArray( particleCount, &#39;vec3&#39; ); // the storage buffer node

const computeInit = Fn( () =&gt; { // the compute shader

    const position = positionBuffer.element( instanceIndex );

    // compute position data

    position.x = 1;
    position.y = 1;
    position.z = 1;

} )().compute( particleCount );

const particleMaterial = new THREE.SpriteNodeMaterial();
particleMaterial.positionNode = positionBuffer.toAttribute();

renderer.computeAsync( computeInit );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#storage">storage(value, [type], [count])</a> ⇒ <code><a href="#StorageBufferNode">StorageBufferNode</a></code></dt>
<dd><p>TSL function for creating a storage buffer node.</p>
</dd>
<dt><del><a href="#storageObject">storageObject(value, type, count)</a> ⇒ <code><a href="#StorageBufferNode">StorageBufferNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="StorageBufferNode"></a>

## StorageBufferNode ⇐ <code>BufferNode</code>
This node is used in context of compute shaders and allows to define a
storage buffer for data. A typical workflow is to create instances of
this node with the convenience functions `attributeArray()` or `instancedArray()`,
setup up a compute shader that writes into the buffers and then convert
the storage buffers to attribute nodes for rendering.

```js
const positionBuffer = instancedArray( particleCount, 'vec3' ); // the storage buffer node

const computeInit = Fn( () => { // the compute shader

	const position = positionBuffer.element( instanceIndex );

	// compute position data

	position.x = 1;
	position.y = 1;
	position.z = 1;

} )().compute( particleCount );

const particleMaterial = new THREE.SpriteNodeMaterial();
particleMaterial.positionNode = positionBuffer.toAttribute();

renderer.computeAsync( computeInit );

```

**Kind**: global class  
**Extends**: <code>BufferNode</code>  

* [StorageBufferNode](#StorageBufferNode) ⇐ <code>BufferNode</code>
    * [new StorageBufferNode(value, [bufferType], [bufferCount])](#new_StorageBufferNode_new)
    * [.isStorageBufferNode](#StorageBufferNode+isStorageBufferNode) : <code>boolean</code>
    * [.structTypeNode](#StorageBufferNode+structTypeNode) : <code>StructTypeNode</code>
    * [.access](#StorageBufferNode+access) : <code>string</code>
    * [.isAtomic](#StorageBufferNode+isAtomic) : <code>boolean</code>
    * [.isPBO](#StorageBufferNode+isPBO) : <code>boolean</code>
    * [._attribute](#StorageBufferNode+_attribute) : <code>BufferAttributeNode</code>
    * [._varying](#StorageBufferNode+_varying) : <code>VaryingNode</code>
    * [.global](#StorageBufferNode+global) : <code>boolean</code>
    * [.getHash(builder)](#StorageBufferNode+getHash) ⇒ <code>string</code>
    * [.getInputType(builder)](#StorageBufferNode+getInputType) ⇒ <code>string</code>
    * [.element(indexNode)](#StorageBufferNode+element) ⇒ <code>StorageArrayElementNode</code>
    * [.setPBO(value)](#StorageBufferNode+setPBO) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.getPBO()](#StorageBufferNode+getPBO) ⇒ <code>boolean</code>
    * [.setAccess(value)](#StorageBufferNode+setAccess) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.toReadOnly()](#StorageBufferNode+toReadOnly) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.setAtomic(value)](#StorageBufferNode+setAtomic) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.toAtomic()](#StorageBufferNode+toAtomic) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
    * [.getAttributeData()](#StorageBufferNode+getAttributeData) ⇒ <code>Object</code>
    * [.getNodeType(builder)](#StorageBufferNode+getNodeType) ⇒ <code>string</code>
    * [.generate(builder)](#StorageBufferNode+generate) ⇒ <code>string</code>

<a name="new_StorageBufferNode_new"></a>

### new StorageBufferNode(value, [bufferType], [bufferCount])
Constructs a new storage buffer node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageBufferAttribute</code> \| <code>StorageInstancedBufferAttribute</code> \| <code>BufferAttribute</code> |  | The buffer data. |
| [bufferType] | <code>string</code> \| <code>Struct</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [bufferCount] | <code>number</code> | <code>0</code> | The buffer count. |

<a name="StorageBufferNode+isStorageBufferNode"></a>

### storageBufferNode.isStorageBufferNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageBufferNode+structTypeNode"></a>

### storageBufferNode.structTypeNode : <code>StructTypeNode</code>
The buffer struct type.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>null</code>  
<a name="StorageBufferNode+access"></a>

### storageBufferNode.access : <code>string</code>
The access type of the texture node.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>&quot;&#x27;readWrite&#x27;&quot;</code>  
<a name="StorageBufferNode+isAtomic"></a>

### storageBufferNode.isAtomic : <code>boolean</code>
Whether the node is atomic or not.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>false</code>  
<a name="StorageBufferNode+isPBO"></a>

### storageBufferNode.isPBO : <code>boolean</code>
Whether the node represents a PBO or not.
Only relevant for WebGL.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>false</code>  
<a name="StorageBufferNode+_attribute"></a>

### storageBufferNode.\_attribute : <code>BufferAttributeNode</code>
A reference to the internal buffer attribute node.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>null</code>  
<a name="StorageBufferNode+_varying"></a>

### storageBufferNode.\_varying : <code>VaryingNode</code>
A reference to the internal varying node.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>null</code>  
<a name="StorageBufferNode+global"></a>

### storageBufferNode.global : <code>boolean</code>
`StorageBufferNode` sets this property to `true` by default.

**Kind**: instance property of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Default**: <code>true</code>  
<a name="StorageBufferNode+getHash"></a>

### storageBufferNode.getHash(builder) ⇒ <code>string</code>
This method is overwritten since the buffer data might be shared
and thus the hash should be shared as well.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>string</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="StorageBufferNode+getInputType"></a>

### storageBufferNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="StorageBufferNode+element"></a>

### storageBufferNode.element(indexNode) ⇒ <code>StorageArrayElementNode</code>
Enables element access with the given index node.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>StorageArrayElementNode</code> - A node representing the element access.  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | The index node. |

<a name="StorageBufferNode+setPBO"></a>

### storageBufferNode.setPBO(value) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Defines whether this node is a PBO or not. Only relevant for WebGL.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The value so set. |

<a name="StorageBufferNode+getPBO"></a>

### storageBufferNode.getPBO() ⇒ <code>boolean</code>
Returns the `isPBO` value.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>boolean</code> - Whether the node represents a PBO or not.  
<a name="StorageBufferNode+setAccess"></a>

### storageBufferNode.setAccess(value) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Defines the node access.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>string</code> | The node access. |

<a name="StorageBufferNode+toReadOnly"></a>

### storageBufferNode.toReadOnly() ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Convenience method for configuring a read-only node access.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  
<a name="StorageBufferNode+setAtomic"></a>

### storageBufferNode.setAtomic(value) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Defines whether the node is atomic or not.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The atomic flag. |

<a name="StorageBufferNode+toAtomic"></a>

### storageBufferNode.toAtomic() ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
Convenience method for making this node atomic.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: [<code>StorageBufferNode</code>](#StorageBufferNode) - A reference to this node.  
<a name="StorageBufferNode+getAttributeData"></a>

### storageBufferNode.getAttributeData() ⇒ <code>Object</code>
Returns attribute data for this storage buffer node.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>Object</code> - The attribute data.  
<a name="StorageBufferNode+getNodeType"></a>

### storageBufferNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type from the availability of storage buffers
and the attribute data.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="StorageBufferNode+generate"></a>

### storageBufferNode.generate(builder) ⇒ <code>string</code>
Generates the code snippet of the storage buffer node.

**Kind**: instance method of [<code>StorageBufferNode</code>](#StorageBufferNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="storage"></a>

## storage(value, [type], [count]) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)
TSL function for creating a storage buffer node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageBufferAttribute</code> \| <code>StorageInstancedBufferAttribute</code> \| <code>BufferAttribute</code> |  | The buffer data. |
| [type] | <code>string</code> \| <code>Struct</code> | <code>null</code> | The buffer type (e.g. `'vec3'`). |
| [count] | <code>number</code> | <code>0</code> | The buffer count. |

<a name="storageObject"></a>

## ~~storageObject(value, type, count) ⇒ [<code>StorageBufferNode</code>](#StorageBufferNode)~~
***since r171. Use `storage().setPBO( true )` instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>StorageBufferAttribute</code> \| <code>StorageInstancedBufferAttribute</code> \| <code>BufferAttribute</code> | The buffer data. |
| type | <code>string</code> | The buffer type (e.g. `'vec3'`). |
| count | <code>number</code> | The buffer count. |

## Classes

<dl>
<dt><a href="#StorageTextureNode">StorageTextureNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>This special version of a texture node can be used to
write data into a storage texture with a compute shader.</p>
<pre><code class="language-js">const storageTexture = new THREE.StorageTexture( width, height );

const computeTexture = Fn( ( { storageTexture } ) =&gt; {

    const posX = instanceIndex.mod( width );
    const posY = instanceIndex.div( width );
    const indexUV = uvec2( posX, posY );

    // generate RGB values

    const r = 1;
    const g = 1;
    const b = 1;

    textureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();

} );

const computeNode = computeTexture( { storageTexture } ).compute( width * height );
renderer.computeAsync( computeNode );
</code></pre>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#storageTexture">storageTexture(value, uvNode, [storeNode])</a> ⇒ <code><a href="#StorageTextureNode">StorageTextureNode</a></code></dt>
<dd><p>TSL function for creating a storage texture node.</p>
</dd>
<dt><a href="#textureStore">textureStore(value, uvNode, [storeNode])</a> ⇒ <code><a href="#StorageTextureNode">StorageTextureNode</a></code></dt>
<dd><p>TODO: Explain difference to <code>storageTexture()</code>.</p>
</dd>
</dl>

<a name="StorageTextureNode"></a>

## StorageTextureNode ⇐ <code>TextureNode</code>
This special version of a texture node can be used to
write data into a storage texture with a compute shader.

```js
const storageTexture = new THREE.StorageTexture( width, height );

const computeTexture = Fn( ( { storageTexture } ) => {

	const posX = instanceIndex.mod( width );
	const posY = instanceIndex.div( width );
	const indexUV = uvec2( posX, posY );

	// generate RGB values

	const r = 1;
	const g = 1;
	const b = 1;

	textureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();

} );

const computeNode = computeTexture( { storageTexture } ).compute( width * height );
renderer.computeAsync( computeNode );
```

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [StorageTextureNode](#StorageTextureNode) ⇐ <code>TextureNode</code>
    * [new StorageTextureNode(value, uvNode, [storeNode])](#new_StorageTextureNode_new)
    * [.storeNode](#StorageTextureNode+storeNode) : <code>Node</code>
    * [.isStorageTextureNode](#StorageTextureNode+isStorageTextureNode) : <code>boolean</code>
    * [.access](#StorageTextureNode+access) : <code>string</code>
    * [.getInputType(builder)](#StorageTextureNode+getInputType) ⇒ <code>string</code>
    * [.setAccess(value)](#StorageTextureNode+setAccess) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
    * [.generate(builder, output)](#StorageTextureNode+generate) ⇒ <code>string</code>
    * [.toReadWrite()](#StorageTextureNode+toReadWrite) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
    * [.toReadOnly()](#StorageTextureNode+toReadOnly) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
    * [.toWriteOnly()](#StorageTextureNode+toWriteOnly) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
    * [.generateStore(builder)](#StorageTextureNode+generateStore)

<a name="new_StorageTextureNode_new"></a>

### new StorageTextureNode(value, uvNode, [storeNode])
Constructs a new storage texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageTexture</code> |  | The storage texture. |
| uvNode | <code>Node.&lt;(vec2\|vec3)&gt;</code> |  | The uv node. |
| [storeNode] | <code>Node</code> | <code></code> | The value node that should be stored in the texture. |

<a name="StorageTextureNode+storeNode"></a>

### storageTextureNode.storeNode : <code>Node</code>
The value node that should be stored in the texture.

**Kind**: instance property of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Default**: <code>null</code>  
<a name="StorageTextureNode+isStorageTextureNode"></a>

### storageTextureNode.isStorageTextureNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StorageTextureNode+access"></a>

### storageTextureNode.access : <code>string</code>
The access type of the texture node.

**Kind**: instance property of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Default**: <code>&quot;&#x27;writeOnly&#x27;&quot;</code>  
<a name="StorageTextureNode+getInputType"></a>

### storageTextureNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'storageTexture'`.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="StorageTextureNode+setAccess"></a>

### storageTextureNode.setAccess(value) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
Defines the node access.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: [<code>StorageTextureNode</code>](#StorageTextureNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>string</code> | The node access. |

<a name="StorageTextureNode+generate"></a>

### storageTextureNode.generate(builder, output) ⇒ <code>string</code>
Generates the code snippet of the storage node. If no `storeNode`
is defined, the texture node is generated as normal texture.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | The current output. |

<a name="StorageTextureNode+toReadWrite"></a>

### storageTextureNode.toReadWrite() ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
Convenience method for configuring a read/write node access.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: [<code>StorageTextureNode</code>](#StorageTextureNode) - A reference to this node.  
<a name="StorageTextureNode+toReadOnly"></a>

### storageTextureNode.toReadOnly() ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
Convenience method for configuring a read-only node access.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: [<code>StorageTextureNode</code>](#StorageTextureNode) - A reference to this node.  
<a name="StorageTextureNode+toWriteOnly"></a>

### storageTextureNode.toWriteOnly() ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
Convenience method for configuring a write-only node access.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  
**Returns**: [<code>StorageTextureNode</code>](#StorageTextureNode) - A reference to this node.  
<a name="StorageTextureNode+generateStore"></a>

### storageTextureNode.generateStore(builder)
Generates the code snippet of the storage texture node.

**Kind**: instance method of [<code>StorageTextureNode</code>](#StorageTextureNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="storageTexture"></a>

## storageTexture(value, uvNode, [storeNode]) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
TSL function for creating a storage texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageTexture</code> |  | The storage texture. |
| uvNode | <code>Node.&lt;(vec2\|vec3)&gt;</code> |  | The uv node. |
| [storeNode] | <code>Node</code> | <code></code> | The value node that should be stored in the texture. |

<a name="textureStore"></a>

## textureStore(value, uvNode, [storeNode]) ⇒ [<code>StorageTextureNode</code>](#StorageTextureNode)
TODO: Explain difference to `storageTexture()`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>StorageTexture</code> |  | The storage texture. |
| uvNode | <code>Node.&lt;(vec2\|vec3)&gt;</code> |  | The uv node. |
| [storeNode] | <code>Node</code> | <code></code> | The value node that should be stored in the texture. |

## Constants

<dl>
<dt><a href="#tangentGeometry">tangentGeometry</a> : <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the tangent attribute of the current rendered object.</p>
</dd>
<dt><a href="#tangentLocal">tangentLocal</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex tangent in local space of the current rendered object.</p>
</dd>
<dt><a href="#tangentView">tangentView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex tangent in view space of the current rendered object.</p>
</dd>
<dt><a href="#tangentWorld">tangentWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex tangent in world space of the current rendered object.</p>
</dd>
<dt><a href="#transformedTangentView">transformedTangentView</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex tangent in view space of the current rendered object.</p>
</dd>
<dt><a href="#transformedTangentWorld">transformedTangentWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the transformed vertex tangent in world space of the current rendered object.</p>
</dd>
</dl>

<a name="tangentGeometry"></a>

## tangentGeometry : <code>Node.&lt;vec4&gt;</code>
TSL object that represents the tangent attribute of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="tangentLocal"></a>

## tangentLocal : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex tangent in local space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="tangentView"></a>

## tangentView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex tangent in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="tangentWorld"></a>

## tangentWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex tangent in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedTangentView"></a>

## transformedTangentView : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed vertex tangent in view space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
<a name="transformedTangentWorld"></a>

## transformedTangentWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the transformed vertex tangent in world space of the current rendered object.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#Texture3DNode">Texture3DNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>This type of uniform node represents a 3D texture.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#texture3D">texture3D(value, [uvNode], [levelNode])</a> ⇒ <code><a href="#Texture3DNode">Texture3DNode</a></code></dt>
<dd><p>TSL function for creating a 3D texture node.</p>
</dd>
</dl>

<a name="Texture3DNode"></a>

## Texture3DNode ⇐ <code>TextureNode</code>
This type of uniform node represents a 3D texture.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [Texture3DNode](#Texture3DNode) ⇐ <code>TextureNode</code>
    * [new Texture3DNode(value, [uvNode], [levelNode])](#new_Texture3DNode_new)
    * [.isTexture3DNode](#Texture3DNode+isTexture3DNode) : <code>boolean</code>
    * [.getInputType(builder)](#Texture3DNode+getInputType) ⇒ <code>string</code>
    * [.getDefaultUV()](#Texture3DNode+getDefaultUV) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setUpdateMatrix(value)](#Texture3DNode+setUpdateMatrix)
    * [.setupUV(builder, uvNode)](#Texture3DNode+setupUV) ⇒ <code>Node</code>
    * [.generateUV(builder, uvNode)](#Texture3DNode+generateUV) ⇒ <code>string</code>
    * [.normal(uvNode)](#Texture3DNode+normal) ⇒ <code>Node.&lt;vec3&gt;</code>

<a name="new_Texture3DNode_new"></a>

### new Texture3DNode(value, [uvNode], [levelNode])
Constructs a new 3D texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Data3DTexture</code> |  | The 3D texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |

<a name="Texture3DNode+isTexture3DNode"></a>

### texture3DNode.isTexture3DNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Texture3DNode</code>](#Texture3DNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Texture3DNode+getInputType"></a>

### texture3DNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'texture3D'`.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Texture3DNode+getDefaultUV"></a>

### texture3DNode.getDefaultUV() ⇒ <code>Node.&lt;vec3&gt;</code>
Returns a default uv node which is in context of 3D textures a three-dimensional
uv node.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The default uv node.  
<a name="Texture3DNode+setUpdateMatrix"></a>

### texture3DNode.setUpdateMatrix(value)
Overwritten with an empty implementation since the `updateMatrix` flag is ignored
for 3D textures. The uv transformation matrix is not applied to 3D textures.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The update toggle. |

<a name="Texture3DNode+setupUV"></a>

### texture3DNode.setupUV(builder, uvNode) ⇒ <code>Node</code>
Overwrites the default implementation to return the unmodified uv node.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>Node</code> - The unmodified uv node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to setup. |

<a name="Texture3DNode+generateUV"></a>

### texture3DNode.generateUV(builder, uvNode) ⇒ <code>string</code>
Generates the uv code snippet.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to generate code for. |

<a name="Texture3DNode+normal"></a>

### texture3DNode.normal(uvNode) ⇒ <code>Node.&lt;vec3&gt;</code>
TODO.

**Kind**: instance method of [<code>Texture3DNode</code>](#Texture3DNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - TODO.  

| Param | Type | Description |
| --- | --- | --- |
| uvNode | <code>Node.&lt;vec3&gt;</code> | The uv node . |

<a name="texture3D"></a>

## texture3D(value, [uvNode], [levelNode]) ⇒ [<code>Texture3DNode</code>](#Texture3DNode)
TSL function for creating a 3D texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Data3DTexture</code> |  | The 3D texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |

<a name="textureBicubic"></a>

## textureBicubic(textureNode, [lodNode]) ⇒ <code>Node</code>
Applies mipped bicubic texture filtering to the given texture node.

**Kind**: global function  
**Returns**: <code>Node</code> - The filtered texture sample.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that should be filtered. |
| [lodNode] | <code>Node.&lt;float&gt;</code> | <code>float(3)</code> | Defines the LOD to sample from. |

## Classes

<dl>
<dt><a href="#TextureNode">TextureNode</a> ⇐ <code>UniformNode</code></dt>
<dd><p>This type of uniform node represents a 2D texture.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#texture">texture(value, [uvNode], [levelNode], [biasNode])</a> ⇒ <code><a href="#TextureNode">TextureNode</a></code></dt>
<dd><p>TSL function for creating a texture node.</p>
</dd>
<dt><a href="#textureLoad">textureLoad(value, [uvNode], [levelNode], [biasNode])</a> ⇒ <code><a href="#TextureNode">TextureNode</a></code></dt>
<dd><p>TSL function for creating a texture node that fetches/loads texels without interpolation.</p>
</dd>
<dt><a href="#sampler">sampler(value)</a> ⇒ <code>Node</code></dt>
<dd><p>Converts a texture or texture node to a sampler.</p>
</dd>
<dt><a href="#samplerComparison">samplerComparison(value)</a> ⇒ <code>Node</code></dt>
<dd><p>Converts a texture or texture node to a sampler comparison.</p>
</dd>
</dl>

<a name="TextureNode"></a>

## TextureNode ⇐ <code>UniformNode</code>
This type of uniform node represents a 2D texture.

**Kind**: global class  
**Extends**: <code>UniformNode</code>  

* [TextureNode](#TextureNode) ⇐ <code>UniformNode</code>
    * [new TextureNode(value, [uvNode], [levelNode], [biasNode])](#new_TextureNode_new)
    * [.isTextureNode](#TextureNode+isTextureNode) : <code>boolean</code>
    * [.uvNode](#TextureNode+uvNode) : <code>Node.&lt;(vec2\|vec3)&gt;</code>
    * [.levelNode](#TextureNode+levelNode) : <code>Node.&lt;int&gt;</code>
    * [.biasNode](#TextureNode+biasNode) : <code>Node.&lt;float&gt;</code>
    * [.compareNode](#TextureNode+compareNode) : <code>Node.&lt;float&gt;</code>
    * [.depthNode](#TextureNode+depthNode) : <code>Node.&lt;int&gt;</code>
    * [.gradNode](#TextureNode+gradNode) : <code>Array.&lt;Node.&lt;vec2&gt;&gt;</code>
    * [.sampler](#TextureNode+sampler) : <code>boolean</code>
    * [.updateMatrix](#TextureNode+updateMatrix) : <code>boolean</code>
    * [.updateType](#TextureNode+updateType) : <code>string</code>
    * [.referenceNode](#TextureNode+referenceNode) : <code>Node</code>
    * [.value](#TextureNode+value) : <code>Texture</code>
    * [.getUniformHash(builder)](#TextureNode+getUniformHash) ⇒ <code>string</code>
    * [.getNodeType(builder)](#TextureNode+getNodeType) ⇒ <code>string</code>
    * [.getInputType(builder)](#TextureNode+getInputType) ⇒ <code>string</code>
    * [.getDefaultUV()](#TextureNode+getDefaultUV) ⇒ <code>AttributeNode.&lt;vec2&gt;</code>
    * [.updateReference(state)](#TextureNode+updateReference) ⇒ <code>Texture</code>
    * [.getTransformedUV(uvNode)](#TextureNode+getTransformedUV) ⇒ <code>Node</code>
    * [.setUpdateMatrix(value)](#TextureNode+setUpdateMatrix) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.setupUV(builder, uvNode)](#TextureNode+setupUV) ⇒ <code>Node</code>
    * [.setup(builder)](#TextureNode+setup)
    * [.generateUV(builder, uvNode)](#TextureNode+generateUV) ⇒ <code>string</code>
    * [.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet)](#TextureNode+generateSnippet) ⇒ <code>string</code>
    * [.generate(builder, output)](#TextureNode+generate) ⇒ <code>string</code>
    * [.setSampler(value)](#TextureNode+setSampler) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.getSampler()](#TextureNode+getSampler) ⇒ <code>boolean</code>
    * ~~[.uv(uvNode)](#TextureNode+uv) ⇒ [<code>TextureNode</code>](#TextureNode)~~
    * [.sample(uvNode)](#TextureNode+sample) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.blur(amountNode)](#TextureNode+blur) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.level(levelNode)](#TextureNode+level) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.size(levelNode)](#TextureNode+size) ⇒ <code>TextureSizeNode</code>
    * [.bias(biasNode)](#TextureNode+bias) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.compare(compareNode)](#TextureNode+compare) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.grad(gradNodeX, gradNodeY)](#TextureNode+grad) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.depth(depthNode)](#TextureNode+depth) ⇒ [<code>TextureNode</code>](#TextureNode)
    * [.update()](#TextureNode+update)
    * [.clone()](#TextureNode+clone) ⇒ [<code>TextureNode</code>](#TextureNode)

<a name="new_TextureNode_new"></a>

### new TextureNode(value, [uvNode], [levelNode], [biasNode])
Constructs a new texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

<a name="TextureNode+isTextureNode"></a>

### textureNode.isTextureNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TextureNode+uvNode"></a>

### textureNode.uvNode : <code>Node.&lt;(vec2\|vec3)&gt;</code>
Represents the texture coordinates.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+levelNode"></a>

### textureNode.levelNode : <code>Node.&lt;int&gt;</code>
Represents the mip level that should be selected.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+biasNode"></a>

### textureNode.biasNode : <code>Node.&lt;float&gt;</code>
Represents the bias to be applied during level-of-detail computation.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+compareNode"></a>

### textureNode.compareNode : <code>Node.&lt;float&gt;</code>
Represents a reference value a texture sample is compared to.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+depthNode"></a>

### textureNode.depthNode : <code>Node.&lt;int&gt;</code>
When using texture arrays, the depth node defines the layer to select.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+gradNode"></a>

### textureNode.gradNode : <code>Array.&lt;Node.&lt;vec2&gt;&gt;</code>
When defined, a texture is sampled using explicit gradients.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+sampler"></a>

### textureNode.sampler : <code>boolean</code>
Whether texture values should be sampled or fetched.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>true</code>  
<a name="TextureNode+updateMatrix"></a>

### textureNode.updateMatrix : <code>boolean</code>
Whether the uv transformation matrix should be
automatically updated or not. Use `setUpdateMatrix()`
if you want to change the value of the property.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>false</code>  
<a name="TextureNode+updateType"></a>

### textureNode.updateType : <code>string</code>
By default the `update()` method is not executed. `setUpdateMatrix()`
sets the value to `frame` when the uv transformation matrix should
automatically be updated.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>&quot;&#x27;none&#x27;&quot;</code>  
<a name="TextureNode+referenceNode"></a>

### textureNode.referenceNode : <code>Node</code>
The reference node.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
**Default**: <code>null</code>  
<a name="TextureNode+value"></a>

### textureNode.value : <code>Texture</code>
The texture value.

**Kind**: instance property of [<code>TextureNode</code>](#TextureNode)  
<a name="TextureNode+getUniformHash"></a>

### textureNode.getUniformHash(builder) ⇒ <code>string</code>
Overwritten since the uniform hash is defined by the texture's UUID.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The uniform hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TextureNode+getNodeType"></a>

### textureNode.getNodeType(builder) ⇒ <code>string</code>
Overwritten since the node type is inferred from the texture type.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TextureNode+getInputType"></a>

### textureNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return a fixed value `'texture'`.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TextureNode+getDefaultUV"></a>

### textureNode.getDefaultUV() ⇒ <code>AttributeNode.&lt;vec2&gt;</code>
Returns a default uvs based on the current texture's channel.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>AttributeNode.&lt;vec2&gt;</code> - The default uvs.  
<a name="TextureNode+updateReference"></a>

### textureNode.updateReference(state) ⇒ <code>Texture</code>
Overwritten to always return the texture reference of the node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>Texture</code> - The texture reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>any</code> | This method can be invocated in different contexts so `state` can refer to any object type. |

<a name="TextureNode+getTransformedUV"></a>

### textureNode.getTransformedUV(uvNode) ⇒ <code>Node</code>
Transforms the given uv node with the texture transformation matrix.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>Node</code> - The transformed uv node.  

| Param | Type | Description |
| --- | --- | --- |
| uvNode | <code>Node</code> | The uv node to transform. |

<a name="TextureNode+setUpdateMatrix"></a>

### textureNode.setUpdateMatrix(value) ⇒ [<code>TextureNode</code>](#TextureNode)
Defines whether the uv transformation matrix should automatically be updated or not.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The update toggle. |

<a name="TextureNode+setupUV"></a>

### textureNode.setupUV(builder, uvNode) ⇒ <code>Node</code>
Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
to modify the uv node for correct sampling.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>Node</code> - The updated uv node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to setup. |

<a name="TextureNode+setup"></a>

### textureNode.setup(builder)
Setups texture node by preparing the internal nodes for code generation.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TextureNode+generateUV"></a>

### textureNode.generateUV(builder, uvNode) ⇒ <code>string</code>
Generates the uv code snippet.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| uvNode | <code>Node</code> | The uv node to generate code for. |

<a name="TextureNode+generateSnippet"></a>

### textureNode.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet) ⇒ <code>string</code>
Generates the snippet for the texture sampling.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| textureProperty | <code>string</code> | The texture property. |
| uvSnippet | <code>string</code> | The uv snippet. |
| levelSnippet | <code>string</code> | The level snippet. |
| biasSnippet | <code>string</code> | The bias snippet. |
| depthSnippet | <code>string</code> | The depth snippet. |
| compareSnippet | <code>string</code> | The compare snippet. |
| gradSnippet | <code>Array.&lt;string&gt;</code> | The grad snippet. |

<a name="TextureNode+generate"></a>

### textureNode.generate(builder, output) ⇒ <code>string</code>
Generates the code snippet of the texture node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>string</code> - The generated code snippet.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | The current output. |

<a name="TextureNode+setSampler"></a>

### textureNode.setSampler(value) ⇒ [<code>TextureNode</code>](#TextureNode)
Sets the sampler value.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A reference to this texture node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | The sampler value to set. |

<a name="TextureNode+getSampler"></a>

### textureNode.getSampler() ⇒ <code>boolean</code>
Returns the sampler value.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>boolean</code> - The sampler value.  
<a name="TextureNode+uv"></a>

### ~~textureNode.uv(uvNode) ⇒ [<code>TextureNode</code>](#TextureNode)~~
***since r172. Use [sample](#TextureNode+sample) instead.***

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| uvNode | <code>Node</code> | The uv node. |

<a name="TextureNode+sample"></a>

### textureNode.sample(uvNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture with the given uv node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| uvNode | <code>Node</code> | The uv node. |

<a name="TextureNode+blur"></a>

### textureNode.blur(amountNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples a blurred version of the texture by defining an internal bias.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| amountNode | <code>Node.&lt;float&gt;</code> | How blurred the texture should be. |

<a name="TextureNode+level"></a>

### textureNode.level(levelNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples a specific mip of the texture.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| levelNode | <code>Node.&lt;int&gt;</code> | The mip level to sample. |

<a name="TextureNode+size"></a>

### textureNode.size(levelNode) ⇒ <code>TextureSizeNode</code>
Returns the texture size of the requested level.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: <code>TextureSizeNode</code> - The texture size.  

| Param | Type | Description |
| --- | --- | --- |
| levelNode | <code>Node.&lt;int&gt;</code> | The level to compute the size for. |

<a name="TextureNode+bias"></a>

### textureNode.bias(biasNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture with the given bias.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| biasNode | <code>Node.&lt;float&gt;</code> | The bias node. |

<a name="TextureNode+compare"></a>

### textureNode.compare(compareNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture by executing a compare operation.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| compareNode | <code>Node.&lt;float&gt;</code> | The node that defines the compare value. |

<a name="TextureNode+grad"></a>

### textureNode.grad(gradNodeX, gradNodeY) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture using an explicit gradient.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| gradNodeX | <code>Node.&lt;vec2&gt;</code> | The gradX node. |
| gradNodeY | <code>Node.&lt;vec2&gt;</code> | The gradY node. |

<a name="TextureNode+depth"></a>

### textureNode.depth(depthNode) ⇒ [<code>TextureNode</code>](#TextureNode)
Samples the texture by defining a depth node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - A texture node representing the texture sample.  

| Param | Type | Description |
| --- | --- | --- |
| depthNode | <code>Node.&lt;int&gt;</code> | The depth node. |

<a name="TextureNode+update"></a>

### textureNode.update()
The update is used to implement the update of the uv transformation matrix.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
<a name="TextureNode+clone"></a>

### textureNode.clone() ⇒ [<code>TextureNode</code>](#TextureNode)
Clones the texture node.

**Kind**: instance method of [<code>TextureNode</code>](#TextureNode)  
**Returns**: [<code>TextureNode</code>](#TextureNode) - The cloned texture node.  
<a name="texture"></a>

## texture(value, [uvNode], [levelNode], [biasNode]) ⇒ [<code>TextureNode</code>](#TextureNode)
TSL function for creating a texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

<a name="textureLoad"></a>

## textureLoad(value, [uvNode], [levelNode], [biasNode]) ⇒ [<code>TextureNode</code>](#TextureNode)
TSL function for creating a texture node that fetches/loads texels without interpolation.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Texture</code> |  | The texture. |
| [uvNode] | <code>Node.&lt;(vec2\|vec3)&gt;</code> | <code></code> | The uv node. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | The level node. |
| [biasNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The bias node. |

<a name="sampler"></a>

## sampler(value) ⇒ <code>Node</code>
Converts a texture or texture node to a sampler.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | [<code>TextureNode</code>](#TextureNode) \| <code>Texture</code> | The texture or texture node to convert. |

<a name="samplerComparison"></a>

## samplerComparison(value) ⇒ <code>Node</code>
Converts a texture or texture node to a sampler comparison.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | [<code>TextureNode</code>](#TextureNode) \| <code>Texture</code> | The texture or texture node to convert. |

## Classes

<dl>
<dt><a href="#TextureSizeNode">TextureSizeNode</a> ⇐ <code>Node</code></dt>
<dd><p>A node that represents the dimensions of a texture. The texture size is
retrieved in the shader via built-in shader functions like <code>textureDimensions()</code>
or <code>textureSize()</code>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#textureSize">textureSize(textureNode, [levelNode])</a> ⇒ <code><a href="#TextureSizeNode">TextureSizeNode</a></code></dt>
<dd><p>TSL function for creating a texture size node.</p>
</dd>
</dl>

<a name="TextureSizeNode"></a>

## TextureSizeNode ⇐ <code>Node</code>
A node that represents the dimensions of a texture. The texture size is
retrieved in the shader via built-in shader functions like `textureDimensions()`
or `textureSize()`.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [TextureSizeNode](#TextureSizeNode) ⇐ <code>Node</code>
    * [new TextureSizeNode(textureNode, [levelNode])](#new_TextureSizeNode_new)
    * [.isTextureSizeNode](#TextureSizeNode+isTextureSizeNode) : <code>boolean</code>
    * [.textureNode](#TextureSizeNode+textureNode) : <code>TextureNode</code>
    * [.levelNode](#TextureSizeNode+levelNode) : <code>Node.&lt;int&gt;</code>

<a name="new_TextureSizeNode_new"></a>

### new TextureSizeNode(textureNode, [levelNode])
Constructs a new texture size node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | A texture node which size should be retrieved. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | A level node which defines the requested mip. |

<a name="TextureSizeNode+isTextureSizeNode"></a>

### textureSizeNode.isTextureSizeNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>TextureSizeNode</code>](#TextureSizeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TextureSizeNode+textureNode"></a>

### textureSizeNode.textureNode : <code>TextureNode</code>
A texture node which size should be retrieved.

**Kind**: instance property of [<code>TextureSizeNode</code>](#TextureSizeNode)  
<a name="TextureSizeNode+levelNode"></a>

### textureSizeNode.levelNode : <code>Node.&lt;int&gt;</code>
A level node which defines the requested mip.

**Kind**: instance property of [<code>TextureSizeNode</code>](#TextureSizeNode)  
**Default**: <code>null</code>  
<a name="textureSize"></a>

## textureSize(textureNode, [levelNode]) ⇒ [<code>TextureSizeNode</code>](#TextureSizeNode)
TSL function for creating a texture size node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | A texture node which size should be retrieved. |
| [levelNode] | <code>Node.&lt;int&gt;</code> | <code></code> | A level node which defines the requested mip. |

<a name="uv"></a>

## uv([index]) ⇒ <code>AttributeNode.&lt;vec2&gt;</code>
TSL function for creating an uv attribute node with the given index.

**Kind**: global function  
**Returns**: <code>AttributeNode.&lt;vec2&gt;</code> - The uv attribute node.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [index] | <code>number</code> | <code>0</code> | The uv index. |

## Classes

<dl>
<dt><a href="#UniformArrayElementNode">UniformArrayElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>Represents the element access on uniform array nodes.</p>
</dd>
<dt><a href="#UniformArrayNode">UniformArrayNode</a> ⇐ <code>BufferNode</code></dt>
<dd><p>Similar to <a href="BufferNode">BufferNode</a> this module represents array-like data as
uniform buffers. Unlike <a href="BufferNode">BufferNode</a>, it can handle more common
data types in the array (e.g <code>three.js</code> primitives) and automatically
manage buffer padding. It should be the first choice when working with
uniforms buffers.</p>
<pre><code class="language-js">const tintColors = uniformArray( [
    new Color( 1, 0, 0 ),
    new Color( 0, 1, 0 ),
    new Color( 0, 0, 1 )
], &#39;color&#39; );

const redColor = tintColors.element( 0 );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#uniformArray">uniformArray(values, [nodeType])</a> ⇒ <code><a href="#UniformArrayNode">UniformArrayNode</a></code></dt>
<dd><p>TSL function for creating an uniform array node.</p>
</dd>
<dt><del><a href="#uniforms">uniforms(values, nodeType)</a> ⇒ <code><a href="#UniformArrayNode">UniformArrayNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="UniformArrayElementNode"></a>

## UniformArrayElementNode ⇐ <code>ArrayElementNode</code>
Represents the element access on uniform array nodes.

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [UniformArrayElementNode](#UniformArrayElementNode) ⇐ <code>ArrayElementNode</code>
    * [new UniformArrayElementNode(uniformArrayNode, indexNode)](#new_UniformArrayElementNode_new)
    * [.isArrayBufferElementNode](#UniformArrayElementNode+isArrayBufferElementNode) : <code>boolean</code>

<a name="new_UniformArrayElementNode_new"></a>

### new UniformArrayElementNode(uniformArrayNode, indexNode)
Constructs a new buffer node.


| Param | Type | Description |
| --- | --- | --- |
| uniformArrayNode | [<code>UniformArrayNode</code>](#UniformArrayNode) | The uniform array node to access. |
| indexNode | <code>IndexNode</code> | The index data that define the position of the accessed element in the array. |

<a name="UniformArrayElementNode+isArrayBufferElementNode"></a>

### uniformArrayElementNode.isArrayBufferElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>UniformArrayElementNode</code>](#UniformArrayElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="UniformArrayNode"></a>

## UniformArrayNode ⇐ <code>BufferNode</code>
Similar to [BufferNode](BufferNode) this module represents array-like data as
uniform buffers. Unlike [BufferNode](BufferNode), it can handle more common
data types in the array (e.g `three.js` primitives) and automatically
manage buffer padding. It should be the first choice when working with
uniforms buffers.
```js
const tintColors = uniformArray( [
	new Color( 1, 0, 0 ),
	new Color( 0, 1, 0 ),
	new Color( 0, 0, 1 )
], 'color' );

const redColor = tintColors.element( 0 );

**Kind**: global class  
**Extends**: <code>BufferNode</code>  

* [UniformArrayNode](#UniformArrayNode) ⇐ <code>BufferNode</code>
    * [new UniformArrayNode(value, [elementType])](#new_UniformArrayNode_new)
    * [.array](#UniformArrayNode+array) : <code>Array.&lt;any&gt;</code>
    * [.elementType](#UniformArrayNode+elementType) : <code>string</code>
    * [.paddedType](#UniformArrayNode+paddedType) : <code>string</code>
    * [.updateType](#UniformArrayNode+updateType) : <code>string</code>
    * [.isArrayBufferNode](#UniformArrayNode+isArrayBufferNode) : <code>boolean</code>
    * [.getNodeType(builder)](#UniformArrayNode+getNodeType) ⇒ <code>string</code>
    * [.getElementType(builder)](#UniformArrayNode+getElementType) ⇒ <code>string</code>
    * [.getPaddedType()](#UniformArrayNode+getPaddedType) ⇒ <code>string</code>
    * [.update(frame)](#UniformArrayNode+update)
    * [.setup(builder)](#UniformArrayNode+setup) ⇒ <code>null</code>
    * [.element(indexNode)](#UniformArrayNode+element) ⇒ [<code>UniformArrayElementNode</code>](#UniformArrayElementNode)

<a name="new_UniformArrayNode_new"></a>

### new UniformArrayNode(value, [elementType])
Constructs a new uniform array node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Array.&lt;any&gt;</code> |  | Array holding the buffer data. |
| [elementType] | <code>string</code> | <code>null</code> | The data type of a buffer element. |

<a name="UniformArrayNode+array"></a>

### uniformArrayNode.array : <code>Array.&lt;any&gt;</code>
Array holding the buffer data. Unlike [BufferNode](BufferNode), the array can
hold number primitives as well as three.js objects like vectors, matrices
or colors.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
<a name="UniformArrayNode+elementType"></a>

### uniformArrayNode.elementType : <code>string</code>
The data type of an array element.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
<a name="UniformArrayNode+paddedType"></a>

### uniformArrayNode.paddedType : <code>string</code>
The padded type. Uniform buffers must conform to a certain buffer layout
so a separate type is computed to ensure correct buffer size.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
<a name="UniformArrayNode+updateType"></a>

### uniformArrayNode.updateType : <code>string</code>
Overwritten since uniform array nodes are updated per render.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="UniformArrayNode+isArrayBufferNode"></a>

### uniformArrayNode.isArrayBufferNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="UniformArrayNode+getNodeType"></a>

### uniformArrayNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the
[paddedType](#UniformArrayNode+paddedType).

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="UniformArrayNode+getElementType"></a>

### uniformArrayNode.getElementType(builder) ⇒ <code>string</code>
The data type of the array elements.

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Returns**: <code>string</code> - The element type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="UniformArrayNode+getPaddedType"></a>

### uniformArrayNode.getPaddedType() ⇒ <code>string</code>
Returns the padded type based on the element type.

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  
**Returns**: <code>string</code> - The padded type.  
<a name="UniformArrayNode+update"></a>

### uniformArrayNode.update(frame)
The update makes sure to correctly transfer the data from the (complex) objects
in the array to the internal, correctly padded value buffer.

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="UniformArrayNode+setup"></a>

### uniformArrayNode.setup(builder) ⇒ <code>null</code>
Implement the value buffer creation based on the array data.

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="UniformArrayNode+element"></a>

### uniformArrayNode.element(indexNode) ⇒ [<code>UniformArrayElementNode</code>](#UniformArrayElementNode)
Overwrites the default `element()` method to provide element access
based on [UniformArrayNode](#UniformArrayNode).

**Kind**: instance method of [<code>UniformArrayNode</code>](#UniformArrayNode)  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | The index node. |

<a name="uniformArray"></a>

## uniformArray(values, [nodeType]) ⇒ [<code>UniformArrayNode</code>](#UniformArrayNode)
TSL function for creating an uniform array node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| values | <code>Array.&lt;any&gt;</code> | Array-like data. |
| [nodeType] | <code>string</code> | The data type of the array elements. |

<a name="uniforms"></a>

## ~~uniforms(values, nodeType) ⇒ [<code>UniformArrayNode</code>](#UniformArrayNode)~~
***since r168. Use [uniformArray](#uniformArray) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| values | <code>Array.&lt;any&gt;</code> | Array-like data. |
| nodeType | <code>string</code> | The data type of the array elements. |

## Classes

<dl>
<dt><a href="#UserDataNode">UserDataNode</a> ⇐ <code>ReferenceNode</code></dt>
<dd><p>A special type of reference node that allows to link values in
<code>userData</code> fields to node objects.</p>
<pre><code class="language-js">sprite.userData.rotation = 1; // stores individual rotation per sprite

const material = new THREE.SpriteNodeMaterial();
material.rotationNode = userData( &#39;rotation&#39;, &#39;float&#39; );
</code></pre>
<p>Since <code>UserDataNode</code> is extended from <a href="ReferenceNode">ReferenceNode</a>, the node value
will automatically be updated when the <code>rotation</code> user data field changes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#userData">userData(name, inputType, userData)</a> ⇒ <code><a href="#UserDataNode">UserDataNode</a></code></dt>
<dd><p>TSL function for creating a user data node.</p>
</dd>
</dl>

<a name="UserDataNode"></a>

## UserDataNode ⇐ <code>ReferenceNode</code>
A special type of reference node that allows to link values in
`userData` fields to node objects.
```js
sprite.userData.rotation = 1; // stores individual rotation per sprite

const material = new THREE.SpriteNodeMaterial();
material.rotationNode = userData( 'rotation', 'float' );
```
Since `UserDataNode` is extended from [ReferenceNode](ReferenceNode), the node value
will automatically be updated when the `rotation` user data field changes.

**Kind**: global class  
**Extends**: <code>ReferenceNode</code>  

* [UserDataNode](#UserDataNode) ⇐ <code>ReferenceNode</code>
    * [new UserDataNode(property, inputType, [userData])](#new_UserDataNode_new)
    * [.userData](#UserDataNode+userData) : <code>Object</code>
    * [.updateReference(state)](#UserDataNode+updateReference) ⇒ <code>Object</code>

<a name="new_UserDataNode_new"></a>

### new UserDataNode(property, inputType, [userData])
Constructs a new user data node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| property | <code>string</code> |  | The property name that should be referenced by the node. |
| inputType | <code>string</code> |  | The node data type of the reference. |
| [userData] | <code>Object</code> | <code></code> | A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated. |

<a name="UserDataNode+userData"></a>

### userDataNode.userData : <code>Object</code>
A reference to the `userData` object. If not provided, the `userData`
property of the 3D object that uses the node material is evaluated.

**Kind**: instance property of [<code>UserDataNode</code>](#UserDataNode)  
**Default**: <code>null</code>  
<a name="UserDataNode+updateReference"></a>

### userDataNode.updateReference(state) ⇒ <code>Object</code>
Overwritten to make sure [ReferenceNode#reference](ReferenceNode#reference) points to the correct
`userData` field.

**Kind**: instance method of [<code>UserDataNode</code>](#UserDataNode)  
**Returns**: <code>Object</code> - A reference to the `userData` field.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>NodeFrame</code> \| <code>NodeBuilder</code> | The current state to evaluate. |

<a name="userData"></a>

## userData(name, inputType, userData) ⇒ [<code>UserDataNode</code>](#UserDataNode)
TSL function for creating a user data node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The property name that should be referenced by the node. |
| inputType | <code>string</code> | The node data type of the reference. |
| userData | <code>Object</code> | A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated. |

## Classes

<dl>
<dt><a href="#VelocityNode">VelocityNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>A node for representing motion or velocity vectors. Foundation
for advanced post processing effects like motion blur or TRAA.</p>
<p>The node keeps track of the model, view and projection matrices
of the previous frame and uses them to compute offsets in NDC space.
These offsets represent the final velocity.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#velocity">velocity</a> : <code><a href="#VelocityNode">VelocityNode</a></code></dt>
<dd><p>TSL object that represents the velocity of a render pass.</p>
</dd>
</dl>

<a name="VelocityNode"></a>

## VelocityNode ⇐ <code>TempNode</code>
A node for representing motion or velocity vectors. Foundation
for advanced post processing effects like motion blur or TRAA.

The node keeps track of the model, view and projection matrices
of the previous frame and uses them to compute offsets in NDC space.
These offsets represent the final velocity.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [VelocityNode](#VelocityNode) ⇐ <code>TempNode</code>
    * [new VelocityNode()](#new_VelocityNode_new)
    * [.projectionMatrix](#VelocityNode+projectionMatrix) : <code>Matrix4</code>
    * [.updateType](#VelocityNode+updateType) : <code>string</code>
    * [.updateAfterType](#VelocityNode+updateAfterType) : <code>string</code>
    * [.previousModelWorldMatrix](#VelocityNode+previousModelWorldMatrix) : <code>UniformNode.&lt;mat4&gt;</code>
    * [.previousProjectionMatrix](#VelocityNode+previousProjectionMatrix) : <code>UniformNode.&lt;mat4&gt;</code>
    * [.previousCameraViewMatrix](#VelocityNode+previousCameraViewMatrix) : <code>UniformNode.&lt;mat4&gt;</code>
    * [.setProjectionMatrix(projectionMatrix)](#VelocityNode+setProjectionMatrix)
    * [.update(frame)](#VelocityNode+update)
    * [.updateAfter(frame)](#VelocityNode+updateAfter)
    * [.setup(builder)](#VelocityNode+setup) ⇒ <code>Node.&lt;vec2&gt;</code>

<a name="new_VelocityNode_new"></a>

### new VelocityNode()
Constructs a new vertex color node.

<a name="VelocityNode+projectionMatrix"></a>

### velocityNode.projectionMatrix : <code>Matrix4</code>
The current projection matrix.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>null</code>  
<a name="VelocityNode+updateType"></a>

### velocityNode.updateType : <code>string</code>
Overwritten since velocity nodes are updated per object.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="VelocityNode+updateAfterType"></a>

### velocityNode.updateAfterType : <code>string</code>
Overwritten since velocity nodes save data after the update.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="VelocityNode+previousModelWorldMatrix"></a>

### velocityNode.previousModelWorldMatrix : <code>UniformNode.&lt;mat4&gt;</code>
Uniform node representing the previous model matrix in world space.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>null</code>  
<a name="VelocityNode+previousProjectionMatrix"></a>

### velocityNode.previousProjectionMatrix : <code>UniformNode.&lt;mat4&gt;</code>
Uniform node representing the previous projection matrix.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>null</code>  
<a name="VelocityNode+previousCameraViewMatrix"></a>

### velocityNode.previousCameraViewMatrix : <code>UniformNode.&lt;mat4&gt;</code>
Uniform node representing the previous view matrix.

**Kind**: instance property of [<code>VelocityNode</code>](#VelocityNode)  
**Default**: <code>null</code>  
<a name="VelocityNode+setProjectionMatrix"></a>

### velocityNode.setProjectionMatrix(projectionMatrix)
Sets the given projection matrix.

**Kind**: instance method of [<code>VelocityNode</code>](#VelocityNode)  

| Param | Type | Description |
| --- | --- | --- |
| projectionMatrix | <code>Matrix4</code> | The projection matrix to set. |

<a name="VelocityNode+update"></a>

### velocityNode.update(frame)
Updates velocity specific uniforms.

**Kind**: instance method of [<code>VelocityNode</code>](#VelocityNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="VelocityNode+updateAfter"></a>

### velocityNode.updateAfter(frame)
Overwritten to updated velocity specific uniforms.

**Kind**: instance method of [<code>VelocityNode</code>](#VelocityNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="VelocityNode+setup"></a>

### velocityNode.setup(builder) ⇒ <code>Node.&lt;vec2&gt;</code>
Implements the velocity computation based on the previous and current vertex data.

**Kind**: instance method of [<code>VelocityNode</code>](#VelocityNode)  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The motion vector.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="velocity"></a>

## velocity : [<code>VelocityNode</code>](#VelocityNode)
TSL object that represents the velocity of a render pass.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#VertexColorNode">VertexColorNode</a> ⇐ <code>AttributeNode</code></dt>
<dd><p>An attribute node for representing vertex colors.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#vertexColor">vertexColor(index)</a> ⇒ <code><a href="#VertexColorNode">VertexColorNode</a></code></dt>
<dd><p>TSL function for creating a reference node.</p>
</dd>
</dl>

<a name="VertexColorNode"></a>

## VertexColorNode ⇐ <code>AttributeNode</code>
An attribute node for representing vertex colors.

**Kind**: global class  
**Extends**: <code>AttributeNode</code>  

* [VertexColorNode](#VertexColorNode) ⇐ <code>AttributeNode</code>
    * [new VertexColorNode([index])](#new_VertexColorNode_new)
    * [.isVertexColorNode](#VertexColorNode+isVertexColorNode) : <code>boolean</code>
    * [.index](#VertexColorNode+index) : <code>number</code>
    * [.getAttributeName(builder)](#VertexColorNode+getAttributeName) ⇒ <code>string</code>

<a name="new_VertexColorNode_new"></a>

### new VertexColorNode([index])
Constructs a new vertex color node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [index] | <code>number</code> | <code>0</code> | The attribute index. |

<a name="VertexColorNode+isVertexColorNode"></a>

### vertexColorNode.isVertexColorNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VertexColorNode</code>](#VertexColorNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VertexColorNode+index"></a>

### vertexColorNode.index : <code>number</code>
The attribute index to enable more than one sets of vertex colors.

**Kind**: instance property of [<code>VertexColorNode</code>](#VertexColorNode)  
**Default**: <code>0</code>  
<a name="VertexColorNode+getAttributeName"></a>

### vertexColorNode.getAttributeName(builder) ⇒ <code>string</code>
Overwrites the default implementation by honoring the attribute index.

**Kind**: instance method of [<code>VertexColorNode</code>](#VertexColorNode)  
**Returns**: <code>string</code> - The attribute name.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="vertexColor"></a>

## vertexColor(index) ⇒ [<code>VertexColorNode</code>](#VertexColorNode)
TSL function for creating a reference node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| index | <code>number</code> | The attribute index. |

## Classes

<dl>
<dt><a href="#CodeNode">CodeNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class represents native code sections. It is the base
class for modules like <a href="FunctionNode">FunctionNode</a> which allows to implement
functions with native shader languages.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#code">code([code], [includes], [language])</a> ⇒ <code><a href="#CodeNode">CodeNode</a></code></dt>
<dd><p>TSL function for creating a code node.</p>
</dd>
<dt><a href="#js">js(src, includes)</a> ⇒ <code><a href="#CodeNode">CodeNode</a></code></dt>
<dd><p>TSL function for creating a JS code node.</p>
</dd>
<dt><a href="#wgsl">wgsl(src, includes)</a> ⇒ <code><a href="#CodeNode">CodeNode</a></code></dt>
<dd><p>TSL function for creating a WGSL code node.</p>
</dd>
<dt><a href="#glsl">glsl(src, includes)</a> ⇒ <code><a href="#CodeNode">CodeNode</a></code></dt>
<dd><p>TSL function for creating a GLSL code node.</p>
</dd>
</dl>

<a name="CodeNode"></a>

## CodeNode ⇐ <code>Node</code>
This class represents native code sections. It is the base
class for modules like [FunctionNode](FunctionNode) which allows to implement
functions with native shader languages.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [CodeNode](#CodeNode) ⇐ <code>Node</code>
    * [new CodeNode([code], [includes], [language])](#new_CodeNode_new)
    * [.isCodeNode](#CodeNode+isCodeNode) : <code>boolean</code>
    * [.code](#CodeNode+code) : <code>string</code>
    * [.includes](#CodeNode+includes) : <code>Array.&lt;Node&gt;</code>
    * [.language](#CodeNode+language) : <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code>
    * [.isGlobal()](#CodeNode+isGlobal) ⇒ <code>boolean</code>
    * [.setIncludes(includes)](#CodeNode+setIncludes) ⇒ [<code>CodeNode</code>](#CodeNode)
    * [.getIncludes(builder)](#CodeNode+getIncludes) ⇒ <code>Array.&lt;Node&gt;</code>

<a name="new_CodeNode_new"></a>

### new CodeNode([code], [includes], [language])
Constructs a new code node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [code] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The native code. |
| [includes] | <code>Array.&lt;Node&gt;</code> | <code>[]</code> | An array of includes. |
| [language] | <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code> | <code>&#x27;&#x27;</code> | The used language. |

<a name="CodeNode+isCodeNode"></a>

### codeNode.isCodeNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CodeNode</code>](#CodeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CodeNode+code"></a>

### codeNode.code : <code>string</code>
The native code.

**Kind**: instance property of [<code>CodeNode</code>](#CodeNode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="CodeNode+includes"></a>

### codeNode.includes : <code>Array.&lt;Node&gt;</code>
An array of includes

**Kind**: instance property of [<code>CodeNode</code>](#CodeNode)  
**Default**: <code>[]</code>  
<a name="CodeNode+language"></a>

### codeNode.language : <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code>
The used language.

**Kind**: instance property of [<code>CodeNode</code>](#CodeNode)  
**Default**: <code>&#x27;&#x27;</code>  
<a name="CodeNode+isGlobal"></a>

### codeNode.isGlobal() ⇒ <code>boolean</code>
The method is overwritten so it always returns `true`.

**Kind**: instance method of [<code>CodeNode</code>](#CodeNode)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  
<a name="CodeNode+setIncludes"></a>

### codeNode.setIncludes(includes) ⇒ [<code>CodeNode</code>](#CodeNode)
Sets the includes of this code node.

**Kind**: instance method of [<code>CodeNode</code>](#CodeNode)  
**Returns**: [<code>CodeNode</code>](#CodeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| includes | <code>Array.&lt;Node&gt;</code> | The includes to set. |

<a name="CodeNode+getIncludes"></a>

### codeNode.getIncludes(builder) ⇒ <code>Array.&lt;Node&gt;</code>
Returns the includes of this code node.

**Kind**: instance method of [<code>CodeNode</code>](#CodeNode)  
**Returns**: <code>Array.&lt;Node&gt;</code> - The includes.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="code"></a>

## code([code], [includes], [language]) ⇒ [<code>CodeNode</code>](#CodeNode)
TSL function for creating a code node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [code] | <code>string</code> |  | The native code. |
| [includes] | <code>Array.&lt;Node&gt;</code> | <code>[]</code> | An array of includes. |
| [language] | <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code> | <code>&#x27;&#x27;</code> | The used language. |

<a name="js"></a>

## js(src, includes) ⇒ [<code>CodeNode</code>](#CodeNode)
TSL function for creating a JS code node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| src | <code>string</code> | The native code. |
| includes | <code>Array.&lt;Node&gt;</code> | An array of includes. |

<a name="wgsl"></a>

## wgsl(src, includes) ⇒ [<code>CodeNode</code>](#CodeNode)
TSL function for creating a WGSL code node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| src | <code>string</code> | The native code. |
| includes | <code>Array.&lt;Node&gt;</code> | An array of includes. |

<a name="glsl"></a>

## glsl(src, includes) ⇒ [<code>CodeNode</code>](#CodeNode)
TSL function for creating a GLSL code node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| src | <code>string</code> | The native code. |
| includes | <code>Array.&lt;Node&gt;</code> | An array of includes. |

## Classes

<dl>
<dt><a href="#ExpressionNode">ExpressionNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class can be used to implement basic expressions in shader code.
Basic examples for that are <code>return</code>, <code>continue</code> or <code>discard</code> statements.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#expression">expression([snippet], [nodeType])</a> ⇒ <code><a href="#ExpressionNode">ExpressionNode</a></code></dt>
<dd><p>TSL function for creating an expression node.</p>
</dd>
</dl>

<a name="ExpressionNode"></a>

## ExpressionNode ⇐ <code>Node</code>
This class can be used to implement basic expressions in shader code.
Basic examples for that are `return`, `continue` or `discard` statements.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ExpressionNode](#ExpressionNode) ⇐ <code>Node</code>
    * [new ExpressionNode([snippet], [nodeType])](#new_ExpressionNode_new)
    * [.snippet](#ExpressionNode+snippet) : <code>string</code>

<a name="new_ExpressionNode_new"></a>

### new ExpressionNode([snippet], [nodeType])
Constructs a new expression node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [snippet] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The native code snippet. |
| [nodeType] | <code>string</code> | <code>&quot;&#x27;void&#x27;&quot;</code> | The node type. |

<a name="ExpressionNode+snippet"></a>

### expressionNode.snippet : <code>string</code>
The native code snippet.

**Kind**: instance property of [<code>ExpressionNode</code>](#ExpressionNode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="expression"></a>

## expression([snippet], [nodeType]) ⇒ [<code>ExpressionNode</code>](#ExpressionNode)
TSL function for creating an expression node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [snippet] | <code>string</code> |  | The native code snippet. |
| [nodeType] | <code>string</code> | <code>&quot;&#x27;void&#x27;&quot;</code> | The node type. |

<a name="FunctionCallNode"></a>

## FunctionCallNode ⇐ <code>TempNode</code>
This module represents the call of a [FunctionNode](FunctionNode). Developers are usually not confronted
with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate
this logic.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [FunctionCallNode](#FunctionCallNode) ⇐ <code>TempNode</code>
    * [new FunctionCallNode(functionNode, [parameters])](#new_FunctionCallNode_new)
    * [.functionNode](#FunctionCallNode+functionNode) : <code>FunctionNode</code>
    * [.parameters](#FunctionCallNode+parameters) : <code>Object.&lt;string, Node&gt;</code>
    * [.setParameters(parameters)](#FunctionCallNode+setParameters) ⇒ [<code>FunctionCallNode</code>](#FunctionCallNode)
    * [.getParameters()](#FunctionCallNode+getParameters) ⇒ <code>Object.&lt;string, Node&gt;</code>

<a name="new_FunctionCallNode_new"></a>

### new FunctionCallNode(functionNode, [parameters])
Constructs a new function call node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| functionNode | <code>FunctionNode</code> | <code></code> | The function node. |
| [parameters] | <code>Object.&lt;string, Node&gt;</code> | <code>{}</code> | The parameters for the function call. |

<a name="FunctionCallNode+functionNode"></a>

### functionCallNode.functionNode : <code>FunctionNode</code>
The function node.

**Kind**: instance property of [<code>FunctionCallNode</code>](#FunctionCallNode)  
**Default**: <code>null</code>  
<a name="FunctionCallNode+parameters"></a>

### functionCallNode.parameters : <code>Object.&lt;string, Node&gt;</code>
The parameters of the function call.

**Kind**: instance property of [<code>FunctionCallNode</code>](#FunctionCallNode)  
**Default**: <code>{}</code>  
<a name="FunctionCallNode+setParameters"></a>

### functionCallNode.setParameters(parameters) ⇒ [<code>FunctionCallNode</code>](#FunctionCallNode)
Sets the parameters of the function call node.

**Kind**: instance method of [<code>FunctionCallNode</code>](#FunctionCallNode)  
**Returns**: [<code>FunctionCallNode</code>](#FunctionCallNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| parameters | <code>Object.&lt;string, Node&gt;</code> | The parameters to set. |

<a name="FunctionCallNode+getParameters"></a>

### functionCallNode.getParameters() ⇒ <code>Object.&lt;string, Node&gt;</code>
Returns the parameters of the function call node.

**Kind**: instance method of [<code>FunctionCallNode</code>](#FunctionCallNode)  
**Returns**: <code>Object.&lt;string, Node&gt;</code> - The parameters of this node.  
<a name="FunctionNode"></a>

## FunctionNode ⇐ <code>CodeNode</code>
This class represents a native shader function. It can be used to implement
certain aspects of a node material with native shader code. There are two predefined
TSL functions for easier usage.

- `wgslFn`: Creates a WGSL function node.
- `glslFn`: Creates a GLSL function node.

A basic example with one include looks like so:

```js
const desaturateWGSLFn = wgslFn( `
	fn desaturate( color:vec3<f32> ) -> vec3<f32> {
		let lum = vec3<f32>( 0.299, 0.587, 0.114 );
		return vec3<f32>( dot( lum, color ) );
	}`
);
const someWGSLFn = wgslFn( `
	fn someFn( color:vec3<f32> ) -> vec3<f32> {
		return desaturate( color );
	}
`, [ desaturateWGSLFn ] );
material.colorNode = someWGSLFn( { color: texture( map ) } );
```

**Kind**: global class  
**Extends**: <code>CodeNode</code>  

* [FunctionNode](#FunctionNode) ⇐ <code>CodeNode</code>
    * [new FunctionNode([code], [includes], [language])](#new_FunctionNode_new)
    * [.getInputs(builder)](#FunctionNode+getInputs) ⇒ <code>Array.&lt;NodeFunctionInput&gt;</code>
    * [.getNodeFunction(builder)](#FunctionNode+getNodeFunction) ⇒ <code>NodeFunction</code>

<a name="new_FunctionNode_new"></a>

### new FunctionNode([code], [includes], [language])
Constructs a new function node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [code] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The native code. |
| [includes] | <code>Array.&lt;Node&gt;</code> | <code>[]</code> | An array of includes. |
| [language] | <code>&#x27;js&#x27;</code> \| <code>&#x27;wgsl&#x27;</code> \| <code>&#x27;glsl&#x27;</code> | <code>&#x27;&#x27;</code> | The used language. |

<a name="FunctionNode+getInputs"></a>

### functionNode.getInputs(builder) ⇒ <code>Array.&lt;NodeFunctionInput&gt;</code>
Returns the inputs of this function node.

**Kind**: instance method of [<code>FunctionNode</code>](#FunctionNode)  
**Returns**: <code>Array.&lt;NodeFunctionInput&gt;</code> - The inputs.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="FunctionNode+getNodeFunction"></a>

### functionNode.getNodeFunction(builder) ⇒ <code>NodeFunction</code>
Returns the node function for this function node.

**Kind**: instance method of [<code>FunctionNode</code>](#FunctionNode)  
**Returns**: <code>NodeFunction</code> - The node function.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#Resources">Resources</a> ⇐ <code>Map</code></dt>
<dd><p>A Map-like data structure for managing resources of scriptable nodes.</p>
</dd>
<dt><a href="#ScriptableNode">ScriptableNode</a> ⇐ <code>Node</code></dt>
<dd><p>This type of node allows to implement nodes with custom scripts. The script
section is represented as an instance of <code>CodeNode</code> written with JavaScript.
The script itself must adhere to a specific structure.</p>
<ul>
<li>main(): Executed once by default and every time <code>node.needsUpdate</code> is set.</li>
<li>layout: The layout object defines the script&#39;s interface (inputs and outputs).</li>
</ul>
<pre><code class="language-js">ScriptableNodeResources.set( &#39;TSL&#39;, TSL );

const scriptableNode = scriptable( js( `
    layout = {
        outputType: &#39;node&#39;,
        elements: [
            { name: &#39;source&#39;, inputType: &#39;node&#39; },
        ]
    };

    const { mul, oscSine } = TSL;

    function main() {
        const source = parameters.get( &#39;source&#39; ) || float();
        return mul( source, oscSine() ) );
    }

` ) );

scriptableNode.setParameter( &#39;source&#39;, color( 1, 0, 0 ) );

const material = new THREE.MeshBasicNodeMaterial();
material.colorNode = scriptableNode;
</code></pre>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#ScriptableNodeResources">ScriptableNodeResources</a> : <code><a href="#Resources">Resources</a></code></dt>
<dd><p>Defines the resources (e.g. namespaces) of scriptable nodes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#scriptable">scriptable([codeNode], [parameters])</a> ⇒ <code><a href="#ScriptableNode">ScriptableNode</a></code></dt>
<dd><p>TSL function for creating a scriptable node.</p>
</dd>
</dl>

<a name="Resources"></a>

## Resources ⇐ <code>Map</code>
A Map-like data structure for managing resources of scriptable nodes.

**Kind**: global class  
**Extends**: <code>Map</code>  
<a name="ScriptableNode"></a>

## ScriptableNode ⇐ <code>Node</code>
This type of node allows to implement nodes with custom scripts. The script
section is represented as an instance of `CodeNode` written with JavaScript.
The script itself must adhere to a specific structure.

- main(): Executed once by default and every time `node.needsUpdate` is set.
- layout: The layout object defines the script's interface (inputs and outputs).

```js
ScriptableNodeResources.set( 'TSL', TSL );

const scriptableNode = scriptable( js( `
	layout = {
		outputType: 'node',
		elements: [
			{ name: 'source', inputType: 'node' },
		]
	};

	const { mul, oscSine } = TSL;

	function main() {
		const source = parameters.get( 'source' ) || float();
		return mul( source, oscSine() ) );
	}

` ) );

scriptableNode.setParameter( 'source', color( 1, 0, 0 ) );

const material = new THREE.MeshBasicNodeMaterial();
material.colorNode = scriptableNode;
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ScriptableNode](#ScriptableNode) ⇐ <code>Node</code>
    * [new ScriptableNode([codeNode], [parameters])](#new_ScriptableNode_new)
    * [.codeNode](#ScriptableNode+codeNode) : <code>CodeNode</code>
    * [.parameters](#ScriptableNode+parameters) : <code>Object</code>
    * [.isScriptableNode](#ScriptableNode+isScriptableNode) : <code>boolean</code>
    * [.source](#ScriptableNode+source) : <code>string</code>
    * [.setLocal(name, value)](#ScriptableNode+setLocal) ⇒ [<code>Resources</code>](#Resources)
    * [.getLocal(name)](#ScriptableNode+getLocal) ⇒ <code>Object</code>
    * [.onRefresh()](#ScriptableNode+onRefresh)
    * [.getInputLayout(id)](#ScriptableNode+getInputLayout) ⇒ <code>Object</code>
    * [.getOutputLayout(id)](#ScriptableNode+getOutputLayout) ⇒ <code>Object</code>
    * [.setOutput(name, value)](#ScriptableNode+setOutput) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
    * [.getOutput(name)](#ScriptableNode+getOutput) ⇒ <code>ScriptableValueNode</code>
    * [.getParameter(name)](#ScriptableNode+getParameter) ⇒ <code>ScriptableValueNode</code>
    * [.setParameter(name, value)](#ScriptableNode+setParameter) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
    * [.getValue()](#ScriptableNode+getValue) ⇒ <code>Node</code>
    * [.deleteParameter(name)](#ScriptableNode+deleteParameter) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
    * [.clearParameters()](#ScriptableNode+clearParameters) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
    * [.call(name, ...params)](#ScriptableNode+call) ⇒ <code>any</code>
    * [.callAsync(name, ...params)](#ScriptableNode+callAsync) ⇒ <code>Promise.&lt;any&gt;</code>
    * [.getNodeType(builder)](#ScriptableNode+getNodeType) ⇒ <code>string</code>
    * [.refresh([output])](#ScriptableNode+refresh)
    * [.getObject()](#ScriptableNode+getObject) ⇒ <code>Object</code>
    * [.getLayout()](#ScriptableNode+getLayout) ⇒ <code>Object</code>
    * [.getDefaultOutputNode()](#ScriptableNode+getDefaultOutputNode) ⇒ <code>Node</code>
    * [.getDefaultOutput()](#ScriptableNode+getDefaultOutput) ⇒ <code>ScriptableValueNode</code>
    * [.getMethod()](#ScriptableNode+getMethod) ⇒ <code>function</code>
    * [.dispose()](#ScriptableNode+dispose)

<a name="new_ScriptableNode_new"></a>

### new ScriptableNode([codeNode], [parameters])
Constructs a new scriptable node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [codeNode] | <code>CodeNode</code> | <code></code> | The code node. |
| [parameters] | <code>Object</code> | <code>{}</code> | The parameters definition. |

<a name="ScriptableNode+codeNode"></a>

### scriptableNode.codeNode : <code>CodeNode</code>
The code node.

**Kind**: instance property of [<code>ScriptableNode</code>](#ScriptableNode)  
**Default**: <code>null</code>  
<a name="ScriptableNode+parameters"></a>

### scriptableNode.parameters : <code>Object</code>
The parameters definition.

**Kind**: instance property of [<code>ScriptableNode</code>](#ScriptableNode)  
**Default**: <code>{}</code>  
<a name="ScriptableNode+isScriptableNode"></a>

### scriptableNode.isScriptableNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ScriptableNode</code>](#ScriptableNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ScriptableNode+source"></a>

### scriptableNode.source : <code>string</code>
The source code of the scriptable node.

**Kind**: instance property of [<code>ScriptableNode</code>](#ScriptableNode)  
<a name="ScriptableNode+setLocal"></a>

### scriptableNode.setLocal(name, value) ⇒ [<code>Resources</code>](#Resources)
Sets the reference of a local script variable.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>Resources</code>](#Resources) - The resource map  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The variable name. |
| value | <code>Object</code> | The reference to set. |

<a name="ScriptableNode+getLocal"></a>

### scriptableNode.getLocal(name) ⇒ <code>Object</code>
Gets the value of a local script variable.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The value.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The variable name. |

<a name="ScriptableNode+onRefresh"></a>

### scriptableNode.onRefresh()
Event listener for the `refresh` event.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
<a name="ScriptableNode+getInputLayout"></a>

### scriptableNode.getInputLayout(id) ⇒ <code>Object</code>
Returns an input from the layout with the given id/name.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The element entry.  

| Param | Type | Description |
| --- | --- | --- |
| id | <code>string</code> | The id/name of the input. |

<a name="ScriptableNode+getOutputLayout"></a>

### scriptableNode.getOutputLayout(id) ⇒ <code>Object</code>
Returns an output from the layout with the given id/name.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The element entry.  

| Param | Type | Description |
| --- | --- | --- |
| id | <code>string</code> | The id/name of the output. |

<a name="ScriptableNode+setOutput"></a>

### scriptableNode.setOutput(name, value) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
Defines a script output for the given name and value.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>ScriptableNode</code>](#ScriptableNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the output. |
| value | <code>Node</code> | The node value. |

<a name="ScriptableNode+getOutput"></a>

### scriptableNode.getOutput(name) ⇒ <code>ScriptableValueNode</code>
Returns a script output for the given name.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>ScriptableValueNode</code> - The node value.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the output. |

<a name="ScriptableNode+getParameter"></a>

### scriptableNode.getParameter(name) ⇒ <code>ScriptableValueNode</code>
Returns a parameter for the given name

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>ScriptableValueNode</code> - The node value.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the parameter. |

<a name="ScriptableNode+setParameter"></a>

### scriptableNode.setParameter(name, value) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
Sets a value for the given parameter name.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>ScriptableNode</code>](#ScriptableNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The parameter name. |
| value | <code>any</code> | The parameter value. |

<a name="ScriptableNode+getValue"></a>

### scriptableNode.getValue() ⇒ <code>Node</code>
Returns the value of this node which is the value of
the default output.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Node</code> - The value.  
<a name="ScriptableNode+deleteParameter"></a>

### scriptableNode.deleteParameter(name) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
Deletes a parameter from the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>ScriptableNode</code>](#ScriptableNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The parameter to remove. |

<a name="ScriptableNode+clearParameters"></a>

### scriptableNode.clearParameters() ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
Deletes all parameters from the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: [<code>ScriptableNode</code>](#ScriptableNode) - A reference to this node.  
<a name="ScriptableNode+call"></a>

### scriptableNode.call(name, ...params) ⇒ <code>any</code>
Calls a function from the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>any</code> - The result of the function call.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The function name. |
| ...params | <code>any</code> | A list of parameters. |

<a name="ScriptableNode+callAsync"></a>

### scriptableNode.callAsync(name, ...params) ⇒ <code>Promise.&lt;any&gt;</code>
Asynchronously calls a function from the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Promise.&lt;any&gt;</code> - The result of the function call.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The function name. |
| ...params | <code>any</code> | A list of parameters. |

<a name="ScriptableNode+getNodeType"></a>

### scriptableNode.getNodeType(builder) ⇒ <code>string</code>
Overwritten since the node types is inferred from the script's output.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder |

<a name="ScriptableNode+refresh"></a>

### scriptableNode.refresh([output])
Refreshes the script node.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [output] | <code>string</code> | <code>null</code> | An optional output. |

<a name="ScriptableNode+getObject"></a>

### scriptableNode.getObject() ⇒ <code>Object</code>
Returns an object representation of the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The result object.  
<a name="ScriptableNode+getLayout"></a>

### scriptableNode.getLayout() ⇒ <code>Object</code>
Returns the layout of the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Object</code> - The script's layout.  
<a name="ScriptableNode+getDefaultOutputNode"></a>

### scriptableNode.getDefaultOutputNode() ⇒ <code>Node</code>
Returns default node output of the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>Node</code> - The default node output.  
<a name="ScriptableNode+getDefaultOutput"></a>

### scriptableNode.getDefaultOutput() ⇒ <code>ScriptableValueNode</code>
Returns default output of the script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>ScriptableValueNode</code> - The default output.  
<a name="ScriptableNode+getMethod"></a>

### scriptableNode.getMethod() ⇒ <code>function</code>
Returns a function created from the node's script.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
**Returns**: <code>function</code> - The function representing the node's code.  
<a name="ScriptableNode+dispose"></a>

### scriptableNode.dispose()
Frees all internal resources.

**Kind**: instance method of [<code>ScriptableNode</code>](#ScriptableNode)  
<a name="ScriptableNodeResources"></a>

## ScriptableNodeResources : [<code>Resources</code>](#Resources)
Defines the resources (e.g. namespaces) of scriptable nodes.

**Kind**: global constant  
<a name="scriptable"></a>

## scriptable([codeNode], [parameters]) ⇒ [<code>ScriptableNode</code>](#ScriptableNode)
TSL function for creating a scriptable node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [codeNode] | <code>CodeNode</code> |  | The code node. |
| [parameters] | <code>Object</code> | <code>{}</code> | The parameters definition. |

## Classes

<dl>
<dt><a href="#ScriptableValueNode">ScriptableValueNode</a> ⇐ <code>Node</code></dt>
<dd><p><code>ScriptableNode</code> uses this class to manage script inputs and outputs.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#scriptableValue">scriptableValue([value])</a> ⇒ <code><a href="#ScriptableValueNode">ScriptableValueNode</a></code></dt>
<dd><p>TSL function for creating a scriptable value node.</p>
</dd>
</dl>

<a name="ScriptableValueNode"></a>

## ScriptableValueNode ⇐ <code>Node</code>
`ScriptableNode` uses this class to manage script inputs and outputs.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ScriptableValueNode](#ScriptableValueNode) ⇐ <code>Node</code>
    * [new ScriptableValueNode([value])](#new_ScriptableValueNode_new)
    * [.inputType](#ScriptableValueNode+inputType) : <code>string</code>
    * [.outputType](#ScriptableValueNode+outputType) : <code>string</code>
    * [.events](#ScriptableValueNode+events) : <code>EventDispatcher</code>
    * [.isScriptableValueNode](#ScriptableValueNode+isScriptableValueNode) : <code>boolean</code>
    * [.isScriptableOutputNode](#ScriptableValueNode+isScriptableOutputNode) : <code>boolean</code>
    * [.value](#ScriptableValueNode+value) : <code>any</code>
    * [.refresh()](#ScriptableValueNode+refresh)
    * [.getValue()](#ScriptableValueNode+getValue) ⇒ <code>any</code>
    * [.getNodeType(builder)](#ScriptableValueNode+getNodeType) ⇒ <code>string</code>

<a name="new_ScriptableValueNode_new"></a>

### new ScriptableValueNode([value])
Constructs a new scriptable node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [value] | <code>any</code> | <code></code> | The value. |

<a name="ScriptableValueNode+inputType"></a>

### scriptableValueNode.inputType : <code>string</code>
If this node represents an input, this property represents the input type.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="ScriptableValueNode+outputType"></a>

### scriptableValueNode.outputType : <code>string</code>
If this node represents an output, this property represents the output type.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="ScriptableValueNode+events"></a>

### scriptableValueNode.events : <code>EventDispatcher</code>
An event dispatcher for managing events.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
<a name="ScriptableValueNode+isScriptableValueNode"></a>

### scriptableValueNode.isScriptableValueNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ScriptableValueNode+isScriptableOutputNode"></a>

### scriptableValueNode.isScriptableOutputNode : <code>boolean</code>
Whether this node represents an output or not.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ScriptableValueNode+value"></a>

### scriptableValueNode.value : <code>any</code>
The node's value.

**Kind**: instance property of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
<a name="ScriptableValueNode+refresh"></a>

### scriptableValueNode.refresh()
Dispatches the `refresh` event.

**Kind**: instance method of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
<a name="ScriptableValueNode+getValue"></a>

### scriptableValueNode.getValue() ⇒ <code>any</code>
The `value` property usually represents a node or even binary data in form of array buffers.
In this case, this method tries to return the actual value behind the complex type.

**Kind**: instance method of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Returns**: <code>any</code> - The value.  
<a name="ScriptableValueNode+getNodeType"></a>

### scriptableValueNode.getNodeType(builder) ⇒ <code>string</code>
Overwritten since the node type is inferred from the value.

**Kind**: instance method of [<code>ScriptableValueNode</code>](#ScriptableValueNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="scriptableValue"></a>

## scriptableValue([value]) ⇒ [<code>ScriptableValueNode</code>](#ScriptableValueNode)
TSL function for creating a scriptable value node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| [value] | <code>any</code> | The value. |

## Classes

<dl>
<dt><a href="#ArrayNode">ArrayNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>ArrayNode represents a collection of nodes, typically created using the <a href="#array">array</a> function.</p>
<pre><code class="language-js">const colors = array( [
    vec3( 1, 0, 0 ),
    vec3( 0, 1, 0 ),
    vec3( 0, 0, 1 )
] );

const redColor = tintColors.element( 0 );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#array">array(nodeTypeOrValues, [count])</a> ⇒ <code><a href="#ArrayNode">ArrayNode</a></code></dt>
<dd><p>TSL function for creating an array node.</p>
</dd>
</dl>

<a name="ArrayNode"></a>

## ArrayNode ⇐ <code>TempNode</code>
ArrayNode represents a collection of nodes, typically created using the [array](#array) function.
```js
const colors = array( [
	vec3( 1, 0, 0 ),
	vec3( 0, 1, 0 ),
	vec3( 0, 0, 1 )
] );

const redColor = tintColors.element( 0 );

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [ArrayNode](#ArrayNode) ⇐ <code>TempNode</code>
    * [new ArrayNode(nodeType, count, [values])](#new_ArrayNode_new)
    * [.count](#ArrayNode+count) : <code>number</code>
    * [.values](#ArrayNode+values) : <code>Array.&lt;Node&gt;</code>
    * [.isArrayNode](#ArrayNode+isArrayNode) : <code>boolean</code>
    * [.getNodeType(builder)](#ArrayNode+getNodeType) ⇒ <code>string</code>
    * [.getElementType(builder)](#ArrayNode+getElementType) ⇒ <code>string</code>
    * [.generate(builder)](#ArrayNode+generate) ⇒ <code>string</code>

<a name="new_ArrayNode_new"></a>

### new ArrayNode(nodeType, count, [values])
Constructs a new array node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> |  | The data type of the elements. |
| count | <code>number</code> |  | Size of the array. |
| [values] | <code>Array.&lt;Node&gt;</code> | <code></code> | Array default values. |

<a name="ArrayNode+count"></a>

### arrayNode.count : <code>number</code>
Array size.

**Kind**: instance property of [<code>ArrayNode</code>](#ArrayNode)  
<a name="ArrayNode+values"></a>

### arrayNode.values : <code>Array.&lt;Node&gt;</code>
Array default values.

**Kind**: instance property of [<code>ArrayNode</code>](#ArrayNode)  
<a name="ArrayNode+isArrayNode"></a>

### arrayNode.isArrayNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ArrayNode</code>](#ArrayNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ArrayNode+getNodeType"></a>

### arrayNode.getNodeType(builder) ⇒ <code>string</code>
Returns the node's type.

**Kind**: instance method of [<code>ArrayNode</code>](#ArrayNode)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ArrayNode+getElementType"></a>

### arrayNode.getElementType(builder) ⇒ <code>string</code>
Returns the node's type.

**Kind**: instance method of [<code>ArrayNode</code>](#ArrayNode)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ArrayNode+generate"></a>

### arrayNode.generate(builder) ⇒ <code>string</code>
This method builds the output node and returns the resulting array as a shader string.

**Kind**: instance method of [<code>ArrayNode</code>](#ArrayNode)  
**Returns**: <code>string</code> - The generated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="array"></a>

## array(nodeTypeOrValues, [count]) ⇒ [<code>ArrayNode</code>](#ArrayNode)
TSL function for creating an array node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| nodeTypeOrValues | <code>string</code> \| <code>Array.&lt;Node&gt;</code> | A string representing the element type (e.g., 'vec3') or an array containing the default values (e.g., [ vec3() ]). |
| [count] | <code>number</code> | Size of the array. |

## Classes

<dl>
<dt><a href="#AssignNode">AssignNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>These node represents an assign operation. Meaning a node is assigned
to another node.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#assign">assign(targetNode, sourceNode)</a> ⇒ <code><a href="#AssignNode">AssignNode</a></code></dt>
<dd><p>TSL function for creating an assign node.</p>
</dd>
</dl>

<a name="AssignNode"></a>

## AssignNode ⇐ <code>TempNode</code>
These node represents an assign operation. Meaning a node is assigned
to another node.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [AssignNode](#AssignNode) ⇐ <code>TempNode</code>
    * [new AssignNode(targetNode, sourceNode)](#new_AssignNode_new)
    * [.targetNode](#AssignNode+targetNode) : <code>Node</code>
    * [.sourceNode](#AssignNode+sourceNode) : <code>Node</code>
    * [.hasDependencies()](#AssignNode+hasDependencies) ⇒ <code>boolean</code>
    * [.needsSplitAssign(builder)](#AssignNode+needsSplitAssign) ⇒ <code>boolean</code>

<a name="new_AssignNode_new"></a>

### new AssignNode(targetNode, sourceNode)
Constructs a new assign node.


| Param | Type | Description |
| --- | --- | --- |
| targetNode | <code>Node</code> | The target node. |
| sourceNode | <code>Node</code> | The source type. |

<a name="AssignNode+targetNode"></a>

### assignNode.targetNode : <code>Node</code>
The target node.

**Kind**: instance property of [<code>AssignNode</code>](#AssignNode)  
<a name="AssignNode+sourceNode"></a>

### assignNode.sourceNode : <code>Node</code>
The source node.

**Kind**: instance property of [<code>AssignNode</code>](#AssignNode)  
<a name="AssignNode+hasDependencies"></a>

### assignNode.hasDependencies() ⇒ <code>boolean</code>
Whether this node is used more than once in context of other nodes. This method
is overwritten since it always returns `false` (assigns are unique).

**Kind**: instance method of [<code>AssignNode</code>](#AssignNode)  
**Returns**: <code>boolean</code> - A flag that indicates if there is more than one dependency to other nodes. Always `false`.  
<a name="AssignNode+needsSplitAssign"></a>

### assignNode.needsSplitAssign(builder) ⇒ <code>boolean</code>
Whether a split is required when assigning source to target. This can happen when the component length of
target and source data type does not match.

**Kind**: instance method of [<code>AssignNode</code>](#AssignNode)  
**Returns**: <code>boolean</code> - Whether a split is required when assigning source to target.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="assign"></a>

## assign(targetNode, sourceNode) ⇒ [<code>AssignNode</code>](#AssignNode)
TSL function for creating an assign node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| targetNode | <code>Node</code> | The target node. |
| sourceNode | <code>Node</code> | The source type. |

## Classes

<dl>
<dt><a href="#AttributeNode">AttributeNode</a> ⇐ <code>Node</code></dt>
<dd><p>Base class for representing shader attributes as nodes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#attribute">attribute(name, [nodeType])</a> ⇒ <code><a href="#AttributeNode">AttributeNode</a></code></dt>
<dd><p>TSL function for creating an attribute node.</p>
</dd>
</dl>

<a name="AttributeNode"></a>

## AttributeNode ⇐ <code>Node</code>
Base class for representing shader attributes as nodes.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [AttributeNode](#AttributeNode) ⇐ <code>Node</code>
    * [new AttributeNode(attributeName, nodeType)](#new_AttributeNode_new)
    * [.global](#AttributeNode+global) : <code>boolean</code>
    * [.setAttributeName(attributeName)](#AttributeNode+setAttributeName) ⇒ [<code>AttributeNode</code>](#AttributeNode)
    * [.getAttributeName(builder)](#AttributeNode+getAttributeName) ⇒ <code>string</code>

<a name="new_AttributeNode_new"></a>

### new AttributeNode(attributeName, nodeType)
Constructs a new attribute node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| attributeName | <code>string</code> |  | The name of the attribute. |
| nodeType | <code>string</code> | <code>null</code> | The node type. |

<a name="AttributeNode+global"></a>

### attributeNode.global : <code>boolean</code>
`AttributeNode` sets this property to `true` by default.

**Kind**: instance property of [<code>AttributeNode</code>](#AttributeNode)  
**Default**: <code>true</code>  
<a name="AttributeNode+setAttributeName"></a>

### attributeNode.setAttributeName(attributeName) ⇒ [<code>AttributeNode</code>](#AttributeNode)
Sets the attribute name to the given value. The method can be
overwritten in derived classes if the final name must be computed
analytically.

**Kind**: instance method of [<code>AttributeNode</code>](#AttributeNode)  
**Returns**: [<code>AttributeNode</code>](#AttributeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| attributeName | <code>string</code> | The name of the attribute. |

<a name="AttributeNode+getAttributeName"></a>

### attributeNode.getAttributeName(builder) ⇒ <code>string</code>
Returns the attribute name of this node. The method can be
overwritten in derived classes if the final name must be computed
analytically.

**Kind**: instance method of [<code>AttributeNode</code>](#AttributeNode)  
**Returns**: <code>string</code> - The attribute name.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="attribute"></a>

## attribute(name, [nodeType]) ⇒ [<code>AttributeNode</code>](#AttributeNode)
TSL function for creating an attribute node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the attribute. |
| [nodeType] | <code>string</code> | The node type. |

## Classes

<dl>
<dt><a href="#BypassNode">BypassNode</a> ⇐ <code>Node</code></dt>
<dd><p>The class generates the code of a given node but returns another node in the output.
This can be used to call a method or node that does not return a value, i.e.
type <code>void</code> on an input where returning a value is required. Example:</p>
<pre><code class="language-js">material.colorNode = myColor.bypass( runVoidFn() )
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#bypass">bypass(outputNode, callNode)</a> ⇒ <code><a href="#BypassNode">BypassNode</a></code></dt>
<dd><p>TSL function for creating a bypass node.</p>
</dd>
</dl>

<a name="BypassNode"></a>

## BypassNode ⇐ <code>Node</code>
The class generates the code of a given node but returns another node in the output.
This can be used to call a method or node that does not return a value, i.e.
type `void` on an input where returning a value is required. Example:

```js
material.colorNode = myColor.bypass( runVoidFn() )
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [BypassNode](#BypassNode) ⇐ <code>Node</code>
    * [new BypassNode(outputNode, callNode)](#new_BypassNode_new)
    * [.isBypassNode](#BypassNode+isBypassNode) : <code>boolean</code>
    * [.outputNode](#BypassNode+outputNode) : <code>Node</code>
    * [.callNode](#BypassNode+callNode) : <code>Node</code>

<a name="new_BypassNode_new"></a>

### new BypassNode(outputNode, callNode)
Constructs a new bypass node.


| Param | Type | Description |
| --- | --- | --- |
| outputNode | <code>Node</code> | The output node. |
| callNode | <code>Node</code> | The call node. |

<a name="BypassNode+isBypassNode"></a>

### bypassNode.isBypassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>BypassNode</code>](#BypassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="BypassNode+outputNode"></a>

### bypassNode.outputNode : <code>Node</code>
The output node.

**Kind**: instance property of [<code>BypassNode</code>](#BypassNode)  
<a name="BypassNode+callNode"></a>

### bypassNode.callNode : <code>Node</code>
The call node.

**Kind**: instance property of [<code>BypassNode</code>](#BypassNode)  
<a name="bypass"></a>

## bypass(outputNode, callNode) ⇒ [<code>BypassNode</code>](#BypassNode)
TSL function for creating a bypass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| outputNode | <code>Node</code> | The output node. |
| callNode | <code>Node</code> | The call node. |

## Classes

<dl>
<dt><a href="#CacheNode">CacheNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used as a cache management component for another node.
Caching is in general used by default in <a href="NodeBuilder">NodeBuilder</a> but this node
allows the usage of a shared parent cache during the build process.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#cache">cache(node, [parent])</a> ⇒ <code><a href="#CacheNode">CacheNode</a></code></dt>
<dd><p>TSL function for creating a cache node.</p>
</dd>
</dl>

<a name="CacheNode"></a>

## CacheNode ⇐ <code>Node</code>
This node can be used as a cache management component for another node.
Caching is in general used by default in [NodeBuilder](NodeBuilder) but this node
allows the usage of a shared parent cache during the build process.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [CacheNode](#CacheNode) ⇐ <code>Node</code>
    * [new CacheNode(node, [parent])](#new_CacheNode_new)
    * [.node](#CacheNode+node) : <code>Node</code>
    * [.parent](#CacheNode+parent) : <code>boolean</code>
    * [.isCacheNode](#CacheNode+isCacheNode) : <code>boolean</code>

<a name="new_CacheNode_new"></a>

### new CacheNode(node, [parent])
Constructs a new cache node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node that should be cached. |
| [parent] | <code>boolean</code> | <code>true</code> | Whether this node refers to a shared parent cache or not. |

<a name="CacheNode+node"></a>

### cacheNode.node : <code>Node</code>
The node that should be cached.

**Kind**: instance property of [<code>CacheNode</code>](#CacheNode)  
<a name="CacheNode+parent"></a>

### cacheNode.parent : <code>boolean</code>
Whether this node refers to a shared parent cache or not.

**Kind**: instance property of [<code>CacheNode</code>](#CacheNode)  
**Default**: <code>true</code>  
<a name="CacheNode+isCacheNode"></a>

### cacheNode.isCacheNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CacheNode</code>](#CacheNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="cache"></a>

## cache(node, [parent]) ⇒ [<code>CacheNode</code>](#CacheNode)
TSL function for creating a cache node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that should be cached. |
| [parent] | <code>boolean</code> | Whether this node refers to a shared parent cache or not. |

<a name="ConstNode"></a>

## ConstNode ⇐ <code>InputNode</code>
Class for representing a constant value in the shader.

**Kind**: global class  
**Extends**: <code>InputNode</code>  

* [ConstNode](#ConstNode) ⇐ <code>InputNode</code>
    * [new ConstNode(value, nodeType)](#new_ConstNode_new)
    * [.isConstNode](#ConstNode+isConstNode) : <code>boolean</code>
    * [.generateConst(builder)](#ConstNode+generateConst) ⇒ <code>string</code>

<a name="new_ConstNode_new"></a>

### new ConstNode(value, nodeType)
Constructs a new input node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>any</code> |  | The value of this node. Usually a JS primitive or three.js object (vector, matrix, color). |
| nodeType | <code>string</code> | <code>null</code> | The node type. If no explicit type is defined, the node tries to derive the type from its value. |

<a name="ConstNode+isConstNode"></a>

### constNode.isConstNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ConstNode</code>](#ConstNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ConstNode+generateConst"></a>

### constNode.generateConst(builder) ⇒ <code>string</code>
Generates the shader string of the value with the current node builder.

**Kind**: instance method of [<code>ConstNode</code>](#ConstNode)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#ContextNode">ContextNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used as a context management component for another node.
<a href="NodeBuilder">NodeBuilder</a> performs its node building process in a specific context and
this node allows the modify the context. A typical use case is to overwrite <code>getUV()</code> e.g.:</p>
<pre><code class="language-js">node.context( { getUV: () =&gt; customCoord } );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#context">context(node, [value])</a> ⇒ <code><a href="#ContextNode">ContextNode</a></code></dt>
<dd><p>TSL function for creating a context node.</p>
</dd>
<dt><a href="#label">label(node, name)</a> ⇒ <code><a href="#ContextNode">ContextNode</a></code></dt>
<dd><p>TSL function for defining a label context value for a given node.</p>
</dd>
</dl>

<a name="ContextNode"></a>

## ContextNode ⇐ <code>Node</code>
This node can be used as a context management component for another node.
[NodeBuilder](NodeBuilder) performs its node building process in a specific context and
this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:

```js
node.context( { getUV: () => customCoord } );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ContextNode](#ContextNode) ⇐ <code>Node</code>
    * [new ContextNode(node, [value])](#new_ContextNode_new)
    * [.isContextNode](#ContextNode+isContextNode) : <code>boolean</code>
    * [.node](#ContextNode+node) : <code>Node</code>
    * [.value](#ContextNode+value) : <code>Object</code>
    * [.getScope()](#ContextNode+getScope) ⇒ <code>Node</code>
    * [.getNodeType(builder)](#ContextNode+getNodeType) ⇒ <code>string</code>

<a name="new_ContextNode_new"></a>

### new ContextNode(node, [value])
Constructs a new context node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node whose context should be modified. |
| [value] | <code>Object</code> | <code>{}</code> | The modified context data. |

<a name="ContextNode+isContextNode"></a>

### contextNode.isContextNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ContextNode</code>](#ContextNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ContextNode+node"></a>

### contextNode.node : <code>Node</code>
The node whose context should be modified.

**Kind**: instance property of [<code>ContextNode</code>](#ContextNode)  
<a name="ContextNode+value"></a>

### contextNode.value : <code>Object</code>
The modified context data.

**Kind**: instance property of [<code>ContextNode</code>](#ContextNode)  
**Default**: <code>{}</code>  
<a name="ContextNode+getScope"></a>

### contextNode.getScope() ⇒ <code>Node</code>
This method is overwritten to ensure it returns the reference to [node](#ContextNode+node).

**Kind**: instance method of [<code>ContextNode</code>](#ContextNode)  
**Returns**: <code>Node</code> - A reference to [node](#ContextNode+node).  
<a name="ContextNode+getNodeType"></a>

### contextNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten to ensure it returns the type of [node](#ContextNode+node).

**Kind**: instance method of [<code>ContextNode</code>](#ContextNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="context"></a>

## context(node, [value]) ⇒ [<code>ContextNode</code>](#ContextNode)
TSL function for creating a context node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node whose context should be modified. |
| [value] | <code>Object</code> | <code>{}</code> | The modified context data. |

<a name="label"></a>

## label(node, name) ⇒ [<code>ContextNode</code>](#ContextNode)
TSL function for defining a label context value for a given node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node whose context should be modified. |
| name | <code>string</code> | The name/label to set. |

## Classes

<dl>
<dt><a href="#IndexNode">IndexNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class represents shader indices of different types. The following predefined node
objects cover frequent use cases:</p>
<ul>
<li><code>vertexIndex</code>: The index of a vertex within a mesh.</li>
<li><code>instanceIndex</code>: The index of either a mesh instance or an invocation of a compute shader.</li>
<li><code>drawIndex</code>: The index of a draw call.</li>
<li><code>invocationLocalIndex</code>: The index of a compute invocation within the scope of a workgroup load.</li>
<li><code>invocationSubgroupIndex</code>: The index of a compute invocation within the scope of a subgroup.</li>
<li><code>subgroupIndex</code>: The index of the subgroup the current compute invocation belongs to.</li>
</ul>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#vertexIndex">vertexIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of a vertex within a mesh.</p>
</dd>
<dt><a href="#instanceIndex">instanceIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of either a mesh instance or an invocation of a compute shader.</p>
</dd>
<dt><a href="#subgroupIndex">subgroupIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of the subgroup the current compute invocation belongs to.</p>
</dd>
<dt><a href="#invocationSubgroupIndex">invocationSubgroupIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of a compute invocation within the scope of a subgroup.</p>
</dd>
<dt><a href="#invocationLocalIndex">invocationLocalIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of a compute invocation within the scope of a workgroup load.</p>
</dd>
<dt><a href="#drawIndex">drawIndex</a> : <code><a href="#IndexNode">IndexNode</a></code></dt>
<dd><p>TSL object that represents the index of a draw call.</p>
</dd>
</dl>

<a name="IndexNode"></a>

## IndexNode ⇐ <code>Node</code>
This class represents shader indices of different types. The following predefined node
objects cover frequent use cases:

- `vertexIndex`: The index of a vertex within a mesh.
- `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.
- `drawIndex`: The index of a draw call.
- `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.
- `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.
- `subgroupIndex`: The index of the subgroup the current compute invocation belongs to.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [IndexNode](#IndexNode) ⇐ <code>Node</code>
    * [new IndexNode(scope)](#new_IndexNode_new)
    * [.scope](#IndexNode+scope) : <code>string</code>
    * [.isIndexNode](#IndexNode+isIndexNode) : <code>boolean</code>

<a name="new_IndexNode_new"></a>

### new IndexNode(scope)
Constructs a new index node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;instance&#x27;</code> \| <code>&#x27;subgroup&#x27;</code> \| <code>&#x27;invocationLocal&#x27;</code> \| <code>&#x27;invocationSubgroup&#x27;</code> \| <code>&#x27;draw&#x27;</code> | The scope of the index node. |

<a name="IndexNode+scope"></a>

### indexNode.scope : <code>string</code>
The scope of the index node.

**Kind**: instance property of [<code>IndexNode</code>](#IndexNode)  
<a name="IndexNode+isIndexNode"></a>

### indexNode.isIndexNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>IndexNode</code>](#IndexNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="vertexIndex"></a>

## vertexIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of a vertex within a mesh.

**Kind**: global constant  
**Tsl**:   
<a name="instanceIndex"></a>

## instanceIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of either a mesh instance or an invocation of a compute shader.

**Kind**: global constant  
**Tsl**:   
<a name="subgroupIndex"></a>

## subgroupIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of the subgroup the current compute invocation belongs to.

**Kind**: global constant  
**Tsl**:   
<a name="invocationSubgroupIndex"></a>

## invocationSubgroupIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of a compute invocation within the scope of a subgroup.

**Kind**: global constant  
**Tsl**:   
<a name="invocationLocalIndex"></a>

## invocationLocalIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of a compute invocation within the scope of a workgroup load.

**Kind**: global constant  
**Tsl**:   
<a name="drawIndex"></a>

## drawIndex : [<code>IndexNode</code>](#IndexNode)
TSL object that represents the index of a draw call.

**Kind**: global constant  
**Tsl**:   
<a name="InputNode"></a>

## InputNode ⇐ <code>Node</code>
Base class for representing data input nodes.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [InputNode](#InputNode) ⇐ <code>Node</code>
    * [new InputNode(value, nodeType)](#new_InputNode_new)
    * [.isInputNode](#InputNode+isInputNode) : <code>boolean</code>
    * [.value](#InputNode+value) : <code>any</code>
    * [.precision](#InputNode+precision) : <code>&#x27;low&#x27;</code> \| <code>&#x27;medium&#x27;</code> \| <code>&#x27;high&#x27;</code>
    * [.getInputType(builder)](#InputNode+getInputType) ⇒ <code>string</code>
    * [.setPrecision(precision)](#InputNode+setPrecision) ⇒ [<code>InputNode</code>](#InputNode)

<a name="new_InputNode_new"></a>

### new InputNode(value, nodeType)
Constructs a new input node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>any</code> |  | The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors). |
| nodeType | <code>string</code> | <code>null</code> | The node type. If no explicit type is defined, the node tries to derive the type from its value. |

<a name="InputNode+isInputNode"></a>

### inputNode.isInputNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>InputNode</code>](#InputNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="InputNode+value"></a>

### inputNode.value : <code>any</code>
The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).

**Kind**: instance property of [<code>InputNode</code>](#InputNode)  
<a name="InputNode+precision"></a>

### inputNode.precision : <code>&#x27;low&#x27;</code> \| <code>&#x27;medium&#x27;</code> \| <code>&#x27;high&#x27;</code>
The precision of the value in the shader.

**Kind**: instance property of [<code>InputNode</code>](#InputNode)  
**Default**: <code>null</code>  
<a name="InputNode+getInputType"></a>

### inputNode.getInputType(builder) ⇒ <code>string</code>
Returns the input type of the node which is by default the node type. Derived modules
might overwrite this method and use a fixed type or compute one analytically.

A typical example for different input and node types are textures. The input type of a
normal RGBA texture is `texture` whereas its node type is `vec4`.

**Kind**: instance method of [<code>InputNode</code>](#InputNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="InputNode+setPrecision"></a>

### inputNode.setPrecision(precision) ⇒ [<code>InputNode</code>](#InputNode)
Sets the precision to the given value. The method can be
overwritten in derived classes if the final precision must be computed
analytically.

**Kind**: instance method of [<code>InputNode</code>](#InputNode)  
**Returns**: [<code>InputNode</code>](#InputNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| precision | <code>&#x27;low&#x27;</code> \| <code>&#x27;medium&#x27;</code> \| <code>&#x27;high&#x27;</code> | The precision of the input value in the shader. |

<a name="LightingModel"></a>

## LightingModel
Abstract class for implementing lighting models. The module defines
multiple methods that concrete lighting models can implement. These
methods are executed at different points during the light evaluation
process.

**Kind**: global class  

* [LightingModel](#LightingModel)
    * *[.start(builder)](#LightingModel+start)*
    * *[.finish(builder)](#LightingModel+finish)*
    * *[.direct(lightData, builder)](#LightingModel+direct)*
    * *[.directRectArea(lightData, builder)](#LightingModel+directRectArea)*
    * *[.indirect(builder)](#LightingModel+indirect)*
    * *[.ambientOcclusion(builder)](#LightingModel+ambientOcclusion)*

<a name="LightingModel+start"></a>

### *lightingModel.start(builder)*
This method is intended for setting up lighting model and context data
which are later used in the evaluation process.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+finish"></a>

### *lightingModel.finish(builder)*
This method is intended for executing final tasks like final updates
to the outgoing light.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+direct"></a>

### *lightingModel.direct(lightData, builder)*
This method is intended for implementing the direct light term and
executed during the build process of directional, point and spot light nodes.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+directRectArea"></a>

### *lightingModel.directRectArea(lightData, builder)*
This method is intended for implementing the direct light term for
rect area light nodes.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+indirect"></a>

### *lightingModel.indirect(builder)*
This method is intended for implementing the indirect light term.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LightingModel+ambientOcclusion"></a>

### *lightingModel.ambientOcclusion(builder)*
This method is intended for implementing the ambient occlusion term.
Unlike other methods, this method must be called manually by the lighting
model in its indirect term.

**Kind**: instance abstract method of [<code>LightingModel</code>](#LightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

## Classes

<dl>
<dt><a href="#MRTNode">MRTNode</a> ⇐ <code>OutputStructNode</code></dt>
<dd><p>This node can be used setup a MRT context for rendering. A typical MRT setup for
post-processing is shown below:</p>
<pre><code class="language-js">const mrtNode = mrt( {
  output: output,
  normal: normalView
} ) );
</code></pre>
<p>The MRT output is defined as a dictionary.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#getTextureIndex">getTextureIndex(textures, name)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the MRT texture index for the given name.</p>
</dd>
<dt><a href="#mrt">mrt(outputNodes)</a> ⇒ <code><a href="#MRTNode">MRTNode</a></code></dt>
<dd><p>TSL function for creating a MRT node.</p>
</dd>
</dl>

<a name="MRTNode"></a>

## MRTNode ⇐ <code>OutputStructNode</code>
This node can be used setup a MRT context for rendering. A typical MRT setup for
post-processing is shown below:
```js
const mrtNode = mrt( {
  output: output,
  normal: normalView
} ) );
```
The MRT output is defined as a dictionary.

**Kind**: global class  
**Extends**: <code>OutputStructNode</code>  

* [MRTNode](#MRTNode) ⇐ <code>OutputStructNode</code>
    * [new MRTNode(outputNodes)](#new_MRTNode_new)
    * [.outputNodes](#MRTNode+outputNodes) : <code>Object.&lt;string, Node&gt;</code>
    * [.isMRTNode](#MRTNode+isMRTNode) : <code>boolean</code>
    * [.has(name)](#MRTNode+has) ⇒ <code>NodeBuilder</code>
    * [.get(name)](#MRTNode+get) ⇒ <code>Node</code>
    * [.merge(mrtNode)](#MRTNode+merge) ⇒ [<code>MRTNode</code>](#MRTNode)

<a name="new_MRTNode_new"></a>

### new MRTNode(outputNodes)
Constructs a new output struct node.


| Param | Type | Description |
| --- | --- | --- |
| outputNodes | <code>Object.&lt;string, Node&gt;</code> | The MRT outputs. |

<a name="MRTNode+outputNodes"></a>

### mrtNode.outputNodes : <code>Object.&lt;string, Node&gt;</code>
A dictionary representing the MRT outputs. The key
is the name of the output, the value the node which produces
the output result.

**Kind**: instance property of [<code>MRTNode</code>](#MRTNode)  
<a name="MRTNode+isMRTNode"></a>

### mrtNode.isMRTNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MRTNode</code>](#MRTNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MRTNode+has"></a>

### mrtNode.has(name) ⇒ <code>NodeBuilder</code>
Returns `true` if the MRT node has an output with the given name.

**Kind**: instance method of [<code>MRTNode</code>](#MRTNode)  
**Returns**: <code>NodeBuilder</code> - Whether the MRT node has an output for the given name or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the output. |

<a name="MRTNode+get"></a>

### mrtNode.get(name) ⇒ <code>Node</code>
Returns the output node for the given name.

**Kind**: instance method of [<code>MRTNode</code>](#MRTNode)  
**Returns**: <code>Node</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the output. |

<a name="MRTNode+merge"></a>

### mrtNode.merge(mrtNode) ⇒ [<code>MRTNode</code>](#MRTNode)
Merges the outputs of the given MRT node with the outputs of this node.

**Kind**: instance method of [<code>MRTNode</code>](#MRTNode)  
**Returns**: [<code>MRTNode</code>](#MRTNode) - A new MRT node with merged outputs..  

| Param | Type | Description |
| --- | --- | --- |
| mrtNode | [<code>MRTNode</code>](#MRTNode) | The MRT to merge. |

<a name="getTextureIndex"></a>

## getTextureIndex(textures, name) ⇒ <code>number</code>
Returns the MRT texture index for the given name.

**Kind**: global function  
**Returns**: <code>number</code> - The texture index.  

| Param | Type | Description |
| --- | --- | --- |
| textures | <code>Array.&lt;Texture&gt;</code> | The textures of a MRT-configured render target. |
| name | <code>string</code> | The name of the MRT texture which index is requested. |

<a name="mrt"></a>

## mrt(outputNodes) ⇒ [<code>MRTNode</code>](#MRTNode)
TSL function for creating a MRT node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| outputNodes | <code>Object.&lt;string, Node&gt;</code> | The MRT outputs. |

## Classes

<dl>
<dt><a href="#Node">Node</a> ⇐ <code>EventDispatcher</code></dt>
<dd><p>Base class for all nodes.</p>
</dd>
</dl>

## Typedefs

<dl>
<dt><a href="#traverseCallback">traverseCallback</a> : <code>function</code></dt>
<dd><p>Callback for <a href="#Node+traverse">traverse</a>.</p>
</dd>
</dl>

<a name="Node"></a>

## Node ⇐ <code>EventDispatcher</code>
Base class for all nodes.

**Kind**: global class  
**Extends**: <code>EventDispatcher</code>  

* [Node](#Node) ⇐ <code>EventDispatcher</code>
    * [new Node(nodeType)](#new_Node_new)
    * [.nodeType](#Node+nodeType) : <code>string</code>
    * [.updateType](#Node+updateType) : <code>string</code>
    * [.updateBeforeType](#Node+updateBeforeType) : <code>string</code>
    * [.updateAfterType](#Node+updateAfterType) : <code>string</code>
    * [.uuid](#Node+uuid) : <code>string</code>
    * [.version](#Node+version) : <code>number</code>
    * [.global](#Node+global) : <code>boolean</code>
    * [.isNode](#Node+isNode) : <code>boolean</code>
    * [.needsUpdate](#Node+needsUpdate) : <code>boolean</code>
    * [.type](#Node+type) : <code>string</code>
    * [.onUpdate(callback, updateType)](#Node+onUpdate) ⇒ [<code>Node</code>](#Node)
    * [.onFrameUpdate(callback)](#Node+onFrameUpdate) ⇒ [<code>Node</code>](#Node)
    * [.onRenderUpdate(callback)](#Node+onRenderUpdate) ⇒ [<code>Node</code>](#Node)
    * [.onObjectUpdate(callback)](#Node+onObjectUpdate) ⇒ [<code>Node</code>](#Node)
    * [.onReference(callback)](#Node+onReference) ⇒ [<code>Node</code>](#Node)
    * [.getSelf()](#Node+getSelf) ⇒ [<code>Node</code>](#Node)
    * [.updateReference(state)](#Node+updateReference) ⇒ <code>any</code>
    * [.isGlobal(builder)](#Node+isGlobal) ⇒ <code>boolean</code>
    * [.getChildren()](#Node+getChildren)
    * [.dispose()](#Node+dispose)
    * [.traverse(callback)](#Node+traverse)
    * [.getCacheKey([force])](#Node+getCacheKey) ⇒ <code>number</code>
    * [.customCacheKey()](#Node+customCacheKey) ⇒ <code>number</code>
    * [.getScope()](#Node+getScope) ⇒ [<code>Node</code>](#Node)
    * [.getHash(builder)](#Node+getHash) ⇒ <code>string</code>
    * [.getUpdateType()](#Node+getUpdateType) ⇒ <code>NodeUpdateType</code>
    * [.getUpdateBeforeType()](#Node+getUpdateBeforeType) ⇒ <code>NodeUpdateType</code>
    * [.getUpdateAfterType()](#Node+getUpdateAfterType) ⇒ <code>NodeUpdateType</code>
    * [.getElementType(builder)](#Node+getElementType) ⇒ <code>string</code>
    * [.getMemberType(builder, name)](#Node+getMemberType) ⇒ <code>string</code>
    * [.getNodeType(builder)](#Node+getNodeType) ⇒ <code>string</code>
    * [.getShared(builder)](#Node+getShared) ⇒ [<code>Node</code>](#Node)
    * [.setup(builder)](#Node+setup) ⇒ [<code>Node</code>](#Node)
    * [.analyze(builder)](#Node+analyze)
    * [.generate(builder, output)](#Node+generate) ⇒ <code>string</code>
    * *[.updateBefore(frame)](#Node+updateBefore) ⇒ <code>boolean</code>*
    * *[.updateAfter(frame)](#Node+updateAfter) ⇒ <code>boolean</code>*
    * *[.update(frame)](#Node+update) ⇒ <code>boolean</code>*
    * [.build(builder, output)](#Node+build) ⇒ <code>string</code>
    * [.getSerializeChildren()](#Node+getSerializeChildren) ⇒ <code>Array.&lt;Object&gt;</code>
    * [.serialize(json)](#Node+serialize)
    * [.deserialize(json)](#Node+deserialize)
    * [.toJSON(meta)](#Node+toJSON) ⇒ <code>Object</code>

<a name="new_Node_new"></a>

### new Node(nodeType)
Constructs a new node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> | <code>null</code> | The node type. |

<a name="Node+nodeType"></a>

### node.nodeType : <code>string</code>
The node type. This represents the result type of the node (e.g. `float` or `vec3`).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>&quot;null&quot;</code>  
<a name="Node+updateType"></a>

### node.updateType : <code>string</code>
The update type of the node's [update](#Node+update) method. Possible values are listed in [NodeUpdateType](NodeUpdateType).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>&quot;&#x27;none&#x27;&quot;</code>  
<a name="Node+updateBeforeType"></a>

### node.updateBeforeType : <code>string</code>
The update type of the node's [updateBefore](#Node+updateBefore) method. Possible values are listed in [NodeUpdateType](NodeUpdateType).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>&quot;&#x27;none&#x27;&quot;</code>  
<a name="Node+updateAfterType"></a>

### node.updateAfterType : <code>string</code>
The update type of the node's [updateAfter](#Node+updateAfter) method. Possible values are listed in [NodeUpdateType](NodeUpdateType).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>&quot;&#x27;none&#x27;&quot;</code>  
<a name="Node+uuid"></a>

### node.uuid : <code>string</code>
The UUID of the node.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Read only**: true  
<a name="Node+version"></a>

### node.version : <code>number</code>
The version of the node. The version automatically is increased when [needsUpdate](#Node+needsUpdate) is set to `true`.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>0</code>  
**Read only**: true  
<a name="Node+global"></a>

### node.global : <code>boolean</code>
Whether this node is global or not. This property is relevant for the internal
node caching system. All nodes which should be declared just once should
set this flag to `true` (a typical example is [AttributeNode](AttributeNode)).

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>false</code>  
<a name="Node+isNode"></a>

### node.isNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Node+needsUpdate"></a>

### node.needsUpdate : <code>boolean</code>
Set this property to `true` when the node should be regenerated.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Default**: <code>false</code>  

| Param | Type |
| --- | --- |
| value | <code>boolean</code> | 

<a name="Node+type"></a>

### node.type : <code>string</code>
The type of the class. The value is usually the constructor name.

**Kind**: instance property of [<code>Node</code>](#Node)  
**Read only**: true  
<a name="Node+onUpdate"></a>

### node.onUpdate(callback, updateType) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [update](#Node+update).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |
| updateType | <code>string</code> | The update type. |

<a name="Node+onFrameUpdate"></a>

### node.onFrameUpdate(callback) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [update](#Node+update). Similar to [onUpdate](#Node+onUpdate), but
this method automatically sets the update type to `FRAME`.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |

<a name="Node+onRenderUpdate"></a>

### node.onRenderUpdate(callback) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [update](#Node+update). Similar to [onUpdate](#Node+onUpdate), but
this method automatically sets the update type to `RENDER`.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |

<a name="Node+onObjectUpdate"></a>

### node.onObjectUpdate(callback) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [update](#Node+update). Similar to [onUpdate](#Node+onUpdate), but
this method automatically sets the update type to `OBJECT`.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |

<a name="Node+onReference"></a>

### node.onReference(callback) ⇒ [<code>Node</code>](#Node)
Convenient method for defining [updateReference](#Node+updateReference).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | The update method. |

<a name="Node+getSelf"></a>

### node.getSelf() ⇒ [<code>Node</code>](#Node)
The `this` reference might point to a Proxy so this method can be used
to get the reference to the actual node instance.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to the node.  
<a name="Node+updateReference"></a>

### node.updateReference(state) ⇒ <code>any</code>
Nodes might refer to other objects like materials. This method allows to dynamically update the reference
to such objects based on a given state (e.g. the current node frame or builder).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>any</code> - The updated reference.  

| Param | Type | Description |
| --- | --- | --- |
| state | <code>any</code> | This method can be invocated in different contexts so `state` can refer to any object type. |

<a name="Node+isGlobal"></a>

### node.isGlobal(builder) ⇒ <code>boolean</code>
By default this method returns the value of the [global](#Node+global) flag. This method
can be overwritten in derived classes if an analytical way is required to determine the
global status.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+getChildren"></a>

### node.getChildren()
Generator function that can be used to iterate over the child nodes.

**Kind**: instance method of [<code>Node</code>](#Node)  
<a name="Node+dispose"></a>

### node.dispose()
Calling this method dispatches the `dispose` event. This event can be used
to register event listeners for clean up tasks.

**Kind**: instance method of [<code>Node</code>](#Node)  
<a name="Node+traverse"></a>

### node.traverse(callback)
Can be used to traverse through the node's hierarchy.

**Kind**: instance method of [<code>Node</code>](#Node)  

| Param | Type | Description |
| --- | --- | --- |
| callback | [<code>traverseCallback</code>](#traverseCallback) | A callback that is executed per node. |

<a name="Node+getCacheKey"></a>

### node.getCacheKey([force]) ⇒ <code>number</code>
Returns the cache key for this node.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>number</code> - The cache key of the node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of the cache key is forced. |

<a name="Node+customCacheKey"></a>

### node.customCacheKey() ⇒ <code>number</code>
Generate a custom cache key for this node.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>number</code> - The cache key of the node.  
<a name="Node+getScope"></a>

### node.getScope() ⇒ [<code>Node</code>](#Node)
Returns the references to this node which is by default `this`.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - A reference to this node.  
<a name="Node+getHash"></a>

### node.getHash(builder) ⇒ <code>string</code>
Returns the hash of the node which is used to identify the node. By default it's
the [uuid](#Node+uuid) however derived node classes might have to overwrite this method
depending on their implementation.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+getUpdateType"></a>

### node.getUpdateType() ⇒ <code>NodeUpdateType</code>
Returns the update type of [update](#Node+update).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>NodeUpdateType</code> - The update type.  
<a name="Node+getUpdateBeforeType"></a>

### node.getUpdateBeforeType() ⇒ <code>NodeUpdateType</code>
Returns the update type of [updateBefore](#Node+updateBefore).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>NodeUpdateType</code> - The update type.  
<a name="Node+getUpdateAfterType"></a>

### node.getUpdateAfterType() ⇒ <code>NodeUpdateType</code>
Returns the update type of [updateAfter](#Node+updateAfter).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>NodeUpdateType</code> - The update type.  
<a name="Node+getElementType"></a>

### node.getElementType(builder) ⇒ <code>string</code>
Certain types are composed of multiple elements. For example a `vec3`
is composed of three `float` values. This method returns the type of
these elements.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+getMemberType"></a>

### node.getMemberType(builder, name) ⇒ <code>string</code>
Returns the node member type for the given name.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| name | <code>string</code> | The name of the member. |

<a name="Node+getNodeType"></a>

### node.getNodeType(builder) ⇒ <code>string</code>
Returns the node's type.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The type of the node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+getShared"></a>

### node.getShared(builder) ⇒ [<code>Node</code>](#Node)
This method is used during the build process of a node and ensures
equal nodes are not built multiple times but just once. For example if
`attribute( 'uv' )` is used multiple times by the user, the build
process makes sure to process just the first node.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - The shared node if possible. Otherwise `this` is returned.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+setup"></a>

### node.setup(builder) ⇒ [<code>Node</code>](#Node)
Represents the setup stage which is the first step of the build process, see [build](#Node+build) method.
This method is often overwritten in derived modules to prepare the node which is used as the output/result.
The output node must be returned in the `return` statement.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: [<code>Node</code>](#Node) - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+analyze"></a>

### node.analyze(builder)
Represents the analyze stage which is the second step of the build process, see [build](#Node+build) method.
This stage analyzes the node hierarchy and ensures descendent nodes are built.

**Kind**: instance method of [<code>Node</code>](#Node)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="Node+generate"></a>

### node.generate(builder, output) ⇒ <code>string</code>
Represents the generate stage which is the third step of the build process, see [build](#Node+build) method.
This state builds the output node and returns the resulting shader string.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - The generated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | Can be used to define the output type. |

<a name="Node+updateBefore"></a>

### *node.updateBefore(frame) ⇒ <code>boolean</code>*
The method can be implemented to update the node's internal state before it is used to render an object.
The [updateBeforeType](#Node+updateBeforeType) property defines how often the update is executed.

**Kind**: instance abstract method of [<code>Node</code>](#Node)  
**Returns**: <code>boolean</code> - An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="Node+updateAfter"></a>

### *node.updateAfter(frame) ⇒ <code>boolean</code>*
The method can be implemented to update the node's internal state after it was used to render an object.
The [updateAfterType](#Node+updateAfterType) property defines how often the update is executed.

**Kind**: instance abstract method of [<code>Node</code>](#Node)  
**Returns**: <code>boolean</code> - An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="Node+update"></a>

### *node.update(frame) ⇒ <code>boolean</code>*
The method can be implemented to update the node's internal state when it is used to render an object.
The [updateType](#Node+updateType) property defines how often the update is executed.

**Kind**: instance abstract method of [<code>Node</code>](#Node)  
**Returns**: <code>boolean</code> - An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="Node+build"></a>

### node.build(builder, output) ⇒ <code>string</code>
This method performs the build of a node. The behavior of this method as well as its return value depend
on the current build stage (setup, analyze or generate).

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>string</code> - When this method is executed in the setup or analyze stage, `null` is returned. In the generate stage, the generated shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| builder | <code>NodeBuilder</code> |  | The current node builder. |
| output | <code>string</code> | <code>null</code> | Can be used to define the output type. |

<a name="Node+getSerializeChildren"></a>

### node.getSerializeChildren() ⇒ <code>Array.&lt;Object&gt;</code>
Returns the child nodes as a JSON object.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>Array.&lt;Object&gt;</code> - An iterable list of serialized child objects as JSON.  
<a name="Node+serialize"></a>

### node.serialize(json)
Serializes the node to JSON.

**Kind**: instance method of [<code>Node</code>](#Node)  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The output JSON object. |

<a name="Node+deserialize"></a>

### node.deserialize(json)
Deserializes the node from the given JSON.

**Kind**: instance method of [<code>Node</code>](#Node)  

| Param | Type | Description |
| --- | --- | --- |
| json | <code>Object</code> | The JSON object. |

<a name="Node+toJSON"></a>

### node.toJSON(meta) ⇒ <code>Object</code>
Serializes the node into the three.js JSON Object/Scene format.

**Kind**: instance method of [<code>Node</code>](#Node)  
**Returns**: <code>Object</code> - The serialized node.  

| Param | Type | Description |
| --- | --- | --- |
| meta | <code>Object</code> | An optional JSON object that already holds serialized data from other scene objects. |

<a name="traverseCallback"></a>

## traverseCallback : <code>function</code>
Callback for [traverse](#Node+traverse).

**Kind**: global typedef  

| Param | Type | Description |
| --- | --- | --- |
| node | [<code>Node</code>](#Node) | The current node. |

<a name="NodeAttribute"></a>

## NodeAttribute
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent the final shader attributes that are going to be generated
by the builder. Arrays of node attributes is maintained in [NodeBuilder#attributes](NodeBuilder#attributes)
and [NodeBuilder#bufferAttributes](NodeBuilder#bufferAttributes) for this purpose.

**Kind**: global class  

* [NodeAttribute](#NodeAttribute)
    * [new NodeAttribute(name, type, node)](#new_NodeAttribute_new)
    * [.isNodeAttribute](#NodeAttribute+isNodeAttribute) : <code>boolean</code>
    * [.name](#NodeAttribute+name) : <code>string</code>
    * [.type](#NodeAttribute+type) : <code>string</code>
    * [.node](#NodeAttribute+node) : <code>Node</code>

<a name="new_NodeAttribute_new"></a>

### new NodeAttribute(name, type, node)
Constructs a new node attribute.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the attribute. |
| type | <code>string</code> |  | The type of the attribute. |
| node | <code>Node</code> | <code></code> | An optional reference to the node. |

<a name="NodeAttribute+isNodeAttribute"></a>

### nodeAttribute.isNodeAttribute : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeAttribute</code>](#NodeAttribute)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="NodeAttribute+name"></a>

### nodeAttribute.name : <code>string</code>
The name of the attribute.

**Kind**: instance property of [<code>NodeAttribute</code>](#NodeAttribute)  
<a name="NodeAttribute+type"></a>

### nodeAttribute.type : <code>string</code>
The type of the attribute.

**Kind**: instance property of [<code>NodeAttribute</code>](#NodeAttribute)  
<a name="NodeAttribute+node"></a>

### nodeAttribute.node : <code>Node</code>
An optional reference to the node.

**Kind**: instance property of [<code>NodeAttribute</code>](#NodeAttribute)  
**Default**: <code>null</code>  
<a name="NodeBuilder"></a>

## NodeBuilder
Base class for builders which generate a shader program based
on a 3D object and its node material definition.

**Kind**: global class  

* [NodeBuilder](#NodeBuilder)
    * [new NodeBuilder(object, renderer, parser)](#new_NodeBuilder_new)
    * [.object](#NodeBuilder+object) : <code>Object3D</code>
    * [.material](#NodeBuilder+material) : <code>Material</code>
    * [.geometry](#NodeBuilder+geometry) : <code>BufferGeometry</code>
    * [.renderer](#NodeBuilder+renderer) : <code>Renderer</code>
    * [.parser](#NodeBuilder+parser) : <code>NodeParser</code>
    * [.scene](#NodeBuilder+scene) : <code>Scene</code>
    * [.camera](#NodeBuilder+camera) : <code>Camera</code>
    * [.nodes](#NodeBuilder+nodes) : <code>Array.&lt;Node&gt;</code>
    * [.sequentialNodes](#NodeBuilder+sequentialNodes) : <code>Array.&lt;Node&gt;</code>
    * [.updateNodes](#NodeBuilder+updateNodes) : <code>Array.&lt;Node&gt;</code>
    * [.updateBeforeNodes](#NodeBuilder+updateBeforeNodes) : <code>Array.&lt;Node&gt;</code>
    * [.updateAfterNodes](#NodeBuilder+updateAfterNodes) : <code>Array.&lt;Node&gt;</code>
    * [.hashNodes](#NodeBuilder+hashNodes) : <code>Object.&lt;number, Node&gt;</code>
    * [.observer](#NodeBuilder+observer) : <code>NodeMaterialObserver</code>
    * [.lightsNode](#NodeBuilder+lightsNode) : <code>LightsNode</code>
    * [.environmentNode](#NodeBuilder+environmentNode) : <code>Node</code>
    * [.fogNode](#NodeBuilder+fogNode) : <code>FogNode</code>
    * [.clippingContext](#NodeBuilder+clippingContext) : <code>ClippingContext</code>
    * [.vertexShader](#NodeBuilder+vertexShader) : <code>string</code>
    * [.fragmentShader](#NodeBuilder+fragmentShader) : <code>string</code>
    * [.computeShader](#NodeBuilder+computeShader) : <code>string</code>
    * [.flowNodes](#NodeBuilder+flowNodes) : <code>Object.&lt;string, Array.&lt;Node&gt;&gt;</code>
    * [.flowCode](#NodeBuilder+flowCode) : <code>Object.&lt;string, string&gt;</code>
    * [.uniforms](#NodeBuilder+uniforms) : <code>Object</code>
    * [.structs](#NodeBuilder+structs) : <code>Object</code>
    * [.bindings](#NodeBuilder+bindings) : <code>Object</code>
    * [.bindingsIndexes](#NodeBuilder+bindingsIndexes) : <code>Object</code>
    * [.bindGroups](#NodeBuilder+bindGroups) : <code>Array.&lt;BindGroup&gt;</code>
    * [.attributes](#NodeBuilder+attributes) : <code>Array.&lt;NodeAttribute&gt;</code>
    * [.bufferAttributes](#NodeBuilder+bufferAttributes) : <code>Array.&lt;NodeAttribute&gt;</code>
    * [.varyings](#NodeBuilder+varyings) : <code>Array.&lt;NodeVarying&gt;</code>
    * [.codes](#NodeBuilder+codes) : <code>Object.&lt;string, Array.&lt;NodeCode&gt;&gt;</code>
    * [.vars](#NodeBuilder+vars) : <code>Object.&lt;string, (Array.&lt;NodeVar&gt;\|number)&gt;</code>
    * [.declarations](#NodeBuilder+declarations) : <code>Object</code>
    * [.flow](#NodeBuilder+flow) : <code>Object</code>
    * [.chaining](#NodeBuilder+chaining) : <code>Array.&lt;Node&gt;</code>
    * [.stack](#NodeBuilder+stack) : <code>StackNode</code>
    * [.stacks](#NodeBuilder+stacks) : <code>Array.&lt;StackNode&gt;</code>
    * [.tab](#NodeBuilder+tab) : <code>string</code>
    * [.currentFunctionNode](#NodeBuilder+currentFunctionNode) : <code>FunctionNode</code>
    * [.context](#NodeBuilder+context) : <code>Object</code>
    * [.cache](#NodeBuilder+cache) : <code>NodeCache</code>
    * [.globalCache](#NodeBuilder+globalCache) : <code>NodeCache</code>
    * [.shaderStage](#NodeBuilder+shaderStage) : <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code>
    * [.buildStage](#NodeBuilder+buildStage) : <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code>
    * [.currentNode](#NodeBuilder+currentNode) : <code>Node</code>
    * [.getBindGroupsCache()](#NodeBuilder+getBindGroupsCache) ⇒ <code>ChainMap</code>
    * [.createRenderTarget(width, height, options)](#NodeBuilder+createRenderTarget) ⇒ <code>RenderTarget</code>
    * [.createCubeRenderTarget(size, options)](#NodeBuilder+createCubeRenderTarget) ⇒ <code>CubeRenderTarget</code>
    * [.includes(node)](#NodeBuilder+includes) ⇒ <code>boolean</code>
    * *[.getOutputStructName()](#NodeBuilder+getOutputStructName) ⇒ <code>string</code>*
    * [.getBindGroupArray(groupName, shaderStage)](#NodeBuilder+getBindGroupArray) ⇒ <code>Array.&lt;NodeUniformsGroup&gt;</code>
    * [.getBindings()](#NodeBuilder+getBindings) ⇒ <code>Array.&lt;BindGroup&gt;</code>
    * [.sortBindingGroups()](#NodeBuilder+sortBindingGroups)
    * [.setHashNode(node, hash)](#NodeBuilder+setHashNode)
    * [.addNode(node)](#NodeBuilder+addNode)
    * [.addSequentialNode(node)](#NodeBuilder+addSequentialNode)
    * [.buildUpdateNodes()](#NodeBuilder+buildUpdateNodes)
    * [.isFilteredTexture(texture)](#NodeBuilder+isFilteredTexture) ⇒ <code>boolean</code>
    * [.addChain(node)](#NodeBuilder+addChain)
    * [.removeChain(node)](#NodeBuilder+removeChain)
    * *[.getMethod(method)](#NodeBuilder+getMethod) ⇒ <code>string</code>*
    * [.getNodeFromHash(hash)](#NodeBuilder+getNodeFromHash) ⇒ <code>Node</code>
    * [.addFlow(shaderStage, node)](#NodeBuilder+addFlow) ⇒ <code>Node</code>
    * [.setContext(context)](#NodeBuilder+setContext)
    * [.getContext()](#NodeBuilder+getContext) ⇒ <code>Object</code>
    * [.getSharedContext()](#NodeBuilder+getSharedContext) ⇒ <code>Object</code>
    * [.setCache(cache)](#NodeBuilder+setCache)
    * [.getCache()](#NodeBuilder+getCache) ⇒ <code>NodeCache</code>
    * [.getCacheFromNode(node, [parent])](#NodeBuilder+getCacheFromNode) ⇒ <code>NodeCache</code>
    * *[.isAvailable(name)](#NodeBuilder+isAvailable) ⇒ <code>boolean</code>*
    * *[.getVertexIndex()](#NodeBuilder+getVertexIndex) ⇒ <code>string</code>*
    * *[.getInstanceIndex()](#NodeBuilder+getInstanceIndex) ⇒ <code>string</code>*
    * *[.getDrawIndex()](#NodeBuilder+getDrawIndex) ⇒ <code>string</code>*
    * *[.getFrontFacing()](#NodeBuilder+getFrontFacing) ⇒ <code>string</code>*
    * *[.getFragCoord()](#NodeBuilder+getFragCoord) ⇒ <code>string</code>*
    * *[.isFlipY()](#NodeBuilder+isFlipY) ⇒ <code>boolean</code>*
    * [.increaseUsage(node)](#NodeBuilder+increaseUsage) ⇒ <code>number</code>
    * *[.generateTexture(texture, textureProperty, uvSnippet)](#NodeBuilder+generateTexture) ⇒ <code>string</code>*
    * *[.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet)](#NodeBuilder+generateTextureLod) ⇒ <code>string</code>*
    * [.generateArrayDeclaration(type, [count])](#NodeBuilder+generateArrayDeclaration) ⇒ <code>string</code>
    * [.generateArray(type, [count], [values])](#NodeBuilder+generateArray) ⇒ <code>string</code>
    * [.generateStruct(type, [membersLayout], [values])](#NodeBuilder+generateStruct) ⇒ <code>string</code>
    * [.generateConst(type, [value])](#NodeBuilder+generateConst) ⇒ <code>string</code>
    * [.getType(type)](#NodeBuilder+getType) ⇒ <code>string</code>
    * [.hasGeometryAttribute(name)](#NodeBuilder+hasGeometryAttribute) ⇒ <code>boolean</code>
    * [.getAttribute(name, type)](#NodeBuilder+getAttribute) ⇒ <code>NodeAttribute</code>
    * [.getPropertyName(node, shaderStage)](#NodeBuilder+getPropertyName) ⇒ <code>string</code>
    * [.isVector(type)](#NodeBuilder+isVector) ⇒ <code>boolean</code>
    * [.isMatrix(type)](#NodeBuilder+isMatrix) ⇒ <code>boolean</code>
    * [.isReference(type)](#NodeBuilder+isReference) ⇒ <code>boolean</code>
    * *[.needsToWorkingColorSpace(texture)](#NodeBuilder+needsToWorkingColorSpace) ⇒ <code>boolean</code>*
    * [.getComponentTypeFromTexture(texture)](#NodeBuilder+getComponentTypeFromTexture) ⇒ <code>string</code>
    * [.getElementType(type)](#NodeBuilder+getElementType) ⇒ <code>string</code>
    * [.getComponentType(type)](#NodeBuilder+getComponentType) ⇒ <code>string</code>
    * [.getVectorType(type)](#NodeBuilder+getVectorType) ⇒ <code>string</code>
    * [.getTypeFromLength(length, [componentType])](#NodeBuilder+getTypeFromLength) ⇒ <code>string</code>
    * [.getTypeFromArray(array)](#NodeBuilder+getTypeFromArray) ⇒ <code>string</code>
    * [.isInteger(type)](#NodeBuilder+isInteger) ⇒ <code>boolean</code>
    * [.getTypeFromAttribute(attribute)](#NodeBuilder+getTypeFromAttribute) ⇒ <code>string</code>
    * [.getTypeLength(type)](#NodeBuilder+getTypeLength) ⇒ <code>number</code>
    * [.getVectorFromMatrix(type)](#NodeBuilder+getVectorFromMatrix) ⇒ <code>string</code>
    * [.changeComponentType(type, newComponentType)](#NodeBuilder+changeComponentType) ⇒ <code>string</code>
    * [.getIntegerType(type)](#NodeBuilder+getIntegerType) ⇒ <code>string</code>
    * [.addStack()](#NodeBuilder+addStack) ⇒ <code>StackNode</code>
    * [.removeStack()](#NodeBuilder+removeStack) ⇒ <code>StackNode</code>
    * [.getDataFromNode(node, [shaderStage], cache)](#NodeBuilder+getDataFromNode) ⇒ <code>Object</code>
    * [.getNodeProperties(node, [shaderStage])](#NodeBuilder+getNodeProperties) ⇒ <code>Object</code>
    * [.getBufferAttributeFromNode(node, type)](#NodeBuilder+getBufferAttributeFromNode) ⇒ <code>NodeAttribute</code>
    * [.getStructTypeFromNode(node, membersLayout, [name], [shaderStage])](#NodeBuilder+getStructTypeFromNode) ⇒ <code>StructType</code>
    * [.getOutputStructTypeFromNode(node, membersLayout)](#NodeBuilder+getOutputStructTypeFromNode) ⇒ <code>StructType</code>
    * [.getUniformFromNode(node, type, [shaderStage], name)](#NodeBuilder+getUniformFromNode) ⇒ <code>NodeUniform</code>
    * [.getArrayCount(node)](#NodeBuilder+getArrayCount) ⇒ <code>number</code>
    * [.getVarFromNode(node, name, [type], [shaderStage], [readOnly])](#NodeBuilder+getVarFromNode) ⇒ <code>NodeVar</code>
    * [.isDeterministic(node)](#NodeBuilder+isDeterministic) ⇒ <code>boolean</code>
    * [.getVaryingFromNode(node, name, [type])](#NodeBuilder+getVaryingFromNode) ⇒ <code>NodeVar</code>
    * [.registerDeclaration(node)](#NodeBuilder+registerDeclaration)
    * [.getCodeFromNode(node, type, [shaderStage])](#NodeBuilder+getCodeFromNode) ⇒ <code>NodeCode</code>
    * [.addFlowCodeHierarchy(node, nodeBlock)](#NodeBuilder+addFlowCodeHierarchy)
    * [.addLineFlowCodeBlock(node, code, nodeBlock)](#NodeBuilder+addLineFlowCodeBlock)
    * [.addLineFlowCode(code, [node])](#NodeBuilder+addLineFlowCode) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.addFlowCode(code)](#NodeBuilder+addFlowCode) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.addFlowTab()](#NodeBuilder+addFlowTab) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.removeFlowTab()](#NodeBuilder+removeFlowTab) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.getFlowData(node, shaderStage)](#NodeBuilder+getFlowData) ⇒ <code>Object</code>
    * [.flowNode(node)](#NodeBuilder+flowNode) ⇒ <code>Object</code>
    * [.addInclude(node)](#NodeBuilder+addInclude) ⇒ <code>void</code>
    * [.buildFunctionNode(shaderNode)](#NodeBuilder+buildFunctionNode) ⇒ <code>FunctionNode</code>
    * [.flowShaderNode(shaderNode)](#NodeBuilder+flowShaderNode) ⇒ <code>Object</code>
    * [.flowStagesNode(node, output)](#NodeBuilder+flowStagesNode) ⇒ <code>Object</code>
    * *[.getFunctionOperator(op)](#NodeBuilder+getFunctionOperator) ⇒ <code>string</code>*
    * *[.buildFunctionCode(shaderNode)](#NodeBuilder+buildFunctionCode) ⇒ <code>string</code>*
    * [.flowChildNode(node, output)](#NodeBuilder+flowChildNode) ⇒ <code>Object</code>
    * [.flowNodeFromShaderStage(shaderStage, node, output, propertyName)](#NodeBuilder+flowNodeFromShaderStage) ⇒ <code>Object</code>
    * [.getAttributesArray()](#NodeBuilder+getAttributesArray) ⇒ <code>Array.&lt;NodeAttribute&gt;</code>
    * *[.getAttributes(shaderStage)](#NodeBuilder+getAttributes) ⇒ <code>string</code>*
    * *[.getVaryings(shaderStage)](#NodeBuilder+getVaryings) ⇒ <code>string</code>*
    * [.getVar(type, name, [count])](#NodeBuilder+getVar) ⇒ <code>string</code>
    * [.getVars(shaderStage)](#NodeBuilder+getVars) ⇒ <code>string</code>
    * *[.getUniforms(shaderStage)](#NodeBuilder+getUniforms) ⇒ <code>string</code>*
    * [.getCodes(shaderStage)](#NodeBuilder+getCodes) ⇒ <code>string</code>
    * [.getHash()](#NodeBuilder+getHash) ⇒ <code>string</code>
    * [.setShaderStage(shaderStage)](#NodeBuilder+setShaderStage)
    * [.getShaderStage()](#NodeBuilder+getShaderStage) ⇒ <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code>
    * [.setBuildStage(buildStage)](#NodeBuilder+setBuildStage)
    * [.getBuildStage()](#NodeBuilder+getBuildStage) ⇒ <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code>
    * *[.buildCode()](#NodeBuilder+buildCode)*
    * [.build()](#NodeBuilder+build) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
    * [.getNodeUniform(uniformNode, type)](#NodeBuilder+getNodeUniform) ⇒ <code>Uniform</code>
    * [.format(snippet, fromType, toType)](#NodeBuilder+format) ⇒ <code>string</code>
    * [.getSignature()](#NodeBuilder+getSignature) ⇒ <code>string</code>
    * ~~[.createNodeMaterial([type])](#NodeBuilder+createNodeMaterial)~~

<a name="new_NodeBuilder_new"></a>

### new NodeBuilder(object, renderer, parser)
Constructs a new node builder.


| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object. |
| renderer | <code>Renderer</code> | The current renderer. |
| parser | <code>NodeParser</code> | A reference to a node parser. |

<a name="NodeBuilder+object"></a>

### nodeBuilder.object : <code>Object3D</code>
The 3D object.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+material"></a>

### nodeBuilder.material : <code>Material</code>
The material of the 3D object.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+geometry"></a>

### nodeBuilder.geometry : <code>BufferGeometry</code>
The geometry of the 3D object.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+renderer"></a>

### nodeBuilder.renderer : <code>Renderer</code>
The current renderer.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+parser"></a>

### nodeBuilder.parser : <code>NodeParser</code>
A reference to a node parser.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+scene"></a>

### nodeBuilder.scene : <code>Scene</code>
The scene the 3D object belongs to.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+camera"></a>

### nodeBuilder.camera : <code>Camera</code>
The camera the 3D object is rendered with.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+nodes"></a>

### nodeBuilder.nodes : <code>Array.&lt;Node&gt;</code>
A list of all nodes the builder is processing
for this 3D object.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+sequentialNodes"></a>

### nodeBuilder.sequentialNodes : <code>Array.&lt;Node&gt;</code>
A list of all sequential nodes.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+updateNodes"></a>

### nodeBuilder.updateNodes : <code>Array.&lt;Node&gt;</code>
A list of all nodes which [Node#update](Node#update) method should be executed.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+updateBeforeNodes"></a>

### nodeBuilder.updateBeforeNodes : <code>Array.&lt;Node&gt;</code>
A list of all nodes which [Node#updateBefore](Node#updateBefore) method should be executed.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+updateAfterNodes"></a>

### nodeBuilder.updateAfterNodes : <code>Array.&lt;Node&gt;</code>
A list of all nodes which [Node#updateAfter](Node#updateAfter) method should be executed.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+hashNodes"></a>

### nodeBuilder.hashNodes : <code>Object.&lt;number, Node&gt;</code>
A dictionary that assigns each node to a unique hash.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+observer"></a>

### nodeBuilder.observer : <code>NodeMaterialObserver</code>
A reference to a node material observer.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+lightsNode"></a>

### nodeBuilder.lightsNode : <code>LightsNode</code>
A reference to the current lights node.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+environmentNode"></a>

### nodeBuilder.environmentNode : <code>Node</code>
A reference to the current environment node.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+fogNode"></a>

### nodeBuilder.fogNode : <code>FogNode</code>
A reference to the current fog node.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+clippingContext"></a>

### nodeBuilder.clippingContext : <code>ClippingContext</code>
The current clipping context.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+vertexShader"></a>

### nodeBuilder.vertexShader : <code>string</code>
The generated vertex shader.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+fragmentShader"></a>

### nodeBuilder.fragmentShader : <code>string</code>
The generated fragment shader.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+computeShader"></a>

### nodeBuilder.computeShader : <code>string</code>
The generated compute shader.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+flowNodes"></a>

### nodeBuilder.flowNodes : <code>Object.&lt;string, Array.&lt;Node&gt;&gt;</code>
Nodes used in the primary flow of code generation.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+flowCode"></a>

### nodeBuilder.flowCode : <code>Object.&lt;string, string&gt;</code>
Nodes code from `.flowNodes`.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+uniforms"></a>

### nodeBuilder.uniforms : <code>Object</code>
This dictionary holds the node uniforms of the builder.
The uniforms are maintained in an array for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+structs"></a>

### nodeBuilder.structs : <code>Object</code>
This dictionary holds the output structs of the builder.
The structs are maintained in an array for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+bindings"></a>

### nodeBuilder.bindings : <code>Object</code>
This dictionary holds the bindings for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+bindingsIndexes"></a>

### nodeBuilder.bindingsIndexes : <code>Object</code>
This dictionary maintains the binding indices per bind group.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+bindGroups"></a>

### nodeBuilder.bindGroups : <code>Array.&lt;BindGroup&gt;</code>
Reference to the array of bind groups.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+attributes"></a>

### nodeBuilder.attributes : <code>Array.&lt;NodeAttribute&gt;</code>
This array holds the node attributes of this builder
created via [AttributeNode](AttributeNode).

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+bufferAttributes"></a>

### nodeBuilder.bufferAttributes : <code>Array.&lt;NodeAttribute&gt;</code>
This array holds the node attributes of this builder
created via [BufferAttributeNode](BufferAttributeNode).

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+varyings"></a>

### nodeBuilder.varyings : <code>Array.&lt;NodeVarying&gt;</code>
This array holds the node varyings of this builder.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+codes"></a>

### nodeBuilder.codes : <code>Object.&lt;string, Array.&lt;NodeCode&gt;&gt;</code>
This dictionary holds the (native) node codes of this builder.
The codes are maintained in an array for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+vars"></a>

### nodeBuilder.vars : <code>Object.&lt;string, (Array.&lt;NodeVar&gt;\|number)&gt;</code>
This dictionary holds the node variables of this builder.
The variables are maintained in an array for each shader stage.
This dictionary is also used to count the number of variables
according to their type (const, vars).

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+declarations"></a>

### nodeBuilder.declarations : <code>Object</code>
This dictionary holds the declarations for each shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+flow"></a>

### nodeBuilder.flow : <code>Object</code>
Current code flow.
All code generated in this stack will be stored in `.flow`.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+chaining"></a>

### nodeBuilder.chaining : <code>Array.&lt;Node&gt;</code>
A chain of nodes.
Used to check recursive calls in node-graph.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+stack"></a>

### nodeBuilder.stack : <code>StackNode</code>
The current stack.
This reflects the current process in the code block hierarchy,
it is useful to know if the current process is inside a conditional for example.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+stacks"></a>

### nodeBuilder.stacks : <code>Array.&lt;StackNode&gt;</code>
List of stack nodes.
The current stack hierarchy is stored in an array.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+tab"></a>

### nodeBuilder.tab : <code>string</code>
A tab value. Used for shader string generation.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>&quot;&#x27;\\t&#x27;&quot;</code>  
<a name="NodeBuilder+currentFunctionNode"></a>

### nodeBuilder.currentFunctionNode : <code>FunctionNode</code>
Reference to the current function node.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>null</code>  
<a name="NodeBuilder+context"></a>

### nodeBuilder.context : <code>Object</code>
The builder's context.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+cache"></a>

### nodeBuilder.cache : <code>NodeCache</code>
The builder's cache.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+globalCache"></a>

### nodeBuilder.globalCache : <code>NodeCache</code>
Since the [cache](#NodeBuilder+cache) might be temporarily
overwritten by other caches, this member retains the reference
to the builder's own cache.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
**Default**: <code>this.cache</code>  
<a name="NodeBuilder+shaderStage"></a>

### nodeBuilder.shaderStage : <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code>
The current shader stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+buildStage"></a>

### nodeBuilder.buildStage : <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code>
The current build stage.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+currentNode"></a>

### nodeBuilder.currentNode : <code>Node</code>
A reference the current node which is the
last node in the chain of nodes.

**Kind**: instance property of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+getBindGroupsCache"></a>

### nodeBuilder.getBindGroupsCache() ⇒ <code>ChainMap</code>
Returns the bind groups of the current renderer.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>ChainMap</code> - The cache.  
<a name="NodeBuilder+createRenderTarget"></a>

### nodeBuilder.createRenderTarget(width, height, options) ⇒ <code>RenderTarget</code>
Factory method for creating an instance of [RenderTarget](RenderTarget) with the given
dimensions and options.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>RenderTarget</code> - The render target.  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the render target. |
| height | <code>number</code> | The height of the render target. |
| options | <code>Object</code> | The options of the render target. |

<a name="NodeBuilder+createCubeRenderTarget"></a>

### nodeBuilder.createCubeRenderTarget(size, options) ⇒ <code>CubeRenderTarget</code>
Factory method for creating an instance of [CubeRenderTarget](CubeRenderTarget) with the given
dimensions and options.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>CubeRenderTarget</code> - The cube render target.  

| Param | Type | Description |
| --- | --- | --- |
| size | <code>number</code> | The size of the cube render target. |
| options | <code>Object</code> | The options of the cube render target. |

<a name="NodeBuilder+includes"></a>

### nodeBuilder.includes(node) ⇒ <code>boolean</code>
Whether the given node is included in the internal array of nodes or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given node is included in the internal array of nodes or not.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to test. |

<a name="NodeBuilder+getOutputStructName"></a>

### *nodeBuilder.getOutputStructName() ⇒ <code>string</code>*
Returns the output struct name which is required by
[OutputStructNode](OutputStructNode).

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The name of the output struct.  
<a name="NodeBuilder+getBindGroupArray"></a>

### nodeBuilder.getBindGroupArray(groupName, shaderStage) ⇒ <code>Array.&lt;NodeUniformsGroup&gt;</code>
Returns an array of node uniform groups for the given group name and shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Array.&lt;NodeUniformsGroup&gt;</code> - The array of node uniform groups.  

| Param | Type | Description |
| --- | --- | --- |
| groupName | <code>string</code> | The group name. |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getBindings"></a>

### nodeBuilder.getBindings() ⇒ <code>Array.&lt;BindGroup&gt;</code>
Returns a list bindings of all shader stages separated by groups.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Array.&lt;BindGroup&gt;</code> - The list of bindings.  
<a name="NodeBuilder+sortBindingGroups"></a>

### nodeBuilder.sortBindingGroups()
Sorts the bind groups and updates [bindingsIndexes](#NodeBuilder+bindingsIndexes).

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+setHashNode"></a>

### nodeBuilder.setHashNode(node, hash)
The builder maintains each node in a hash-based dictionary.
This method sets the given node (value) with the given hash (key) into this dictionary.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |
| hash | <code>number</code> | The hash of the node. |

<a name="NodeBuilder+addNode"></a>

### nodeBuilder.addNode(node)
Adds a node to this builder.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |

<a name="NodeBuilder+addSequentialNode"></a>

### nodeBuilder.addSequentialNode(node)
It is used to add Nodes that will be used as FRAME and RENDER events,
and need to follow a certain sequence in the calls to work correctly.
This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |

<a name="NodeBuilder+buildUpdateNodes"></a>

### nodeBuilder.buildUpdateNodes()
Checks the update types of nodes

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+isFilteredTexture"></a>

### nodeBuilder.isFilteredTexture(texture) ⇒ <code>boolean</code>
Whether the given texture is filtered or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture is filtered or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to check. |

<a name="NodeBuilder+addChain"></a>

### nodeBuilder.addChain(node)
Adds the given node to the internal node chain.
This is used to check recursive calls in node-graph.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |

<a name="NodeBuilder+removeChain"></a>

### nodeBuilder.removeChain(node)
Removes the given node from the internal node chain.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to remove. |

<a name="NodeBuilder+getMethod"></a>

### *nodeBuilder.getMethod(method) ⇒ <code>string</code>*
Returns the native shader method name for a given generic name. E.g.
the method name `textureDimensions` matches the WGSL name but must be
resolved to `textureSize` in GLSL.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The resolved method name.  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The method name to resolve. |

<a name="NodeBuilder+getNodeFromHash"></a>

### nodeBuilder.getNodeFromHash(hash) ⇒ <code>Node</code>
Returns a node for the given hash, see [setHashNode](#NodeBuilder+setHashNode).

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Node</code> - The found node.  

| Param | Type | Description |
| --- | --- | --- |
| hash | <code>number</code> | The hash of the node. |

<a name="NodeBuilder+addFlow"></a>

### nodeBuilder.addFlow(shaderStage, node) ⇒ <code>Node</code>
Adds the Node to a target flow so that it can generate code in the 'generate' process.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Node</code> - The node.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> | The shader stage. |
| node | <code>Node</code> | The node to add. |

<a name="NodeBuilder+setContext"></a>

### nodeBuilder.setContext(context)
Sets builder's context.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| context | <code>Object</code> | The context to set. |

<a name="NodeBuilder+getContext"></a>

### nodeBuilder.getContext() ⇒ <code>Object</code>
Returns the builder's current context.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The builder's current context.  
<a name="NodeBuilder+getSharedContext"></a>

### nodeBuilder.getSharedContext() ⇒ <code>Object</code>
Gets a context used in shader construction that can be shared across different materials.
This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The builder's current context without material.  
<a name="NodeBuilder+setCache"></a>

### nodeBuilder.setCache(cache)
Sets builder's cache.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| cache | <code>NodeCache</code> | The cache to set. |

<a name="NodeBuilder+getCache"></a>

### nodeBuilder.getCache() ⇒ <code>NodeCache</code>
Returns the builder's current cache.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeCache</code> - The builder's current cache.  
<a name="NodeBuilder+getCacheFromNode"></a>

### nodeBuilder.getCacheFromNode(node, [parent]) ⇒ <code>NodeCache</code>
Returns a cache for the given node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeCache</code> - The cache.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node. |
| [parent] | <code>boolean</code> | <code>true</code> | Whether this node refers to a shared parent cache or not. |

<a name="NodeBuilder+isAvailable"></a>

### *nodeBuilder.isAvailable(name) ⇒ <code>boolean</code>*
Whether the requested feature is available or not.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the requested feature is supported or not.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The requested feature. |

<a name="NodeBuilder+getVertexIndex"></a>

### *nodeBuilder.getVertexIndex() ⇒ <code>string</code>*
Returns the vertexIndex input variable as a native shader string.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The instanceIndex shader string.  
<a name="NodeBuilder+getInstanceIndex"></a>

### *nodeBuilder.getInstanceIndex() ⇒ <code>string</code>*
Returns the instanceIndex input variable as a native shader string.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The instanceIndex shader string.  
<a name="NodeBuilder+getDrawIndex"></a>

### *nodeBuilder.getDrawIndex() ⇒ <code>string</code>*
Returns the drawIndex input variable as a native shader string.
Only relevant for WebGL and its `WEBGL_multi_draw` extension.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The drawIndex shader string.  
<a name="NodeBuilder+getFrontFacing"></a>

### *nodeBuilder.getFrontFacing() ⇒ <code>string</code>*
Returns the frontFacing input variable as a native shader string.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The frontFacing shader string.  
<a name="NodeBuilder+getFragCoord"></a>

### *nodeBuilder.getFragCoord() ⇒ <code>string</code>*
Returns the fragCoord input variable as a native shader string.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The fragCoord shader string.  
<a name="NodeBuilder+isFlipY"></a>

### *nodeBuilder.isFlipY() ⇒ <code>boolean</code>*
Whether to flip texture data along its vertical axis or not. WebGL needs
this method evaluate to `true`, WebGPU to `false`.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether to flip texture data along its vertical axis or not.  
<a name="NodeBuilder+increaseUsage"></a>

### nodeBuilder.increaseUsage(node) ⇒ <code>number</code>
Calling this method increases the usage count for the given node by one.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>number</code> - The updated usage count.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to increase the usage count for. |

<a name="NodeBuilder+generateTexture"></a>

### *nodeBuilder.generateTexture(texture, textureProperty, uvSnippet) ⇒ <code>string</code>*
Generates a texture sample shader string for the given texture data.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The texture property name. |
| uvSnippet | <code>string</code> | Snippet defining the texture coordinates. |

<a name="NodeBuilder+generateTextureLod"></a>

### *nodeBuilder.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet) ⇒ <code>string</code>*
Generates a texture LOD shader string for the given texture data.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |
| textureProperty | <code>string</code> | The texture property name. |
| uvSnippet | <code>string</code> | Snippet defining the texture coordinates. |
| depthSnippet | <code>string</code> | Snippet defining the 0-based texture array index to sample. |
| levelSnippet | <code>string</code> | Snippet defining the mip level. |

<a name="NodeBuilder+generateArrayDeclaration"></a>

### nodeBuilder.generateArrayDeclaration(type, [count]) ⇒ <code>string</code>
Generates the array declaration string.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |
| [count] | <code>number</code> | The count. |

<a name="NodeBuilder+generateArray"></a>

### nodeBuilder.generateArray(type, [count], [values]) ⇒ <code>string</code>
Generates the array shader string for the given type and value.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type. |
| [count] | <code>number</code> |  | The count. |
| [values] | <code>Array.&lt;Node&gt;</code> | <code></code> | The default values. |

<a name="NodeBuilder+generateStruct"></a>

### nodeBuilder.generateStruct(type, [membersLayout], [values]) ⇒ <code>string</code>
Generates the struct shader string.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type. |
| [membersLayout] | <code>Array.&lt;Object&gt;</code> |  | The count. |
| [values] | <code>Array.&lt;Node&gt;</code> | <code></code> | The default values. |

<a name="NodeBuilder+generateConst"></a>

### nodeBuilder.generateConst(type, [value]) ⇒ <code>string</code>
Generates the shader string for the given type and value.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The generated value as a shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type. |
| [value] | <code>any</code> | <code></code> | The value. |

<a name="NodeBuilder+getType"></a>

### nodeBuilder.getType(type) ⇒ <code>string</code>
It might be necessary to convert certain data types to different ones
so this method can be used to hide the conversion.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The updated type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+hasGeometryAttribute"></a>

### nodeBuilder.hasGeometryAttribute(name) ⇒ <code>boolean</code>
Whether the given attribute name is defined in the geometry or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given attribute name is defined in the geometry.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute name. |

<a name="NodeBuilder+getAttribute"></a>

### nodeBuilder.getAttribute(name, type) ⇒ <code>NodeAttribute</code>
Returns a node attribute for the given name and type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeAttribute</code> - The node attribute.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The attribute's name. |
| type | <code>string</code> | The attribute's type. |

<a name="NodeBuilder+getPropertyName"></a>

### nodeBuilder.getPropertyName(node, shaderStage) ⇒ <code>string</code>
Returns for the given node and shader stage the property name for the shader.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The property name.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node. |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+isVector"></a>

### nodeBuilder.isVector(type) ⇒ <code>boolean</code>
Whether the given type is a vector type or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given type is a vector type or not.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type to check. |

<a name="NodeBuilder+isMatrix"></a>

### nodeBuilder.isMatrix(type) ⇒ <code>boolean</code>
Whether the given type is a matrix type or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given type is a matrix type or not.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type to check. |

<a name="NodeBuilder+isReference"></a>

### nodeBuilder.isReference(type) ⇒ <code>boolean</code>
Whether the given type is a reference type or not.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given type is a reference type or not.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type to check. |

<a name="NodeBuilder+needsToWorkingColorSpace"></a>

### *nodeBuilder.needsToWorkingColorSpace(texture) ⇒ <code>boolean</code>*
Checks if the given texture requires a manual conversion to the working color space.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the given texture requires a conversion to working color space or not.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture to check. |

<a name="NodeBuilder+getComponentTypeFromTexture"></a>

### nodeBuilder.getComponentTypeFromTexture(texture) ⇒ <code>string</code>
Returns the component type of a given texture.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The component type.  

| Param | Type | Description |
| --- | --- | --- |
| texture | <code>Texture</code> | The texture. |

<a name="NodeBuilder+getElementType"></a>

### nodeBuilder.getElementType(type) ⇒ <code>string</code>
Returns the element type for a given type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The element type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+getComponentType"></a>

### nodeBuilder.getComponentType(type) ⇒ <code>string</code>
Returns the component type for a given type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The component type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+getVectorType"></a>

### nodeBuilder.getVectorType(type) ⇒ <code>string</code>
Returns the vector type for a given type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The vector type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+getTypeFromLength"></a>

### nodeBuilder.getTypeFromLength(length, [componentType]) ⇒ <code>string</code>
Returns the data type for the given the length and component type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The type.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| length | <code>number</code> |  | The length. |
| [componentType] | <code>string</code> | <code>&quot;&#x27;float&#x27;&quot;</code> | The component type. |

<a name="NodeBuilder+getTypeFromArray"></a>

### nodeBuilder.getTypeFromArray(array) ⇒ <code>string</code>
Returns the type for a given typed array.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The type.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>TypedArray</code> | The typed array. |

<a name="NodeBuilder+isInteger"></a>

### nodeBuilder.isInteger(type) ⇒ <code>boolean</code>
Returns the type is an integer type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Whether the type is an integer type or not.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+getTypeFromAttribute"></a>

### nodeBuilder.getTypeFromAttribute(attribute) ⇒ <code>string</code>
Returns the type for a given buffer attribute.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The type.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The buffer attribute. |

<a name="NodeBuilder+getTypeLength"></a>

### nodeBuilder.getTypeLength(type) ⇒ <code>number</code>
Returns the length for the given data type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>number</code> - The length.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The data type. |

<a name="NodeBuilder+getVectorFromMatrix"></a>

### nodeBuilder.getVectorFromMatrix(type) ⇒ <code>string</code>
Returns the vector type for a given matrix type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The vector type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The matrix type. |

<a name="NodeBuilder+changeComponentType"></a>

### nodeBuilder.changeComponentType(type, newComponentType) ⇒ <code>string</code>
For a given type this method changes the component type to the
given value. E.g. `vec4` should be changed to the new component type
`uint` which results in `uvec4`.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The new type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |
| newComponentType | <code>string</code> | The new component type. |

<a name="NodeBuilder+getIntegerType"></a>

### nodeBuilder.getIntegerType(type) ⇒ <code>string</code>
Returns the integer type pendant for the given type.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The integer type.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type. |

<a name="NodeBuilder+addStack"></a>

### nodeBuilder.addStack() ⇒ <code>StackNode</code>
Adds a stack node to the internal stack.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>StackNode</code> - The added stack node.  
<a name="NodeBuilder+removeStack"></a>

### nodeBuilder.removeStack() ⇒ <code>StackNode</code>
Removes the last stack node from the internal stack.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>StackNode</code> - The removed stack node.  
<a name="NodeBuilder+getDataFromNode"></a>

### nodeBuilder.getDataFromNode(node, [shaderStage], cache) ⇒ <code>Object</code>
The builder maintains (cached) data for each node during the building process. This method
can be used to get these data for a specific shader stage and cache.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The node data.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to get the data for. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |
| cache | <code>NodeCache</code> | <code></code> | An optional cache. |

<a name="NodeBuilder+getNodeProperties"></a>

### nodeBuilder.getNodeProperties(node, [shaderStage]) ⇒ <code>Object</code>
Returns the properties for the given node and shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The node properties.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to get the properties for. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getBufferAttributeFromNode"></a>

### nodeBuilder.getBufferAttributeFromNode(node, type) ⇒ <code>NodeAttribute</code>
Returns an instance of [NodeAttribute](NodeAttribute) for the given buffer attribute node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeAttribute</code> - The node attribute.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>BufferAttributeNode</code> | The buffer attribute node. |
| type | <code>string</code> | The node type. |

<a name="NodeBuilder+getStructTypeFromNode"></a>

### nodeBuilder.getStructTypeFromNode(node, membersLayout, [name], [shaderStage]) ⇒ <code>StructType</code>
Returns an instance of [StructType](StructType) for the given output struct node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>StructType</code> - The struct type attribute.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>OutputStructNode</code> |  | The output struct node. |
| membersLayout | <code>Array.&lt;Object&gt;</code> |  | The output struct types. |
| [name] | <code>string</code> | <code>null</code> | The name of the struct. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |

<a name="NodeBuilder+getOutputStructTypeFromNode"></a>

### nodeBuilder.getOutputStructTypeFromNode(node, membersLayout) ⇒ <code>StructType</code>
Returns an instance of [StructType](StructType) for the given output struct node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>StructType</code> - The struct type attribute.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>OutputStructNode</code> | The output struct node. |
| membersLayout | <code>Array.&lt;Object&gt;</code> | The output struct types. |

<a name="NodeBuilder+getUniformFromNode"></a>

### nodeBuilder.getUniformFromNode(node, type, [shaderStage], name) ⇒ <code>NodeUniform</code>
Returns an instance of [NodeUniform](NodeUniform) for the given uniform node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeUniform</code> - The node uniform.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>UniformNode</code> |  | The uniform node. |
| type | <code>string</code> |  | The uniform type. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |
| name | <code>string</code> | <code>null</code> | The name of the uniform. |

<a name="NodeBuilder+getArrayCount"></a>

### nodeBuilder.getArrayCount(node) ⇒ <code>number</code>
Returns the array length.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>number</code> - The array length.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node. |

<a name="NodeBuilder+getVarFromNode"></a>

### nodeBuilder.getVarFromNode(node, name, [type], [shaderStage], [readOnly]) ⇒ <code>NodeVar</code>
Returns an instance of [NodeVar](NodeVar) for the given variable node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeVar</code> - The node variable.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>VarNode</code> |  | The variable node. |
| name | <code>string</code> | <code>null</code> | The variable's name. |
| [type] | <code>string</code> | <code>&quot;node.getNodeType( this )&quot;</code> | The variable's type. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |
| [readOnly] | <code>boolean</code> | <code>false</code> | Whether the variable is read-only or not. |

<a name="NodeBuilder+isDeterministic"></a>

### nodeBuilder.isDeterministic(node) ⇒ <code>boolean</code>
Returns whether a Node or its flow is deterministic, useful for use in `const`.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>boolean</code> - Returns true if deterministic.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The varying node. |

<a name="NodeBuilder+getVaryingFromNode"></a>

### nodeBuilder.getVaryingFromNode(node, name, [type]) ⇒ <code>NodeVar</code>
Returns an instance of [NodeVarying](NodeVarying) for the given varying node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeVar</code> - The node varying.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>VaryingNode</code> \| <code>PropertyNode</code> |  | The varying node. |
| name | <code>string</code> | <code>null</code> | The varying's name. |
| [type] | <code>string</code> | <code>&quot;node.getNodeType( this )&quot;</code> | The varying's type. |

<a name="NodeBuilder+registerDeclaration"></a>

### nodeBuilder.registerDeclaration(node)
Registers a node declaration in the current shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Object</code> | The node to be registered. |

<a name="NodeBuilder+getCodeFromNode"></a>

### nodeBuilder.getCodeFromNode(node, type, [shaderStage]) ⇒ <code>NodeCode</code>
Returns an instance of [NodeCode](NodeCode) for the given code node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>NodeCode</code> - The node code.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>CodeNode</code> |  | The code node. |
| type | <code>string</code> |  | The node type. |
| [shaderStage] | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | <code>this.shaderStage</code> | The shader stage. |

<a name="NodeBuilder+addFlowCodeHierarchy"></a>

### nodeBuilder.addFlowCodeHierarchy(node, nodeBlock)
Adds a code flow based on the code-block hierarchy.
This is used so that code-blocks like If,Else create their variables locally if the Node
is only used inside one of these conditionals in the current shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |
| nodeBlock | <code>Node</code> | Node-based code-block. Usually 'ConditionalNode'. |

<a name="NodeBuilder+addLineFlowCodeBlock"></a>

### nodeBuilder.addLineFlowCodeBlock(node, code, nodeBlock)
Add a inline-code to the current flow code-block.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |
| code | <code>string</code> | The code to add. |
| nodeBlock | <code>Node</code> | Current ConditionalNode |

<a name="NodeBuilder+addLineFlowCode"></a>

### nodeBuilder.addLineFlowCode(code, [node]) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Add a inline-code to the current flow.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| code | <code>string</code> |  | The code to add. |
| [node] | <code>Node</code> | <code></code> | Optional Node, can help the system understand if the Node is part of a code-block. |

<a name="NodeBuilder+addFlowCode"></a>

### nodeBuilder.addFlowCode(code) ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Adds a code to the current code flow.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  

| Param | Type | Description |
| --- | --- | --- |
| code | <code>string</code> | Shader code. |

<a name="NodeBuilder+addFlowTab"></a>

### nodeBuilder.addFlowTab() ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Add tab in the code that will be generated so that other snippets respect the current tabulation.
Typically used in codes with If,Else.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  
<a name="NodeBuilder+removeFlowTab"></a>

### nodeBuilder.removeFlowTab() ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Removes a tab.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  
<a name="NodeBuilder+getFlowData"></a>

### nodeBuilder.getFlowData(node, shaderStage) ⇒ <code>Object</code>
Gets the current flow data based on a Node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The flow data.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Node that the flow was started. |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+flowNode"></a>

### nodeBuilder.flowNode(node) ⇒ <code>Object</code>
Executes the node flow based on a root node to generate the final shader code.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The code flow.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to execute. |

<a name="NodeBuilder+addInclude"></a>

### nodeBuilder.addInclude(node) ⇒ <code>void</code>
Includes a node in the current function node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to include. |

<a name="NodeBuilder+buildFunctionNode"></a>

### nodeBuilder.buildFunctionNode(shaderNode) ⇒ <code>FunctionNode</code>
Returns the native shader operator name for a given generic name.
It is a similar type of method like [getMethod](#NodeBuilder+getMethod).

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>FunctionNode</code> - The build function node.  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | The shader node to build the function node with. |

<a name="NodeBuilder+flowShaderNode"></a>

### nodeBuilder.flowShaderNode(shaderNode) ⇒ <code>Object</code>
Generates a code flow based on a TSL function: Fn().

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | A function code will be generated based on the input. |

<a name="NodeBuilder+flowStagesNode"></a>

### nodeBuilder.flowStagesNode(node, output) ⇒ <code>Object</code>
Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to execute. |
| output | <code>string</code> | <code>null</code> | Expected output type. For example 'vec3'. |

<a name="NodeBuilder+getFunctionOperator"></a>

### *nodeBuilder.getFunctionOperator(op) ⇒ <code>string</code>*
Returns the native shader operator name for a given generic name.
It is a similar type of method like [getMethod](#NodeBuilder+getMethod).

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The resolved operator name.  

| Param | Type | Description |
| --- | --- | --- |
| op | <code>string</code> | The operator name to resolve. |

<a name="NodeBuilder+buildFunctionCode"></a>

### *nodeBuilder.buildFunctionCode(shaderNode) ⇒ <code>string</code>*
Builds the given shader node.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The function code.  

| Param | Type | Description |
| --- | --- | --- |
| shaderNode | <code>ShaderNodeInternal</code> | The shader node. |

<a name="NodeBuilder+flowChildNode"></a>

### nodeBuilder.flowChildNode(node, output) ⇒ <code>Object</code>
Generates a code flow based on a child Node.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Object</code> - The code flow.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node to execute. |
| output | <code>string</code> | <code>null</code> | Expected output type. For example 'vec3'. |

<a name="NodeBuilder+flowNodeFromShaderStage"></a>

### nodeBuilder.flowNodeFromShaderStage(shaderStage, node, output, propertyName) ⇒ <code>Object</code>
Executes a flow of code in a different stage.

Some nodes like `varying()` have the ability to compute code in vertex-stage and
return the value in fragment-stage even if it is being executed in an input fragment.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> |  | The shader stage. |
| node | <code>Node</code> |  | The node to execute. |
| output | <code>string</code> | <code>null</code> | Expected output type. For example 'vec3'. |
| propertyName | <code>string</code> | <code>null</code> | The property name to assign the result. |

<a name="NodeBuilder+getAttributesArray"></a>

### nodeBuilder.getAttributesArray() ⇒ <code>Array.&lt;NodeAttribute&gt;</code>
Returns an array holding all node attributes of this node builder.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Array.&lt;NodeAttribute&gt;</code> - The node attributes of this builder.  
<a name="NodeBuilder+getAttributes"></a>

### *nodeBuilder.getAttributes(shaderStage) ⇒ <code>string</code>*
Returns the attribute definitions as a shader string for the given shader stage.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The attribute code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getVaryings"></a>

### *nodeBuilder.getVaryings(shaderStage) ⇒ <code>string</code>*
Returns the varying definitions as a shader string for the given shader stage.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The varying code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getVar"></a>

### nodeBuilder.getVar(type, name, [count]) ⇒ <code>string</code>
Returns a single variable definition as a shader string for the given variable type and name.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The shader string.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The variable's type. |
| name | <code>string</code> |  | The variable's name. |
| [count] | <code>number</code> | <code></code> | The array length. |

<a name="NodeBuilder+getVars"></a>

### nodeBuilder.getVars(shaderStage) ⇒ <code>string</code>
Returns the variable definitions as a shader string for the given shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The variable code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getUniforms"></a>

### *nodeBuilder.getUniforms(shaderStage) ⇒ <code>string</code>*
Returns the uniform definitions as a shader string for the given shader stage.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The uniform code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getCodes"></a>

### nodeBuilder.getCodes(shaderStage) ⇒ <code>string</code>
Returns the native code definitions as a shader string for the given shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The native code section.  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage. |

<a name="NodeBuilder+getHash"></a>

### nodeBuilder.getHash() ⇒ <code>string</code>
Returns the hash of this node builder.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The hash.  
<a name="NodeBuilder+setShaderStage"></a>

### nodeBuilder.setShaderStage(shaderStage)
Sets the current shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| shaderStage | <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> | The shader stage to set. |

<a name="NodeBuilder+getShaderStage"></a>

### nodeBuilder.getShaderStage() ⇒ <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code>
Returns the current shader stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>&#x27;vertex&#x27;</code> \| <code>&#x27;fragment&#x27;</code> \| <code>&#x27;compute&#x27;</code> \| <code>&#x27;any&#x27;</code> - The current shader stage.  
<a name="NodeBuilder+setBuildStage"></a>

### nodeBuilder.setBuildStage(buildStage)
Sets the current build stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  

| Param | Type | Description |
| --- | --- | --- |
| buildStage | <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code> | The build stage to set. |

<a name="NodeBuilder+getBuildStage"></a>

### nodeBuilder.getBuildStage() ⇒ <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code>
Returns the current build stage.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>&#x27;setup&#x27;</code> \| <code>&#x27;analyze&#x27;</code> \| <code>&#x27;generate&#x27;</code> - The current build stage.  
<a name="NodeBuilder+buildCode"></a>

### *nodeBuilder.buildCode()*
Controls the code build of the shader stages.

**Kind**: instance abstract method of [<code>NodeBuilder</code>](#NodeBuilder)  
<a name="NodeBuilder+build"></a>

### nodeBuilder.build() ⇒ [<code>NodeBuilder</code>](#NodeBuilder)
Central build method which controls the build for the given object.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: [<code>NodeBuilder</code>](#NodeBuilder) - A reference to this node builder.  
<a name="NodeBuilder+getNodeUniform"></a>

### nodeBuilder.getNodeUniform(uniformNode, type) ⇒ <code>Uniform</code>
Returns a uniform representation which is later used for UBO generation and rendering.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>Uniform</code> - The uniform.  

| Param | Type | Description |
| --- | --- | --- |
| uniformNode | <code>NodeUniform</code> | The uniform node. |
| type | <code>string</code> | The requested type. |

<a name="NodeBuilder+format"></a>

### nodeBuilder.format(snippet, fromType, toType) ⇒ <code>string</code>
Formats the given shader snippet from a given type into another one. E.g.
this method might be used to convert a simple float string `"1.0"` into a
`vec3` representation: `"vec3<f32>( 1.0 )"`.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The updated shader string.  

| Param | Type | Description |
| --- | --- | --- |
| snippet | <code>string</code> | The shader snippet. |
| fromType | <code>string</code> | The source type. |
| toType | <code>string</code> | The target type. |

<a name="NodeBuilder+getSignature"></a>

### nodeBuilder.getSignature() ⇒ <code>string</code>
Returns a signature with the engine's current revision.

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Returns**: <code>string</code> - The signature.  
<a name="NodeBuilder+createNodeMaterial"></a>

### ~~nodeBuilder.createNodeMaterial([type])~~
***since r168. Use `new NodeMaterial()` instead, with targeted node material name.***

**Kind**: instance method of [<code>NodeBuilder</code>](#NodeBuilder)  
**Throws**:

- <code>Error</code> 


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [type] | <code>string</code> | <code>&quot;&#x27;NodeMaterial&#x27;&quot;</code> | The node material type. |

<a name="NodeCache"></a>

## NodeCache
This utility class is used in [NodeBuilder](NodeBuilder) as an internal
cache data structure for node data.

**Kind**: global class  

* [NodeCache](#NodeCache)
    * [new NodeCache(parent)](#new_NodeCache_new)
    * [.id](#NodeCache+id) : <code>number</code>
    * [.nodesData](#NodeCache+nodesData) : <code>WeakMap.&lt;Node, Object&gt;</code>
    * [.parent](#NodeCache+parent) : [<code>NodeCache</code>](#NodeCache)
    * [.getData(node)](#NodeCache+getData) ⇒ <code>Object</code>
    * [.setData(node, data)](#NodeCache+setData)

<a name="new_NodeCache_new"></a>

### new NodeCache(parent)
Constructs a new node cache.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| parent | [<code>NodeCache</code>](#NodeCache) | <code></code> | A reference to a parent cache. |

<a name="NodeCache+id"></a>

### nodeCache.id : <code>number</code>
The id of the cache.

**Kind**: instance property of [<code>NodeCache</code>](#NodeCache)  
**Read only**: true  
<a name="NodeCache+nodesData"></a>

### nodeCache.nodesData : <code>WeakMap.&lt;Node, Object&gt;</code>
A weak map for managing node data.

**Kind**: instance property of [<code>NodeCache</code>](#NodeCache)  
<a name="NodeCache+parent"></a>

### nodeCache.parent : [<code>NodeCache</code>](#NodeCache)
Reference to a parent node cache.

**Kind**: instance property of [<code>NodeCache</code>](#NodeCache)  
**Default**: <code>null</code>  
<a name="NodeCache+getData"></a>

### nodeCache.getData(node) ⇒ <code>Object</code>
Returns the data for the given node.

**Kind**: instance method of [<code>NodeCache</code>](#NodeCache)  
**Returns**: <code>Object</code> - The data for the node.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node. |

<a name="NodeCache+setData"></a>

### nodeCache.setData(node, data)
Sets the data for a given node.

**Kind**: instance method of [<code>NodeCache</code>](#NodeCache)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node. |
| data | <code>Object</code> | The data that should be cached. |

<a name="NodeCode"></a>

## NodeCode
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent user-defined, native shader code portions that are going to be
injected by the builder. A dictionary of node codes is maintained in [NodeBuilder#codes](NodeBuilder#codes)
for this purpose.

**Kind**: global class  

* [NodeCode](#NodeCode)
    * [new NodeCode(name, type, [code])](#new_NodeCode_new)
    * [.name](#NodeCode+name) : <code>string</code>
    * [.type](#NodeCode+type) : <code>string</code>
    * [.code](#NodeCode+code) : <code>string</code>

<a name="new_NodeCode_new"></a>

### new NodeCode(name, type, [code])
Constructs a new code node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the code. |
| type | <code>string</code> |  | The node type. |
| [code] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The native shader code. |

<a name="NodeCode+name"></a>

### nodeCode.name : <code>string</code>
The name of the code.

**Kind**: instance property of [<code>NodeCode</code>](#NodeCode)  
<a name="NodeCode+type"></a>

### nodeCode.type : <code>string</code>
The node type.

**Kind**: instance property of [<code>NodeCode</code>](#NodeCode)  
<a name="NodeCode+code"></a>

### nodeCode.code : <code>string</code>
The native shader code.

**Kind**: instance property of [<code>NodeCode</code>](#NodeCode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="NodeFrame"></a>

## NodeFrame
Management class for updating nodes. The module tracks metrics like
the elapsed time, delta time, the render and frame ID to correctly
call the node update methods [Node#updateBefore](Node#updateBefore), [Node#update](Node#update)
and [Node#updateAfter](Node#updateAfter) depending on the node's configuration.

**Kind**: global class  

* [NodeFrame](#NodeFrame)
    * [new NodeFrame()](#new_NodeFrame_new)
    * [.time](#NodeFrame+time) : <code>number</code>
    * [.deltaTime](#NodeFrame+deltaTime) : <code>number</code>
    * [.frameId](#NodeFrame+frameId) : <code>number</code>
    * [.renderId](#NodeFrame+renderId) : <code>number</code>
    * [.updateMap](#NodeFrame+updateMap) : <code>WeakMap.&lt;Node, Object&gt;</code>
    * [.updateBeforeMap](#NodeFrame+updateBeforeMap) : <code>WeakMap.&lt;Node, Object&gt;</code>
    * [.updateAfterMap](#NodeFrame+updateAfterMap) : <code>WeakMap.&lt;Node, Object&gt;</code>
    * [.renderer](#NodeFrame+renderer) : <code>Renderer</code>
    * [.material](#NodeFrame+material) : <code>Material</code>
    * [.camera](#NodeFrame+camera) : <code>Camera</code>
    * [.object](#NodeFrame+object) : <code>Object3D</code>
    * [.scene](#NodeFrame+scene) : <code>Scene</code>
    * [.updateBeforeNode(node)](#NodeFrame+updateBeforeNode)
    * [.updateAfterNode(node)](#NodeFrame+updateAfterNode)
    * [.updateNode(node)](#NodeFrame+updateNode)
    * [.update()](#NodeFrame+update)

<a name="new_NodeFrame_new"></a>

### new NodeFrame()
Constructs a new node fame.

<a name="NodeFrame+time"></a>

### nodeFrame.time : <code>number</code>
The elapsed time in seconds.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>0</code>  
<a name="NodeFrame+deltaTime"></a>

### nodeFrame.deltaTime : <code>number</code>
The delta time in seconds.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>0</code>  
<a name="NodeFrame+frameId"></a>

### nodeFrame.frameId : <code>number</code>
The frame ID.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>0</code>  
<a name="NodeFrame+renderId"></a>

### nodeFrame.renderId : <code>number</code>
The render ID.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>0</code>  
<a name="NodeFrame+updateMap"></a>

### nodeFrame.updateMap : <code>WeakMap.&lt;Node, Object&gt;</code>
Used to control the [Node#update](Node#update) call.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
<a name="NodeFrame+updateBeforeMap"></a>

### nodeFrame.updateBeforeMap : <code>WeakMap.&lt;Node, Object&gt;</code>
Used to control the [Node#updateBefore](Node#updateBefore) call.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
<a name="NodeFrame+updateAfterMap"></a>

### nodeFrame.updateAfterMap : <code>WeakMap.&lt;Node, Object&gt;</code>
Used to control the [Node#updateAfter](Node#updateAfter) call.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
<a name="NodeFrame+renderer"></a>

### nodeFrame.renderer : <code>Renderer</code>
A reference to the current renderer.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+material"></a>

### nodeFrame.material : <code>Material</code>
A reference to the current material.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+camera"></a>

### nodeFrame.camera : <code>Camera</code>
A reference to the current camera.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+object"></a>

### nodeFrame.object : <code>Object3D</code>
A reference to the current 3D object.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+scene"></a>

### nodeFrame.scene : <code>Scene</code>
A reference to the current scene.

**Kind**: instance property of [<code>NodeFrame</code>](#NodeFrame)  
**Default**: <code>null</code>  
<a name="NodeFrame+updateBeforeNode"></a>

### nodeFrame.updateBeforeNode(node)
This method executes the [Node#updateBefore](Node#updateBefore) for the given node.
It makes sure [Node#updateBeforeType](Node#updateBeforeType) is honored meaning the update
is only executed once per frame, render or object depending on the update
type.

**Kind**: instance method of [<code>NodeFrame</code>](#NodeFrame)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that should be updated. |

<a name="NodeFrame+updateAfterNode"></a>

### nodeFrame.updateAfterNode(node)
This method executes the [Node#updateAfter](Node#updateAfter) for the given node.
It makes sure [Node#updateAfterType](Node#updateAfterType) is honored meaning the update
is only executed once per frame, render or object depending on the update
type.

**Kind**: instance method of [<code>NodeFrame</code>](#NodeFrame)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that should be updated. |

<a name="NodeFrame+updateNode"></a>

### nodeFrame.updateNode(node)
This method executes the [Node#update](Node#update) for the given node.
It makes sure [Node#updateType](Node#updateType) is honored meaning the update
is only executed once per frame, render or object depending on the update
type.

**Kind**: instance method of [<code>NodeFrame</code>](#NodeFrame)  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that should be updated. |

<a name="NodeFrame+update"></a>

### nodeFrame.update()
Updates the internal state of the node frame. This method is
called by the renderer in its internal animation loop.

**Kind**: instance method of [<code>NodeFrame</code>](#NodeFrame)  
<a name="NodeFunction"></a>

## NodeFunction
Base class for node functions. A derived module must be implemented
for each supported native shader language. Similar to other `Node*` modules,
this class is only relevant during the building process and not used
in user-level code.

**Kind**: global class  

* [NodeFunction](#NodeFunction)
    * [new NodeFunction(type, inputs, [name], [precision])](#new_NodeFunction_new)
    * [.type](#NodeFunction+type) : <code>string</code>
    * [.inputs](#NodeFunction+inputs) : <code>Array.&lt;NodeFunctionInput&gt;</code>
    * [.name](#NodeFunction+name) : <code>string</code>
    * [.precision](#NodeFunction+precision) : <code>string</code>
    * *[.getCode(name)](#NodeFunction+getCode) ⇒ <code>string</code>*

<a name="new_NodeFunction_new"></a>

### new NodeFunction(type, inputs, [name], [precision])
Constructs a new node function.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The node type. This type is the return type of the node function. |
| inputs | <code>Array.&lt;NodeFunctionInput&gt;</code> |  | The function's inputs. |
| [name] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The function's name. |
| [precision] | <code>string</code> | <code>&quot;&#x27;&#x27;&quot;</code> | The precision qualifier. |

<a name="NodeFunction+type"></a>

### nodeFunction.type : <code>string</code>
The node type. This type is the return type of the node function.

**Kind**: instance property of [<code>NodeFunction</code>](#NodeFunction)  
<a name="NodeFunction+inputs"></a>

### nodeFunction.inputs : <code>Array.&lt;NodeFunctionInput&gt;</code>
The function's inputs.

**Kind**: instance property of [<code>NodeFunction</code>](#NodeFunction)  
<a name="NodeFunction+name"></a>

### nodeFunction.name : <code>string</code>
The name of the uniform.

**Kind**: instance property of [<code>NodeFunction</code>](#NodeFunction)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="NodeFunction+precision"></a>

### nodeFunction.precision : <code>string</code>
The precision qualifier.

**Kind**: instance property of [<code>NodeFunction</code>](#NodeFunction)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="NodeFunction+getCode"></a>

### *nodeFunction.getCode(name) ⇒ <code>string</code>*
This method returns the native code of the node function.

**Kind**: instance abstract method of [<code>NodeFunction</code>](#NodeFunction)  
**Returns**: <code>string</code> - A shader code.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The function's name. |

<a name="NodeFunctionInput"></a>

## NodeFunctionInput
Describes the input of a [NodeFunction](NodeFunction).

**Kind**: global class  

* [NodeFunctionInput](#NodeFunctionInput)
    * [new NodeFunctionInput(type, name, [count], [qualifier], [isConst])](#new_NodeFunctionInput_new)
    * [.type](#NodeFunctionInput+type) : <code>string</code>
    * [.name](#NodeFunctionInput+name) : <code>string</code>
    * [.count](#NodeFunctionInput+count) : <code>number</code>
    * [.qualifier](#NodeFunctionInput+qualifier) : <code>&#x27;in&#x27;</code> \| <code>&#x27;out&#x27;</code> \| <code>&#x27;inout&#x27;</code>
    * [.isConst](#NodeFunctionInput+isConst) : <code>boolean</code>

<a name="new_NodeFunctionInput_new"></a>

### new NodeFunctionInput(type, name, [count], [qualifier], [isConst])
Constructs a new node function input.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The input type. |
| name | <code>string</code> |  | The input name. |
| [count] | <code>number</code> | <code></code> | If the input is an Array, count will be the length. |
| [qualifier] | <code>&#x27;in&#x27;</code> \| <code>&#x27;out&#x27;</code> \| <code>&#x27;inout&#x27;</code> | <code>&#x27;&#x27;</code> | The parameter qualifier (only relevant for GLSL). |
| [isConst] | <code>boolean</code> | <code>false</code> | Whether the input uses a const qualifier or not (only relevant for GLSL). |

<a name="NodeFunctionInput+type"></a>

### nodeFunctionInput.type : <code>string</code>
The input type.

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
<a name="NodeFunctionInput+name"></a>

### nodeFunctionInput.name : <code>string</code>
The input name.

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
<a name="NodeFunctionInput+count"></a>

### nodeFunctionInput.count : <code>number</code>
If the input is an Array, count will be the length.

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
**Default**: <code>null</code>  
<a name="NodeFunctionInput+qualifier"></a>

### nodeFunctionInput.qualifier : <code>&#x27;in&#x27;</code> \| <code>&#x27;out&#x27;</code> \| <code>&#x27;inout&#x27;</code>
The parameter qualifier (only relevant for GLSL).

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
**Default**: <code>&#x27;&#x27;</code>  
<a name="NodeFunctionInput+isConst"></a>

### nodeFunctionInput.isConst : <code>boolean</code>
Whether the input uses a const qualifier or not (only relevant for GLSL).

**Kind**: instance property of [<code>NodeFunctionInput</code>](#NodeFunctionInput)  
**Default**: <code>false</code>  
<a name="NodeParser"></a>

## NodeParser
Base class for node parsers. A derived parser must be implemented
for each supported native shader language.

**Kind**: global class  
<a name="NodeParser+parseFunction"></a>

### *nodeParser.parseFunction(source) ⇒ <code>NodeFunction</code>*
The method parses the given native code an returns a node function.

**Kind**: instance abstract method of [<code>NodeParser</code>](#NodeParser)  
**Returns**: <code>NodeFunction</code> - A node function.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The native shader code. |

<a name="NodeUniform"></a>

## NodeUniform
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent the final shader uniforms that are going to be generated
by the builder. A dictionary of node uniforms is maintained in [NodeBuilder#uniforms](NodeBuilder#uniforms)
for this purpose.

**Kind**: global class  

* [NodeUniform](#NodeUniform)
    * [new NodeUniform(name, type, node)](#new_NodeUniform_new)
    * [.isNodeUniform](#NodeUniform+isNodeUniform) : <code>boolean</code>
    * [.name](#NodeUniform+name) : <code>string</code>
    * [.type](#NodeUniform+type) : <code>string</code>
    * [.node](#NodeUniform+node) : <code>UniformNode</code>
    * [.value](#NodeUniform+value) : <code>any</code>
    * [.id](#NodeUniform+id) : <code>number</code>
    * [.groupNode](#NodeUniform+groupNode) : <code>UniformGroupNode</code>

<a name="new_NodeUniform_new"></a>

### new NodeUniform(name, type, node)
Constructs a new node uniform.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the uniform. |
| type | <code>string</code> | The type of the uniform. |
| node | <code>UniformNode</code> | An reference to the node. |

<a name="NodeUniform+isNodeUniform"></a>

### nodeUniform.isNodeUniform : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="NodeUniform+name"></a>

### nodeUniform.name : <code>string</code>
The name of the uniform.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+type"></a>

### nodeUniform.type : <code>string</code>
The type of the uniform.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+node"></a>

### nodeUniform.node : <code>UniformNode</code>
An reference to the node.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+value"></a>

### nodeUniform.value : <code>any</code>
The value of the uniform node.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+id"></a>

### nodeUniform.id : <code>number</code>
The id of the uniform node.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
<a name="NodeUniform+groupNode"></a>

### nodeUniform.groupNode : <code>UniformGroupNode</code>
The uniform node's group.

**Kind**: instance property of [<code>NodeUniform</code>](#NodeUniform)  
## Functions

<dl>
<dt><a href="#hashString">hashString(str)</a> ⇒ <code>number</code></dt>
<dd><p>Computes a hash for the given string.</p>
</dd>
<dt><a href="#hashArray">hashArray(array)</a> ⇒ <code>number</code></dt>
<dd><p>Computes a hash for the given array.</p>
</dd>
<dt><a href="#hash">hash(...params)</a> ⇒ <code>number</code></dt>
<dd><p>Computes a hash for the given list of parameters.</p>
</dd>
<dt><a href="#getCacheKey">getCacheKey(object, [force])</a> ⇒ <code>number</code></dt>
<dd><p>Computes a cache key for the given node.</p>
</dd>
<dt><a href="#getNodeChildren">getNodeChildren(node, [toJSON])</a></dt>
<dd><p>This generator function can be used to iterate over the node children
of the given object.</p>
</dd>
<dt><a href="#getTypeFromLength">getTypeFromLength(length)</a> ⇒ <code>string</code></dt>
<dd><p>Returns the data type for the given the length.</p>
</dd>
<dt><a href="#getTypedArrayFromType">getTypedArrayFromType(type)</a> ⇒ <code>TypedArray</code></dt>
<dd><p>Returns the typed array for the given data type.</p>
</dd>
<dt><a href="#getLengthFromType">getLengthFromType(type)</a> ⇒ <code>number</code></dt>
<dd><p>Returns the length for the given data type.</p>
</dd>
<dt><a href="#getValueType">getValueType(value)</a> ⇒ <code>string</code></dt>
<dd><p>Returns the data type for the given value.</p>
</dd>
<dt><a href="#getValueFromType">getValueFromType(type, ...params)</a> ⇒ <code>any</code></dt>
<dd><p>Returns the value/object for the given data type and parameters.</p>
</dd>
<dt><a href="#getDataFromObject">getDataFromObject(object)</a> ⇒ <code>Object</code></dt>
<dd><p>Gets the object data that can be shared between different rendering steps.</p>
</dd>
<dt><a href="#arrayBufferToBase64">arrayBufferToBase64(arrayBuffer)</a> ⇒ <code>string</code></dt>
<dd><p>Converts the given array buffer to a Base64 string.</p>
</dd>
<dt><a href="#base64ToArrayBuffer">base64ToArrayBuffer(base64)</a> ⇒ <code>ArrayBuffer</code></dt>
<dd><p>Converts the given Base64 string to an array buffer.</p>
</dd>
</dl>

<a name="hashString"></a>

## hashString(str) ⇒ <code>number</code>
Computes a hash for the given string.

**Kind**: global function  
**Returns**: <code>number</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| str | <code>string</code> | The string to be hashed. |

<a name="hashArray"></a>

## hashArray(array) ⇒ <code>number</code>
Computes a hash for the given array.

**Kind**: global function  
**Returns**: <code>number</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| array | <code>Array.&lt;number&gt;</code> | The array to be hashed. |

<a name="hash"></a>

## hash(...params) ⇒ <code>number</code>
Computes a hash for the given list of parameters.

**Kind**: global function  
**Returns**: <code>number</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| ...params | <code>number</code> | A list of parameters. |

<a name="getCacheKey"></a>

## getCacheKey(object, [force]) ⇒ <code>number</code>
Computes a cache key for the given node.

**Kind**: global function  
**Returns**: <code>number</code> - The hash.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object</code> \| <code>Node</code> |  | The object to be hashed. |
| [force] | <code>boolean</code> | <code>false</code> | Whether to force a cache key computation or not. |

<a name="getNodeChildren"></a>

## getNodeChildren(node, [toJSON])
This generator function can be used to iterate over the node children
of the given object.

**Kind**: global function  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Object</code> |  | The object to be hashed. |
| [toJSON] | <code>boolean</code> | <code>false</code> | Whether to return JSON or not. |

<a name="getTypeFromLength"></a>

## getTypeFromLength(length) ⇒ <code>string</code>
Returns the data type for the given the length.

**Kind**: global function  
**Returns**: <code>string</code> - The data type.  

| Param | Type | Description |
| --- | --- | --- |
| length | <code>number</code> | The length. |

<a name="getTypedArrayFromType"></a>

## getTypedArrayFromType(type) ⇒ <code>TypedArray</code>
Returns the typed array for the given data type.

**Kind**: global function  
**Returns**: <code>TypedArray</code> - The typed array.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The data type. |

<a name="getLengthFromType"></a>

## getLengthFromType(type) ⇒ <code>number</code>
Returns the length for the given data type.

**Kind**: global function  
**Returns**: <code>number</code> - The length.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The data type. |

<a name="getValueType"></a>

## getValueType(value) ⇒ <code>string</code>
Returns the data type for the given value.

**Kind**: global function  
**Returns**: <code>string</code> - The data type.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>any</code> | The value. |

<a name="getValueFromType"></a>

## getValueFromType(type, ...params) ⇒ <code>any</code>
Returns the value/object for the given data type and parameters.

**Kind**: global function  
**Returns**: <code>any</code> - The value/object.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The given type. |
| ...params | <code>any</code> | A parameter list. |

<a name="getDataFromObject"></a>

## getDataFromObject(object) ⇒ <code>Object</code>
Gets the object data that can be shared between different rendering steps.

**Kind**: global function  
**Returns**: <code>Object</code> - The object data.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object</code> | The object to get the data for. |

<a name="arrayBufferToBase64"></a>

## arrayBufferToBase64(arrayBuffer) ⇒ <code>string</code>
Converts the given array buffer to a Base64 string.

**Kind**: global function  
**Returns**: <code>string</code> - The Base64 string.  

| Param | Type | Description |
| --- | --- | --- |
| arrayBuffer | <code>ArrayBuffer</code> | The array buffer. |

<a name="base64ToArrayBuffer"></a>

## base64ToArrayBuffer(base64) ⇒ <code>ArrayBuffer</code>
Converts the given Base64 string to an array buffer.

**Kind**: global function  
**Returns**: <code>ArrayBuffer</code> - The array buffer.  

| Param | Type | Description |
| --- | --- | --- |
| base64 | <code>string</code> | The Base64 string. |

<a name="NodeVar"></a>

## NodeVar
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent the final shader variables that are going to be generated
by the builder. A dictionary of node variables is maintained in [NodeBuilder#vars](NodeBuilder#vars) for
this purpose.

**Kind**: global class  

* [NodeVar](#NodeVar)
    * [new NodeVar(name, type, [readOnly], [count])](#new_NodeVar_new)
    * [.isNodeVar](#NodeVar+isNodeVar) : <code>boolean</code>
    * [.name](#NodeVar+name) : <code>string</code>
    * [.type](#NodeVar+type) : <code>string</code>
    * [.readOnly](#NodeVar+readOnly) : <code>boolean</code>
    * [.count](#NodeVar+count) : <code>number</code>

<a name="new_NodeVar_new"></a>

### new NodeVar(name, type, [readOnly], [count])
Constructs a new node variable.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the variable. |
| type | <code>string</code> |  | The type of the variable. |
| [readOnly] | <code>boolean</code> | <code>false</code> | The read-only flag. |
| [count] | <code>number</code> | <code></code> | The size. |

<a name="NodeVar+isNodeVar"></a>

### nodeVar.isNodeVar : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="NodeVar+name"></a>

### nodeVar.name : <code>string</code>
The name of the variable.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
<a name="NodeVar+type"></a>

### nodeVar.type : <code>string</code>
The type of the variable.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
<a name="NodeVar+readOnly"></a>

### nodeVar.readOnly : <code>boolean</code>
The read-only flag.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
<a name="NodeVar+count"></a>

### nodeVar.count : <code>number</code>
The size.

**Kind**: instance property of [<code>NodeVar</code>](#NodeVar)  
<a name="NodeVarying"></a>

## NodeVarying ⇐ <code>NodeVar</code>
[NodeBuilder](NodeBuilder) is going to create instances of this class during the build process
of nodes. They represent the final shader varyings that are going to be generated
by the builder. An array of node varyings is maintained in [NodeBuilder#varyings](NodeBuilder#varyings) for
this purpose.

**Kind**: global class  
**Extends**: <code>NodeVar</code>  

* [NodeVarying](#NodeVarying) ⇐ <code>NodeVar</code>
    * [new NodeVarying(name, type)](#new_NodeVarying_new)
    * [.needsInterpolation](#NodeVarying+needsInterpolation) : <code>boolean</code>
    * [.isNodeVarying](#NodeVarying+isNodeVarying) : <code>boolean</code>

<a name="new_NodeVarying_new"></a>

### new NodeVarying(name, type)
Constructs a new node varying.


| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the varying. |
| type | <code>string</code> | The type of the varying. |

<a name="NodeVarying+needsInterpolation"></a>

### nodeVarying.needsInterpolation : <code>boolean</code>
Whether this varying requires interpolation or not. This property can be used
to check if the varying can be optimized for a variable.

**Kind**: instance property of [<code>NodeVarying</code>](#NodeVarying)  
**Default**: <code>false</code>  
<a name="NodeVarying+isNodeVarying"></a>

### nodeVarying.isNodeVarying : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>NodeVarying</code>](#NodeVarying)  
**Default**: <code>true</code>  
**Read only**: true  
## Classes

<dl>
<dt><a href="#OutputStructNode">OutputStructNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used to define multiple outputs in a shader programs.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#outputStruct">outputStruct(...members)</a> ⇒ <code><a href="#OutputStructNode">OutputStructNode</a></code></dt>
<dd><p>TSL function for creating an output struct node.</p>
</dd>
</dl>

<a name="OutputStructNode"></a>

## OutputStructNode ⇐ <code>Node</code>
This node can be used to define multiple outputs in a shader programs.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [OutputStructNode](#OutputStructNode) ⇐ <code>Node</code>
    * [new OutputStructNode(...members)](#new_OutputStructNode_new)
    * [.members](#OutputStructNode+members) : <code>Array.&lt;Node&gt;</code>
    * [.isOutputStructNode](#OutputStructNode+isOutputStructNode) : <code>boolean</code>

<a name="new_OutputStructNode_new"></a>

### new OutputStructNode(...members)
Constructs a new output struct node. The constructor can be invoked with an
arbitrary number of nodes representing the members.


| Param | Type | Description |
| --- | --- | --- |
| ...members | <code>Node</code> | A parameter list of nodes. |

<a name="OutputStructNode+members"></a>

### outputStructNode.members : <code>Array.&lt;Node&gt;</code>
An array of nodes which defines the output.

**Kind**: instance property of [<code>OutputStructNode</code>](#OutputStructNode)  
<a name="OutputStructNode+isOutputStructNode"></a>

### outputStructNode.isOutputStructNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>OutputStructNode</code>](#OutputStructNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="outputStruct"></a>

## outputStruct(...members) ⇒ [<code>OutputStructNode</code>](#OutputStructNode)
TSL function for creating an output struct node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...members | <code>Node</code> | A parameter list of nodes. |

## Classes

<dl>
<dt><a href="#ParameterNode">ParameterNode</a> ⇐ <code>PropertyNode</code></dt>
<dd><p>Special version of <a href="PropertyNode">PropertyNode</a> which is used for parameters.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#parameter">parameter(type, name)</a> ⇒ <code><a href="#ParameterNode">ParameterNode</a></code></dt>
<dd><p>TSL function for creating a parameter node.</p>
</dd>
</dl>

<a name="ParameterNode"></a>

## ParameterNode ⇐ <code>PropertyNode</code>
Special version of [PropertyNode](PropertyNode) which is used for parameters.

**Kind**: global class  
**Extends**: <code>PropertyNode</code>  

* [ParameterNode](#ParameterNode) ⇐ <code>PropertyNode</code>
    * [new ParameterNode(nodeType, [name])](#new_ParameterNode_new)
    * [.isParameterNode](#ParameterNode+isParameterNode) : <code>boolean</code>

<a name="new_ParameterNode_new"></a>

### new ParameterNode(nodeType, [name])
Constructs a new parameter node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> |  | The type of the node. |
| [name] | <code>string</code> | <code>null</code> | The name of the parameter in the shader. |

<a name="ParameterNode+isParameterNode"></a>

### parameterNode.isParameterNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ParameterNode</code>](#ParameterNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="parameter"></a>

## parameter(type, name) ⇒ [<code>ParameterNode</code>](#ParameterNode)
TSL function for creating a parameter node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| type | <code>string</code> | The type of the node. |
| name | <code>string</code> | The name of the parameter in the shader. |

## Classes

<dl>
<dt><a href="#PropertyNode">PropertyNode</a> ⇐ <code>Node</code></dt>
<dd><p>This class represents a shader property. It can be used
to explicitly define a property and assign a value to it.</p>
<pre><code class="language-js">const threshold = property( &#39;float&#39;, &#39;threshold&#39; ).assign( THRESHOLD );
</code></pre>
<p><code>PropertyNode</code> is used by the engine to predefined common material properties
for TSL code.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#diffuseColor">diffuseColor</a> : <code>PropertyNode.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>DiffuseColor</code>.</p>
</dd>
<dt><a href="#emissive">emissive</a> : <code>PropertyNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>EmissiveColor</code>.</p>
</dd>
<dt><a href="#roughness">roughness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Roughness</code>.</p>
</dd>
<dt><a href="#metalness">metalness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Metalness</code>.</p>
</dd>
<dt><a href="#clearcoat">clearcoat</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Clearcoat</code>.</p>
</dd>
<dt><a href="#clearcoatRoughness">clearcoatRoughness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>ClearcoatRoughness</code>.</p>
</dd>
<dt><a href="#sheen">sheen</a> : <code>PropertyNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Sheen</code>.</p>
</dd>
<dt><a href="#sheenRoughness">sheenRoughness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>SheenRoughness</code>.</p>
</dd>
<dt><a href="#iridescence">iridescence</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Iridescence</code>.</p>
</dd>
<dt><a href="#iridescenceIOR">iridescenceIOR</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>IridescenceIOR</code>.</p>
</dd>
<dt><a href="#iridescenceThickness">iridescenceThickness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>IridescenceThickness</code>.</p>
</dd>
<dt><a href="#alphaT">alphaT</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AlphaT</code>.</p>
</dd>
<dt><a href="#anisotropy">anisotropy</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Anisotropy</code>.</p>
</dd>
<dt><a href="#anisotropyT">anisotropyT</a> : <code>PropertyNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AnisotropyT</code>.</p>
</dd>
<dt><a href="#anisotropyB">anisotropyB</a> : <code>PropertyNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AnisotropyB</code>.</p>
</dd>
<dt><a href="#specularColor">specularColor</a> : <code>PropertyNode.&lt;color&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>SpecularColor</code>.</p>
</dd>
<dt><a href="#specularF90">specularF90</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>SpecularF90</code>.</p>
</dd>
<dt><a href="#shininess">shininess</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Shininess</code>.</p>
</dd>
<dt><a href="#output">output</a> : <code>PropertyNode.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Output</code>.</p>
</dd>
<dt><a href="#dashSize">dashSize</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>dashSize</code>.</p>
</dd>
<dt><a href="#gapSize">gapSize</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>gapSize</code>.</p>
</dd>
<dt><a href="#pointWidth">pointWidth</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>pointWidth</code>.</p>
</dd>
<dt><a href="#ior">ior</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>IOR</code>.</p>
</dd>
<dt><a href="#transmission">transmission</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Transmission</code>.</p>
</dd>
<dt><a href="#thickness">thickness</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Thickness</code>.</p>
</dd>
<dt><a href="#attenuationDistance">attenuationDistance</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AttenuationDistance</code>.</p>
</dd>
<dt><a href="#attenuationColor">attenuationColor</a> : <code>PropertyNode.&lt;color&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>AttenuationColor</code>.</p>
</dd>
<dt><a href="#dispersion">dispersion</a> : <code>PropertyNode.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the shader variable <code>Dispersion</code>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#property">property(type, [name])</a> ⇒ <code><a href="#PropertyNode">PropertyNode</a></code></dt>
<dd><p>TSL function for creating a property node.</p>
</dd>
<dt><a href="#varyingProperty">varyingProperty(type, [name])</a> ⇒ <code><a href="#PropertyNode">PropertyNode</a></code></dt>
<dd><p>TSL function for creating a varying property node.</p>
</dd>
</dl>

<a name="PropertyNode"></a>

## PropertyNode ⇐ <code>Node</code>
This class represents a shader property. It can be used
to explicitly define a property and assign a value to it.

```js
const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );
```
`PropertyNode` is used by the engine to predefined common material properties
for TSL code.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [PropertyNode](#PropertyNode) ⇐ <code>Node</code>
    * [new PropertyNode(nodeType, [name], [varying])](#new_PropertyNode_new)
    * [.name](#PropertyNode+name) : <code>string</code>
    * [.varying](#PropertyNode+varying) : <code>boolean</code>
    * [.isPropertyNode](#PropertyNode+isPropertyNode) : <code>boolean</code>
    * [.isGlobal(builder)](#PropertyNode+isGlobal) ⇒ <code>boolean</code>

<a name="new_PropertyNode_new"></a>

### new PropertyNode(nodeType, [name], [varying])
Constructs a new property node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> |  | The type of the node. |
| [name] | <code>string</code> | <code>null</code> | The name of the property in the shader. |
| [varying] | <code>boolean</code> | <code>false</code> | Whether this property is a varying or not. |

<a name="PropertyNode+name"></a>

### propertyNode.name : <code>string</code>
The name of the property in the shader. If no name is defined,
the node system auto-generates one.

**Kind**: instance property of [<code>PropertyNode</code>](#PropertyNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="PropertyNode+varying"></a>

### propertyNode.varying : <code>boolean</code>
Whether this property is a varying or not.

**Kind**: instance property of [<code>PropertyNode</code>](#PropertyNode)  
**Default**: <code>false</code>  
<a name="PropertyNode+isPropertyNode"></a>

### propertyNode.isPropertyNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PropertyNode</code>](#PropertyNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PropertyNode+isGlobal"></a>

### propertyNode.isGlobal(builder) ⇒ <code>boolean</code>
The method is overwritten so it always returns `true`.

**Kind**: instance method of [<code>PropertyNode</code>](#PropertyNode)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="diffuseColor"></a>

## diffuseColor : <code>PropertyNode.&lt;vec4&gt;</code>
TSL object that represents the shader variable `DiffuseColor`.

**Kind**: global constant  
**Tsl**:   
<a name="emissive"></a>

## emissive : <code>PropertyNode.&lt;vec3&gt;</code>
TSL object that represents the shader variable `EmissiveColor`.

**Kind**: global constant  
**Tsl**:   
<a name="roughness"></a>

## roughness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Roughness`.

**Kind**: global constant  
**Tsl**:   
<a name="metalness"></a>

## metalness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Metalness`.

**Kind**: global constant  
**Tsl**:   
<a name="clearcoat"></a>

## clearcoat : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Clearcoat`.

**Kind**: global constant  
**Tsl**:   
<a name="clearcoatRoughness"></a>

## clearcoatRoughness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `ClearcoatRoughness`.

**Kind**: global constant  
**Tsl**:   
<a name="sheen"></a>

## sheen : <code>PropertyNode.&lt;vec3&gt;</code>
TSL object that represents the shader variable `Sheen`.

**Kind**: global constant  
**Tsl**:   
<a name="sheenRoughness"></a>

## sheenRoughness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `SheenRoughness`.

**Kind**: global constant  
**Tsl**:   
<a name="iridescence"></a>

## iridescence : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Iridescence`.

**Kind**: global constant  
**Tsl**:   
<a name="iridescenceIOR"></a>

## iridescenceIOR : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `IridescenceIOR`.

**Kind**: global constant  
**Tsl**:   
<a name="iridescenceThickness"></a>

## iridescenceThickness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `IridescenceThickness`.

**Kind**: global constant  
**Tsl**:   
<a name="alphaT"></a>

## alphaT : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `AlphaT`.

**Kind**: global constant  
**Tsl**:   
<a name="anisotropy"></a>

## anisotropy : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Anisotropy`.

**Kind**: global constant  
**Tsl**:   
<a name="anisotropyT"></a>

## anisotropyT : <code>PropertyNode.&lt;vec3&gt;</code>
TSL object that represents the shader variable `AnisotropyT`.

**Kind**: global constant  
**Tsl**:   
<a name="anisotropyB"></a>

## anisotropyB : <code>PropertyNode.&lt;vec3&gt;</code>
TSL object that represents the shader variable `AnisotropyB`.

**Kind**: global constant  
**Tsl**:   
<a name="specularColor"></a>

## specularColor : <code>PropertyNode.&lt;color&gt;</code>
TSL object that represents the shader variable `SpecularColor`.

**Kind**: global constant  
**Tsl**:   
<a name="specularF90"></a>

## specularF90 : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `SpecularF90`.

**Kind**: global constant  
**Tsl**:   
<a name="shininess"></a>

## shininess : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Shininess`.

**Kind**: global constant  
**Tsl**:   
<a name="output"></a>

## output : <code>PropertyNode.&lt;vec4&gt;</code>
TSL object that represents the shader variable `Output`.

**Kind**: global constant  
**Tsl**:   
<a name="dashSize"></a>

## dashSize : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `dashSize`.

**Kind**: global constant  
**Tsl**:   
<a name="gapSize"></a>

## gapSize : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `gapSize`.

**Kind**: global constant  
**Tsl**:   
<a name="pointWidth"></a>

## pointWidth : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `pointWidth`.

**Kind**: global constant  
**Tsl**:   
<a name="ior"></a>

## ior : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `IOR`.

**Kind**: global constant  
**Tsl**:   
<a name="transmission"></a>

## transmission : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Transmission`.

**Kind**: global constant  
**Tsl**:   
<a name="thickness"></a>

## thickness : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Thickness`.

**Kind**: global constant  
**Tsl**:   
<a name="attenuationDistance"></a>

## attenuationDistance : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `AttenuationDistance`.

**Kind**: global constant  
**Tsl**:   
<a name="attenuationColor"></a>

## attenuationColor : <code>PropertyNode.&lt;color&gt;</code>
TSL object that represents the shader variable `AttenuationColor`.

**Kind**: global constant  
**Tsl**:   
<a name="dispersion"></a>

## dispersion : <code>PropertyNode.&lt;float&gt;</code>
TSL object that represents the shader variable `Dispersion`.

**Kind**: global constant  
**Tsl**:   
<a name="property"></a>

## property(type, [name]) ⇒ [<code>PropertyNode</code>](#PropertyNode)
TSL function for creating a property node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type of the node. |
| [name] | <code>string</code> | <code>null</code> | The name of the property in the shader. |

<a name="varyingProperty"></a>

## varyingProperty(type, [name]) ⇒ [<code>PropertyNode</code>](#PropertyNode)
TSL function for creating a varying property node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The type of the node. |
| [name] | <code>string</code> | <code>null</code> | The name of the varying in the shader. |

## Classes

<dl>
<dt><a href="#StackNode">StackNode</a> ⇐ <code>Node</code></dt>
<dd><p>Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
They are usually needed in cases like <code>If</code>, <code>Else</code>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#stack">stack([parent])</a> ⇒ <code><a href="#StackNode">StackNode</a></code></dt>
<dd><p>TSL function for creating a stack node.</p>
</dd>
</dl>

<a name="StackNode"></a>

## StackNode ⇐ <code>Node</code>
Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
They are usually needed in cases like `If`, `Else`.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [StackNode](#StackNode) ⇐ <code>Node</code>
    * [new StackNode([parent])](#new_StackNode_new)
    * [.nodes](#StackNode+nodes) : <code>Array.&lt;Node&gt;</code>
    * [.outputNode](#StackNode+outputNode) : <code>Node</code>
    * [.parent](#StackNode+parent) : [<code>StackNode</code>](#StackNode)
    * [.isStackNode](#StackNode+isStackNode) : <code>boolean</code>
    * [.add(node)](#StackNode+add) ⇒ [<code>StackNode</code>](#StackNode)
    * [.If(boolNode, method)](#StackNode+If) ⇒ [<code>StackNode</code>](#StackNode)
    * [.ElseIf(boolNode, method)](#StackNode+ElseIf) ⇒ [<code>StackNode</code>](#StackNode)
    * [.Else(method)](#StackNode+Else) ⇒ [<code>StackNode</code>](#StackNode)
    * ~~[.else(...params)](#StackNode+else) ⇒ [<code>StackNode</code>](#StackNode)~~
    * ~~[.elseif(...params)](#StackNode+elseif) ⇒ [<code>StackNode</code>](#StackNode)~~

<a name="new_StackNode_new"></a>

### new StackNode([parent])
Constructs a new stack node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parent] | [<code>StackNode</code>](#StackNode) | <code></code> | The parent stack node. |

<a name="StackNode+nodes"></a>

### stackNode.nodes : <code>Array.&lt;Node&gt;</code>
List of nodes.

**Kind**: instance property of [<code>StackNode</code>](#StackNode)  
<a name="StackNode+outputNode"></a>

### stackNode.outputNode : <code>Node</code>
The output node.

**Kind**: instance property of [<code>StackNode</code>](#StackNode)  
**Default**: <code>null</code>  
<a name="StackNode+parent"></a>

### stackNode.parent : [<code>StackNode</code>](#StackNode)
The parent stack node.

**Kind**: instance property of [<code>StackNode</code>](#StackNode)  
**Default**: <code>null</code>  
<a name="StackNode+isStackNode"></a>

### stackNode.isStackNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StackNode</code>](#StackNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StackNode+add"></a>

### stackNode.add(node) ⇒ [<code>StackNode</code>](#StackNode)
Adds a node to this stack.

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  
**Returns**: [<code>StackNode</code>](#StackNode) - A reference to this stack node.  

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node to add. |

<a name="StackNode+If"></a>

### stackNode.If(boolNode, method) ⇒ [<code>StackNode</code>](#StackNode)
Represent an `if` statement in TSL.

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  
**Returns**: [<code>StackNode</code>](#StackNode) - A reference to this stack node.  

| Param | Type | Description |
| --- | --- | --- |
| boolNode | <code>Node</code> | Represents the condition. |
| method | <code>function</code> | TSL code which is executed if the condition evaluates to `true`. |

<a name="StackNode+ElseIf"></a>

### stackNode.ElseIf(boolNode, method) ⇒ [<code>StackNode</code>](#StackNode)
Represent an `elseif` statement in TSL.

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  
**Returns**: [<code>StackNode</code>](#StackNode) - A reference to this stack node.  

| Param | Type | Description |
| --- | --- | --- |
| boolNode | <code>Node</code> | Represents the condition. |
| method | <code>function</code> | TSL code which is executed if the condition evaluates to `true`. |

<a name="StackNode+Else"></a>

### stackNode.Else(method) ⇒ [<code>StackNode</code>](#StackNode)
Represent an `else` statement in TSL.

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  
**Returns**: [<code>StackNode</code>](#StackNode) - A reference to this stack node.  

| Param | Type | Description |
| --- | --- | --- |
| method | <code>function</code> | TSL code which is executed in the `else` case. |

<a name="StackNode+else"></a>

### ~~stackNode.else(...params) ⇒ [<code>StackNode</code>](#StackNode)~~
***since r168. Use [Else](#StackNode+Else) instead.***

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="StackNode+elseif"></a>

### ~~stackNode.elseif(...params) ⇒ [<code>StackNode</code>](#StackNode)~~
***since r168. Use [ElseIf](#StackNode+ElseIf) instead.***

**Kind**: instance method of [<code>StackNode</code>](#StackNode)  

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="stack"></a>

## stack([parent]) ⇒ [<code>StackNode</code>](#StackNode)
TSL function for creating a stack node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [parent] | [<code>StackNode</code>](#StackNode) | <code></code> | The parent stack node. |

## Classes

<dl>
<dt><a href="#StructNode">StructNode</a> ⇐ <code>Node</code></dt>
<dd><p>StructNode allows to create custom structures with multiple members.
This can also be used to define structures in attribute and uniform data.</p>
<pre><code class="language-js">// Define a custom struct
const BoundingBox = struct( { min: &#39;vec3&#39;, max: &#39;vec3&#39; } );

// Create a new instance of the struct
const bb = BoundingBox( vec3( 0 ), vec3( 1 ) ); // style 1
const bb = BoundingBox( { min: vec3( 0 ), max: vec3( 1 ) } ); // style 2

// Access the struct members
const min = bb.get( &#39;min&#39; );

// Assign a new value to a member
min.assign( vec3() );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#struct">struct(membersLayout, [name])</a> ⇒ <code>function</code></dt>
<dd><p>TSL function for creating a struct node.</p>
</dd>
</dl>

<a name="StructNode"></a>

## StructNode ⇐ <code>Node</code>
StructNode allows to create custom structures with multiple members.
This can also be used to define structures in attribute and uniform data.

```js
// Define a custom struct
const BoundingBox = struct( { min: 'vec3', max: 'vec3' } );

// Create a new instance of the struct
const bb = BoundingBox( vec3( 0 ), vec3( 1 ) ); // style 1
const bb = BoundingBox( { min: vec3( 0 ), max: vec3( 1 ) } ); // style 2

// Access the struct members
const min = bb.get( 'min' );

// Assign a new value to a member
min.assign( vec3() );
```

**Kind**: global class  
**Extends**: <code>Node</code>  
<a name="struct"></a>

## struct(membersLayout, [name]) ⇒ <code>function</code>
TSL function for creating a struct node.

**Kind**: global function  
**Returns**: <code>function</code> - The struct function.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| membersLayout | <code>Object</code> |  | The layout of the struct members. |
| [name] | <code>string</code> | <code>null</code> | The name of the struct. |

## Classes

<dl>
<dt><a href="#StructTypeNode">StructTypeNode</a> ⇐ <code>Node</code></dt>
<dd><p>Represents a struct type node in the node-based system.
This class is used to define and manage the layout and types of struct members.
It extends the base Node class and provides methods to get the length of the struct,
retrieve member types, and generate the struct type for a builder.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#getMembersLayout">getMembersLayout(members)</a> ⇒ <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code></dt>
<dd><p>Generates a layout for struct members.
This function takes an object representing struct members and returns an array of member layouts.
Each member layout includes the member&#39;s name, type, and whether it is atomic.</p>
</dd>
</dl>

<a name="StructTypeNode"></a>

## StructTypeNode ⇐ <code>Node</code>
Represents a struct type node in the node-based system.
This class is used to define and manage the layout and types of struct members.
It extends the base Node class and provides methods to get the length of the struct,
retrieve member types, and generate the struct type for a builder.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [StructTypeNode](#StructTypeNode) ⇐ <code>Node</code>
    * [new StructTypeNode(membersLayout, [name])](#new_StructTypeNode_new)
    * [.membersLayout](#StructTypeNode+membersLayout) : <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code>
    * [.name](#StructTypeNode+name) : <code>string</code>
    * [.isStructLayoutNode](#StructTypeNode+isStructLayoutNode) : <code>boolean</code>
    * [.getLength()](#StructTypeNode+getLength) ⇒ <code>number</code>

<a name="new_StructTypeNode_new"></a>

### new StructTypeNode(membersLayout, [name])
Creates an instance of StructTypeNode.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| membersLayout | <code>Object</code> |  | The layout of the members for the struct. |
| [name] | <code>string</code> | <code>null</code> | The optional name of the struct. |

<a name="StructTypeNode+membersLayout"></a>

### structTypeNode.membersLayout : <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code>
The layout of the members for the struct

**Kind**: instance property of [<code>StructTypeNode</code>](#StructTypeNode)  
<a name="StructTypeNode+name"></a>

### structTypeNode.name : <code>string</code>
The name of the struct.

**Kind**: instance property of [<code>StructTypeNode</code>](#StructTypeNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="StructTypeNode+isStructLayoutNode"></a>

### structTypeNode.isStructLayoutNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StructTypeNode</code>](#StructTypeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StructTypeNode+getLength"></a>

### structTypeNode.getLength() ⇒ <code>number</code>
Returns the length of the struct.
The length is calculated by summing the lengths of the struct's members.

**Kind**: instance method of [<code>StructTypeNode</code>](#StructTypeNode)  
**Returns**: <code>number</code> - The length of the struct.  
<a name="getMembersLayout"></a>

## getMembersLayout(members) ⇒ <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code>
Generates a layout for struct members.
This function takes an object representing struct members and returns an array of member layouts.
Each member layout includes the member's name, type, and whether it is atomic.

**Kind**: global function  
**Returns**: <code>Array.&lt;{name: string, type: string, atomic: boolean}&gt;</code> - An array of member layouts.  

| Param | Type | Description |
| --- | --- | --- |
| members | <code>Object.&lt;string, (string\|Object)&gt;</code> | An object where keys are member names and values are either types (as strings) or objects with type and atomic properties. |

<a name="TempNode"></a>

## TempNode ⇐ <code>Node</code>
This module uses cache management to create temporary variables
if the node is used more than once to prevent duplicate calculations.

The class acts as a base class for many other nodes types.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [TempNode](#TempNode) ⇐ <code>Node</code>
    * [new TempNode(nodeType)](#new_TempNode_new)
    * [.isTempNode](#TempNode+isTempNode) : <code>boolean</code>
    * [.hasDependencies(builder)](#TempNode+hasDependencies) ⇒ <code>boolean</code>

<a name="new_TempNode_new"></a>

### new TempNode(nodeType)
Constructs a temp node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| nodeType | <code>string</code> | <code>null</code> | The node type. |

<a name="TempNode+isTempNode"></a>

### tempNode.isTempNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>TempNode</code>](#TempNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TempNode+hasDependencies"></a>

### tempNode.hasDependencies(builder) ⇒ <code>boolean</code>
Whether this node is used more than once in context of other nodes.

**Kind**: instance method of [<code>TempNode</code>](#TempNode)  
**Returns**: <code>boolean</code> - A flag that indicates if there is more than one dependency to other nodes.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The node builder. |

## Classes

<dl>
<dt><a href="#UniformGroupNode">UniformGroupNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used to group single instances of <a href="UniformNode">UniformNode</a>
and manage them as a uniform buffer.</p>
<p>In most cases, the predefined nodes <code>objectGroup</code>, <code>renderGroup</code> and <code>frameGroup</code>
will be used when defining the <a href="UniformNode#groupNode">UniformNode#groupNode</a> property.</p>
<ul>
<li><code>objectGroup</code>: Uniform buffer per object.</li>
<li><code>renderGroup</code>: Shared uniform buffer, updated once per render call.</li>
<li><code>frameGroup</code>: Shared uniform buffer, updated once per frame.</li>
</ul>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#frameGroup">frameGroup</a> : <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL object that represents a shared uniform group node which is updated once per frame.</p>
</dd>
<dt><a href="#renderGroup">renderGroup</a> : <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL object that represents a shared uniform group node which is updated once per render.</p>
</dd>
<dt><a href="#objectGroup">objectGroup</a> : <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL object that represents a uniform group node which is updated once per object.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#uniformGroup">uniformGroup(name)</a> ⇒ <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL function for creating a uniform group node with the given name.</p>
</dd>
<dt><a href="#sharedUniformGroup">sharedUniformGroup(name, [order])</a> ⇒ <code><a href="#UniformGroupNode">UniformGroupNode</a></code></dt>
<dd><p>TSL function for creating a shared uniform group node with the given name and order.</p>
</dd>
</dl>

<a name="UniformGroupNode"></a>

## UniformGroupNode ⇐ <code>Node</code>
This node can be used to group single instances of [UniformNode](UniformNode)
and manage them as a uniform buffer.

In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`
will be used when defining the [UniformNode#groupNode](UniformNode#groupNode) property.

- `objectGroup`: Uniform buffer per object.
- `renderGroup`: Shared uniform buffer, updated once per render call.
- `frameGroup`: Shared uniform buffer, updated once per frame.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [UniformGroupNode](#UniformGroupNode) ⇐ <code>Node</code>
    * [new UniformGroupNode(name, [shared], [order])](#new_UniformGroupNode_new)
    * [.name](#UniformGroupNode+name) : <code>string</code>
    * [.shared](#UniformGroupNode+shared) : <code>boolean</code>
    * [.order](#UniformGroupNode+order) : <code>number</code>
    * [.isUniformGroup](#UniformGroupNode+isUniformGroup) : <code>boolean</code>

<a name="new_UniformGroupNode_new"></a>

### new UniformGroupNode(name, [shared], [order])
Constructs a new uniform group node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the uniform group node. |
| [shared] | <code>boolean</code> | <code>false</code> | Whether this uniform group node is shared or not. |
| [order] | <code>number</code> | <code>1</code> | Influences the internal sorting. |

<a name="UniformGroupNode+name"></a>

### uniformGroupNode.name : <code>string</code>
The name of the uniform group node.

**Kind**: instance property of [<code>UniformGroupNode</code>](#UniformGroupNode)  
<a name="UniformGroupNode+shared"></a>

### uniformGroupNode.shared : <code>boolean</code>
Whether this uniform group node is shared or not.

**Kind**: instance property of [<code>UniformGroupNode</code>](#UniformGroupNode)  
**Default**: <code>false</code>  
<a name="UniformGroupNode+order"></a>

### uniformGroupNode.order : <code>number</code>
Influences the internal sorting.
TODO: Add details when this property should be changed.

**Kind**: instance property of [<code>UniformGroupNode</code>](#UniformGroupNode)  
**Default**: <code>1</code>  
<a name="UniformGroupNode+isUniformGroup"></a>

### uniformGroupNode.isUniformGroup : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>UniformGroupNode</code>](#UniformGroupNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="frameGroup"></a>

## frameGroup : [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL object that represents a shared uniform group node which is updated once per frame.

**Kind**: global constant  
**Tsl**:   
<a name="renderGroup"></a>

## renderGroup : [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL object that represents a shared uniform group node which is updated once per render.

**Kind**: global constant  
**Tsl**:   
<a name="objectGroup"></a>

## objectGroup : [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL object that represents a uniform group node which is updated once per object.

**Kind**: global constant  
**Tsl**:   
<a name="uniformGroup"></a>

## uniformGroup(name) ⇒ [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL function for creating a uniform group node with the given name.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the uniform group node. |

<a name="sharedUniformGroup"></a>

## sharedUniformGroup(name, [order]) ⇒ [<code>UniformGroupNode</code>](#UniformGroupNode)
TSL function for creating a shared uniform group node with the given name and order.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| name | <code>string</code> |  | The name of the uniform group node. |
| [order] | <code>number</code> | <code>0</code> | Influences the internal sorting. |

## Classes

<dl>
<dt><a href="#UniformNode">UniformNode</a> ⇐ <code>InputNode</code></dt>
<dd><p>Class for representing a uniform.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#uniform">uniform(arg1, [arg2])</a> ⇒ <code><a href="#UniformNode">UniformNode</a></code></dt>
<dd><p>TSL function for creating a uniform node.</p>
</dd>
</dl>

<a name="UniformNode"></a>

## UniformNode ⇐ <code>InputNode</code>
Class for representing a uniform.

**Kind**: global class  
**Extends**: <code>InputNode</code>  

* [UniformNode](#UniformNode) ⇐ <code>InputNode</code>
    * [new UniformNode(value, nodeType)](#new_UniformNode_new)
    * [.isUniformNode](#UniformNode+isUniformNode) : <code>boolean</code>
    * [.name](#UniformNode+name) : <code>string</code>
    * [.groupNode](#UniformNode+groupNode) : <code>UniformGroupNode</code>
    * [.label(name)](#UniformNode+label) ⇒ [<code>UniformNode</code>](#UniformNode)
    * [.setGroup(group)](#UniformNode+setGroup) ⇒ [<code>UniformNode</code>](#UniformNode)
    * [.getGroup()](#UniformNode+getGroup) ⇒ <code>UniformGroupNode</code>
    * [.getUniformHash(builder)](#UniformNode+getUniformHash) ⇒ <code>string</code>

<a name="new_UniformNode_new"></a>

### new UniformNode(value, nodeType)
Constructs a new uniform node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>any</code> |  | The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture). |
| nodeType | <code>string</code> | <code>null</code> | The node type. If no explicit type is defined, the node tries to derive the type from its value. |

<a name="UniformNode+isUniformNode"></a>

### uniformNode.isUniformNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>UniformNode</code>](#UniformNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="UniformNode+name"></a>

### uniformNode.name : <code>string</code>
The name or label of the uniform.

**Kind**: instance property of [<code>UniformNode</code>](#UniformNode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="UniformNode+groupNode"></a>

### uniformNode.groupNode : <code>UniformGroupNode</code>
The uniform group of this uniform. By default, uniforms are
managed per object but they might belong to a shared group
which is updated per frame or render call.

**Kind**: instance property of [<code>UniformNode</code>](#UniformNode)  
<a name="UniformNode+label"></a>

### uniformNode.label(name) ⇒ [<code>UniformNode</code>](#UniformNode)
Sets the [name](#UniformNode+name) property.

**Kind**: instance method of [<code>UniformNode</code>](#UniformNode)  
**Returns**: [<code>UniformNode</code>](#UniformNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the uniform. |

<a name="UniformNode+setGroup"></a>

### uniformNode.setGroup(group) ⇒ [<code>UniformNode</code>](#UniformNode)
Sets the [groupNode](#UniformNode+groupNode) property.

**Kind**: instance method of [<code>UniformNode</code>](#UniformNode)  
**Returns**: [<code>UniformNode</code>](#UniformNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| group | <code>UniformGroupNode</code> | The uniform group. |

<a name="UniformNode+getGroup"></a>

### uniformNode.getGroup() ⇒ <code>UniformGroupNode</code>
Returns the [groupNode](#UniformNode+groupNode).

**Kind**: instance method of [<code>UniformNode</code>](#UniformNode)  
**Returns**: <code>UniformGroupNode</code> - The uniform group.  
<a name="UniformNode+getUniformHash"></a>

### uniformNode.getUniformHash(builder) ⇒ <code>string</code>
By default, this method returns the result of [Node#getHash](Node#getHash) but derived
classes might overwrite this method with a different implementation.

**Kind**: instance method of [<code>UniformNode</code>](#UniformNode)  
**Returns**: <code>string</code> - The uniform hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="uniform"></a>

## uniform(arg1, [arg2]) ⇒ [<code>UniformNode</code>](#UniformNode)
TSL function for creating a uniform node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| arg1 | <code>any</code> | The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture). |
| [arg2] | <code>string</code> | The node type. If no explicit type is defined, the node tries to derive the type from its value. |

## Classes

<dl>
<dt><a href="#VarNode">VarNode</a> ⇐ <code>Node</code></dt>
<dd><p>Class for representing shader variables as nodes. Variables are created from
existing nodes like the following:</p>
<pre><code class="language-js">const depth = sampleDepth( uvNode ).toVar( &#39;depth&#39; );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#createVar">createVar(node, name)</a> ⇒ <code><a href="#VarNode">VarNode</a></code></dt>
<dd><p>TSL function for creating a var node.</p>
</dd>
<dt><a href="#Var">Var(node, name)</a> ⇒ <code><a href="#VarNode">VarNode</a></code></dt>
<dd><p>TSL function for creating a var node.</p>
</dd>
<dt><a href="#Const">Const(node, name)</a> ⇒ <code><a href="#VarNode">VarNode</a></code></dt>
<dd><p>TSL function for creating a const node.</p>
</dd>
<dt><del><a href="#temp">temp(node)</a> ⇒ <code><a href="#VarNode">VarNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="VarNode"></a>

## VarNode ⇐ <code>Node</code>
Class for representing shader variables as nodes. Variables are created from
existing nodes like the following:

```js
const depth = sampleDepth( uvNode ).toVar( 'depth' );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [VarNode](#VarNode) ⇐ <code>Node</code>
    * [new VarNode(node, [name], [readOnly])](#new_VarNode_new)
    * [.node](#VarNode+node) : <code>Node</code>
    * [.name](#VarNode+name) : <code>string</code>
    * [.global](#VarNode+global) : <code>boolean</code>
    * [.isVarNode](#VarNode+isVarNode) : <code>boolean</code>
    * [.readOnly](#VarNode+readOnly) : <code>boolean</code>

<a name="new_VarNode_new"></a>

### new VarNode(node, [name], [readOnly])
Constructs a new variable node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node for which a variable should be created. |
| [name] | <code>string</code> | <code>null</code> | The name of the variable in the shader. |
| [readOnly] | <code>boolean</code> | <code>false</code> | The read-only flag. |

<a name="VarNode+node"></a>

### varNode.node : <code>Node</code>
The node for which a variable should be created.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
<a name="VarNode+name"></a>

### varNode.name : <code>string</code>
The name of the variable in the shader. If no name is defined,
the node system auto-generates one.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="VarNode+global"></a>

### varNode.global : <code>boolean</code>
`VarNode` sets this property to `true` by default.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
**Default**: <code>true</code>  
<a name="VarNode+isVarNode"></a>

### varNode.isVarNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VarNode+readOnly"></a>

### varNode.readOnly : <code>boolean</code>
The read-only flag.

**Kind**: instance property of [<code>VarNode</code>](#VarNode)  
**Default**: <code>false</code>  
<a name="createVar"></a>

## createVar(node, name) ⇒ [<code>VarNode</code>](#VarNode)
TSL function for creating a var node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node for which a variable should be created. |
| name | <code>string</code> | The name of the variable in the shader. |

<a name="Var"></a>

## Var(node, name) ⇒ [<code>VarNode</code>](#VarNode)
TSL function for creating a var node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node for which a variable should be created. |
| name | <code>string</code> | The name of the variable in the shader. |

<a name="Const"></a>

## Const(node, name) ⇒ [<code>VarNode</code>](#VarNode)
TSL function for creating a const node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node for which a constant should be created. |
| name | <code>string</code> | The name of the constant in the shader. |

<a name="temp"></a>

## ~~temp(node) ⇒ [<code>VarNode</code>](#VarNode)~~
***since r170. Use `Var( node )` or `node.toVar()` instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| node | <code>any</code> | 

## Classes

<dl>
<dt><a href="#VaryingNode">VaryingNode</a> ⇐ <code>Node</code></dt>
<dd><p>Class for representing shader varyings as nodes. Varyings are create from
existing nodes like the following:</p>
<pre><code class="language-js">const positionLocal = positionGeometry.toVarying( &#39;vPositionLocal&#39; );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#varying">varying(node, name)</a> ⇒ <code><a href="#VaryingNode">VaryingNode</a></code></dt>
<dd><p>TSL function for creating a varying node.</p>
</dd>
<dt><a href="#vertexStage">vertexStage(node)</a> ⇒ <code><a href="#VaryingNode">VaryingNode</a></code></dt>
<dd><p>Computes a node in the vertex stage.</p>
</dd>
</dl>

<a name="VaryingNode"></a>

## VaryingNode ⇐ <code>Node</code>
Class for representing shader varyings as nodes. Varyings are create from
existing nodes like the following:

```js
const positionLocal = positionGeometry.toVarying( 'vPositionLocal' );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [VaryingNode](#VaryingNode) ⇐ <code>Node</code>
    * [new VaryingNode(node, name)](#new_VaryingNode_new)
    * [.node](#VaryingNode+node) : <code>Node</code>
    * [.name](#VaryingNode+name) : <code>string</code>
    * [.isVaryingNode](#VaryingNode+isVaryingNode) : <code>boolean</code>
    * [.isGlobal(builder)](#VaryingNode+isGlobal) ⇒ <code>boolean</code>
    * [.setupVarying(builder)](#VaryingNode+setupVarying) ⇒ <code>NodeVarying</code>

<a name="new_VaryingNode_new"></a>

### new VaryingNode(node, name)
Constructs a new varying node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | The node for which a varying should be created. |
| name | <code>string</code> | <code>null</code> | The name of the varying in the shader. |

<a name="VaryingNode+node"></a>

### varyingNode.node : <code>Node</code>
The node for which a varying should be created.

**Kind**: instance property of [<code>VaryingNode</code>](#VaryingNode)  
<a name="VaryingNode+name"></a>

### varyingNode.name : <code>string</code>
The name of the varying in the shader. If no name is defined,
the node system auto-generates one.

**Kind**: instance property of [<code>VaryingNode</code>](#VaryingNode)  
**Default**: <code>&quot;null&quot;</code>  
<a name="VaryingNode+isVaryingNode"></a>

### varyingNode.isVaryingNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>VaryingNode</code>](#VaryingNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="VaryingNode+isGlobal"></a>

### varyingNode.isGlobal(builder) ⇒ <code>boolean</code>
The method is overwritten so it always returns `true`.

**Kind**: instance method of [<code>VaryingNode</code>](#VaryingNode)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="VaryingNode+setupVarying"></a>

### varyingNode.setupVarying(builder) ⇒ <code>NodeVarying</code>
This method performs the setup of a varying node with the current node builder.

**Kind**: instance method of [<code>VaryingNode</code>](#VaryingNode)  
**Returns**: <code>NodeVarying</code> - The node varying from the node builder.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="varying"></a>

## varying(node, name) ⇒ [<code>VaryingNode</code>](#VaryingNode)
TSL function for creating a varying node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node for which a varying should be created. |
| name | <code>string</code> | The name of the varying in the shader. |

<a name="vertexStage"></a>

## vertexStage(node) ⇒ [<code>VaryingNode</code>](#VaryingNode)
Computes a node in the vertex stage.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node which should be executed in the vertex stage. |

## Constants

<dl>
<dt><a href="#NodeShaderStage">NodeShaderStage</a></dt>
<dd><p>Possible shader stages.</p>
</dd>
<dt><a href="#NodeUpdateType">NodeUpdateType</a></dt>
<dd><p>Update types of a node.</p>
</dd>
<dt><a href="#NodeType">NodeType</a></dt>
<dd><p>Data types of a node.</p>
</dd>
<dt><a href="#NodeAccess">NodeAccess</a></dt>
<dd><p>Access types of a node. These are relevant for compute and storage usage.</p>
</dd>
</dl>

<a name="NodeShaderStage"></a>

## NodeShaderStage
Possible shader stages.

**Kind**: global constant  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| VERTEX | <code>string</code> | The vertex shader stage. |
| FRAGMENT | <code>string</code> | The fragment shader stage. |

<a name="NodeUpdateType"></a>

## NodeUpdateType
Update types of a node.

**Kind**: global constant  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| NONE | <code>string</code> | The update method is not executed. |
| FRAME | <code>string</code> | The update method is executed per frame. |
| RENDER | <code>string</code> | The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME. |
| OBJECT | <code>string</code> | The update method is executed per [Object3D](Object3D) that uses the node for rendering. |

<a name="NodeType"></a>

## NodeType
Data types of a node.

**Kind**: global constant  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| BOOLEAN | <code>string</code> | Boolean type. |
| INTEGER | <code>string</code> | Integer type. |
| FLOAT | <code>string</code> | Float type. |
| VECTOR2 | <code>string</code> | Two-dimensional vector type. |
| VECTOR3 | <code>string</code> | Three-dimensional vector type. |
| VECTOR4 | <code>string</code> | Four-dimensional vector type. |
| MATRIX2 | <code>string</code> | 2x2 matrix type. |
| MATRIX3 | <code>string</code> | 3x3 matrix type. |
| MATRIX4 | <code>string</code> | 4x4 matrix type. |

<a name="NodeAccess"></a>

## NodeAccess
Access types of a node. These are relevant for compute and storage usage.

**Kind**: global constant  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| READ_ONLY | <code>string</code> | Read-only access |
| WRITE_ONLY | <code>string</code> | Write-only access. |
| READ_WRITE | <code>string</code> | Read and write access. |

## Functions

<dl>
<dt><a href="#blendBurn">blendBurn(base, blend)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Represents a &quot;Color Burn&quot; blend mode.</p>
<p>It&#39;s designed to darken the base layer&#39;s colors based on the color of the blend layer.
It significantly increases the contrast of the base layer, making the colors more vibrant and saturated.
The darker the color in the blend layer, the stronger the darkening and contrast effect on the base layer.</p>
</dd>
<dt><a href="#blendDodge">blendDodge(base, blend)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Represents a &quot;Color Dodge&quot; blend mode.</p>
<p>It&#39;s designed to lighten the base layer&#39;s colors based on the color of the blend layer.
It significantly increases the brightness of the base layer, making the colors lighter and more vibrant.
The brighter the color in the blend layer, the stronger the lightening and contrast effect on the base layer.</p>
</dd>
<dt><a href="#blendScreen">blendScreen(base, blend)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Represents a &quot;Screen&quot; blend mode.</p>
<p>Similar to <code>blendDodge()</code>, this mode also lightens the base layer&#39;s colors based on the color of the blend layer.
The &quot;Screen&quot; blend mode is better for general brightening whereas the &quot;Dodge&quot; results in more subtle and nuanced
effects.</p>
</dd>
<dt><a href="#blendOverlay">blendOverlay(base, blend)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Represents a &quot;Overlay&quot; blend mode.</p>
<p>It&#39;s designed to increase the contrast of the base layer based on the color of the blend layer.
It amplifies the existing colors and contrast in the base layer, making lighter areas lighter and darker areas darker.
The color of the blend layer significantly influences the resulting contrast and color shift in the base layer.</p>
</dd>
<dt><a href="#blendColor">blendColor(base, blend)</a> ⇒ <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>This function blends two color based on their alpha values by replicating the behavior of <code>THREE.NormalBlending</code>.
It assumes both input colors have non-premultiplied alpha.</p>
</dd>
<dt><del><a href="#burn">burn(...params)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
<dt><del><a href="#dodge">dodge(...params)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
<dt><del><a href="#screen">screen(...params)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
<dt><del><a href="#overlay">overlay(...params)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
</dl>

<a name="blendBurn"></a>

## blendBurn(base, blend) ⇒ <code>Node.&lt;vec3&gt;</code>
Represents a "Color Burn" blend mode.

It's designed to darken the base layer's colors based on the color of the blend layer.
It significantly increases the contrast of the base layer, making the colors more vibrant and saturated.
The darker the color in the blend layer, the stronger the darkening and contrast effect on the base layer.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec3&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec3&gt;</code> | The blend color. A white (#ffffff) blend color does not alter the base color. |

<a name="blendDodge"></a>

## blendDodge(base, blend) ⇒ <code>Node.&lt;vec3&gt;</code>
Represents a "Color Dodge" blend mode.

It's designed to lighten the base layer's colors based on the color of the blend layer.
It significantly increases the brightness of the base layer, making the colors lighter and more vibrant.
The brighter the color in the blend layer, the stronger the lightening and contrast effect on the base layer.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec3&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec3&gt;</code> | The blend color. A black (#000000) blend color does not alter the base color. |

<a name="blendScreen"></a>

## blendScreen(base, blend) ⇒ <code>Node.&lt;vec3&gt;</code>
Represents a "Screen" blend mode.

Similar to `blendDodge()`, this mode also lightens the base layer's colors based on the color of the blend layer.
The "Screen" blend mode is better for general brightening whereas the "Dodge" results in more subtle and nuanced
effects.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec3&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec3&gt;</code> | The blend color. A black (#000000) blend color does not alter the base color. |

<a name="blendOverlay"></a>

## blendOverlay(base, blend) ⇒ <code>Node.&lt;vec3&gt;</code>
Represents a "Overlay" blend mode.

It's designed to increase the contrast of the base layer based on the color of the blend layer.
It amplifies the existing colors and contrast in the base layer, making lighter areas lighter and darker areas darker.
The color of the blend layer significantly influences the resulting contrast and color shift in the base layer.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec3&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec3&gt;</code> | The blend color |

<a name="blendColor"></a>

## blendColor(base, blend) ⇒ <code>Node.&lt;vec4&gt;</code>
This function blends two color based on their alpha values by replicating the behavior of `THREE.NormalBlending`.
It assumes both input colors have non-premultiplied alpha.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The result.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| base | <code>Node.&lt;vec4&gt;</code> | The base color. |
| blend | <code>Node.&lt;vec4&gt;</code> | The blend color |

<a name="burn"></a>

## ~~burn(...params) ⇒ <code>function</code>~~
***since r171. Use [blendBurn](#blendBurn) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="dodge"></a>

## ~~dodge(...params) ⇒ <code>function</code>~~
***since r171. Use [blendDodge](#blendDodge) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="screen"></a>

## ~~screen(...params) ⇒ <code>function</code>~~
***since r171. Use [blendScreen](#blendScreen) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="overlay"></a>

## ~~overlay(...params) ⇒ <code>function</code>~~
***since r171. Use [blendOverlay](#blendOverlay) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

## Classes

<dl>
<dt><a href="#BumpMapNode">BumpMapNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This class can be used for applying bump maps to materials.</p>
<pre><code class="language-js">material.normalNode = bumpMap( texture( bumpTex ) );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#bumpMap">bumpMap(textureNode, [scaleNode])</a> ⇒ <code><a href="#BumpMapNode">BumpMapNode</a></code></dt>
<dd><p>TSL function for creating a bump map node.</p>
</dd>
</dl>

<a name="BumpMapNode"></a>

## BumpMapNode ⇐ <code>TempNode</code>
This class can be used for applying bump maps to materials.

```js
material.normalNode = bumpMap( texture( bumpTex ) );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [BumpMapNode](#BumpMapNode) ⇐ <code>TempNode</code>
    * [new BumpMapNode(textureNode, [scaleNode])](#new_BumpMapNode_new)
    * [.textureNode](#BumpMapNode+textureNode) : <code>Node.&lt;float&gt;</code>
    * [.scaleNode](#BumpMapNode+scaleNode) : <code>Node.&lt;float&gt;</code>

<a name="new_BumpMapNode_new"></a>

### new BumpMapNode(textureNode, [scaleNode])
Constructs a new bump map node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>Node.&lt;float&gt;</code> |  | Represents the bump map data. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code></code> | Controls the intensity of the bump effect. |

<a name="BumpMapNode+textureNode"></a>

### bumpMapNode.textureNode : <code>Node.&lt;float&gt;</code>
Represents the bump map data.

**Kind**: instance property of [<code>BumpMapNode</code>](#BumpMapNode)  
<a name="BumpMapNode+scaleNode"></a>

### bumpMapNode.scaleNode : <code>Node.&lt;float&gt;</code>
Controls the intensity of the bump effect.

**Kind**: instance property of [<code>BumpMapNode</code>](#BumpMapNode)  
**Default**: <code>null</code>  
<a name="bumpMap"></a>

## bumpMap(textureNode, [scaleNode]) ⇒ [<code>BumpMapNode</code>](#BumpMapNode)
TSL function for creating a bump map node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>Node.&lt;float&gt;</code> |  | Represents the bump map data. |
| [scaleNode] | <code>Node.&lt;float&gt;</code> | <code></code> | Controls the intensity of the bump effect. |

## Functions

<dl>
<dt><a href="#grayscale">grayscale(color)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Computes a grayscale value for the given RGB color value.</p>
</dd>
<dt><a href="#saturation">saturation(color, [adjustment])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Super-saturates or desaturates the given RGB color.</p>
</dd>
<dt><a href="#vibrance">vibrance(color, [adjustment])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Selectively enhance the intensity of less saturated RGB colors. Can result
in a more natural and visually appealing image with enhanced color depth
compared to <a href="ColorAdjustment#saturation">ColorAdjustment#saturation</a>.</p>
</dd>
<dt><a href="#hue">hue(color, [adjustment])</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Updates the hue component of the given RGB color while preserving its luminance and saturation.</p>
</dd>
<dt><a href="#luminance">luminance(color, luminanceCoefficients)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Computes the luminance for the given RGB color value.</p>
</dd>
<dt><a href="#cdl">cdl(color, slope, offset, power, saturation, luminanceCoefficients)</a> ⇒ <code>Node.&lt;vec4&gt;</code></dt>
<dd><p>Color Decision List (CDL) v1.2</p>
<p>Compact representation of color grading information, defined by slope, offset, power, and
saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,
or AgX Log), and will return output in the same space. Output may require clamping &gt;=0.</p>
</dd>
</dl>

<a name="grayscale"></a>

## grayscale(color) ⇒ <code>Node.&lt;vec3&gt;</code>
Computes a grayscale value for the given RGB color value.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The grayscale color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color value to compute the grayscale for. |

<a name="saturation"></a>

## saturation(color, [adjustment]) ⇒ <code>Node.&lt;vec3&gt;</code>
Super-saturates or desaturates the given RGB color.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The saturated color.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> |  | The input color. |
| [adjustment] | <code>Node.&lt;float&gt;</code> | <code>1</code> | Specifies the amount of the conversion. A value under `1` desaturates the color, a value over `1` super-saturates it. |

<a name="vibrance"></a>

## vibrance(color, [adjustment]) ⇒ <code>Node.&lt;vec3&gt;</code>
Selectively enhance the intensity of less saturated RGB colors. Can result
in a more natural and visually appealing image with enhanced color depth
compared to [ColorAdjustment#saturation](ColorAdjustment#saturation).

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The updated color.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> |  | The input color. |
| [adjustment] | <code>Node.&lt;float&gt;</code> | <code>1</code> | Controls the intensity of the vibrance effect. |

<a name="hue"></a>

## hue(color, [adjustment]) ⇒ <code>Node.&lt;vec3&gt;</code>
Updates the hue component of the given RGB color while preserving its luminance and saturation.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The updated color.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> |  | The input color. |
| [adjustment] | <code>Node.&lt;float&gt;</code> | <code>1</code> | Defines the degree of hue rotation in radians. A positive value rotates the hue clockwise, while a negative value rotates it counterclockwise. |

<a name="luminance"></a>

## luminance(color, luminanceCoefficients) ⇒ <code>Node.&lt;vec3&gt;</code>
Computes the luminance for the given RGB color value.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The luminance.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color value to compute the luminance for. |
| luminanceCoefficients | <code>Node.&lt;vec3&gt;</code> | The luminance coefficients. By default predefined values of the current working color space are used. |

<a name="cdl"></a>

## cdl(color, slope, offset, power, saturation, luminanceCoefficients) ⇒ <code>Node.&lt;vec4&gt;</code>
Color Decision List (CDL) v1.2

Compact representation of color grading information, defined by slope, offset, power, and
saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,
or AgX Log), and will return output in the same space. Output may require clamping >=0.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - Output, -Infinity < output < +Infinity

References:
- ASC CDL v1.2
- [https://blender.stackexchange.com/a/55239/43930](https://blender.stackexchange.com/a/55239/43930)
- [https://docs.acescentral.com/specifications/acescc/](https://docs.acescentral.com/specifications/acescc/)  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec4&gt;</code> | Input (-Infinity < input < +Infinity) |
| slope | <code>Node.&lt;vec3&gt;</code> | Slope (0 ≤ slope < +Infinity) |
| offset | <code>Node.&lt;vec3&gt;</code> | Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1) |
| power | <code>Node.&lt;vec3&gt;</code> | Power (0 < power < +Infinity) |
| saturation | <code>Node.&lt;float&gt;</code> | Saturation (0 ≤ saturation < +Infinity; typically 0 ≤ saturation < 4) |
| luminanceCoefficients | <code>Node.&lt;vec3&gt;</code> | Luminance coefficients for saturation term, typically Rec. 709 |

## Functions

<dl>
<dt><a href="#sRGBTransferEOTF">sRGBTransferEOTF(color)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Converts the given color value from sRGB to linear-sRGB color space.</p>
</dd>
<dt><a href="#sRGBTransferOETF">sRGBTransferOETF(color)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Converts the given color value from linear-sRGB to sRGB color space.</p>
</dd>
</dl>

<a name="sRGBTransferEOTF"></a>

## sRGBTransferEOTF(color) ⇒ <code>Node.&lt;vec3&gt;</code>
Converts the given color value from sRGB to linear-sRGB color space.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The linear-sRGB color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The sRGB color. |

<a name="sRGBTransferOETF"></a>

## sRGBTransferOETF(color) ⇒ <code>Node.&lt;vec3&gt;</code>
Converts the given color value from linear-sRGB to sRGB color space.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The sRGB color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The linear-sRGB color. |

## Classes

<dl>
<dt><a href="#ColorSpaceNode">ColorSpaceNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents a color space conversion. Meaning it converts
a color value from a source to a target color space.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#toOutputColorSpace">toOutputColorSpace(node)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node to the current output color space.</p>
</dd>
<dt><a href="#toWorkingColorSpace">toWorkingColorSpace(node)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node to the current working color space.</p>
</dd>
<dt><a href="#workingToColorSpace">workingToColorSpace(node, colorSpace)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node from the current working color space to the given color space.</p>
</dd>
<dt><a href="#colorSpaceToWorking">colorSpaceToWorking(node, colorSpace)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node from the given color space to the current working color space.</p>
</dd>
<dt><a href="#convertColorSpace">convertColorSpace(node, sourceColorSpace, targetColorSpace)</a> ⇒ <code><a href="#ColorSpaceNode">ColorSpaceNode</a></code></dt>
<dd><p>TSL function for converting a given color node from one color space to another one.</p>
</dd>
</dl>

<a name="ColorSpaceNode"></a>

## ColorSpaceNode ⇐ <code>TempNode</code>
This node represents a color space conversion. Meaning it converts
a color value from a source to a target color space.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [ColorSpaceNode](#ColorSpaceNode) ⇐ <code>TempNode</code>
    * [new ColorSpaceNode(colorNode, source, target)](#new_ColorSpaceNode_new)
    * [.colorNode](#ColorSpaceNode+colorNode) : <code>Node</code>
    * [.source](#ColorSpaceNode+source) : <code>string</code>
    * [.target](#ColorSpaceNode+target) : <code>string</code>
    * [.resolveColorSpace(builder, colorSpace)](#ColorSpaceNode+resolveColorSpace) ⇒ <code>string</code>

<a name="new_ColorSpaceNode_new"></a>

### new ColorSpaceNode(colorNode, source, target)
Constructs a new color space node.


| Param | Type | Description |
| --- | --- | --- |
| colorNode | <code>Node</code> | Represents the color to convert. |
| source | <code>string</code> | The source color space. |
| target | <code>string</code> | The target color space. |

<a name="ColorSpaceNode+colorNode"></a>

### colorSpaceNode.colorNode : <code>Node</code>
Represents the color to convert.

**Kind**: instance property of [<code>ColorSpaceNode</code>](#ColorSpaceNode)  
<a name="ColorSpaceNode+source"></a>

### colorSpaceNode.source : <code>string</code>
The source color space.

**Kind**: instance property of [<code>ColorSpaceNode</code>](#ColorSpaceNode)  
<a name="ColorSpaceNode+target"></a>

### colorSpaceNode.target : <code>string</code>
The target color space.

**Kind**: instance property of [<code>ColorSpaceNode</code>](#ColorSpaceNode)  
<a name="ColorSpaceNode+resolveColorSpace"></a>

### colorSpaceNode.resolveColorSpace(builder, colorSpace) ⇒ <code>string</code>
This method resolves the constants `WORKING_COLOR_SPACE` and
`OUTPUT_COLOR_SPACE` based on the current configuration of the
color management and renderer.

**Kind**: instance method of [<code>ColorSpaceNode</code>](#ColorSpaceNode)  
**Returns**: <code>string</code> - The resolved color space.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| colorSpace | <code>string</code> | The color space to resolve. |

<a name="toOutputColorSpace"></a>

## toOutputColorSpace(node) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node to the current output color space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |

<a name="toWorkingColorSpace"></a>

## toWorkingColorSpace(node) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node to the current working color space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |

<a name="workingToColorSpace"></a>

## workingToColorSpace(node, colorSpace) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node from the current working color space to the given color space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |
| colorSpace | <code>string</code> | The target color space. |

<a name="colorSpaceToWorking"></a>

## colorSpaceToWorking(node, colorSpace) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node from the given color space to the current working color space.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |
| colorSpace | <code>string</code> | The source color space. |

<a name="convertColorSpace"></a>

## convertColorSpace(node, sourceColorSpace, targetColorSpace) ⇒ [<code>ColorSpaceNode</code>](#ColorSpaceNode)
TSL function for converting a given color node from one color space to another one.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | Represents the node to convert. |
| sourceColorSpace | <code>string</code> | The source color space. |
| targetColorSpace | <code>string</code> | The target color space. |

## Classes

<dl>
<dt><a href="#FrontFacingNode">FrontFacingNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node can be used to evaluate whether a primitive is front or back facing.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#frontFacing">frontFacing</a> : <code>FrontFacingNode.&lt;bool&gt;</code></dt>
<dd><p>TSL object that represents whether a primitive is front or back facing</p>
</dd>
<dt><a href="#faceDirection">faceDirection</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL object that represents the front facing status as a number instead of a bool.
<code>1</code> means front facing, <code>-1</code> means back facing.</p>
</dd>
</dl>

<a name="FrontFacingNode"></a>

## FrontFacingNode ⇐ <code>Node</code>
This node can be used to evaluate whether a primitive is front or back facing.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [FrontFacingNode](#FrontFacingNode) ⇐ <code>Node</code>
    * [new FrontFacingNode()](#new_FrontFacingNode_new)
    * [.isFrontFacingNode](#FrontFacingNode+isFrontFacingNode) : <code>boolean</code>

<a name="new_FrontFacingNode_new"></a>

### new FrontFacingNode()
Constructs a new front facing node.

<a name="FrontFacingNode+isFrontFacingNode"></a>

### frontFacingNode.isFrontFacingNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>FrontFacingNode</code>](#FrontFacingNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="frontFacing"></a>

## frontFacing : <code>FrontFacingNode.&lt;bool&gt;</code>
TSL object that represents whether a primitive is front or back facing

**Kind**: global constant  
**Tsl**:   
<a name="faceDirection"></a>

## faceDirection : <code>Node.&lt;float&gt;</code>
TSL object that represents the front facing status as a number instead of a bool.
`1` means front facing, `-1` means back facing.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#NormalMapNode">NormalMapNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This class can be used for applying normals maps to materials.</p>
<pre><code class="language-js">material.normalNode = normalMap( texture( normalTex ) );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#normalMap">normalMap(node, [scaleNode])</a> ⇒ <code><a href="#NormalMapNode">NormalMapNode</a></code></dt>
<dd><p>TSL function for creating a normal map node.</p>
</dd>
</dl>

<a name="NormalMapNode"></a>

## NormalMapNode ⇐ <code>TempNode</code>
This class can be used for applying normals maps to materials.

```js
material.normalNode = normalMap( texture( normalTex ) );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [NormalMapNode](#NormalMapNode) ⇐ <code>TempNode</code>
    * [new NormalMapNode(node, [scaleNode])](#new_NormalMapNode_new)
    * [.node](#NormalMapNode+node) : <code>Node.&lt;vec3&gt;</code>
    * [.scaleNode](#NormalMapNode+scaleNode) : <code>Node.&lt;vec2&gt;</code>
    * [.normalMapType](#NormalMapNode+normalMapType) : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>

<a name="new_NormalMapNode_new"></a>

### new NormalMapNode(node, [scaleNode])
Constructs a new normal map node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> |  | Represents the normal map data. |
| [scaleNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | Controls the intensity of the effect. |

<a name="NormalMapNode+node"></a>

### normalMapNode.node : <code>Node.&lt;vec3&gt;</code>
Represents the normal map data.

**Kind**: instance property of [<code>NormalMapNode</code>](#NormalMapNode)  
<a name="NormalMapNode+scaleNode"></a>

### normalMapNode.scaleNode : <code>Node.&lt;vec2&gt;</code>
Controls the intensity of the effect.

**Kind**: instance property of [<code>NormalMapNode</code>](#NormalMapNode)  
**Default**: <code>null</code>  
<a name="NormalMapNode+normalMapType"></a>

### normalMapNode.normalMapType : <code>TangentSpaceNormalMap</code> \| <code>ObjectSpaceNormalMap</code>
The normal map type.

**Kind**: instance property of [<code>NormalMapNode</code>](#NormalMapNode)  
**Default**: <code>TangentSpaceNormalMap</code>  
<a name="normalMap"></a>

## normalMap(node, [scaleNode]) ⇒ [<code>NormalMapNode</code>](#NormalMapNode)
TSL function for creating a normal map node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> |  | Represents the normal map data. |
| [scaleNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | Controls the intensity of the effect. |

## Classes

<dl>
<dt><a href="#PassTextureNode">PassTextureNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>Represents the texture of a pass node.</p>
</dd>
<dt><a href="#PassMultipleTextureNode">PassMultipleTextureNode</a> ⇐ <code><a href="#PassTextureNode">PassTextureNode</a></code></dt>
<dd><p>An extension of <code>PassTextureNode</code> which allows to manage more than one
internal texture. Relevant for the <code>getPreviousTexture()</code> related API.</p>
</dd>
<dt><a href="#PassNode">PassNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Represents a render pass (sometimes called beauty pass) in context of post processing.
This pass produces a render for the given scene and camera and can provide multiple outputs
via MRT for further processing.</p>
<pre><code class="language-js">const postProcessing = new PostProcessing( renderer );

const scenePass = pass( scene, camera );

postProcessing.outputNode = scenePass;
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#pass">pass(scene, camera, options)</a> ⇒ <code><a href="#PassNode">PassNode</a></code></dt>
<dd><p>TSL function for creating a pass node.</p>
</dd>
<dt><a href="#passTexture">passTexture(pass, texture)</a> ⇒ <code><a href="#PassTextureNode">PassTextureNode</a></code></dt>
<dd><p>TSL function for creating a pass texture node.</p>
</dd>
<dt><a href="#depthPass">depthPass(scene, camera, options)</a> ⇒ <code><a href="#PassNode">PassNode</a></code></dt>
<dd><p>TSL function for creating a depth pass node.</p>
</dd>
</dl>

<a name="PassTextureNode"></a>

## PassTextureNode ⇐ <code>TextureNode</code>
Represents the texture of a pass node.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [PassTextureNode](#PassTextureNode) ⇐ <code>TextureNode</code>
    * [new PassTextureNode(passNode, texture)](#new_PassTextureNode_new)
    * [.passNode](#PassTextureNode+passNode) : [<code>PassNode</code>](#PassNode)

<a name="new_PassTextureNode_new"></a>

### new PassTextureNode(passNode, texture)
Constructs a new pass texture node.


| Param | Type | Description |
| --- | --- | --- |
| passNode | [<code>PassNode</code>](#PassNode) | The pass node. |
| texture | <code>Texture</code> | The output texture. |

<a name="PassTextureNode+passNode"></a>

### passTextureNode.passNode : [<code>PassNode</code>](#PassNode)
A reference to the pass node.

**Kind**: instance property of [<code>PassTextureNode</code>](#PassTextureNode)  
<a name="PassMultipleTextureNode"></a>

## PassMultipleTextureNode ⇐ [<code>PassTextureNode</code>](#PassTextureNode)
An extension of `PassTextureNode` which allows to manage more than one
internal texture. Relevant for the `getPreviousTexture()` related API.

**Kind**: global class  
**Extends**: [<code>PassTextureNode</code>](#PassTextureNode)  

* [PassMultipleTextureNode](#PassMultipleTextureNode) ⇐ [<code>PassTextureNode</code>](#PassTextureNode)
    * [new PassMultipleTextureNode(passNode, textureName, [previousTexture])](#new_PassMultipleTextureNode_new)
    * [.textureName](#PassMultipleTextureNode+textureName) : <code>string</code>
    * [.previousTexture](#PassMultipleTextureNode+previousTexture) : <code>boolean</code>
    * [.passNode](#PassTextureNode+passNode) : [<code>PassNode</code>](#PassNode)
    * [.updateTexture()](#PassMultipleTextureNode+updateTexture)

<a name="new_PassMultipleTextureNode_new"></a>

### new PassMultipleTextureNode(passNode, textureName, [previousTexture])
Constructs a new pass texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| passNode | [<code>PassNode</code>](#PassNode) |  | The pass node. |
| textureName | <code>string</code> |  | The output texture name. |
| [previousTexture] | <code>boolean</code> | <code>false</code> | Whether previous frame data should be used or not. |

<a name="PassMultipleTextureNode+textureName"></a>

### passMultipleTextureNode.textureName : <code>string</code>
The output texture name.

**Kind**: instance property of [<code>PassMultipleTextureNode</code>](#PassMultipleTextureNode)  
<a name="PassMultipleTextureNode+previousTexture"></a>

### passMultipleTextureNode.previousTexture : <code>boolean</code>
Whether previous frame data should be used or not.

**Kind**: instance property of [<code>PassMultipleTextureNode</code>](#PassMultipleTextureNode)  
<a name="PassTextureNode+passNode"></a>

### passMultipleTextureNode.passNode : [<code>PassNode</code>](#PassNode)
A reference to the pass node.

**Kind**: instance property of [<code>PassMultipleTextureNode</code>](#PassMultipleTextureNode)  
**Overrides**: [<code>passNode</code>](#PassTextureNode+passNode)  
<a name="PassMultipleTextureNode+updateTexture"></a>

### passMultipleTextureNode.updateTexture()
Updates the texture reference of this node.

**Kind**: instance method of [<code>PassMultipleTextureNode</code>](#PassMultipleTextureNode)  
<a name="PassNode"></a>

## PassNode ⇐ <code>TempNode</code>
Represents a render pass (sometimes called beauty pass) in context of post processing.
This pass produces a render for the given scene and camera and can provide multiple outputs
via MRT for further processing.

```js
const postProcessing = new PostProcessing( renderer );

const scenePass = pass( scene, camera );

postProcessing.outputNode = scenePass;
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [PassNode](#PassNode) ⇐ <code>TempNode</code>
    * [new PassNode(scope, scene, camera, options)](#new_PassNode_new)
    * _instance_
        * [.scope](#PassNode+scope) : <code>&#x27;color&#x27;</code> \| <code>&#x27;depth&#x27;</code>
        * [.scene](#PassNode+scene) : <code>Scene</code>
        * [.camera](#PassNode+camera) : <code>Camera</code>
        * [.options](#PassNode+options) : <code>Object</code>
        * [.renderTarget](#PassNode+renderTarget) : <code>RenderTarget</code>
        * [.isPassNode](#PassNode+isPassNode) : <code>boolean</code>
        * [.updateBeforeType](#PassNode+updateBeforeType) : <code>string</code>
        * [.setResolution(resolution)](#PassNode+setResolution) ⇒ [<code>PassNode</code>](#PassNode)
        * [.getResolution()](#PassNode+getResolution) ⇒ <code>number</code>
        * [.setMRT(mrt)](#PassNode+setMRT) ⇒ [<code>PassNode</code>](#PassNode)
        * [.getMRT()](#PassNode+getMRT) ⇒ <code>MRTNode</code>
        * [.isGlobal()](#PassNode+isGlobal) ⇒ <code>boolean</code>
        * [.getTexture(name)](#PassNode+getTexture) ⇒ <code>Texture</code>
        * [.getPreviousTexture(name)](#PassNode+getPreviousTexture) ⇒ <code>Texture</code>
        * [.toggleTexture(name)](#PassNode+toggleTexture)
        * [.getTextureNode([name])](#PassNode+getTextureNode) ⇒ <code>TextureNode</code>
        * [.getPreviousTextureNode([name])](#PassNode+getPreviousTextureNode) ⇒ <code>TextureNode</code>
        * [.getViewZNode([name])](#PassNode+getViewZNode) ⇒ <code>Node</code>
        * [.getLinearDepthNode([name])](#PassNode+getLinearDepthNode) ⇒ <code>Node</code>
        * [.setSize(width, height)](#PassNode+setSize)
        * [.setPixelRatio(pixelRatio)](#PassNode+setPixelRatio)
        * [.dispose()](#PassNode+dispose)
    * _static_
        * [.COLOR](#PassNode.COLOR) : <code>&#x27;color&#x27;</code>
        * [.DEPTH](#PassNode.DEPTH) : <code>&#x27;depth&#x27;</code>

<a name="new_PassNode_new"></a>

### new PassNode(scope, scene, camera, options)
Constructs a new pass node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>&#x27;color&#x27;</code> \| <code>&#x27;depth&#x27;</code> | The scope of the pass. The scope determines whether the node outputs color or depth. |
| scene | <code>Scene</code> | A reference to the scene. |
| camera | <code>Camera</code> | A reference to the camera. |
| options | <code>Object</code> | Options for the internal render target. |

<a name="PassNode+scope"></a>

### passNode.scope : <code>&#x27;color&#x27;</code> \| <code>&#x27;depth&#x27;</code>
The scope of the pass. The scope determines whether the node outputs color or depth.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+scene"></a>

### passNode.scene : <code>Scene</code>
A reference to the scene.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+camera"></a>

### passNode.camera : <code>Camera</code>
A reference to the camera.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+options"></a>

### passNode.options : <code>Object</code>
Options for the internal render target.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+renderTarget"></a>

### passNode.renderTarget : <code>RenderTarget</code>
The pass's render target.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
<a name="PassNode+isPassNode"></a>

### passNode.isPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PassNode+updateBeforeType"></a>

### passNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
scene once per frame in its [PassNode#updateBefore](PassNode#updateBefore) method.

**Kind**: instance property of [<code>PassNode</code>](#PassNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="PassNode+setResolution"></a>

### passNode.setResolution(resolution) ⇒ [<code>PassNode</code>](#PassNode)
Sets the resolution for the pass.
The resolution is a factor that is multiplied with the renderer's width and height.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: [<code>PassNode</code>](#PassNode) - A reference to this pass.  

| Param | Type | Description |
| --- | --- | --- |
| resolution | <code>number</code> | The resolution to set. A value of `1` means full resolution. |

<a name="PassNode+getResolution"></a>

### passNode.getResolution() ⇒ <code>number</code>
Gets the current resolution of the pass.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Default**: <code>1</code>  
**Returns**: <code>number</code> - The current resolution. A value of `1` means full resolution.  
<a name="PassNode+setMRT"></a>

### passNode.setMRT(mrt) ⇒ [<code>PassNode</code>](#PassNode)
Sets the given MRT node to setup MRT for this pass.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: [<code>PassNode</code>](#PassNode) - A reference to this pass.  

| Param | Type | Description |
| --- | --- | --- |
| mrt | <code>MRTNode</code> | The MRT object. |

<a name="PassNode+getMRT"></a>

### passNode.getMRT() ⇒ <code>MRTNode</code>
Returns the current MRT node.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>MRTNode</code> - The current MRT node.  
<a name="PassNode+isGlobal"></a>

### passNode.isGlobal() ⇒ <code>boolean</code>
The method is overwritten so it always returns `true`.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>boolean</code> - Whether this node is global or not.  
<a name="PassNode+getTexture"></a>

### passNode.getTexture(name) ⇒ <code>Texture</code>
Returns the texture for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>Texture</code> - The texture.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The output name to get the texture for. |

<a name="PassNode+getPreviousTexture"></a>

### passNode.getPreviousTexture(name) ⇒ <code>Texture</code>
Returns the texture holding the data of the previous frame for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>Texture</code> - The texture holding the data of the previous frame.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The output name to get the texture for. |

<a name="PassNode+toggleTexture"></a>

### passNode.toggleTexture(name)
Switches current and previous textures for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The output name. |

<a name="PassNode+getTextureNode"></a>

### passNode.getTextureNode([name]) ⇒ <code>TextureNode</code>
Returns the texture node for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>TextureNode</code> - The texture node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;&#x27;output&#x27;&quot;</code> | The output name to get the texture node for. |

<a name="PassNode+getPreviousTextureNode"></a>

### passNode.getPreviousTextureNode([name]) ⇒ <code>TextureNode</code>
Returns the previous texture node for the given output name.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>TextureNode</code> - The previous texture node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;&#x27;output&#x27;&quot;</code> | The output name to get the previous texture node for. |

<a name="PassNode+getViewZNode"></a>

### passNode.getViewZNode([name]) ⇒ <code>Node</code>
Returns a viewZ node of this pass.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>Node</code> - The viewZ node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;&#x27;depth&#x27;&quot;</code> | The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs. |

<a name="PassNode+getLinearDepthNode"></a>

### passNode.getLinearDepthNode([name]) ⇒ <code>Node</code>
Returns a linear depth node of this pass.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
**Returns**: <code>Node</code> - The linear depth node.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [name] | <code>string</code> | <code>&quot;&#x27;depth&#x27;&quot;</code> | The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs. |

<a name="PassNode+setSize"></a>

### passNode.setSize(width, height)
Sets the size of the pass's render target. Honors the pixel ratio.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The height to set. |

<a name="PassNode+setPixelRatio"></a>

### passNode.setPixelRatio(pixelRatio)
Sets the pixel ratio the pass's render target and updates the size.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  

| Param | Type | Description |
| --- | --- | --- |
| pixelRatio | <code>number</code> | The pixel ratio to set. |

<a name="PassNode+dispose"></a>

### passNode.dispose()
Frees internal resources. Should be called when the node is no longer in use.

**Kind**: instance method of [<code>PassNode</code>](#PassNode)  
<a name="PassNode.COLOR"></a>

### PassNode.COLOR : <code>&#x27;color&#x27;</code>
**Kind**: static property of [<code>PassNode</code>](#PassNode)  
**Default**: <code>&#x27;color&#x27;</code>  
<a name="PassNode.DEPTH"></a>

### PassNode.DEPTH : <code>&#x27;depth&#x27;</code>
**Kind**: static property of [<code>PassNode</code>](#PassNode)  
**Default**: <code>&#x27;depth&#x27;</code>  
<a name="pass"></a>

## pass(scene, camera, options) ⇒ [<code>PassNode</code>](#PassNode)
TSL function for creating a pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | A reference to the scene. |
| camera | <code>Camera</code> | A reference to the camera. |
| options | <code>Object</code> | Options for the internal render target. |

<a name="passTexture"></a>

## passTexture(pass, texture) ⇒ [<code>PassTextureNode</code>](#PassTextureNode)
TSL function for creating a pass texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pass | [<code>PassNode</code>](#PassNode) | The pass node. |
| texture | <code>Texture</code> | The output texture. |

<a name="depthPass"></a>

## depthPass(scene, camera, options) ⇒ [<code>PassNode</code>](#PassNode)
TSL function for creating a depth pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | A reference to the scene. |
| camera | <code>Camera</code> | A reference to the camera. |
| options | <code>Object</code> | Options for the internal render target. |

## Classes

<dl>
<dt><a href="#PosterizeNode">PosterizeNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Represents a posterize effect which reduces the number of colors
in an image, resulting in a more blocky and stylized appearance.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#posterize">posterize(sourceNode, stepsNode)</a> ⇒ <code><a href="#PosterizeNode">PosterizeNode</a></code></dt>
<dd><p>TSL function for creating a posterize node.</p>
</dd>
</dl>

<a name="PosterizeNode"></a>

## PosterizeNode ⇐ <code>TempNode</code>
Represents a posterize effect which reduces the number of colors
in an image, resulting in a more blocky and stylized appearance.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [PosterizeNode](#PosterizeNode) ⇐ <code>TempNode</code>
    * [new PosterizeNode(sourceNode, stepsNode)](#new_PosterizeNode_new)
    * [.sourceNode](#PosterizeNode+sourceNode) : <code>Node</code>
    * [.stepsNode](#PosterizeNode+stepsNode) : <code>Node</code>

<a name="new_PosterizeNode_new"></a>

### new PosterizeNode(sourceNode, stepsNode)
Constructs a new posterize node.


| Param | Type | Description |
| --- | --- | --- |
| sourceNode | <code>Node</code> | The input color. |
| stepsNode | <code>Node</code> | Controls the intensity of the posterization effect. A lower number results in a more blocky appearance. |

<a name="PosterizeNode+sourceNode"></a>

### posterizeNode.sourceNode : <code>Node</code>
The input color.

**Kind**: instance property of [<code>PosterizeNode</code>](#PosterizeNode)  
<a name="PosterizeNode+stepsNode"></a>

### posterizeNode.stepsNode : <code>Node</code>
Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.

**Kind**: instance property of [<code>PosterizeNode</code>](#PosterizeNode)  
<a name="posterize"></a>

## posterize(sourceNode, stepsNode) ⇒ [<code>PosterizeNode</code>](#PosterizeNode)
TSL function for creating a posterize node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| sourceNode | <code>Node</code> | The input color. |
| stepsNode | <code>Node</code> | Controls the intensity of the posterization effect. A lower number results in a more blocky appearance. |

## Classes

<dl>
<dt><a href="#RenderOutputNode">RenderOutputNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Normally, tone mapping and color conversion happens automatically
before outputting pixel too the default (screen) framebuffer. In certain
post processing setups this happens to late because certain effects
require e.g. sRGB input. For such scenarios, <code>RenderOutputNode</code> can be used
to apply tone mapping and color space conversion at an arbitrary point
in the effect chain.</p>
<p>When applying tone mapping and color space conversion manually with this node,
you have to set <a href="PostProcessing#outputColorTransform">PostProcessing#outputColorTransform</a> to <code>false</code>.</p>
<pre><code class="language-js">const postProcessing = new PostProcessing( renderer );
postProcessing.outputColorTransform = false;

const scenePass = pass( scene, camera );
const outputPass = renderOutput( scenePass );

postProcessing.outputNode = outputPass;
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#renderOutput">renderOutput(color, [toneMapping], [outputColorSpace])</a> ⇒ <code><a href="#RenderOutputNode">RenderOutputNode</a></code></dt>
<dd><p>TSL function for creating a posterize node.</p>
</dd>
</dl>

<a name="RenderOutputNode"></a>

## RenderOutputNode ⇐ <code>TempNode</code>
Normally, tone mapping and color conversion happens automatically
before outputting pixel too the default (screen) framebuffer. In certain
post processing setups this happens to late because certain effects
require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used
to apply tone mapping and color space conversion at an arbitrary point
in the effect chain.

When applying tone mapping and color space conversion manually with this node,
you have to set [PostProcessing#outputColorTransform](PostProcessing#outputColorTransform) to `false`.

```js
const postProcessing = new PostProcessing( renderer );
postProcessing.outputColorTransform = false;

const scenePass = pass( scene, camera );
const outputPass = renderOutput( scenePass );

postProcessing.outputNode = outputPass;
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [RenderOutputNode](#RenderOutputNode) ⇐ <code>TempNode</code>
    * [new RenderOutputNode(colorNode, toneMapping, outputColorSpace)](#new_RenderOutputNode_new)
    * [.colorNode](#RenderOutputNode+colorNode) : <code>Node</code>
    * [.toneMapping](#RenderOutputNode+toneMapping) : <code>number</code>
    * [.outputColorSpace](#RenderOutputNode+outputColorSpace) : <code>string</code>
    * [.isRenderOutputNode](#RenderOutputNode+isRenderOutputNode) : <code>boolean</code>

<a name="new_RenderOutputNode_new"></a>

### new RenderOutputNode(colorNode, toneMapping, outputColorSpace)
Constructs a new render output node.


| Param | Type | Description |
| --- | --- | --- |
| colorNode | <code>Node</code> | The color node to process. |
| toneMapping | <code>number</code> | The tone mapping type. |
| outputColorSpace | <code>string</code> | The output color space. |

<a name="RenderOutputNode+colorNode"></a>

### renderOutputNode.colorNode : <code>Node</code>
The color node to process.

**Kind**: instance property of [<code>RenderOutputNode</code>](#RenderOutputNode)  
<a name="RenderOutputNode+toneMapping"></a>

### renderOutputNode.toneMapping : <code>number</code>
The tone mapping type.

**Kind**: instance property of [<code>RenderOutputNode</code>](#RenderOutputNode)  
<a name="RenderOutputNode+outputColorSpace"></a>

### renderOutputNode.outputColorSpace : <code>string</code>
The output color space.

**Kind**: instance property of [<code>RenderOutputNode</code>](#RenderOutputNode)  
<a name="RenderOutputNode+isRenderOutputNode"></a>

### renderOutputNode.isRenderOutputNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>RenderOutputNode</code>](#RenderOutputNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="renderOutput"></a>

## renderOutput(color, [toneMapping], [outputColorSpace]) ⇒ [<code>RenderOutputNode</code>](#RenderOutputNode)
TSL function for creating a posterize node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node</code> |  | The color node to process. |
| [toneMapping] | <code>number</code> | <code></code> | The tone mapping type. |
| [outputColorSpace] | <code>string</code> | <code>null</code> | The output color space. |

## Classes

<dl>
<dt><a href="#ScreenNode">ScreenNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node provides a collection of screen related metrics.
Depending on <a href="#ScreenNode+scope">scope</a>, the nodes can represent
resolution or viewport data as well as fragment or uv coordinates.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#screenUV">screenUV</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents normalized screen coordinates, unitless in <code>[0, 1]</code>.</p>
</dd>
<dt><a href="#screenSize">screenSize</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the screen resolution in physical pixel units.</p>
</dd>
<dt><a href="#screenCoordinate">screenCoordinate</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the current <code>x</code>/<code>y</code> pixel position on the screen in physical pixel units.</p>
</dd>
<dt><a href="#viewport">viewport</a> : <code>ScreenNode.&lt;vec4&gt;</code></dt>
<dd><p>TSL object that represents the viewport rectangle as <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code> in physical pixel units.</p>
</dd>
<dt><a href="#viewportSize">viewportSize</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the viewport resolution in physical pixel units.</p>
</dd>
<dt><a href="#viewportCoordinate">viewportCoordinate</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents the current <code>x</code>/<code>y</code> pixel position on the viewport in physical pixel units.</p>
</dd>
<dt><a href="#viewportUV">viewportUV</a> : <code>ScreenNode.&lt;vec2&gt;</code></dt>
<dd><p>TSL object that represents normalized viewport coordinates, unitless in <code>[0, 1]</code>.</p>
</dd>
<dt><del><a href="#viewportResolution">viewportResolution</a></del></dt>
<dd></dd>
<dt><del><a href="#viewportTopLeft">viewportTopLeft</a> : <code>Node.&lt;vec2&gt;</code></del></dt>
<dd></dd>
<dt><del><a href="#viewportBottomLeft">viewportBottomLeft</a> : <code>Node.&lt;vec2&gt;</code></del></dt>
<dd></dd>
</dl>

<a name="ScreenNode"></a>

## ScreenNode ⇐ <code>Node</code>
This node provides a collection of screen related metrics.
Depending on [scope](#ScreenNode+scope), the nodes can represent
resolution or viewport data as well as fragment or uv coordinates.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ScreenNode](#ScreenNode) ⇐ <code>Node</code>
    * [new ScreenNode(scope)](#new_ScreenNode_new)
    * [.scope](#ScreenNode+scope) : <code>&#x27;coordinate&#x27;</code> \| <code>&#x27;viewport&#x27;</code> \| <code>&#x27;size&#x27;</code> \| <code>&#x27;uv&#x27;</code>
    * [.isViewportNode](#ScreenNode+isViewportNode) : <code>boolean</code>
    * [.getNodeType()](#ScreenNode+getNodeType) ⇒ <code>&#x27;vec2&#x27;</code> \| <code>&#x27;vec4&#x27;</code>
    * [.getUpdateType()](#ScreenNode+getUpdateType) ⇒ <code>NodeUpdateType</code>
    * [.update(frame)](#ScreenNode+update)

<a name="new_ScreenNode_new"></a>

### new ScreenNode(scope)
Constructs a new screen node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>&#x27;coordinate&#x27;</code> \| <code>&#x27;viewport&#x27;</code> \| <code>&#x27;size&#x27;</code> \| <code>&#x27;uv&#x27;</code> | The node's scope. |

<a name="ScreenNode+scope"></a>

### screenNode.scope : <code>&#x27;coordinate&#x27;</code> \| <code>&#x27;viewport&#x27;</code> \| <code>&#x27;size&#x27;</code> \| <code>&#x27;uv&#x27;</code>
The node represents different metric depending on which scope is selected.

- `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.
- `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.
- `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.
- `ScreenNode.UV`: Normalized coordinates.

**Kind**: instance property of [<code>ScreenNode</code>](#ScreenNode)  
<a name="ScreenNode+isViewportNode"></a>

### screenNode.isViewportNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ScreenNode</code>](#ScreenNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ScreenNode+getNodeType"></a>

### screenNode.getNodeType() ⇒ <code>&#x27;vec2&#x27;</code> \| <code>&#x27;vec4&#x27;</code>
This method is overwritten since the node type depends on the selected scope.

**Kind**: instance method of [<code>ScreenNode</code>](#ScreenNode)  
**Returns**: <code>&#x27;vec2&#x27;</code> \| <code>&#x27;vec4&#x27;</code> - The node type.  
<a name="ScreenNode+getUpdateType"></a>

### screenNode.getUpdateType() ⇒ <code>NodeUpdateType</code>
This method is overwritten since the node's update type depends on the selected scope.

**Kind**: instance method of [<code>ScreenNode</code>](#ScreenNode)  
**Returns**: <code>NodeUpdateType</code> - The update type.  
<a name="ScreenNode+update"></a>

### screenNode.update(frame)
`ScreenNode` implements [Node#update](Node#update) to retrieve viewport and size information
from the current renderer.

**Kind**: instance method of [<code>ScreenNode</code>](#ScreenNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="screenUV"></a>

## screenUV : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.

**Kind**: global constant  
**Tsl**:   
<a name="screenSize"></a>

## screenSize : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents the screen resolution in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="screenCoordinate"></a>

## screenCoordinate : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="viewport"></a>

## viewport : <code>ScreenNode.&lt;vec4&gt;</code>
TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="viewportSize"></a>

## viewportSize : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents the viewport resolution in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="viewportCoordinate"></a>

## viewportCoordinate : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.

**Kind**: global constant  
**Tsl**:   
<a name="viewportUV"></a>

## viewportUV : <code>ScreenNode.&lt;vec2&gt;</code>
TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.

**Kind**: global constant  
**Tsl**:   
<a name="viewportResolution"></a>

## ~~viewportResolution~~
***since r169. Use [screenSize](#screenSize) instead.***

**Kind**: global constant  
<a name="viewportTopLeft"></a>

## ~~viewportTopLeft : <code>Node.&lt;vec2&gt;</code>~~
***since r168. Use [screenUV](#screenUV) instead.***

**Kind**: global constant  
**Tsl**:   
<a name="viewportBottomLeft"></a>

## ~~viewportBottomLeft : <code>Node.&lt;vec2&gt;</code>~~
***since r168. Use `screenUV.flipY()` instead.***

**Kind**: global constant  
**Tsl**:   
## Functions

<dl>
<dt><a href="#linearToneMapping">linearToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Linear tone mapping, exposure only.</p>
</dd>
<dt><a href="#reinhardToneMapping">reinhardToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Reinhard tone mapping.</p>
<p>Reference: <a href="https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf">https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf</a></p>
</dd>
<dt><a href="#cineonToneMapping">cineonToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Cineon tone mapping.</p>
<p>Reference: <a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">http://filmicworlds.com/blog/filmic-tonemapping-operators/</a></p>
</dd>
<dt><a href="#acesFilmicToneMapping">acesFilmicToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>ACESFilmic tone mapping.</p>
<p>Reference: <a href="https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs">https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs</a></p>
</dd>
<dt><a href="#agxToneMapping">agxToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>AgX tone mapping.</p>
</dd>
<dt><a href="#neutralToneMapping">neutralToneMapping(color, exposure)</a> ⇒ <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>Neutral tone mapping.</p>
<p>Reference: <a href="https://modelviewer.dev/examples/tone-mapping">https://modelviewer.dev/examples/tone-mapping</a></p>
</dd>
</dl>

<a name="linearToneMapping"></a>

## linearToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
Linear tone mapping, exposure only.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="reinhardToneMapping"></a>

## reinhardToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
Reinhard tone mapping.

Reference: [https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf](https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf)

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="cineonToneMapping"></a>

## cineonToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
Cineon tone mapping.

Reference: [http://filmicworlds.com/blog/filmic-tonemapping-operators/](http://filmicworlds.com/blog/filmic-tonemapping-operators/)

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="acesFilmicToneMapping"></a>

## acesFilmicToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
ACESFilmic tone mapping.

Reference: [https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs](https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs)

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="agxToneMapping"></a>

## agxToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
AgX tone mapping.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

<a name="neutralToneMapping"></a>

## neutralToneMapping(color, exposure) ⇒ <code>Node.&lt;vec3&gt;</code>
Neutral tone mapping.

Reference: [https://modelviewer.dev/examples/tone-mapping](https://modelviewer.dev/examples/tone-mapping)

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The tone mapped color.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec3&gt;</code> | The color that should be tone mapped. |
| exposure | <code>Node.&lt;float&gt;</code> | The exposure. |

## Classes

<dl>
<dt><a href="#ToneMappingNode">ToneMappingNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents a tone mapping operation.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#toneMappingExposure">toneMappingExposure</a> : <code>RendererReferenceNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the global tone mapping exposure of the renderer.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#toneMapping">toneMapping(mapping, exposure, color)</a> ⇒ <code>ToneMappingNode.&lt;vec3&gt;</code></dt>
<dd><p>TSL function for creating a tone mapping node.</p>
</dd>
</dl>

<a name="ToneMappingNode"></a>

## ToneMappingNode ⇐ <code>TempNode</code>
This node represents a tone mapping operation.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [ToneMappingNode](#ToneMappingNode) ⇐ <code>TempNode</code>
    * [new ToneMappingNode(toneMapping, exposureNode, [colorNode])](#new_ToneMappingNode_new)
    * [.toneMapping](#ToneMappingNode+toneMapping) : <code>number</code>
    * [.exposureNode](#ToneMappingNode+exposureNode) : <code>Node</code>
    * [.colorNode](#ToneMappingNode+colorNode) : <code>Node</code>
    * [.customCacheKey()](#ToneMappingNode+customCacheKey) ⇒ <code>number</code>

<a name="new_ToneMappingNode_new"></a>

### new ToneMappingNode(toneMapping, exposureNode, [colorNode])
Constructs a new tone mapping node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| toneMapping | <code>number</code> |  | The tone mapping type. |
| exposureNode | <code>Node</code> |  | The tone mapping exposure. |
| [colorNode] | <code>Node</code> | <code></code> | The color node to process. |

<a name="ToneMappingNode+toneMapping"></a>

### toneMappingNode.toneMapping : <code>number</code>
The tone mapping type.

**Kind**: instance property of [<code>ToneMappingNode</code>](#ToneMappingNode)  
<a name="ToneMappingNode+exposureNode"></a>

### toneMappingNode.exposureNode : <code>Node</code>
The tone mapping exposure.

**Kind**: instance property of [<code>ToneMappingNode</code>](#ToneMappingNode)  
**Default**: <code>null</code>  
<a name="ToneMappingNode+colorNode"></a>

### toneMappingNode.colorNode : <code>Node</code>
Represents the color to process.

**Kind**: instance property of [<code>ToneMappingNode</code>](#ToneMappingNode)  
**Default**: <code>null</code>  
<a name="ToneMappingNode+customCacheKey"></a>

### toneMappingNode.customCacheKey() ⇒ <code>number</code>
Overwrites the default `customCacheKey()` implementation by including the tone
mapping type into the cache key.

**Kind**: instance method of [<code>ToneMappingNode</code>](#ToneMappingNode)  
**Returns**: <code>number</code> - The hash.  
<a name="toneMappingExposure"></a>

## toneMappingExposure : <code>RendererReferenceNode.&lt;vec3&gt;</code>
TSL object that represents the global tone mapping exposure of the renderer.

**Kind**: global constant  
**Tsl**:   
<a name="toneMapping"></a>

## toneMapping(mapping, exposure, color) ⇒ <code>ToneMappingNode.&lt;vec3&gt;</code>
TSL function for creating a tone mapping node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| mapping | <code>number</code> | The tone mapping type. |
| exposure | <code>Node.&lt;float&gt;</code> \| <code>number</code> | The tone mapping exposure. |
| color | <code>Node.&lt;vec3&gt;</code> \| <code>Color</code> | The color node to process. |

## Classes

<dl>
<dt><a href="#ToonOutlinePassNode">ToonOutlinePassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>Represents a render pass for producing a toon outline effect on compatible objects.
Only 3D objects with materials of type <code>MeshToonMaterial</code> and <code>MeshToonNodeMaterial</code>
will receive the outline.</p>
<pre><code class="language-js">const postProcessing = new PostProcessing( renderer );

const scenePass = toonOutlinePass( scene, camera );

postProcessing.outputNode = scenePass;
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#toonOutlinePass">toonOutlinePass(scene, camera, color, [thickness], [alpha])</a> ⇒ <code><a href="#ToonOutlinePassNode">ToonOutlinePassNode</a></code></dt>
<dd><p>TSL function for creating a toon outline pass node.</p>
</dd>
</dl>

<a name="ToonOutlinePassNode"></a>

## ToonOutlinePassNode ⇐ <code>PassNode</code>
Represents a render pass for producing a toon outline effect on compatible objects.
Only 3D objects with materials of type `MeshToonMaterial` and `MeshToonNodeMaterial`
will receive the outline.

```js
const postProcessing = new PostProcessing( renderer );

const scenePass = toonOutlinePass( scene, camera );

postProcessing.outputNode = scenePass;
```

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [ToonOutlinePassNode](#ToonOutlinePassNode) ⇐ <code>PassNode</code>
    * [new ToonOutlinePassNode(scene, camera, colorNode, thicknessNode, alphaNode)](#new_ToonOutlinePassNode_new)
    * [.colorNode](#ToonOutlinePassNode+colorNode) : <code>Node</code>
    * [.thicknessNode](#ToonOutlinePassNode+thicknessNode) : <code>Node</code>
    * [.alphaNode](#ToonOutlinePassNode+alphaNode) : <code>Node</code>

<a name="new_ToonOutlinePassNode_new"></a>

### new ToonOutlinePassNode(scene, camera, colorNode, thicknessNode, alphaNode)
Constructs a new outline pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | A reference to the scene. |
| camera | <code>Camera</code> | A reference to the camera. |
| colorNode | <code>Node</code> | Defines the outline's color. |
| thicknessNode | <code>Node</code> | Defines the outline's thickness. |
| alphaNode | <code>Node</code> | Defines the outline's alpha. |

<a name="ToonOutlinePassNode+colorNode"></a>

### toonOutlinePassNode.colorNode : <code>Node</code>
Defines the outline's color.

**Kind**: instance property of [<code>ToonOutlinePassNode</code>](#ToonOutlinePassNode)  
<a name="ToonOutlinePassNode+thicknessNode"></a>

### toonOutlinePassNode.thicknessNode : <code>Node</code>
Defines the outline's thickness.

**Kind**: instance property of [<code>ToonOutlinePassNode</code>](#ToonOutlinePassNode)  
<a name="ToonOutlinePassNode+alphaNode"></a>

### toonOutlinePassNode.alphaNode : <code>Node</code>
Defines the outline's alpha.

**Kind**: instance property of [<code>ToonOutlinePassNode</code>](#ToonOutlinePassNode)  
<a name="toonOutlinePass"></a>

## toonOutlinePass(scene, camera, color, [thickness], [alpha]) ⇒ [<code>ToonOutlinePassNode</code>](#ToonOutlinePassNode)
TSL function for creating a toon outline pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | A reference to the scene. |
| camera | <code>Camera</code> |  | A reference to the camera. |
| color | <code>Color</code> |  | Defines the outline's color. |
| [thickness] | <code>number</code> | <code>0.003</code> | Defines the outline's thickness. |
| [alpha] | <code>number</code> | <code>1</code> | Defines the outline's alpha. |

## Classes

<dl>
<dt><a href="#ViewportDepthNode">ViewportDepthNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node offers a collection of features in context of the depth logic in the fragment shader.
Depending on <a href="#ViewportDepthNode+scope">scope</a>, it can be used to define a depth value for the current
fragment or for depth evaluation purposes.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#depth">depth</a> : <code><a href="#ViewportDepthNode">ViewportDepthNode</a></code></dt>
<dd><p>TSL object that represents the depth value for the current fragment.</p>
</dd>
<dt><a href="#viewportLinearDepth">viewportLinearDepth</a> : <code><a href="#ViewportDepthNode">ViewportDepthNode</a></code></dt>
<dd><p>TSL object that represents the linear (orthographic) depth value of the current fragment</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#viewZToOrthographicDepth">viewZToOrthographicDepth(viewZ, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a viewZ value to an orthographic depth value.</p>
</dd>
<dt><a href="#orthographicDepthToViewZ">orthographicDepthToViewZ(depth, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting an orthographic depth value to a viewZ value.</p>
</dd>
<dt><a href="#viewZToPerspectiveDepth">viewZToPerspectiveDepth(viewZ, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a viewZ value to a perspective depth value.</p>
<p>Note: {link <a href="https://twitter.com/gonnavis/status/1377183786949959682%7D">https://twitter.com/gonnavis/status/1377183786949959682}</a>.</p>
</dd>
<dt><a href="#perspectiveDepthToViewZ">perspectiveDepthToViewZ(depth, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a perspective depth value to a viewZ value.</p>
</dd>
<dt><a href="#viewZToLogarithmicDepth">viewZToLogarithmicDepth(viewZ, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a viewZ value to a logarithmic depth value.</p>
</dd>
<dt><a href="#logarithmicDepthToViewZ">logarithmicDepthToViewZ(depth, near, far)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a logarithmic depth value to a viewZ value.</p>
</dd>
<dt><a href="#depthBase">depthBase(value)</a> ⇒ <code>ViewportDepthNode.&lt;float&gt;</code></dt>
<dd><p>TSL function for defining a value for the current fragment&#39;s depth.</p>
</dd>
<dt><a href="#linearDepth">linearDepth([value])</a> ⇒ <code>ViewportDepthNode.&lt;float&gt;</code></dt>
<dd><p>TSL function for converting a perspective depth value to linear depth.</p>
</dd>
</dl>

<a name="ViewportDepthNode"></a>

## ViewportDepthNode ⇐ <code>Node</code>
This node offers a collection of features in context of the depth logic in the fragment shader.
Depending on [scope](#ViewportDepthNode+scope), it can be used to define a depth value for the current
fragment or for depth evaluation purposes.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ViewportDepthNode](#ViewportDepthNode) ⇐ <code>Node</code>
    * [new ViewportDepthNode(scope, [valueNode])](#new_ViewportDepthNode_new)
    * [.scope](#ViewportDepthNode+scope) : <code>&#x27;depth&#x27;</code> \| <code>&#x27;depthBase&#x27;</code> \| <code>&#x27;linearDepth&#x27;</code>
    * [.valueNode](#ViewportDepthNode+valueNode) : <code>Node</code>
    * [.isViewportDepthNode](#ViewportDepthNode+isViewportDepthNode) : <code>boolean</code>

<a name="new_ViewportDepthNode_new"></a>

### new ViewportDepthNode(scope, [valueNode])
Constructs a new viewport depth node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scope | <code>&#x27;depth&#x27;</code> \| <code>&#x27;depthBase&#x27;</code> \| <code>&#x27;linearDepth&#x27;</code> |  | The node's scope. |
| [valueNode] | <code>Node</code> | <code></code> | The value node. |

<a name="ViewportDepthNode+scope"></a>

### viewportDepthNode.scope : <code>&#x27;depth&#x27;</code> \| <code>&#x27;depthBase&#x27;</code> \| <code>&#x27;linearDepth&#x27;</code>
The node behaves differently depending on which scope is selected.

- `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.
- `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).
- `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.
If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.

**Kind**: instance property of [<code>ViewportDepthNode</code>](#ViewportDepthNode)  
<a name="ViewportDepthNode+valueNode"></a>

### viewportDepthNode.valueNode : <code>Node</code>
Can be used to define a custom depth value.
The property is ignored in the `ViewportDepthNode.DEPTH` scope.

**Kind**: instance property of [<code>ViewportDepthNode</code>](#ViewportDepthNode)  
**Default**: <code>null</code>  
<a name="ViewportDepthNode+isViewportDepthNode"></a>

### viewportDepthNode.isViewportDepthNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ViewportDepthNode</code>](#ViewportDepthNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="depth"></a>

## depth : [<code>ViewportDepthNode</code>](#ViewportDepthNode)
TSL object that represents the depth value for the current fragment.

**Kind**: global constant  
**Tsl**:   
<a name="viewportLinearDepth"></a>

## viewportLinearDepth : [<code>ViewportDepthNode</code>](#ViewportDepthNode)
TSL object that represents the linear (orthographic) depth value of the current fragment

**Kind**: global constant  
**Tsl**:   
<a name="viewZToOrthographicDepth"></a>

## viewZToOrthographicDepth(viewZ, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a viewZ value to an orthographic depth value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| viewZ | <code>Node.&lt;float&gt;</code> | The viewZ node. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="orthographicDepthToViewZ"></a>

## orthographicDepthToViewZ(depth, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting an orthographic depth value to a viewZ value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| depth | <code>Node.&lt;float&gt;</code> | The orthographic depth. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="viewZToPerspectiveDepth"></a>

## viewZToPerspectiveDepth(viewZ, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a viewZ value to a perspective depth value.

Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| viewZ | <code>Node.&lt;float&gt;</code> | The viewZ node. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="perspectiveDepthToViewZ"></a>

## perspectiveDepthToViewZ(depth, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a perspective depth value to a viewZ value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| depth | <code>Node.&lt;float&gt;</code> | The perspective depth. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="viewZToLogarithmicDepth"></a>

## viewZToLogarithmicDepth(viewZ, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a viewZ value to a logarithmic depth value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| viewZ | <code>Node.&lt;float&gt;</code> | The viewZ node. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="logarithmicDepthToViewZ"></a>

## logarithmicDepthToViewZ(depth, near, far) ⇒ <code>Node.&lt;float&gt;</code>
TSL function for converting a logarithmic depth value to a viewZ value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| depth | <code>Node.&lt;float&gt;</code> | The logarithmic depth. |
| near | <code>Node.&lt;float&gt;</code> | The camera's near value. |
| far | <code>Node.&lt;float&gt;</code> | The camera's far value. |

<a name="depthBase"></a>

## depthBase(value) ⇒ <code>ViewportDepthNode.&lt;float&gt;</code>
TSL function for defining a value for the current fragment's depth.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Node.&lt;float&gt;</code> | The depth value to set. |

<a name="linearDepth"></a>

## linearDepth([value]) ⇒ <code>ViewportDepthNode.&lt;float&gt;</code>
TSL function for converting a perspective depth value to linear depth.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [value] | <code>Node.&lt;float&gt;</code> | <code></code> | The perspective depth. If `null` is provided, the current fragment's depth is used. |

## Classes

<dl>
<dt><a href="#ViewportDepthTextureNode">ViewportDepthTextureNode</a> ⇐ <code>ViewportTextureNode</code></dt>
<dd><p>Represents the depth of the current viewport as a texture. This module
can be used in combination with viewport texture to achieve effects
that require depth evaluation.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#viewportDepthTexture">viewportDepthTexture([uvNode], [levelNode])</a> ⇒ <code><a href="#ViewportDepthTextureNode">ViewportDepthTextureNode</a></code></dt>
<dd><p>TSL function for a viewport depth texture node.</p>
</dd>
</dl>

<a name="ViewportDepthTextureNode"></a>

## ViewportDepthTextureNode ⇐ <code>ViewportTextureNode</code>
Represents the depth of the current viewport as a texture. This module
can be used in combination with viewport texture to achieve effects
that require depth evaluation.

**Kind**: global class  
**Extends**: <code>ViewportTextureNode</code>  
<a name="new_ViewportDepthTextureNode_new"></a>

### new ViewportDepthTextureNode([uvNode], [levelNode])
Constructs a new viewport depth texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |

<a name="viewportDepthTexture"></a>

## viewportDepthTexture([uvNode], [levelNode]) ⇒ [<code>ViewportDepthTextureNode</code>](#ViewportDepthTextureNode)
TSL function for a viewport depth texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |

## Classes

<dl>
<dt><a href="#ViewportSharedTextureNode">ViewportSharedTextureNode</a> ⇐ <code>ViewportTextureNode</code></dt>
<dd><p><code>ViewportTextureNode</code> creates an internal texture for each node instance. This module
shares a texture across all instances of <code>ViewportSharedTextureNode</code>. It should
be the first choice when using data of the default/screen framebuffer for performance reasons.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#viewportSharedTexture">viewportSharedTexture([uvNode], [levelNode])</a> ⇒ <code><a href="#ViewportSharedTextureNode">ViewportSharedTextureNode</a></code></dt>
<dd><p>TSL function for creating a shared viewport texture node.</p>
</dd>
</dl>

<a name="ViewportSharedTextureNode"></a>

## ViewportSharedTextureNode ⇐ <code>ViewportTextureNode</code>
`ViewportTextureNode` creates an internal texture for each node instance. This module
shares a texture across all instances of `ViewportSharedTextureNode`. It should
be the first choice when using data of the default/screen framebuffer for performance reasons.

**Kind**: global class  
**Extends**: <code>ViewportTextureNode</code>  
<a name="new_ViewportSharedTextureNode_new"></a>

### new ViewportSharedTextureNode([uvNode], [levelNode])
Constructs a new viewport shared texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |

<a name="viewportSharedTexture"></a>

## viewportSharedTexture([uvNode], [levelNode]) ⇒ [<code>ViewportSharedTextureNode</code>](#ViewportSharedTextureNode)
TSL function for creating a shared viewport texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |

## Classes

<dl>
<dt><a href="#ViewportTextureNode">ViewportTextureNode</a> ⇐ <code>TextureNode</code></dt>
<dd><p>A special type of texture node which represents the data of the current viewport
as a texture. The module extracts data from the current bound framebuffer with
a copy operation so no extra render pass is required to produce the texture data
(which is good for performance). <code>ViewportTextureNode</code> can be used as an input for a
variety of effects like refractive or transmissive materials.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#viewportTexture">viewportTexture([uvNode], [levelNode], [framebufferTexture])</a> ⇒ <code><a href="#ViewportTextureNode">ViewportTextureNode</a></code></dt>
<dd><p>TSL function for creating a viewport texture node.</p>
</dd>
<dt><a href="#viewportMipTexture">viewportMipTexture([uvNode], [levelNode], [framebufferTexture])</a> ⇒ <code><a href="#ViewportTextureNode">ViewportTextureNode</a></code></dt>
<dd><p>TSL function for creating a viewport texture node with enabled mipmap generation.</p>
</dd>
</dl>

<a name="ViewportTextureNode"></a>

## ViewportTextureNode ⇐ <code>TextureNode</code>
A special type of texture node which represents the data of the current viewport
as a texture. The module extracts data from the current bound framebuffer with
a copy operation so no extra render pass is required to produce the texture data
(which is good for performance). `ViewportTextureNode` can be used as an input for a
variety of effects like refractive or transmissive materials.

**Kind**: global class  
**Extends**: <code>TextureNode</code>  

* [ViewportTextureNode](#ViewportTextureNode) ⇐ <code>TextureNode</code>
    * [new ViewportTextureNode([uvNode], [levelNode], [framebufferTexture])](#new_ViewportTextureNode_new)
    * [.generateMipmaps](#ViewportTextureNode+generateMipmaps) : <code>boolean</code>
    * [.isOutputTextureNode](#ViewportTextureNode+isOutputTextureNode) : <code>boolean</code>
    * [.updateBeforeType](#ViewportTextureNode+updateBeforeType) : <code>string</code>

<a name="new_ViewportTextureNode_new"></a>

### new ViewportTextureNode([uvNode], [levelNode], [framebufferTexture])
Constructs a new viewport texture node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |
| [framebufferTexture] | <code>Texture</code> | <code></code> | A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically. |

<a name="ViewportTextureNode+generateMipmaps"></a>

### viewportTextureNode.generateMipmaps : <code>boolean</code>
Whether to generate mipmaps or not.

**Kind**: instance property of [<code>ViewportTextureNode</code>](#ViewportTextureNode)  
**Default**: <code>false</code>  
<a name="ViewportTextureNode+isOutputTextureNode"></a>

### viewportTextureNode.isOutputTextureNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ViewportTextureNode</code>](#ViewportTextureNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ViewportTextureNode+updateBeforeType"></a>

### viewportTextureNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
scene once per frame in its [ViewportTextureNode#updateBefore](ViewportTextureNode#updateBefore) method.

**Kind**: instance property of [<code>ViewportTextureNode</code>](#ViewportTextureNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="viewportTexture"></a>

## viewportTexture([uvNode], [levelNode], [framebufferTexture]) ⇒ [<code>ViewportTextureNode</code>](#ViewportTextureNode)
TSL function for creating a viewport texture node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |
| [framebufferTexture] | <code>Texture</code> | <code></code> | A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically. |

<a name="viewportMipTexture"></a>

## viewportMipTexture([uvNode], [levelNode], [framebufferTexture]) ⇒ [<code>ViewportTextureNode</code>](#ViewportTextureNode)
TSL function for creating a viewport texture node with enabled mipmap generation.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [uvNode] | <code>Node</code> | <code>screenUV</code> | The uv node. |
| [levelNode] | <code>Node</code> | <code></code> | The level node. |
| [framebufferTexture] | <code>Texture</code> | <code></code> | A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically. |

## Functions

<dl>
<dt><a href="#getViewZNode">getViewZNode(builder)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns a node that represents the <code>z</code> coordinate in view space
for the current fragment. It&#39;s a different representation of the
default depth value.</p>
<p>This value can be part of a computation that defines how the fog
density increases when moving away from the camera.</p>
</dd>
<dt><a href="#rangeFogFactor">rangeFogFactor(near, far)</a></dt>
<dd><p>Constructs a new range factor node.</p>
</dd>
<dt><a href="#densityFogFactor">densityFogFactor(density)</a></dt>
<dd><p>Represents an exponential squared fog. This type of fog gives
a clear view near the camera and a faster than exponentially
densening fog farther from the camera.</p>
</dd>
<dt><a href="#fog">fog(color, factor)</a></dt>
<dd><p>This class can be used to configure a fog for the scene.
Nodes of this type are assigned to <code>Scene.fogNode</code>.</p>
</dd>
<dt><del><a href="#rangeFog">rangeFog(color, near, far)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
<dt><del><a href="#densityFog">densityFog(color, density)</a> ⇒ <code>function</code></del></dt>
<dd></dd>
</dl>

<a name="getViewZNode"></a>

## getViewZNode(builder) ⇒ <code>Node</code>
Returns a node that represents the `z` coordinate in view space
for the current fragment. It's a different representation of the
default depth value.

This value can be part of a computation that defines how the fog
density increases when moving away from the camera.

**Kind**: global function  
**Returns**: <code>Node</code> - The viewZ node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="rangeFogFactor"></a>

## rangeFogFactor(near, far)
Constructs a new range factor node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| near | <code>Node</code> | Defines the near value. |
| far | <code>Node</code> | Defines the far value. |

<a name="densityFogFactor"></a>

## densityFogFactor(density)
Represents an exponential squared fog. This type of fog gives
a clear view near the camera and a faster than exponentially
densening fog farther from the camera.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| density | <code>Node</code> | Defines the fog density. |

<a name="fog"></a>

## fog(color, factor)
This class can be used to configure a fog for the scene.
Nodes of this type are assigned to `Scene.fogNode`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node</code> | Defines the color of the fog. |
| factor | <code>Node</code> | Defines how the fog is factored in the scene. |

<a name="rangeFog"></a>

## ~~rangeFog(color, near, far) ⇒ <code>function</code>~~
***since r171. Use `fog( color, rangeFogFactor( near, far ) )` instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| color | <code>Node</code> | 
| near | <code>Node</code> | 
| far | <code>Node</code> | 

<a name="densityFog"></a>

## ~~densityFog(color, density) ⇒ <code>function</code>~~
***since r171. Use `fog( color, densityFogFactor( density ) )` instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| color | <code>Node</code> | 
| density | <code>Node</code> | 

<a name="BasicLightingModel"></a>

## BasicLightingModel ⇐ <code>LightingModel</code>
Represents the lighting model for unlit materials. The only light contribution
is baked indirect lighting modulated with ambient occlusion and the material's
diffuse color. Environment mapping is supported. Used in [MeshBasicNodeMaterial](MeshBasicNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingModel</code>  

* [BasicLightingModel](#BasicLightingModel) ⇐ <code>LightingModel</code>
    * [new BasicLightingModel()](#new_BasicLightingModel_new)
    * [.indirect(builder)](#BasicLightingModel+indirect)
    * [.finish(builder)](#BasicLightingModel+finish)

<a name="new_BasicLightingModel_new"></a>

### new BasicLightingModel()
Constructs a new basic lighting model.

<a name="BasicLightingModel+indirect"></a>

### basicLightingModel.indirect(builder)
Implements the baked indirect lighting with its modulation.

**Kind**: instance method of [<code>BasicLightingModel</code>](#BasicLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BasicLightingModel+finish"></a>

### basicLightingModel.finish(builder)
Implements the environment mapping.

**Kind**: instance method of [<code>BasicLightingModel</code>](#BasicLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhongLightingModel"></a>

## PhongLightingModel ⇐ <code>BasicLightingModel</code>
Represents the lighting model for a phong material. Used in [MeshPhongNodeMaterial](MeshPhongNodeMaterial).

**Kind**: global class  
**Extends**: <code>BasicLightingModel</code>  

* [PhongLightingModel](#PhongLightingModel) ⇐ <code>BasicLightingModel</code>
    * [new PhongLightingModel([specular])](#new_PhongLightingModel_new)
    * [.specular](#PhongLightingModel+specular) : <code>boolean</code>
    * [.direct(lightData)](#PhongLightingModel+direct)
    * [.indirect(builder)](#PhongLightingModel+indirect)

<a name="new_PhongLightingModel_new"></a>

### new PhongLightingModel([specular])
Constructs a new phong lighting model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [specular] | <code>boolean</code> | <code>true</code> | Whether specular is supported or not. |

<a name="PhongLightingModel+specular"></a>

### phongLightingModel.specular : <code>boolean</code>
Whether specular is supported or not. Set this to `false` if you are
looking for a Lambert-like material meaning a material for non-shiny
surfaces, without specular highlights.

**Kind**: instance property of [<code>PhongLightingModel</code>](#PhongLightingModel)  
**Default**: <code>true</code>  
<a name="PhongLightingModel+direct"></a>

### phongLightingModel.direct(lightData)
Implements the direct lighting. The specular portion is optional an can be controlled
with the [specular](#PhongLightingModel+specular) flag.

**Kind**: instance method of [<code>PhongLightingModel</code>](#PhongLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |

<a name="PhongLightingModel+indirect"></a>

### phongLightingModel.indirect(builder)
Implements the indirect lighting.

**Kind**: instance method of [<code>PhongLightingModel</code>](#PhongLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel"></a>

## PhysicalLightingModel ⇐ <code>LightingModel</code>
Represents the lighting model for a PBR material.

**Kind**: global class  
**Extends**: <code>LightingModel</code>  

* [PhysicalLightingModel](#PhysicalLightingModel) ⇐ <code>LightingModel</code>
    * [new PhysicalLightingModel([clearcoat], [sheen], [iridescence], [anisotropy], [transmission], [dispersion])](#new_PhysicalLightingModel_new)
    * [.clearcoat](#PhysicalLightingModel+clearcoat) : <code>boolean</code>
    * [.sheen](#PhysicalLightingModel+sheen) : <code>boolean</code>
    * [.iridescence](#PhysicalLightingModel+iridescence) : <code>boolean</code>
    * [.anisotropy](#PhysicalLightingModel+anisotropy) : <code>boolean</code>
    * [.transmission](#PhysicalLightingModel+transmission) : <code>boolean</code>
    * [.dispersion](#PhysicalLightingModel+dispersion) : <code>boolean</code>
    * [.clearcoatRadiance](#PhysicalLightingModel+clearcoatRadiance) : <code>Node</code>
    * [.clearcoatSpecularDirect](#PhysicalLightingModel+clearcoatSpecularDirect) : <code>Node</code>
    * [.clearcoatSpecularIndirect](#PhysicalLightingModel+clearcoatSpecularIndirect) : <code>Node</code>
    * [.sheenSpecularDirect](#PhysicalLightingModel+sheenSpecularDirect) : <code>Node</code>
    * [.sheenSpecularIndirect](#PhysicalLightingModel+sheenSpecularIndirect) : <code>Node</code>
    * [.iridescenceFresnel](#PhysicalLightingModel+iridescenceFresnel) : <code>Node</code>
    * [.iridescenceF0](#PhysicalLightingModel+iridescenceF0) : <code>Node</code>
    * [.start(builder)](#PhysicalLightingModel+start)
    * [.direct(lightData, builder)](#PhysicalLightingModel+direct)
    * [.directRectArea(input, builder)](#PhysicalLightingModel+directRectArea)
    * [.indirect(builder)](#PhysicalLightingModel+indirect)
    * [.indirectDiffuse(builder)](#PhysicalLightingModel+indirectDiffuse)
    * [.indirectSpecular(builder)](#PhysicalLightingModel+indirectSpecular)
    * [.ambientOcclusion(builder)](#PhysicalLightingModel+ambientOcclusion)
    * [.finish(builder)](#PhysicalLightingModel+finish)

<a name="new_PhysicalLightingModel_new"></a>

### new PhysicalLightingModel([clearcoat], [sheen], [iridescence], [anisotropy], [transmission], [dispersion])
Constructs a new physical lighting model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [clearcoat] | <code>boolean</code> | <code>false</code> | Whether clearcoat is supported or not. |
| [sheen] | <code>boolean</code> | <code>false</code> | Whether sheen is supported or not. |
| [iridescence] | <code>boolean</code> | <code>false</code> | Whether iridescence is supported or not. |
| [anisotropy] | <code>boolean</code> | <code>false</code> | Whether anisotropy is supported or not. |
| [transmission] | <code>boolean</code> | <code>false</code> | Whether transmission is supported or not. |
| [dispersion] | <code>boolean</code> | <code>false</code> | Whether dispersion is supported or not. |

<a name="PhysicalLightingModel+clearcoat"></a>

### physicalLightingModel.clearcoat : <code>boolean</code>
Whether clearcoat is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+sheen"></a>

### physicalLightingModel.sheen : <code>boolean</code>
Whether sheen is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+iridescence"></a>

### physicalLightingModel.iridescence : <code>boolean</code>
Whether iridescence is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+anisotropy"></a>

### physicalLightingModel.anisotropy : <code>boolean</code>
Whether anisotropy is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+transmission"></a>

### physicalLightingModel.transmission : <code>boolean</code>
Whether transmission is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+dispersion"></a>

### physicalLightingModel.dispersion : <code>boolean</code>
Whether dispersion is supported or not.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>false</code>  
<a name="PhysicalLightingModel+clearcoatRadiance"></a>

### physicalLightingModel.clearcoatRadiance : <code>Node</code>
The clear coat radiance.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+clearcoatSpecularDirect"></a>

### physicalLightingModel.clearcoatSpecularDirect : <code>Node</code>
The clear coat specular direct.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+clearcoatSpecularIndirect"></a>

### physicalLightingModel.clearcoatSpecularIndirect : <code>Node</code>
The clear coat specular indirect.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+sheenSpecularDirect"></a>

### physicalLightingModel.sheenSpecularDirect : <code>Node</code>
The sheen specular direct.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+sheenSpecularIndirect"></a>

### physicalLightingModel.sheenSpecularIndirect : <code>Node</code>
The sheen specular indirect.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+iridescenceFresnel"></a>

### physicalLightingModel.iridescenceFresnel : <code>Node</code>
The iridescence Fresnel.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+iridescenceF0"></a>

### physicalLightingModel.iridescenceF0 : <code>Node</code>
The iridescence F0.

**Kind**: instance property of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  
**Default**: <code>null</code>  
<a name="PhysicalLightingModel+start"></a>

### physicalLightingModel.start(builder)
Depending on what features are requested, the method prepares certain node variables
which are later used for lighting computations.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+direct"></a>

### physicalLightingModel.direct(lightData, builder)
Implements the direct light.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+directRectArea"></a>

### physicalLightingModel.directRectArea(input, builder)
This method is intended for implementing the direct light term for
rect area light nodes.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Object</code> | The input data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+indirect"></a>

### physicalLightingModel.indirect(builder)
Implements the indirect lighting.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+indirectDiffuse"></a>

### physicalLightingModel.indirectDiffuse(builder)
Implements the indirect diffuse term.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+indirectSpecular"></a>

### physicalLightingModel.indirectSpecular(builder)
Implements the indirect specular term.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+ambientOcclusion"></a>

### physicalLightingModel.ambientOcclusion(builder)
Implements the ambient occlusion term.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PhysicalLightingModel+finish"></a>

### physicalLightingModel.finish(builder)
Used for final lighting accumulations depending on the requested features.

**Kind**: instance method of [<code>PhysicalLightingModel</code>](#PhysicalLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ShadowMaskModel"></a>

## ShadowMaskModel ⇐ <code>LightingModel</code>
Represents lighting model for a shadow material. Used in [ShadowNodeMaterial](ShadowNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingModel</code>  

* [ShadowMaskModel](#ShadowMaskModel) ⇐ <code>LightingModel</code>
    * [new ShadowMaskModel()](#new_ShadowMaskModel_new)
    * [.shadowNode](#ShadowMaskModel+shadowNode) : <code>Node</code>
    * [.direct(input)](#ShadowMaskModel+direct)
    * [.finish(builder)](#ShadowMaskModel+finish)

<a name="new_ShadowMaskModel_new"></a>

### new ShadowMaskModel()
Constructs a new shadow mask model.

<a name="ShadowMaskModel+shadowNode"></a>

### shadowMaskModel.shadowNode : <code>Node</code>
The shadow mask node.

**Kind**: instance property of [<code>ShadowMaskModel</code>](#ShadowMaskModel)  
<a name="ShadowMaskModel+direct"></a>

### shadowMaskModel.direct(input)
Only used to save the shadow mask.

**Kind**: instance method of [<code>ShadowMaskModel</code>](#ShadowMaskModel)  

| Param | Type | Description |
| --- | --- | --- |
| input | <code>Object</code> | The input data. |

<a name="ShadowMaskModel+finish"></a>

### shadowMaskModel.finish(builder)
Uses the shadow mask to produce the final color.

**Kind**: instance method of [<code>ShadowMaskModel</code>](#ShadowMaskModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ToonLightingModel"></a>

## ToonLightingModel ⇐ <code>LightingModel</code>
Represents the lighting model for a toon material. Used in [MeshToonNodeMaterial](MeshToonNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingModel</code>  

* [ToonLightingModel](#ToonLightingModel) ⇐ <code>LightingModel</code>
    * [.direct(lightData, builder)](#ToonLightingModel+direct)
    * [.indirect(builder)](#ToonLightingModel+indirect)

<a name="ToonLightingModel+direct"></a>

### toonLightingModel.direct(lightData, builder)
Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
reduced to a small number of discrete shades to create a comic-like, flat look.

**Kind**: instance method of [<code>ToonLightingModel</code>](#ToonLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| lightData | <code>Object</code> | The light data. |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ToonLightingModel+indirect"></a>

### toonLightingModel.indirect(builder)
Implements the indirect lighting.

**Kind**: instance method of [<code>ToonLightingModel</code>](#ToonLightingModel)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="VolumetricLightingModel"></a>

## VolumetricLightingModel ⇐ <code>LightingModel</code>
VolumetricLightingModel class extends the LightingModel to implement volumetric lighting effects.
This model calculates the scattering and transmittance of light through a volumetric medium.
It dynamically adjusts the direction of the ray based on the camera and object positions.
The model supports custom scattering and depth nodes to enhance the lighting effects.

**Kind**: global class  
**Extends**: <code>LightingModel</code>  
<a name="getParallaxCorrectNormal"></a>

## getParallaxCorrectNormal(normal, cubeSize, cubePos) ⇒ <code>Node.&lt;vec3&gt;</code>
This computes a parallax corrected normal which is used for box-projected cube mapping (BPCEM).

Reference: [https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html](https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html)

```js
const uvNode = getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) );
material.envNode = pmremTexture( renderTarget.texture, uvNode );
```

**Kind**: global function  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The parallax corrected normal.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| normal | <code>Node.&lt;vec3&gt;</code> | The normal to correct. |
| cubeSize | <code>Node.&lt;vec3&gt;</code> | The cube size should reflect the size of the environment (BPCEM is usually applied in closed environments like rooms). |
| cubePos | <code>Node.&lt;vec3&gt;</code> | The cube position. |

## Classes

<dl>
<dt><a href="#RangeNode">RangeNode</a> ⇐ <code>Node</code></dt>
<dd><p><code>RangeNode</code> generates random instanced attribute data in a defined range.
An exemplary use case for this utility node is to generate random per-instance
colors:</p>
<pre><code class="language-js">const material = new MeshBasicNodeMaterial();
material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );
const mesh = new InstancedMesh( geometry, material, count );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#range">range([minNode], [maxNode])</a> ⇒ <code><a href="#RangeNode">RangeNode</a></code></dt>
<dd><p>TSL function for creating a range node.</p>
</dd>
</dl>

<a name="RangeNode"></a>

## RangeNode ⇐ <code>Node</code>
`RangeNode` generates random instanced attribute data in a defined range.
An exemplary use case for this utility node is to generate random per-instance
colors:
```js
const material = new MeshBasicNodeMaterial();
material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );
const mesh = new InstancedMesh( geometry, material, count );
```

**Kind**: global class  
**Extends**: <code>Node</code>  

* [RangeNode](#RangeNode) ⇐ <code>Node</code>
    * [new RangeNode([minNode], [maxNode])](#new_RangeNode_new)
    * [.minNode](#RangeNode+minNode) : <code>Node.&lt;any&gt;</code>
    * [.maxNode](#RangeNode+maxNode) : <code>Node.&lt;any&gt;</code>
    * [.getVectorLength(builder)](#RangeNode+getVectorLength) ⇒ <code>number</code>
    * [.getNodeType(builder)](#RangeNode+getNodeType) ⇒ <code>string</code>

<a name="new_RangeNode_new"></a>

### new RangeNode([minNode], [maxNode])
Constructs a new range node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [minNode] | <code>Node.&lt;any&gt;</code> | <code>float()</code> | A node defining the lower bound of the range. |
| [maxNode] | <code>Node.&lt;any&gt;</code> | <code>float()</code> | A node defining the upper bound of the range. |

<a name="RangeNode+minNode"></a>

### rangeNode.minNode : <code>Node.&lt;any&gt;</code>
A node defining the lower bound of the range.

**Kind**: instance property of [<code>RangeNode</code>](#RangeNode)  
**Default**: <code>float()</code>  
<a name="RangeNode+maxNode"></a>

### rangeNode.maxNode : <code>Node.&lt;any&gt;</code>
A node defining the upper bound of the range.

**Kind**: instance property of [<code>RangeNode</code>](#RangeNode)  
**Default**: <code>float()</code>  
<a name="RangeNode+getVectorLength"></a>

### rangeNode.getVectorLength(builder) ⇒ <code>number</code>
Returns the vector length which is computed based on the range definition.

**Kind**: instance method of [<code>RangeNode</code>](#RangeNode)  
**Returns**: <code>number</code> - The vector length.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="RangeNode+getNodeType"></a>

### rangeNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from range definition.

**Kind**: instance method of [<code>RangeNode</code>](#RangeNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="range"></a>

## range([minNode], [maxNode]) ⇒ [<code>RangeNode</code>](#RangeNode)
TSL function for creating a range node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [minNode] | <code>Node.&lt;any&gt;</code> | <code>float()</code> | A node defining the lower bound of the range. |
| [maxNode] | <code>Node.&lt;any&gt;</code> | <code>float()</code> | A node defining the upper bound of the range. |

## Classes

<dl>
<dt><a href="#AtomicFunctionNode">AtomicFunctionNode</a> ⇐ <code>TempNode</code></dt>
<dd><p><code>AtomicFunctionNode</code> represents any function that can operate on atomic variable types
within a shader. In an atomic function, any modification to an atomic variable will
occur as an indivisible step with a defined order relative to other modifications.
Accordingly, even if multiple atomic functions are modifying an atomic variable at once
atomic operations will not interfere with each other.</p>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#atomicNode">atomicNode(method, pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>TSL function for creating an atomic function node.</p>
</dd>
<dt><a href="#atomicFunc">atomicFunc(method, pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>TSL function for appending an atomic function call into the programmatic flow of a compute shader.</p>
</dd>
<dt><a href="#atomicLoad">atomicLoad(pointerNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Loads the value stored in the atomic variable.</p>
</dd>
<dt><a href="#atomicStore">atomicStore(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores a value in the atomic variable.</p>
</dd>
<dt><a href="#atomicAdd">atomicAdd(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Increments the value stored in the atomic variable.</p>
</dd>
<dt><a href="#atomicSub">atomicSub(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Decrements the value stored in the atomic variable.</p>
</dd>
<dt><a href="#atomicMax">atomicMax(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the maximum between its current value and a parameter.</p>
</dd>
<dt><a href="#atomicMin">atomicMin(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the minimum between its current value and a parameter.</p>
</dd>
<dt><a href="#atomicAnd">atomicAnd(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the bitwise AND of its value with a parameter.</p>
</dd>
<dt><a href="#atomicOr">atomicOr(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the bitwise OR of its value with a parameter.</p>
</dd>
<dt><a href="#atomicXor">atomicXor(pointerNode, valueNode)</a> ⇒ <code><a href="#AtomicFunctionNode">AtomicFunctionNode</a></code></dt>
<dd><p>Stores in an atomic variable the bitwise XOR of its value with a parameter.</p>
</dd>
</dl>

<a name="AtomicFunctionNode"></a>

## AtomicFunctionNode ⇐ <code>TempNode</code>
`AtomicFunctionNode` represents any function that can operate on atomic variable types
within a shader. In an atomic function, any modification to an atomic variable will
occur as an indivisible step with a defined order relative to other modifications.
Accordingly, even if multiple atomic functions are modifying an atomic variable at once
atomic operations will not interfere with each other.

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [AtomicFunctionNode](#AtomicFunctionNode) ⇐ <code>TempNode</code>
    * [new AtomicFunctionNode(method, pointerNode, valueNode)](#new_AtomicFunctionNode_new)
    * [.method](#AtomicFunctionNode+method) : <code>string</code>
    * [.pointerNode](#AtomicFunctionNode+pointerNode) : <code>Node</code>
    * [.valueNode](#AtomicFunctionNode+valueNode) : <code>Node</code>
    * [.getInputType(builder)](#AtomicFunctionNode+getInputType) ⇒ <code>string</code>
    * [.getNodeType(builder)](#AtomicFunctionNode+getNodeType) ⇒ <code>string</code>

<a name="new_AtomicFunctionNode_new"></a>

### new AtomicFunctionNode(method, pointerNode, valueNode)
Constructs a new atomic function node.


| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The signature of the atomic function to construct. |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="AtomicFunctionNode+method"></a>

### atomicFunctionNode.method : <code>string</code>
The signature of the atomic function to construct.

**Kind**: instance property of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
<a name="AtomicFunctionNode+pointerNode"></a>

### atomicFunctionNode.pointerNode : <code>Node</code>
An atomic variable or element of an atomic buffer.

**Kind**: instance property of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
<a name="AtomicFunctionNode+valueNode"></a>

### atomicFunctionNode.valueNode : <code>Node</code>
A value that modifies the atomic variable.

**Kind**: instance property of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
<a name="AtomicFunctionNode+getInputType"></a>

### atomicFunctionNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation to return the type of
the pointer node.

**Kind**: instance method of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AtomicFunctionNode+getNodeType"></a>

### atomicFunctionNode.getNodeType(builder) ⇒ <code>string</code>
Overwritten since the node type is inferred from the input type.

**Kind**: instance method of [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="atomicNode"></a>

## atomicNode(method, pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
TSL function for creating an atomic function node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The signature of the atomic function to construct. |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicFunc"></a>

## atomicFunc(method, pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
TSL function for appending an atomic function call into the programmatic flow of a compute shader.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| method | <code>string</code> | The signature of the atomic function to construct. |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicLoad"></a>

## atomicLoad(pointerNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Loads the value stored in the atomic variable.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |

<a name="atomicStore"></a>

## atomicStore(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores a value in the atomic variable.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicAdd"></a>

## atomicAdd(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Increments the value stored in the atomic variable.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicSub"></a>

## atomicSub(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Decrements the value stored in the atomic variable.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicMax"></a>

## atomicMax(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the maximum between its current value and a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicMin"></a>

## atomicMin(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the minimum between its current value and a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicAnd"></a>

## atomicAnd(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the bitwise AND of its value with a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicOr"></a>

## atomicOr(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the bitwise OR of its value with a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

<a name="atomicXor"></a>

## atomicXor(pointerNode, valueNode) ⇒ [<code>AtomicFunctionNode</code>](#AtomicFunctionNode)
Stores in an atomic variable the bitwise XOR of its value with a parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| pointerNode | <code>Node</code> | An atomic variable or element of an atomic buffer. |
| valueNode | <code>Node</code> | The value that mutates the atomic variable. |

## Classes

<dl>
<dt><a href="#BarrierNode">BarrierNode</a> ⇐ <code>Node</code></dt>
<dd><p>Represents a GPU control barrier that synchronizes compute operations within a given scope.</p>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#barrier">barrier(scope)</a> ⇒ <code><a href="#BarrierNode">BarrierNode</a></code></dt>
<dd><p>TSL function for creating a barrier node.</p>
</dd>
<dt><a href="#workgroupBarrier">workgroupBarrier()</a> ⇒ <code><a href="#BarrierNode">BarrierNode</a></code></dt>
<dd><p>TSL function for creating a workgroup barrier. All compute shader
invocations must wait for each invocation within a workgroup to
complete before the barrier can be surpassed.</p>
</dd>
<dt><a href="#storageBarrier">storageBarrier()</a> ⇒ <code><a href="#BarrierNode">BarrierNode</a></code></dt>
<dd><p>TSL function for creating a storage barrier. All invocations must
wait for each access to variables within the &#39;storage&#39; address space
to complete before the barrier can be passed.</p>
</dd>
<dt><a href="#textureBarrier">textureBarrier()</a> ⇒ <code><a href="#BarrierNode">BarrierNode</a></code></dt>
<dd><p>TSL function for creating a texture barrier. All invocations must
wait for each access to variables within the &#39;texture&#39; address space
to complete before the barrier can be passed.</p>
</dd>
</dl>

<a name="BarrierNode"></a>

## BarrierNode ⇐ <code>Node</code>
Represents a GPU control barrier that synchronizes compute operations within a given scope.

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>Node</code>  
<a name="new_BarrierNode_new"></a>

### new BarrierNode(scope)
Constructs a new barrier node.


| Param | Type | Description |
| --- | --- | --- |
| scope | <code>string</code> | The scope defines the behavior of the node. |

<a name="barrier"></a>

## barrier(scope) ⇒ [<code>BarrierNode</code>](#BarrierNode)
TSL function for creating a barrier node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scope | <code>string</code> | The scope defines the behavior of the node.. |

<a name="workgroupBarrier"></a>

## workgroupBarrier() ⇒ [<code>BarrierNode</code>](#BarrierNode)
TSL function for creating a workgroup barrier. All compute shader
invocations must wait for each invocation within a workgroup to
complete before the barrier can be surpassed.

**Kind**: global function  
**Tsl**:   
<a name="storageBarrier"></a>

## storageBarrier() ⇒ [<code>BarrierNode</code>](#BarrierNode)
TSL function for creating a storage barrier. All invocations must
wait for each access to variables within the 'storage' address space
to complete before the barrier can be passed.

**Kind**: global function  
**Tsl**:   
<a name="textureBarrier"></a>

## textureBarrier() ⇒ [<code>BarrierNode</code>](#BarrierNode)
TSL function for creating a texture barrier. All invocations must
wait for each access to variables within the 'texture' address space
to complete before the barrier can be passed.

**Kind**: global function  
**Tsl**:   
## Classes

<dl>
<dt><a href="#ComputeBuiltinNode">ComputeBuiltinNode</a> ⇐ <code>Node</code></dt>
<dd><p><code>ComputeBuiltinNode</code> represents a compute-scope builtin value that expose information
about the currently running dispatch and/or the device it is running on.</p>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#numWorkgroups">numWorkgroups</a> : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code></dt>
<dd><p>Represents the number of workgroups dispatched by the compute shader.</p>
<pre><code class="language-js">// Run 512 invocations/threads with a workgroup size of 128.
const computeFn = Fn(() =&gt; {

    // numWorkgroups.x = 4
    storageBuffer.element(0).assign(numWorkgroups.x)

})().compute(512, [128]);

// Run 512 invocations/threads with the default workgroup size of 64.
const computeFn = Fn(() =&gt; {

    // numWorkgroups.x = 8
    storageBuffer.element(0).assign(numWorkgroups.x)

})().compute(512);
</code></pre>
</dd>
<dt><a href="#workgroupId">workgroupId</a> : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code></dt>
<dd><p>Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.</p>
<pre><code class="language-js">// Execute 12 compute threads with a workgroup size of 3.
const computeFn = Fn( () =&gt; {

    If( workgroupId.x.mod( 2 ).equal( 0 ), () =&gt; {

        storageBuffer.element( instanceIndex ).assign( instanceIndex );

    } ).Else( () =&gt; {

        storageBuffer.element( instanceIndex ).assign( 0 );

    } );

} )().compute( 12, [ 3 ] );

// workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];
// Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];
</code></pre>
</dd>
<dt><a href="#globalId">globalId</a> : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code></dt>
<dd><p>A non-linearized 3-dimensional representation of the current invocation&#39;s position within a 3D global grid.</p>
</dd>
<dt><a href="#localId">localId</a> : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code></dt>
<dd><p>A non-linearized 3-dimensional representation of the current invocation&#39;s position within a 3D workgroup grid.</p>
</dd>
<dt><a href="#subgroupSize">subgroupSize</a> : <code>ComputeBuiltinNode.&lt;uint&gt;</code></dt>
<dd><p>A device dependent variable that exposes the size of the current invocation&#39;s subgroup.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#computeBuiltin">computeBuiltin(name, nodeType)</a> ⇒ <code><a href="#ComputeBuiltinNode">ComputeBuiltinNode</a></code></dt>
<dd><p>TSL function for creating a compute builtin node.</p>
</dd>
</dl>

<a name="ComputeBuiltinNode"></a>

## ComputeBuiltinNode ⇐ <code>Node</code>
`ComputeBuiltinNode` represents a compute-scope builtin value that expose information
about the currently running dispatch and/or the device it is running on.

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ComputeBuiltinNode](#ComputeBuiltinNode) ⇐ <code>Node</code>
    * [new ComputeBuiltinNode(builtinName, nodeType)](#new_ComputeBuiltinNode_new)
    * [.getHash(builder)](#ComputeBuiltinNode+getHash) ⇒ <code>string</code>
    * [.getNodeType(builder)](#ComputeBuiltinNode+getNodeType) ⇒ <code>string</code>
    * [.setBuiltinName(builtinName)](#ComputeBuiltinNode+setBuiltinName) ⇒ [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)
    * [.getBuiltinName(builder)](#ComputeBuiltinNode+getBuiltinName) ⇒ <code>string</code>
    * [.hasBuiltin(builder)](#ComputeBuiltinNode+hasBuiltin) ⇒ <code>boolean</code>

<a name="new_ComputeBuiltinNode_new"></a>

### new ComputeBuiltinNode(builtinName, nodeType)
Constructs a new compute builtin node.


| Param | Type | Description |
| --- | --- | --- |
| builtinName | <code>string</code> | The built-in name. |
| nodeType | <code>string</code> | The node type. |

<a name="ComputeBuiltinNode+getHash"></a>

### computeBuiltinNode.getHash(builder) ⇒ <code>string</code>
This method is overwritten since hash is derived from the built-in name.

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: <code>string</code> - The hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ComputeBuiltinNode+getNodeType"></a>

### computeBuiltinNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is simply derived from `nodeType`..

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ComputeBuiltinNode+setBuiltinName"></a>

### computeBuiltinNode.setBuiltinName(builtinName) ⇒ [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)
Sets the builtin name.

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| builtinName | <code>string</code> | The built-in name. |

<a name="ComputeBuiltinNode+getBuiltinName"></a>

### computeBuiltinNode.getBuiltinName(builder) ⇒ <code>string</code>
Returns the builtin name.

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: <code>string</code> - The builtin name.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="ComputeBuiltinNode+hasBuiltin"></a>

### computeBuiltinNode.hasBuiltin(builder) ⇒ <code>boolean</code>
Whether the current node builder has the builtin or not.

**Kind**: instance method of [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)  
**Returns**: <code>boolean</code> - Whether the builder has the builtin or not.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="numWorkgroups"></a>

## numWorkgroups : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code>
Represents the number of workgroups dispatched by the compute shader.
```js
// Run 512 invocations/threads with a workgroup size of 128.
const computeFn = Fn(() => {

    // numWorkgroups.x = 4
    storageBuffer.element(0).assign(numWorkgroups.x)

})().compute(512, [128]);

// Run 512 invocations/threads with the default workgroup size of 64.
const computeFn = Fn(() => {

    // numWorkgroups.x = 8
    storageBuffer.element(0).assign(numWorkgroups.x)

})().compute(512);
```

**Kind**: global constant  
**Tsl**:   
<a name="workgroupId"></a>

## workgroupId : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code>
Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.
```js
// Execute 12 compute threads with a workgroup size of 3.
const computeFn = Fn( () => {

	If( workgroupId.x.mod( 2 ).equal( 0 ), () => {

		storageBuffer.element( instanceIndex ).assign( instanceIndex );

	} ).Else( () => {

		storageBuffer.element( instanceIndex ).assign( 0 );

	} );

} )().compute( 12, [ 3 ] );

// workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];
// Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];
```

**Kind**: global constant  
**Tsl**:   
<a name="globalId"></a>

## globalId : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code>
A non-linearized 3-dimensional representation of the current invocation's position within a 3D global grid.

**Kind**: global constant  
**Tsl**:   
<a name="localId"></a>

## localId : <code>ComputeBuiltinNode.&lt;uvec3&gt;</code>
A non-linearized 3-dimensional representation of the current invocation's position within a 3D workgroup grid.

**Kind**: global constant  
**Tsl**:   
<a name="subgroupSize"></a>

## subgroupSize : <code>ComputeBuiltinNode.&lt;uint&gt;</code>
A device dependent variable that exposes the size of the current invocation's subgroup.

**Kind**: global constant  
**Tsl**:   
<a name="computeBuiltin"></a>

## computeBuiltin(name, nodeType) ⇒ [<code>ComputeBuiltinNode</code>](#ComputeBuiltinNode)
TSL function for creating a compute builtin node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The built-in name. |
| nodeType | <code>string</code> | The node type. |

## Classes

<dl>
<dt><a href="#ComputeNode">ComputeNode</a> ⇐ <code>Node</code></dt>
<dd><p>TODO</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#compute">compute(node, count, [workgroupSize])</a> ⇒ <code>AtomicFunctionNode</code></dt>
<dd><p>TSL function for creating a compute node.</p>
</dd>
</dl>

<a name="ComputeNode"></a>

## ComputeNode ⇐ <code>Node</code>
TODO

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ComputeNode](#ComputeNode) ⇐ <code>Node</code>
    * [new ComputeNode(computeNode, count, [workgroupSize])](#new_ComputeNode_new)
    * [.isComputeNode](#ComputeNode+isComputeNode) : <code>boolean</code>
    * [.computeNode](#ComputeNode+computeNode) : <code>Node</code>
    * [.count](#ComputeNode+count) : <code>number</code>
    * [.workgroupSize](#ComputeNode+workgroupSize) : <code>Array.&lt;number&gt;</code>
    * [.dispatchCount](#ComputeNode+dispatchCount) : <code>number</code>
    * [.version](#ComputeNode+version) : <code>number</code>
    * [.name](#ComputeNode+name) : <code>string</code>
    * [.updateBeforeType](#ComputeNode+updateBeforeType) : <code>string</code>
    * [.onInitFunction](#ComputeNode+onInitFunction) : <code>function</code>
    * [.dispose()](#ComputeNode+dispose)
    * [.label(name)](#ComputeNode+label) ⇒ [<code>ComputeNode</code>](#ComputeNode)
    * [.updateDispatchCount()](#ComputeNode+updateDispatchCount)
    * [.onInit(callback)](#ComputeNode+onInit) ⇒ [<code>ComputeNode</code>](#ComputeNode)
    * [.updateBefore(frame)](#ComputeNode+updateBefore)

<a name="new_ComputeNode_new"></a>

### new ComputeNode(computeNode, count, [workgroupSize])
Constructs a new compute node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| computeNode | <code>Node</code> |  | TODO |
| count | <code>number</code> |  | TODO. |
| [workgroupSize] | <code>Array.&lt;number&gt;</code> | <code>[64]</code> | TODO. |

<a name="ComputeNode+isComputeNode"></a>

### computeNode.isComputeNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ComputeNode+computeNode"></a>

### computeNode.computeNode : <code>Node</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+count"></a>

### computeNode.count : <code>number</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+workgroupSize"></a>

### computeNode.workgroupSize : <code>Array.&lt;number&gt;</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
**Default**: <code>[64]</code>  
<a name="ComputeNode+dispatchCount"></a>

### computeNode.dispatchCount : <code>number</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+version"></a>

### computeNode.version : <code>number</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+name"></a>

### computeNode.name : <code>string</code>
The name or label of the uniform.

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
**Default**: <code>&quot;&#x27;&#x27;&quot;</code>  
<a name="ComputeNode+updateBeforeType"></a>

### computeNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since [updateBefore](#ComputeNode+updateBefore)
is executed once per object by default.

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
**Default**: <code>&quot;&#x27;object&#x27;&quot;</code>  
<a name="ComputeNode+onInitFunction"></a>

### computeNode.onInitFunction : <code>function</code>
TODO

**Kind**: instance property of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+dispose"></a>

### computeNode.dispose()
Executes the `dispose` event for this node.

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+label"></a>

### computeNode.label(name) ⇒ [<code>ComputeNode</code>](#ComputeNode)
Sets the [name](#ComputeNode+name) property.

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  
**Returns**: [<code>ComputeNode</code>](#ComputeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name of the uniform. |

<a name="ComputeNode+updateDispatchCount"></a>

### computeNode.updateDispatchCount()
TODO

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  
<a name="ComputeNode+onInit"></a>

### computeNode.onInit(callback) ⇒ [<code>ComputeNode</code>](#ComputeNode)
TODO

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  
**Returns**: [<code>ComputeNode</code>](#ComputeNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| callback | <code>function</code> | TODO. |

<a name="ComputeNode+updateBefore"></a>

### computeNode.updateBefore(frame)
The method execute the compute for this node.

**Kind**: instance method of [<code>ComputeNode</code>](#ComputeNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="compute"></a>

## compute(node, count, [workgroupSize]) ⇒ <code>AtomicFunctionNode</code>
TSL function for creating a compute node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node</code> |  | TODO |
| count | <code>number</code> |  | TODO. |
| [workgroupSize] | <code>Array.&lt;number&gt;</code> | <code>[64]</code> | TODO. |

## Classes

<dl>
<dt><a href="#WorkgroupInfoElementNode">WorkgroupInfoElementNode</a> ⇐ <code>ArrayElementNode</code></dt>
<dd><p>Represents an element of a &#39;workgroup&#39; scoped buffer.</p>
</dd>
<dt><a href="#WorkgroupInfoNode">WorkgroupInfoNode</a> ⇐ <code>Node</code></dt>
<dd><p>A node allowing the user to create a &#39;workgroup&#39; scoped buffer within the
context of a compute shader. Typically, workgroup scoped buffers are
created to hold data that is transferred from a global storage scope into
a local workgroup scope. For invocations within a workgroup, data
access speeds on &#39;workgroup&#39; scoped buffers can be significantly faster
than similar access operations on globally accessible storage buffers.</p>
<p>This node can only be used with a WebGPU backend.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#workgroupArray">workgroupArray(type, [count])</a> ⇒ <code><a href="#WorkgroupInfoNode">WorkgroupInfoNode</a></code></dt>
<dd><p>TSL function for creating a workgroup info node.
Creates a new &#39;workgroup&#39; scoped array buffer.</p>
</dd>
</dl>

<a name="WorkgroupInfoElementNode"></a>

## WorkgroupInfoElementNode ⇐ <code>ArrayElementNode</code>
Represents an element of a 'workgroup' scoped buffer.

**Kind**: global class  
**Extends**: <code>ArrayElementNode</code>  

* [WorkgroupInfoElementNode](#WorkgroupInfoElementNode) ⇐ <code>ArrayElementNode</code>
    * [new WorkgroupInfoElementNode(workgroupInfoNode, indexNode)](#new_WorkgroupInfoElementNode_new)
    * [.isWorkgroupInfoElementNode](#WorkgroupInfoElementNode+isWorkgroupInfoElementNode) : <code>boolean</code>

<a name="new_WorkgroupInfoElementNode_new"></a>

### new WorkgroupInfoElementNode(workgroupInfoNode, indexNode)
Constructs a new workgroup info element node.


| Param | Type | Description |
| --- | --- | --- |
| workgroupInfoNode | <code>Node</code> | The workgroup info node. |
| indexNode | <code>Node</code> | The index node that defines the element access. |

<a name="WorkgroupInfoElementNode+isWorkgroupInfoElementNode"></a>

### workgroupInfoElementNode.isWorkgroupInfoElementNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WorkgroupInfoElementNode</code>](#WorkgroupInfoElementNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WorkgroupInfoNode"></a>

## WorkgroupInfoNode ⇐ <code>Node</code>
A node allowing the user to create a 'workgroup' scoped buffer within the
context of a compute shader. Typically, workgroup scoped buffers are
created to hold data that is transferred from a global storage scope into
a local workgroup scope. For invocations within a workgroup, data
access speeds on 'workgroup' scoped buffers can be significantly faster
than similar access operations on globally accessible storage buffers.

This node can only be used with a WebGPU backend.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [WorkgroupInfoNode](#WorkgroupInfoNode) ⇐ <code>Node</code>
    * [new WorkgroupInfoNode(scope, bufferType, [bufferCount])](#new_WorkgroupInfoNode_new)
    * [.bufferType](#WorkgroupInfoNode+bufferType) : <code>string</code>
    * [.bufferCount](#WorkgroupInfoNode+bufferCount) : <code>number</code>
    * [.isWorkgroupInfoNode](#WorkgroupInfoNode+isWorkgroupInfoNode) : <code>boolean</code>
    * [.elementType](#WorkgroupInfoNode+elementType) : <code>string</code>
    * [.scope](#WorkgroupInfoNode+scope) : <code>string</code>
    * [.label(name)](#WorkgroupInfoNode+label) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
    * [.setScope(scope)](#WorkgroupInfoNode+setScope) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
    * [.getElementType()](#WorkgroupInfoNode+getElementType) ⇒ <code>string</code>
    * [.getInputType(builder)](#WorkgroupInfoNode+getInputType) ⇒ <code>string</code>
    * [.element(indexNode)](#WorkgroupInfoNode+element) ⇒ [<code>WorkgroupInfoElementNode</code>](#WorkgroupInfoElementNode)

<a name="new_WorkgroupInfoNode_new"></a>

### new WorkgroupInfoNode(scope, bufferType, [bufferCount])
Constructs a new buffer scoped to type scope.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scope | <code>string</code> |  | TODO. |
| bufferType | <code>string</code> |  | The data type of a 'workgroup' scoped buffer element. |
| [bufferCount] | <code>number</code> | <code>0</code> | The number of elements in the buffer. |

<a name="WorkgroupInfoNode+bufferType"></a>

### workgroupInfoNode.bufferType : <code>string</code>
The buffer type.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
<a name="WorkgroupInfoNode+bufferCount"></a>

### workgroupInfoNode.bufferCount : <code>number</code>
The buffer count.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Default**: <code>0</code>  
<a name="WorkgroupInfoNode+isWorkgroupInfoNode"></a>

### workgroupInfoNode.isWorkgroupInfoNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="WorkgroupInfoNode+elementType"></a>

### workgroupInfoNode.elementType : <code>string</code>
The data type of the array buffer.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
<a name="WorkgroupInfoNode+scope"></a>

### workgroupInfoNode.scope : <code>string</code>
TODO.

**Kind**: instance property of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
<a name="WorkgroupInfoNode+label"></a>

### workgroupInfoNode.label(name) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
Sets the name/label of this node.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>string</code> | The name to set. |

<a name="WorkgroupInfoNode+setScope"></a>

### workgroupInfoNode.setScope(scope) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
Sets the scope of this node.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| scope | <code>string</code> | The scope to set. |

<a name="WorkgroupInfoNode+getElementType"></a>

### workgroupInfoNode.getElementType() ⇒ <code>string</code>
The data type of the array buffer.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: <code>string</code> - The element type.  
<a name="WorkgroupInfoNode+getInputType"></a>

### workgroupInfoNode.getInputType(builder) ⇒ <code>string</code>
Overwrites the default implementation since the input type
is inferred from the scope.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="WorkgroupInfoNode+element"></a>

### workgroupInfoNode.element(indexNode) ⇒ [<code>WorkgroupInfoElementNode</code>](#WorkgroupInfoElementNode)
This method can be used to access elements via an index node.

**Kind**: instance method of [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)  
**Returns**: [<code>WorkgroupInfoElementNode</code>](#WorkgroupInfoElementNode) - A reference to an element.  

| Param | Type | Description |
| --- | --- | --- |
| indexNode | <code>IndexNode</code> | indexNode. |

<a name="workgroupArray"></a>

## workgroupArray(type, [count]) ⇒ [<code>WorkgroupInfoNode</code>](#WorkgroupInfoNode)
TSL function for creating a workgroup info node.
Creates a new 'workgroup' scoped array buffer.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| type | <code>string</code> |  | The data type of a 'workgroup' scoped buffer element. |
| [count] | <code>number</code> | <code>0</code> | The number of elements in the buffer. |

<a name="AONode"></a>

## AONode ⇐ <code>LightingNode</code>
A generic class that can be used by nodes which contribute
ambient occlusion to the scene. E.g. an ambient occlusion map
node can be used as input for this module. Used in [NodeMaterial](NodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [AONode](#AONode) ⇐ <code>LightingNode</code>
    * [new AONode([aoNode])](#new_AONode_new)
    * [.aoNode](#AONode+aoNode) : <code>Node.&lt;float&gt;</code>

<a name="new_AONode_new"></a>

### new AONode([aoNode])
Constructs a new AO node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [aoNode] | <code>Node.&lt;float&gt;</code> | <code></code> | The ambient occlusion node. |

<a name="AONode+aoNode"></a>

### aoNode.aoNode : <code>Node.&lt;float&gt;</code>
The ambient occlusion node.

**Kind**: instance property of [<code>AONode</code>](#AONode)  
**Default**: <code>null</code>  
<a name="AmbientLightNode"></a>

## AmbientLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing ambient lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  
<a name="new_AmbientLightNode_new"></a>

### new AmbientLightNode([light])
Constructs a new ambient light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>AmbientLight</code> | <code></code> | The ambient light source. |

<a name="AnalyticLightNode"></a>

## AnalyticLightNode ⇐ <code>LightingNode</code>
Base class for analytic light nodes.

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [AnalyticLightNode](#AnalyticLightNode) ⇐ <code>LightingNode</code>
    * [new AnalyticLightNode([light])](#new_AnalyticLightNode_new)
    * [.light](#AnalyticLightNode+light) : <code>Light</code>
    * [.color](#AnalyticLightNode+color) : <code>Color</code>
    * [.colorNode](#AnalyticLightNode+colorNode) : <code>Node</code>
    * [.baseColorNode](#AnalyticLightNode+baseColorNode) : <code>Node</code>
    * [.shadowNode](#AnalyticLightNode+shadowNode) : <code>ShadowNode</code>
    * [.shadowColorNode](#AnalyticLightNode+shadowColorNode) : <code>Node</code>
    * [.isAnalyticLightNode](#AnalyticLightNode+isAnalyticLightNode) : <code>boolean</code>
    * [.updateType](#AnalyticLightNode+updateType) : <code>string</code>
    * [.customCacheKey()](#AnalyticLightNode+customCacheKey) ⇒ <code>number</code>
    * *[.setupDirect(builder)](#AnalyticLightNode+setupDirect) ⇒ <code>Object</code> \| <code>undefined</code>*
    * *[.setupDirectRectArea(builder)](#AnalyticLightNode+setupDirectRectArea) ⇒ <code>Object</code> \| <code>undefined</code>*
    * [.setupShadowNode()](#AnalyticLightNode+setupShadowNode) ⇒ <code>ShadowNode</code>
    * [.setupShadow(builder)](#AnalyticLightNode+setupShadow)
    * [.setup(builder)](#AnalyticLightNode+setup)
    * [.update(frame)](#AnalyticLightNode+update)

<a name="new_AnalyticLightNode_new"></a>

### new AnalyticLightNode([light])
Constructs a new analytic light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>Light</code> | <code></code> | The light source. |

<a name="AnalyticLightNode+light"></a>

### analyticLightNode.light : <code>Light</code>
The light source.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>null</code>  
<a name="AnalyticLightNode+color"></a>

### analyticLightNode.color : <code>Color</code>
The light's color value.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
<a name="AnalyticLightNode+colorNode"></a>

### analyticLightNode.colorNode : <code>Node</code>
The light's color node. Points to `colorNode` of the light source, if set. Otherwise
it creates a uniform node based on [color](#AnalyticLightNode+color).

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
<a name="AnalyticLightNode+baseColorNode"></a>

### analyticLightNode.baseColorNode : <code>Node</code>
This property is used to retain a reference to the original value of [colorNode](#AnalyticLightNode+colorNode).
The final color node is represented by a different node when using shadows.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>null</code>  
<a name="AnalyticLightNode+shadowNode"></a>

### analyticLightNode.shadowNode : <code>ShadowNode</code>
Represents the light's shadow.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>null</code>  
<a name="AnalyticLightNode+shadowColorNode"></a>

### analyticLightNode.shadowColorNode : <code>Node</code>
Represents the light's shadow color.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>null</code>  
<a name="AnalyticLightNode+isAnalyticLightNode"></a>

### analyticLightNode.isAnalyticLightNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="AnalyticLightNode+updateType"></a>

### analyticLightNode.updateType : <code>string</code>
Overwritten since analytic light nodes are updated
once per frame.

**Kind**: instance property of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="AnalyticLightNode+customCacheKey"></a>

### analyticLightNode.customCacheKey() ⇒ <code>number</code>
Overwrites the default [Node#customCacheKey](Node#customCacheKey) implementation by including the
`light.id` and `light.castShadow` into the cache key.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Returns**: <code>number</code> - The custom cache key.  
<a name="AnalyticLightNode+setupDirect"></a>

### *analyticLightNode.setupDirect(builder) ⇒ <code>Object</code> \| <code>undefined</code>*
Sets up the direct lighting for the analytic light node.

**Kind**: instance abstract method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Returns**: <code>Object</code> \| <code>undefined</code> - The direct light data (color and direction).  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The builder object used for setting up the light. |

<a name="AnalyticLightNode+setupDirectRectArea"></a>

### *analyticLightNode.setupDirectRectArea(builder) ⇒ <code>Object</code> \| <code>undefined</code>*
Sets up the direct rect area lighting for the analytic light node.

**Kind**: instance abstract method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Returns**: <code>Object</code> \| <code>undefined</code> - The direct rect area light data.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The builder object used for setting up the light. |

<a name="AnalyticLightNode+setupShadowNode"></a>

### analyticLightNode.setupShadowNode() ⇒ <code>ShadowNode</code>
Setups the shadow node for this light. The method exists so concrete light classes
can setup different types of shadow nodes.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  
**Returns**: <code>ShadowNode</code> - The created shadow node.  
<a name="AnalyticLightNode+setupShadow"></a>

### analyticLightNode.setupShadow(builder)
Setups the shadow for this light. This method is only executed if the light
cast shadows and the current build object receives shadows. It incorporates
shadows into the lighting computation.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AnalyticLightNode+setup"></a>

### analyticLightNode.setup(builder)
Unlike most other nodes, lighting nodes do not return a output node in [Node#setup](Node#setup).
The main purpose of lighting nodes is to configure the current [LightingModel](LightingModel) and/or
invocate the respective interface methods.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AnalyticLightNode+update"></a>

### analyticLightNode.update(frame)
The update method is used to update light uniforms per frame.
Potentially overwritten in concrete light nodes to update light
specific uniforms.

**Kind**: instance method of [<code>AnalyticLightNode</code>](#AnalyticLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="BasicEnvironmentNode"></a>

## BasicEnvironmentNode ⇐ <code>LightingNode</code>
Represents a basic model for Image-based lighting (IBL). The environment
is defined via environment maps in the equirectangular or cube map format.
`BasicEnvironmentNode` is intended for non-PBR materials like [MeshBasicNodeMaterial](MeshBasicNodeMaterial)
or [MeshPhongNodeMaterial](MeshPhongNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [BasicEnvironmentNode](#BasicEnvironmentNode) ⇐ <code>LightingNode</code>
    * [new BasicEnvironmentNode([envNode])](#new_BasicEnvironmentNode_new)
    * [.envNode](#BasicEnvironmentNode+envNode) : <code>Node</code>

<a name="new_BasicEnvironmentNode_new"></a>

### new BasicEnvironmentNode([envNode])
Constructs a new basic environment node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [envNode] | <code>Node</code> | <code></code> | A node representing the environment. |

<a name="BasicEnvironmentNode+envNode"></a>

### basicEnvironmentNode.envNode : <code>Node</code>
A node representing the environment.

**Kind**: instance property of [<code>BasicEnvironmentNode</code>](#BasicEnvironmentNode)  
**Default**: <code>null</code>  
<a name="BasicLightMapNode"></a>

## BasicLightMapNode ⇐ <code>LightingNode</code>
A specific version of [IrradianceNode](IrradianceNode) that is only relevant
for [MeshBasicNodeMaterial](MeshBasicNodeMaterial). Since the material is unlit, it
requires a special scaling factor for the light map.

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [BasicLightMapNode](#BasicLightMapNode) ⇐ <code>LightingNode</code>
    * [new BasicLightMapNode([lightMapNode])](#new_BasicLightMapNode_new)
    * [.lightMapNode](#BasicLightMapNode+lightMapNode) : <code>Node.&lt;vec3&gt;</code>

<a name="new_BasicLightMapNode_new"></a>

### new BasicLightMapNode([lightMapNode])
Constructs a new basic light map node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [lightMapNode] | <code>Node.&lt;vec3&gt;</code> | <code></code> | The light map node. |

<a name="BasicLightMapNode+lightMapNode"></a>

### basicLightMapNode.lightMapNode : <code>Node.&lt;vec3&gt;</code>
The light map node.

**Kind**: instance property of [<code>BasicLightMapNode</code>](#BasicLightMapNode)  
<a name="DirectionalLightNode"></a>

## DirectionalLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing directional lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  
<a name="new_DirectionalLightNode_new"></a>

### new DirectionalLightNode([light])
Constructs a new directional light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>DirectionalLight</code> | <code></code> | The directional light source. |

<a name="EnvironmentNode"></a>

## EnvironmentNode ⇐ <code>LightingNode</code>
Represents a physical model for Image-based lighting (IBL). The environment
is defined via environment maps in the equirectangular, cube map or cubeUV (PMREM) format.
`EnvironmentNode` is intended for PBR materials like [MeshStandardNodeMaterial](MeshStandardNodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [EnvironmentNode](#EnvironmentNode) ⇐ <code>LightingNode</code>
    * [new EnvironmentNode([envNode])](#new_EnvironmentNode_new)
    * [.envNode](#EnvironmentNode+envNode) : <code>Node</code>

<a name="new_EnvironmentNode_new"></a>

### new EnvironmentNode([envNode])
Constructs a new environment node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [envNode] | <code>Node</code> | <code></code> | A node representing the environment. |

<a name="EnvironmentNode+envNode"></a>

### environmentNode.envNode : <code>Node</code>
A node representing the environment.

**Kind**: instance property of [<code>EnvironmentNode</code>](#EnvironmentNode)  
**Default**: <code>null</code>  
<a name="HemisphereLightNode"></a>

## HemisphereLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing hemisphere lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [HemisphereLightNode](#HemisphereLightNode) ⇐ <code>AnalyticLightNode</code>
    * [new HemisphereLightNode([light])](#new_HemisphereLightNode_new)
    * [.lightPositionNode](#HemisphereLightNode+lightPositionNode) : <code>UniformNode.&lt;vec3&gt;</code>
    * [.lightDirectionNode](#HemisphereLightNode+lightDirectionNode) : <code>Node.&lt;vec3&gt;</code>
    * [.groundColorNode](#HemisphereLightNode+groundColorNode) : <code>UniformNode.&lt;vec3&gt;</code>
    * [.update(frame)](#HemisphereLightNode+update)

<a name="new_HemisphereLightNode_new"></a>

### new HemisphereLightNode([light])
Constructs a new hemisphere light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>HemisphereLight</code> | <code></code> | The hemisphere light source. |

<a name="HemisphereLightNode+lightPositionNode"></a>

### hemisphereLightNode.lightPositionNode : <code>UniformNode.&lt;vec3&gt;</code>
Uniform node representing the light's position.

**Kind**: instance property of [<code>HemisphereLightNode</code>](#HemisphereLightNode)  
<a name="HemisphereLightNode+lightDirectionNode"></a>

### hemisphereLightNode.lightDirectionNode : <code>Node.&lt;vec3&gt;</code>
A node representing the light's direction.

**Kind**: instance property of [<code>HemisphereLightNode</code>](#HemisphereLightNode)  
<a name="HemisphereLightNode+groundColorNode"></a>

### hemisphereLightNode.groundColorNode : <code>UniformNode.&lt;vec3&gt;</code>
Uniform node representing the light's ground color.

**Kind**: instance property of [<code>HemisphereLightNode</code>](#HemisphereLightNode)  
<a name="HemisphereLightNode+update"></a>

### hemisphereLightNode.update(frame)
Overwritten to updated hemisphere light specific uniforms.

**Kind**: instance method of [<code>HemisphereLightNode</code>](#HemisphereLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="IESSpotLightNode"></a>

## IESSpotLightNode ⇐ <code>SpotLightNode</code>
An IES version of the default spot light node.

**Kind**: global class  
**Extends**: <code>SpotLightNode</code>  
<a name="IESSpotLightNode+getSpotAttenuation"></a>

### iesSpotLightNode.getSpotAttenuation(angleCosine) ⇒ <code>Node.&lt;float&gt;</code>
Overwrites the default implementation to compute an IES conform spot attenuation.

**Kind**: instance method of [<code>IESSpotLightNode</code>](#IESSpotLightNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The spot attenuation.  

| Param | Type | Description |
| --- | --- | --- |
| angleCosine | <code>Node.&lt;float&gt;</code> | The angle to compute the spot attenuation for. |

<a name="IrradianceNode"></a>

## IrradianceNode ⇐ <code>LightingNode</code>
A generic class that can be used by nodes which contribute
irradiance to the scene. E.g. a light map node can be used
as input for this module. Used in [NodeMaterial](NodeMaterial).

**Kind**: global class  
**Extends**: <code>LightingNode</code>  

* [IrradianceNode](#IrradianceNode) ⇐ <code>LightingNode</code>
    * [new IrradianceNode(node)](#new_IrradianceNode_new)
    * [.node](#IrradianceNode+node) : <code>Node.&lt;vec3&gt;</code>

<a name="new_IrradianceNode_new"></a>

### new IrradianceNode(node)
Constructs a new irradiance node.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec3&gt;</code> | A node contributing irradiance. |

<a name="IrradianceNode+node"></a>

### irradianceNode.node : <code>Node.&lt;vec3&gt;</code>
A node contributing irradiance.

**Kind**: instance property of [<code>IrradianceNode</code>](#IrradianceNode)  
<a name="LightProbeNode"></a>

## LightProbeNode ⇐ <code>AnalyticLightNode</code>
Module for representing light probes as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [LightProbeNode](#LightProbeNode) ⇐ <code>AnalyticLightNode</code>
    * [new LightProbeNode([light])](#new_LightProbeNode_new)
    * [.lightProbe](#LightProbeNode+lightProbe) : <code>UniformArrayNode</code>
    * [.update(frame)](#LightProbeNode+update)

<a name="new_LightProbeNode_new"></a>

### new LightProbeNode([light])
Constructs a new light probe node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>LightProbe</code> | <code></code> | The light probe. |

<a name="LightProbeNode+lightProbe"></a>

### lightProbeNode.lightProbe : <code>UniformArrayNode</code>
Light probe represented as a uniform of spherical harmonics.

**Kind**: instance property of [<code>LightProbeNode</code>](#LightProbeNode)  
<a name="LightProbeNode+update"></a>

### lightProbeNode.update(frame)
Overwritten to updated light probe specific uniforms.

**Kind**: instance method of [<code>LightProbeNode</code>](#LightProbeNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="getDistanceAttenuation"></a>

## getDistanceAttenuation(inputs) ⇒ <code>Node.&lt;float&gt;</code>
Represents a `discard` shader operation in TSL.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The distance falloff.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.lightDistance | <code>Node.&lt;float&gt;</code> | The distance of the light's position to the current fragment position. |
| inputs.cutoffDistance | <code>Node.&lt;float&gt;</code> | The light's cutoff distance. |
| inputs.decayExponent | <code>Node.&lt;float&gt;</code> | The light's decay exponent. |

<a name="LightingContextNode"></a>

## LightingContextNode ⇐ <code>ContextNode</code>
`LightingContextNode` represents an extension of the [ContextNode](ContextNode) module
by adding lighting specific context data. It represents the runtime context of
[LightsNode](LightsNode).

**Kind**: global class  
**Extends**: <code>ContextNode</code>  

* [LightingContextNode](#LightingContextNode) ⇐ <code>ContextNode</code>
    * [new LightingContextNode(lightsNode, [lightingModel], [backdropNode], [backdropAlphaNode])](#new_LightingContextNode_new)
    * [.lightingModel](#LightingContextNode+lightingModel) : <code>LightingModel</code>
    * [.backdropNode](#LightingContextNode+backdropNode) : <code>Node.&lt;vec3&gt;</code>
    * [.backdropAlphaNode](#LightingContextNode+backdropAlphaNode) : <code>Node.&lt;float&gt;</code>
    * [.getContext()](#LightingContextNode+getContext) ⇒ <code>Object</code>

<a name="new_LightingContextNode_new"></a>

### new LightingContextNode(lightsNode, [lightingModel], [backdropNode], [backdropAlphaNode])
Constructs a new lighting context node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| lightsNode | <code>LightsNode</code> |  | The lights node. |
| [lightingModel] | <code>LightingModel</code> | <code></code> | The current lighting model. |
| [backdropNode] | <code>Node.&lt;vec3&gt;</code> | <code></code> | A backdrop node. |
| [backdropAlphaNode] | <code>Node.&lt;float&gt;</code> | <code></code> | A backdrop alpha node. |

<a name="LightingContextNode+lightingModel"></a>

### lightingContextNode.lightingModel : <code>LightingModel</code>
The current lighting model.

**Kind**: instance property of [<code>LightingContextNode</code>](#LightingContextNode)  
**Default**: <code>null</code>  
<a name="LightingContextNode+backdropNode"></a>

### lightingContextNode.backdropNode : <code>Node.&lt;vec3&gt;</code>
A backdrop node.

**Kind**: instance property of [<code>LightingContextNode</code>](#LightingContextNode)  
**Default**: <code>null</code>  
<a name="LightingContextNode+backdropAlphaNode"></a>

### lightingContextNode.backdropAlphaNode : <code>Node.&lt;float&gt;</code>
A backdrop alpha node.

**Kind**: instance property of [<code>LightingContextNode</code>](#LightingContextNode)  
**Default**: <code>null</code>  
<a name="LightingContextNode+getContext"></a>

### lightingContextNode.getContext() ⇒ <code>Object</code>
Returns a lighting context object.

**Kind**: instance method of [<code>LightingContextNode</code>](#LightingContextNode)  
**Returns**: <code>Object</code> - The lighting context object.  
<a name="LightingNode"></a>

## LightingNode ⇐ <code>Node</code>
Base class for lighting nodes.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [LightingNode](#LightingNode) ⇐ <code>Node</code>
    * [new LightingNode()](#new_LightingNode_new)
    * [.isLightingNode](#LightingNode+isLightingNode) : <code>boolean</code>

<a name="new_LightingNode_new"></a>

### new LightingNode()
Constructs a new lighting node.

<a name="LightingNode+isLightingNode"></a>

### lightingNode.isLightingNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>LightingNode</code>](#LightingNode)  
**Default**: <code>true</code>  
**Read only**: true  
## Classes

<dl>
<dt><a href="#LightsNode">LightsNode</a> ⇐ <code>Node</code></dt>
<dd><p>This node represents the scene&#39;s lighting and manages the lighting model&#39;s life cycle
for the current build 3D object. It is responsible for computing the total outgoing
light in a given lighting context.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#lights">lights(lights)</a> ⇒ <code><a href="#LightsNode">LightsNode</a></code></dt>
<dd><p>TSL function for creating an instance of <code>LightsNode</code> and configuring
it with the given array of lights.</p>
</dd>
</dl>

<a name="LightsNode"></a>

## LightsNode ⇐ <code>Node</code>
This node represents the scene's lighting and manages the lighting model's life cycle
for the current build 3D object. It is responsible for computing the total outgoing
light in a given lighting context.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [LightsNode](#LightsNode) ⇐ <code>Node</code>
    * [new LightsNode()](#new_LightsNode_new)
    * [.totalDiffuseNode](#LightsNode+totalDiffuseNode) : <code>Node.&lt;vec3&gt;</code>
    * [.totalSpecularNode](#LightsNode+totalSpecularNode) : <code>Node.&lt;vec3&gt;</code>
    * [.outgoingLightNode](#LightsNode+outgoingLightNode) : <code>Node.&lt;vec3&gt;</code>
    * [.global](#LightsNode+global) : <code>boolean</code>
    * [.hasLights](#LightsNode+hasLights) : <code>boolean</code>
    * [.customCacheKey()](#LightsNode+customCacheKey) ⇒ <code>number</code>
    * [.getHash(builder)](#LightsNode+getHash) ⇒ <code>string</code>
    * [.setupLightsNode(builder)](#LightsNode+setupLightsNode)
    * [.setupDirectLight(builder, lightNode, lightData)](#LightsNode+setupDirectLight)
    * [.setupLights(builder, lightNodes)](#LightsNode+setupLights)
    * [.setup(builder)](#LightsNode+setup) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setLights(lights)](#LightsNode+setLights) ⇒ [<code>LightsNode</code>](#LightsNode)
    * [.getLights()](#LightsNode+getLights) ⇒ <code>Array.&lt;Light&gt;</code>

<a name="new_LightsNode_new"></a>

### new LightsNode()
Constructs a new lights node.

<a name="LightsNode+totalDiffuseNode"></a>

### lightsNode.totalDiffuseNode : <code>Node.&lt;vec3&gt;</code>
A node representing the total diffuse light.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
<a name="LightsNode+totalSpecularNode"></a>

### lightsNode.totalSpecularNode : <code>Node.&lt;vec3&gt;</code>
A node representing the total specular light.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
<a name="LightsNode+outgoingLightNode"></a>

### lightsNode.outgoingLightNode : <code>Node.&lt;vec3&gt;</code>
A node representing the outgoing light.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
<a name="LightsNode+global"></a>

### lightsNode.global : <code>boolean</code>
`LightsNode` sets this property to `true` by default.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
**Default**: <code>true</code>  
<a name="LightsNode+hasLights"></a>

### lightsNode.hasLights : <code>boolean</code>
Whether the scene has lights or not.

**Kind**: instance property of [<code>LightsNode</code>](#LightsNode)  
<a name="LightsNode+customCacheKey"></a>

### lightsNode.customCacheKey() ⇒ <code>number</code>
Overwrites the default [Node#customCacheKey](Node#customCacheKey) implementation by including the
light IDs into the cache key.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: <code>number</code> - The custom cache key.  
<a name="LightsNode+getHash"></a>

### lightsNode.getHash(builder) ⇒ <code>string</code>
Computes a hash value for identifying the current light nodes setup.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: <code>string</code> - The computed hash.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="LightsNode+setupLightsNode"></a>

### lightsNode.setupLightsNode(builder)
Creates lighting nodes for each scene light. This makes it possible to further
process lights in the node system.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="LightsNode+setupDirectLight"></a>

### lightsNode.setupDirectLight(builder, lightNode, lightData)
Sets up a direct light in the lighting model.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>Object</code> | The builder object containing the context and stack. |
| lightNode | <code>Object</code> | The light node. |
| lightData | <code>Object</code> | The light object containing color and direction properties. |

<a name="LightsNode+setupLights"></a>

### lightsNode.setupLights(builder, lightNodes)
Setups the internal lights by building all respective
light nodes.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| lightNodes | <code>Array.&lt;LightingNode&gt;</code> | An array of lighting nodes. |

<a name="LightsNode+setup"></a>

### lightsNode.setup(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
The implementation makes sure that for each light in the scene
there is a corresponding light node. By building the light nodes
and evaluating the lighting model the outgoing light is computed.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - A node representing the outgoing light.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="LightsNode+setLights"></a>

### lightsNode.setLights(lights) ⇒ [<code>LightsNode</code>](#LightsNode)
Configures this node with an array of lights.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: [<code>LightsNode</code>](#LightsNode) - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| lights | <code>Array.&lt;Light&gt;</code> | An array of lights. |

<a name="LightsNode+getLights"></a>

### lightsNode.getLights() ⇒ <code>Array.&lt;Light&gt;</code>
Returns an array of the scene's lights.

**Kind**: instance method of [<code>LightsNode</code>](#LightsNode)  
**Returns**: <code>Array.&lt;Light&gt;</code> - The scene's lights.  
<a name="lights"></a>

## lights(lights) ⇒ [<code>LightsNode</code>](#LightsNode)
TSL function for creating an instance of `LightsNode` and configuring
it with the given array of lights.

**Kind**: global function  
**Returns**: [<code>LightsNode</code>](#LightsNode) - The created lights node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| lights | <code>Array.&lt;Light&gt;</code> | An array of lights. |

<a name="PointLightNode"></a>

## PointLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing point lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [PointLightNode](#PointLightNode) ⇐ <code>AnalyticLightNode</code>
    * [new PointLightNode([light])](#new_PointLightNode_new)
    * [.cutoffDistanceNode](#PointLightNode+cutoffDistanceNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.decayExponentNode](#PointLightNode+decayExponentNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.update(frame)](#PointLightNode+update)
    * [.setupShadowNode()](#PointLightNode+setupShadowNode) ⇒ <code>PointShadowNode</code>

<a name="new_PointLightNode_new"></a>

### new PointLightNode([light])
Constructs a new point light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>PointLight</code> | <code></code> | The point light source. |

<a name="PointLightNode+cutoffDistanceNode"></a>

### pointLightNode.cutoffDistanceNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the cutoff distance.

**Kind**: instance property of [<code>PointLightNode</code>](#PointLightNode)  
<a name="PointLightNode+decayExponentNode"></a>

### pointLightNode.decayExponentNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the decay exponent.

**Kind**: instance property of [<code>PointLightNode</code>](#PointLightNode)  
<a name="PointLightNode+update"></a>

### pointLightNode.update(frame)
Overwritten to updated point light specific uniforms.

**Kind**: instance method of [<code>PointLightNode</code>](#PointLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="PointLightNode+setupShadowNode"></a>

### pointLightNode.setupShadowNode() ⇒ <code>PointShadowNode</code>
Overwritten to setup point light specific shadow.

**Kind**: instance method of [<code>PointLightNode</code>](#PointLightNode)  
## Classes

<dl>
<dt><a href="#PointShadowNode">PointShadowNode</a> ⇐ <code>ShadowNode</code></dt>
<dd><p>Represents the shadow implementation for point light nodes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#pointShadow">pointShadow(light, [shadow])</a> ⇒ <code><a href="#PointShadowNode">PointShadowNode</a></code></dt>
<dd><p>TSL function for creating an instance of <code>PointShadowNode</code>.</p>
</dd>
</dl>

<a name="PointShadowNode"></a>

## PointShadowNode ⇐ <code>ShadowNode</code>
Represents the shadow implementation for point light nodes.

**Kind**: global class  
**Extends**: <code>ShadowNode</code>  

* [PointShadowNode](#PointShadowNode) ⇐ <code>ShadowNode</code>
    * [new PointShadowNode(light, [shadow])](#new_PointShadowNode_new)
    * [.getShadowFilterFn(type)](#PointShadowNode+getShadowFilterFn) ⇒ <code>function</code>
    * [.setupShadowCoord(builder, shadowPosition)](#PointShadowNode+setupShadowCoord) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setupShadowFilter(builder, inputs)](#PointShadowNode+setupShadowFilter) ⇒ <code>Node.&lt;float&gt;</code>
    * [.renderShadow(frame)](#PointShadowNode+renderShadow)

<a name="new_PointShadowNode_new"></a>

### new PointShadowNode(light, [shadow])
Constructs a new point shadow node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>PointLight</code> |  | The shadow casting point light. |
| [shadow] | <code>PointLightShadow</code> | <code></code> | An optional point light shadow. |

<a name="PointShadowNode+getShadowFilterFn"></a>

### pointShadowNode.getShadowFilterFn(type) ⇒ <code>function</code>
Overwrites the default implementation to return point light shadow specific
filtering functions.

**Kind**: instance method of [<code>PointShadowNode</code>](#PointShadowNode)  
**Returns**: <code>function</code> - The filtering function.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>number</code> | The shadow type. |

<a name="PointShadowNode+setupShadowCoord"></a>

### pointShadowNode.setupShadowCoord(builder, shadowPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
Overwrites the default implementation so the unaltered shadow position is used.

**Kind**: instance method of [<code>PointShadowNode</code>](#PointShadowNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The shadow coordinates.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| shadowPosition | <code>Node.&lt;vec3&gt;</code> | A node representing the shadow position. |

<a name="PointShadowNode+setupShadowFilter"></a>

### pointShadowNode.setupShadowFilter(builder, inputs) ⇒ <code>Node.&lt;float&gt;</code>
Overwrites the default implementation to only use point light specific
shadow filter functions.

**Kind**: instance method of [<code>PointShadowNode</code>](#PointShadowNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The result node of the shadow filtering.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| inputs | <code>Object</code> | A configuration object that defines the shadow filtering. |
| inputs.filterFn | <code>function</code> | This function defines the filtering type of the shadow map e.g. PCF. |
| inputs.shadowTexture | <code>Texture</code> | A reference to the shadow map's texture. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | Shadow coordinates which are used to sample from the shadow map. |
| inputs.shadow | <code>LightShadow</code> | The light shadow. |

<a name="PointShadowNode+renderShadow"></a>

### pointShadowNode.renderShadow(frame)
Overwrites the default implementation with point light specific
rendering code.

**Kind**: instance method of [<code>PointShadowNode</code>](#PointShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="pointShadow"></a>

## pointShadow(light, [shadow]) ⇒ [<code>PointShadowNode</code>](#PointShadowNode)
TSL function for creating an instance of `PointShadowNode`.

**Kind**: global function  
**Returns**: [<code>PointShadowNode</code>](#PointShadowNode) - The created point shadow node.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>PointLight</code> |  | The shadow casting point light. |
| [shadow] | <code>PointLightShadow</code> | <code></code> | An optional point light shadow. |

<a name="RectAreaLightNode"></a>

## RectAreaLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing rect area lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [RectAreaLightNode](#RectAreaLightNode) ⇐ <code>AnalyticLightNode</code>
    * [new RectAreaLightNode([light])](#new_RectAreaLightNode_new)
    * _instance_
        * [.halfHeight](#RectAreaLightNode+halfHeight) : <code>UniformNode.&lt;vec3&gt;</code>
        * [.halfWidth](#RectAreaLightNode+halfWidth) : <code>UniformNode.&lt;vec3&gt;</code>
        * [.updateType](#RectAreaLightNode+updateType) : <code>string</code>
        * [.update(frame)](#RectAreaLightNode+update)
    * _static_
        * [.setLTC(ltc)](#RectAreaLightNode.setLTC)

<a name="new_RectAreaLightNode_new"></a>

### new RectAreaLightNode([light])
Constructs a new rect area light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>RectAreaLight</code> | <code></code> | The rect area light source. |

<a name="RectAreaLightNode+halfHeight"></a>

### rectAreaLightNode.halfHeight : <code>UniformNode.&lt;vec3&gt;</code>
Uniform node representing the half height of the are light.

**Kind**: instance property of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  
<a name="RectAreaLightNode+halfWidth"></a>

### rectAreaLightNode.halfWidth : <code>UniformNode.&lt;vec3&gt;</code>
Uniform node representing the half width of the are light.

**Kind**: instance property of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  
<a name="RectAreaLightNode+updateType"></a>

### rectAreaLightNode.updateType : <code>string</code>
The `updateType` is set to `NodeUpdateType.RENDER` since the light
relies on `viewMatrix` which might vary per render call.

**Kind**: instance property of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="RectAreaLightNode+update"></a>

### rectAreaLightNode.update(frame)
Overwritten to updated rect area light specific uniforms.

**Kind**: instance method of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="RectAreaLightNode.setLTC"></a>

### RectAreaLightNode.setLTC(ltc)
Used to configure the internal BRDF approximation texture data.

**Kind**: static method of [<code>RectAreaLightNode</code>](#RectAreaLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| ltc | <code>RectAreaLightTexturesLib</code> | The BRDF approximation texture data. |

## Classes

<dl>
<dt><a href="#ShadowBaseNode">ShadowBaseNode</a> ⇐ <code>Node</code></dt>
<dd><p>Base class for all shadow nodes.</p>
<p>Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.
Lighting nodes might share the same shadow node type or use specific ones depending on
their requirements.</p>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#shadowPositionWorld">shadowPositionWorld</a> : <code>Node.&lt;vec3&gt;</code></dt>
<dd><p>TSL object that represents the vertex position in world space during the shadow pass.</p>
</dd>
</dl>

<a name="ShadowBaseNode"></a>

## ShadowBaseNode ⇐ <code>Node</code>
Base class for all shadow nodes.

Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.
Lighting nodes might share the same shadow node type or use specific ones depending on
their requirements.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ShadowBaseNode](#ShadowBaseNode) ⇐ <code>Node</code>
    * [new ShadowBaseNode(light)](#new_ShadowBaseNode_new)
    * [.light](#ShadowBaseNode+light) : <code>Light</code>
    * [.updateBeforeType](#ShadowBaseNode+updateBeforeType) : <code>string</code>
    * [.isShadowBaseNode](#ShadowBaseNode+isShadowBaseNode) : <code>boolean</code>
    * [.setupShadowPosition(object)](#ShadowBaseNode+setupShadowPosition)
    * [.dispose()](#ShadowBaseNode+dispose)

<a name="new_ShadowBaseNode_new"></a>

### new ShadowBaseNode(light)
Constructs a new shadow base node.


| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The shadow casting light. |

<a name="ShadowBaseNode+light"></a>

### shadowBaseNode.light : <code>Light</code>
The shadow casting light.

**Kind**: instance property of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  
<a name="ShadowBaseNode+updateBeforeType"></a>

### shadowBaseNode.updateBeforeType : <code>string</code>
Overwritten since shadows are updated by default per render.

**Kind**: instance property of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  
**Default**: <code>&quot;&#x27;render&#x27;&quot;</code>  
<a name="ShadowBaseNode+isShadowBaseNode"></a>

### shadowBaseNode.isShadowBaseNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowBaseNode+setupShadowPosition"></a>

### shadowBaseNode.setupShadowPosition(object)
Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.

**Kind**: instance method of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>NodeBuilder</code> | A configuration object that must at least hold a material reference. |

<a name="ShadowBaseNode+dispose"></a>

### shadowBaseNode.dispose()
Can be called when the shadow isn't required anymore. That can happen when
a lighting node stops casting shadows by setting [Object3D#castShadow](Object3D#castShadow)
to `false`.

**Kind**: instance method of [<code>ShadowBaseNode</code>](#ShadowBaseNode)  
<a name="shadowPositionWorld"></a>

## shadowPositionWorld : <code>Node.&lt;vec3&gt;</code>
TSL object that represents the vertex position in world space during the shadow pass.

**Kind**: global constant  
**Tsl**:   
## Classes

<dl>
<dt><a href="#ShadowNode">ShadowNode</a> ⇐ <code>ShadowBaseNode</code></dt>
<dd><p>Represents the default shadow implementation for lighting nodes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#BasicShadowFilter">BasicShadowFilter(inputs)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map
with a binary <code>[0,1]</code> result.</p>
</dd>
<dt><a href="#PCFShadowFilter">PCFShadowFilter(inputs)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A shadow filtering function performing PCF filtering.</p>
</dd>
<dt><a href="#PCFSoftShadowFilter">PCFSoftShadowFilter(inputs)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A shadow filtering function performing PCF soft filtering.</p>
</dd>
<dt><a href="#VSMShadowFilter">VSMShadowFilter(inputs)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A shadow filtering function performing VSM filtering.</p>
</dd>
<dt><a href="#VSMPassVertical">VSMPassVertical(inputs)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Represents the shader code for the first VSM render pass.</p>
</dd>
<dt><a href="#VSMPassHorizontal">VSMPassHorizontal(inputs)</a> ⇒ <code>Node.&lt;vec2&gt;</code></dt>
<dd><p>Represents the shader code for the second VSM render pass.</p>
</dd>
<dt><a href="#shadow">shadow(light, [shadow])</a> ⇒ <code><a href="#ShadowNode">ShadowNode</a></code></dt>
<dd><p>TSL function for creating an instance of <code>ShadowNode</code>.</p>
</dd>
</dl>

<a name="ShadowNode"></a>

## ShadowNode ⇐ <code>ShadowBaseNode</code>
Represents the default shadow implementation for lighting nodes.

**Kind**: global class  
**Extends**: <code>ShadowBaseNode</code>  

* [ShadowNode](#ShadowNode) ⇐ <code>ShadowBaseNode</code>
    * [new ShadowNode(light, [shadow])](#new_ShadowNode_new)
    * [.shadow](#ShadowNode+shadow) : <code>LightShadow</code>
    * [.shadowMap](#ShadowNode+shadowMap) : <code>RenderTarget</code>
    * [.vsmShadowMapVertical](#ShadowNode+vsmShadowMapVertical) : <code>RenderTarget</code>
    * [.vsmShadowMapHorizontal](#ShadowNode+vsmShadowMapHorizontal) : <code>RenderTarget</code>
    * [.vsmMaterialVertical](#ShadowNode+vsmMaterialVertical) : <code>NodeMaterial</code>
    * [.vsmMaterialHorizontal](#ShadowNode+vsmMaterialHorizontal) : <code>NodeMaterial</code>
    * [.isShadowNode](#ShadowNode+isShadowNode) : <code>boolean</code>
    * [.setupShadowFilter(builder, inputs)](#ShadowNode+setupShadowFilter) ⇒ <code>Node.&lt;float&gt;</code>
    * [.setupShadowCoord(builder, shadowPosition)](#ShadowNode+setupShadowCoord) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.getShadowFilterFn(type)](#ShadowNode+getShadowFilterFn) ⇒ <code>function</code>
    * [.setupShadow(builder)](#ShadowNode+setupShadow) ⇒ <code>Node.&lt;vec3&gt;</code>
    * [.setup(builder)](#ShadowNode+setup) ⇒ <code>ShaderCallNodeInternal</code>
    * [.renderShadow(frame)](#ShadowNode+renderShadow)
    * [.updateShadow(frame)](#ShadowNode+updateShadow)
    * [.vsmPass(renderer)](#ShadowNode+vsmPass)
    * [.dispose()](#ShadowNode+dispose)
    * [.updateBefore(frame)](#ShadowNode+updateBefore)

<a name="new_ShadowNode_new"></a>

### new ShadowNode(light, [shadow])
Constructs a new shadow node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| light | <code>Light</code> |  | The shadow casting light. |
| [shadow] | <code>LightShadow</code> | <code></code> | An optional light shadow. |

<a name="ShadowNode+shadow"></a>

### shadowNode.shadow : <code>LightShadow</code>
The light shadow which defines the properties light's
shadow.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+shadowMap"></a>

### shadowNode.shadowMap : <code>RenderTarget</code>
A reference to the shadow map which is a render target.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+vsmShadowMapVertical"></a>

### shadowNode.vsmShadowMapVertical : <code>RenderTarget</code>
Only relevant for VSM shadows. Render target for the
first VSM render pass.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+vsmShadowMapHorizontal"></a>

### shadowNode.vsmShadowMapHorizontal : <code>RenderTarget</code>
Only relevant for VSM shadows. Render target for the
second VSM render pass.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+vsmMaterialVertical"></a>

### shadowNode.vsmMaterialVertical : <code>NodeMaterial</code>
Only relevant for VSM shadows. Node material which
is used to render the first VSM pass.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+vsmMaterialHorizontal"></a>

### shadowNode.vsmMaterialHorizontal : <code>NodeMaterial</code>
Only relevant for VSM shadows. Node material which
is used to render the second VSM pass.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>null</code>  
<a name="ShadowNode+isShadowNode"></a>

### shadowNode.isShadowNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ShadowNode</code>](#ShadowNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ShadowNode+setupShadowFilter"></a>

### shadowNode.setupShadowFilter(builder, inputs) ⇒ <code>Node.&lt;float&gt;</code>
Setups the shadow filtering.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The result node of the shadow filtering.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| inputs | <code>Object</code> | A configuration object that defines the shadow filtering. |
| inputs.filterFn | <code>function</code> | This function defines the filtering type of the shadow map e.g. PCF. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | Shadow coordinates which are used to sample from the shadow map. |
| inputs.shadow | <code>LightShadow</code> | The light shadow. |

<a name="ShadowNode+setupShadowCoord"></a>

### shadowNode.setupShadowCoord(builder, shadowPosition) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the shadow coordinates.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The shadow coordinates.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |
| shadowPosition | <code>Node.&lt;vec3&gt;</code> | A node representing the shadow position. |

<a name="ShadowNode+getShadowFilterFn"></a>

### shadowNode.getShadowFilterFn(type) ⇒ <code>function</code>
Returns the shadow filtering function for the given shadow type.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>function</code> - The filtering function.  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>number</code> | The shadow type. |

<a name="ShadowNode+setupShadow"></a>

### shadowNode.setupShadow(builder) ⇒ <code>Node.&lt;vec3&gt;</code>
Setups the shadow output node.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>Node.&lt;vec3&gt;</code> - The shadow output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="ShadowNode+setup"></a>

### shadowNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
The implementation performs the setup of the output node. An output is only
produces if shadow mapping is globally enabled in the renderer.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
**Returns**: <code>ShaderCallNodeInternal</code> - The output node.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | A reference to the current node builder. |

<a name="ShadowNode+renderShadow"></a>

### shadowNode.renderShadow(frame)
Renders the shadow. The logic of this function could be included
into [updateShadow](#ShadowNode+updateShadow) however more specialized shadow
nodes might require a custom shadow map rendering. By having a
dedicated method, it's easier to overwrite the default behavior.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="ShadowNode+updateShadow"></a>

### shadowNode.updateShadow(frame)
Updates the shadow.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="ShadowNode+vsmPass"></a>

### shadowNode.vsmPass(renderer)
For VSM additional render passes are required.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>Renderer</code> | A reference to the current renderer. |

<a name="ShadowNode+dispose"></a>

### shadowNode.dispose()
Frees the internal resources of this shadow node.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  
<a name="ShadowNode+updateBefore"></a>

### shadowNode.updateBefore(frame)
The implementation performs the update of the shadow map if necessary.

**Kind**: instance method of [<code>ShadowNode</code>](#ShadowNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="BasicShadowFilter"></a>

## BasicShadowFilter(inputs) ⇒ <code>Node.&lt;float&gt;</code>
A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map
with a binary `[0,1]` result.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The filtering result.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | The shadow coordinates. |

<a name="PCFShadowFilter"></a>

## PCFShadowFilter(inputs) ⇒ <code>Node.&lt;float&gt;</code>
A shadow filtering function performing PCF filtering.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The filtering result.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | The shadow coordinates. |
| inputs.shadow | <code>LightShadow</code> | The light shadow. |

<a name="PCFSoftShadowFilter"></a>

## PCFSoftShadowFilter(inputs) ⇒ <code>Node.&lt;float&gt;</code>
A shadow filtering function performing PCF soft filtering.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The filtering result.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | The shadow coordinates. |
| inputs.shadow | <code>LightShadow</code> | The light shadow. |

<a name="VSMShadowFilter"></a>

## VSMShadowFilter(inputs) ⇒ <code>Node.&lt;float&gt;</code>
A shadow filtering function performing VSM filtering.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The filtering result.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.depthTexture | <code>DepthTexture</code> | A reference to the shadow map's texture data. |
| inputs.shadowCoord | <code>Node.&lt;vec3&gt;</code> | The shadow coordinates. |

<a name="VSMPassVertical"></a>

## VSMPassVertical(inputs) ⇒ <code>Node.&lt;vec2&gt;</code>
Represents the shader code for the first VSM render pass.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The VSM output.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.samples | <code>Node.&lt;float&gt;</code> | The number of samples |
| inputs.radius | <code>Node.&lt;float&gt;</code> | The radius. |
| inputs.size | <code>Node.&lt;float&gt;</code> | The size. |
| inputs.shadowPass | <code>TextureNode</code> | A reference to the render target's depth data. |

<a name="VSMPassHorizontal"></a>

## VSMPassHorizontal(inputs) ⇒ <code>Node.&lt;vec2&gt;</code>
Represents the shader code for the second VSM render pass.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec2&gt;</code> - The VSM output.  

| Param | Type | Description |
| --- | --- | --- |
| inputs | <code>Object</code> | The input parameter object. |
| inputs.samples | <code>Node.&lt;float&gt;</code> | The number of samples |
| inputs.radius | <code>Node.&lt;float&gt;</code> | The radius. |
| inputs.size | <code>Node.&lt;float&gt;</code> | The size. |
| inputs.shadowPass | <code>TextureNode</code> | The result of the first VSM render pass. |

<a name="shadow"></a>

## shadow(light, [shadow]) ⇒ [<code>ShadowNode</code>](#ShadowNode)
TSL function for creating an instance of `ShadowNode`.

**Kind**: global function  
**Returns**: [<code>ShadowNode</code>](#ShadowNode) - The created shadow node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The shadow casting light. |
| [shadow] | <code>LightShadow</code> | The light shadow. |

<a name="SpotLightNode"></a>

## SpotLightNode ⇐ <code>AnalyticLightNode</code>
Module for representing spot lights as nodes.

**Kind**: global class  
**Extends**: <code>AnalyticLightNode</code>  

* [SpotLightNode](#SpotLightNode) ⇐ <code>AnalyticLightNode</code>
    * [new SpotLightNode([light])](#new_SpotLightNode_new)
    * [.coneCosNode](#SpotLightNode+coneCosNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.penumbraCosNode](#SpotLightNode+penumbraCosNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.cutoffDistanceNode](#SpotLightNode+cutoffDistanceNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.decayExponentNode](#SpotLightNode+decayExponentNode) : <code>UniformNode.&lt;float&gt;</code>
    * [.update(frame)](#SpotLightNode+update)
    * [.getSpotAttenuation(angleCosine)](#SpotLightNode+getSpotAttenuation) ⇒ <code>Node.&lt;float&gt;</code>

<a name="new_SpotLightNode_new"></a>

### new SpotLightNode([light])
Constructs a new spot light node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [light] | <code>SpotLight</code> | <code></code> | The spot light source. |

<a name="SpotLightNode+coneCosNode"></a>

### spotLightNode.coneCosNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the cone cosine.

**Kind**: instance property of [<code>SpotLightNode</code>](#SpotLightNode)  
<a name="SpotLightNode+penumbraCosNode"></a>

### spotLightNode.penumbraCosNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the penumbra cosine.

**Kind**: instance property of [<code>SpotLightNode</code>](#SpotLightNode)  
<a name="SpotLightNode+cutoffDistanceNode"></a>

### spotLightNode.cutoffDistanceNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the cutoff distance.

**Kind**: instance property of [<code>SpotLightNode</code>](#SpotLightNode)  
<a name="SpotLightNode+decayExponentNode"></a>

### spotLightNode.decayExponentNode : <code>UniformNode.&lt;float&gt;</code>
Uniform node representing the decay exponent.

**Kind**: instance property of [<code>SpotLightNode</code>](#SpotLightNode)  
<a name="SpotLightNode+update"></a>

### spotLightNode.update(frame)
Overwritten to updated spot light specific uniforms.

**Kind**: instance method of [<code>SpotLightNode</code>](#SpotLightNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | A reference to the current node frame. |

<a name="SpotLightNode+getSpotAttenuation"></a>

### spotLightNode.getSpotAttenuation(angleCosine) ⇒ <code>Node.&lt;float&gt;</code>
Computes the spot attenuation for the given angle.

**Kind**: instance method of [<code>SpotLightNode</code>](#SpotLightNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The spot attenuation.  

| Param | Type | Description |
| --- | --- | --- |
| angleCosine | <code>Node.&lt;float&gt;</code> | The angle to compute the spot attenuation for. |

## Classes

<dl>
<dt><a href="#ConditionalNode">ConditionalNode</a> ⇐ <code>Node</code></dt>
<dd><p>Represents a logical <code>if/else</code> statement. Can be used as an alternative
to the <code>If()</code>/<code>Else()</code> syntax.</p>
<p>The corresponding TSL <code>select()</code> looks like so:</p>
<pre><code class="language-js">velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );
</code></pre>
<p>The <code>select()</code> method is called in a chaining fashion on a condition. The parameter nodes of <code>select()</code>
determine the outcome of the entire statement.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#select">select(condNode, ifNode, [elseNode])</a> ⇒ <code><a href="#ConditionalNode">ConditionalNode</a></code></dt>
<dd><p>TSL function for creating a conditional node.</p>
</dd>
<dt><del><a href="#cond">cond(...params)</a> ⇒ <code><a href="#ConditionalNode">ConditionalNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="ConditionalNode"></a>

## ConditionalNode ⇐ <code>Node</code>
Represents a logical `if/else` statement. Can be used as an alternative
to the `If()`/`Else()` syntax.

The corresponding TSL `select()` looks like so:
```js
velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );
```
The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`
determine the outcome of the entire statement.

**Kind**: global class  
**Extends**: <code>Node</code>  

* [ConditionalNode](#ConditionalNode) ⇐ <code>Node</code>
    * [new ConditionalNode(condNode, ifNode, [elseNode])](#new_ConditionalNode_new)
    * [.condNode](#ConditionalNode+condNode) : <code>Node</code>
    * [.ifNode](#ConditionalNode+ifNode) : <code>Node</code>
    * [.elseNode](#ConditionalNode+elseNode) : <code>Node</code>
    * [.getNodeType(builder)](#ConditionalNode+getNodeType) ⇒ <code>string</code>

<a name="new_ConditionalNode_new"></a>

### new ConditionalNode(condNode, ifNode, [elseNode])
Constructs a new conditional node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| condNode | <code>Node</code> |  | The node that defines the condition. |
| ifNode | <code>Node</code> |  | The node that is evaluate when the condition ends up `true`. |
| [elseNode] | <code>Node</code> | <code></code> | The node that is evaluate when the condition ends up `false`. |

<a name="ConditionalNode+condNode"></a>

### conditionalNode.condNode : <code>Node</code>
The node that defines the condition.

**Kind**: instance property of [<code>ConditionalNode</code>](#ConditionalNode)  
<a name="ConditionalNode+ifNode"></a>

### conditionalNode.ifNode : <code>Node</code>
The node that is evaluate when the condition ends up `true`.

**Kind**: instance property of [<code>ConditionalNode</code>](#ConditionalNode)  
<a name="ConditionalNode+elseNode"></a>

### conditionalNode.elseNode : <code>Node</code>
The node that is evaluate when the condition ends up `false`.

**Kind**: instance property of [<code>ConditionalNode</code>](#ConditionalNode)  
**Default**: <code>null</code>  
<a name="ConditionalNode+getNodeType"></a>

### conditionalNode.getNodeType(builder) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the if/else
nodes.

**Kind**: instance method of [<code>ConditionalNode</code>](#ConditionalNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="select"></a>

## select(condNode, ifNode, [elseNode]) ⇒ [<code>ConditionalNode</code>](#ConditionalNode)
TSL function for creating a conditional node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| condNode | <code>Node</code> |  | The node that defines the condition. |
| ifNode | <code>Node</code> |  | The node that is evaluate when the condition ends up `true`. |
| [elseNode] | <code>Node</code> | <code></code> | The node that is evaluate when the condition ends up `false`. |

<a name="cond"></a>

## ~~cond(...params) ⇒ [<code>ConditionalNode</code>](#ConditionalNode)~~
***since r168. Use [select](#select) instead.***

**Kind**: global function  
**Tsl**:   

| Param | Type |
| --- | --- |
| ...params | <code>any</code> | 

<a name="hash"></a>

## hash(seed) ⇒ <code>Node.&lt;float&gt;</code>
Generates a hash value in the range `[0, 1]` from the given seed.

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The hash value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| seed | <code>Node.&lt;float&gt;</code> | The seed. |

## Classes

<dl>
<dt><a href="#MathNode">MathNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents a variety of mathematical methods available in shaders.
They are divided into three categories:</p>
<ul>
<li>Methods with one input like <code>sin</code>, <code>cos</code> or <code>normalize</code>.</li>
<li>Methods with two inputs like <code>dot</code>, <code>cross</code> or <code>pow</code>.</li>
<li>Methods with three inputs like <code>mix</code>, <code>clamp</code> or <code>smoothstep</code>.</li>
</ul>
</dd>
</dl>

## Constants

<dl>
<dt><a href="#EPSILON">EPSILON</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>A small value used to handle floating-point precision errors.</p>
</dd>
<dt><a href="#INFINITY">INFINITY</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>Represents infinity.</p>
</dd>
<dt><a href="#PI">PI</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>Represents PI.</p>
</dd>
<dt><a href="#PI2">PI2</a> : <code>Node.&lt;float&gt;</code></dt>
<dd><p>Represents PI * 2.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#all">all(x)</a> ⇒ <code>Node.&lt;bool&gt;</code></dt>
<dd><p>Returns <code>true</code> if all components of <code>x</code> are <code>true</code>.</p>
</dd>
<dt><a href="#any">any(x)</a> ⇒ <code>Node.&lt;bool&gt;</code></dt>
<dd><p>Returns <code>true</code> if any components of <code>x</code> are <code>true</code>.</p>
</dd>
<dt><a href="#radians">radians(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Converts a quantity in degrees to radians.</p>
</dd>
<dt><a href="#degrees">degrees(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Convert a quantity in radians to degrees.</p>
</dd>
<dt><a href="#exp">exp(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the natural exponentiation of the parameter.</p>
</dd>
<dt><a href="#exp2">exp2(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns 2 raised to the power of the parameter.</p>
</dd>
<dt><a href="#log">log(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the natural logarithm of the parameter.</p>
</dd>
<dt><a href="#log2">log2(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the base 2 logarithm of the parameter.</p>
</dd>
<dt><a href="#sqrt">sqrt(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the square root of the parameter.</p>
</dd>
<dt><a href="#inverseSqrt">inverseSqrt(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the inverse of the square root of the parameter.</p>
</dd>
<dt><a href="#floor">floor(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Finds the nearest integer less than or equal to the parameter.</p>
</dd>
<dt><a href="#ceil">ceil(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Finds the nearest integer that is greater than or equal to the parameter.</p>
</dd>
<dt><a href="#normalize">normalize(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Calculates the unit vector in the same direction as the original vector.</p>
</dd>
<dt><a href="#fract">fract(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Computes the fractional part of the parameter.</p>
</dd>
<dt><a href="#sin">sin(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the sine of the parameter.</p>
</dd>
<dt><a href="#cos">cos(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the cosine of the parameter.</p>
</dd>
<dt><a href="#tan">tan(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the tangent of the parameter.</p>
</dd>
<dt><a href="#asin">asin(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the arcsine of the parameter.</p>
</dd>
<dt><a href="#acos">acos(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the arccosine of the parameter.</p>
</dd>
<dt><a href="#atan">atan(y, x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the arc-tangent of the parameter.
If two parameters are provided, the result is <code>atan2(y/x)</code>.</p>
</dd>
<dt><a href="#abs">abs(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the absolute value of the parameter.</p>
</dd>
<dt><a href="#sign">sign(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Extracts the sign of the parameter.</p>
</dd>
<dt><a href="#length">length(x)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Calculates the length of a vector.</p>
</dd>
<dt><a href="#negate">negate(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Negates the value of the parameter (-x).</p>
</dd>
<dt><a href="#oneMinus">oneMinus(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Return <code>1</code> minus the parameter.</p>
</dd>
<dt><a href="#dFdx">dFdx(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the partial derivative of the parameter with respect to x.</p>
</dd>
<dt><a href="#dFdy">dFdy(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the partial derivative of the parameter with respect to y.</p>
</dd>
<dt><a href="#round">round(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Rounds the parameter to the nearest integer.</p>
</dd>
<dt><a href="#reciprocal">reciprocal(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the reciprocal of the parameter <code>(1/x)</code>.</p>
</dd>
<dt><a href="#trunc">trunc(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Truncates the parameter, removing the fractional part.</p>
</dd>
<dt><a href="#fwidth">fwidth(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the sum of the absolute derivatives in x and y.</p>
</dd>
<dt><a href="#transpose">transpose(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the transpose of a matrix.</p>
</dd>
<dt><a href="#bitcast">bitcast(x, y)</a> ⇒ <code>Node</code></dt>
<dd><p>Reinterpret the bit representation of a value in one type as a value in another type.</p>
</dd>
<dt><del><a href="#equals">equals(x, y)</a> ⇒ <code>Node.&lt;bool&gt;</code></del></dt>
<dd><p>Returns <code>true</code> if <code>x</code> equals <code>y</code>.</p>
</dd>
<dt><a href="#min">min(...values)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the least of the given values.</p>
</dd>
<dt><a href="#max">max(...values)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the greatest of the given values.</p>
</dd>
<dt><a href="#step">step(x, y)</a> ⇒ <code>Node</code></dt>
<dd><p>Generate a step function by comparing two values.</p>
</dd>
<dt><a href="#reflect">reflect(I, N)</a> ⇒ <code>Node.&lt;(vec2|vec3|vec4)&gt;</code></dt>
<dd><p>Calculates the reflection direction for an incident vector.</p>
</dd>
<dt><a href="#distance">distance(x, y)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Calculates the distance between two points.</p>
</dd>
<dt><a href="#difference">difference(x, y)</a> ⇒ <code>Node</code></dt>
<dd><p>Calculates the absolute difference between two values.</p>
</dd>
<dt><a href="#dot">dot(x, y)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Calculates the dot product of two vectors.</p>
</dd>
<dt><a href="#cross">cross(x, y)</a> ⇒ <code>Node.&lt;(vec2|vec3|vec4)&gt;</code></dt>
<dd><p>Calculates the cross product of two vectors.</p>
</dd>
<dt><a href="#pow">pow(x, y)</a> ⇒ <code>Node</code></dt>
<dd><p>Return the value of the first parameter raised to the power of the second one.</p>
</dd>
<dt><a href="#pow2">pow2(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the square of the parameter.</p>
</dd>
<dt><a href="#pow3">pow3(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the cube of the parameter.</p>
</dd>
<dt><a href="#pow4">pow4(x)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the fourth power of the parameter.</p>
</dd>
<dt><a href="#transformDirection">transformDirection(direction, matrix)</a> ⇒ <code>Node</code></dt>
<dd><p>Transforms the direction of a vector by a matrix and then normalizes the result.</p>
</dd>
<dt><a href="#cbrt">cbrt(a)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the cube root of a number.</p>
</dd>
<dt><a href="#lengthSq">lengthSq(a)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Calculate the squared length of a vector.</p>
</dd>
<dt><a href="#mix">mix(a, b, t)</a> ⇒ <code>Node</code></dt>
<dd><p>Linearly interpolates between two values.</p>
</dd>
<dt><a href="#clamp">clamp(value, [low], [high])</a> ⇒ <code>Node</code></dt>
<dd><p>Constrains a value to lie between two further values.</p>
</dd>
<dt><a href="#saturate">saturate(value)</a> ⇒ <code>Node</code></dt>
<dd><p>Constrains a value between <code>0</code> and <code>1</code>.</p>
</dd>
<dt><a href="#refract">refract(I, N, eta)</a> ⇒ <code>Node.&lt;(vec2|vec3|vec4)&gt;</code></dt>
<dd><p>Calculates the refraction direction for an incident vector.</p>
</dd>
<dt><a href="#smoothstep">smoothstep(low, high, x)</a> ⇒ <code>Node</code></dt>
<dd><p>Performs a Hermite interpolation between two values.</p>
</dd>
<dt><a href="#faceForward">faceForward(N, I, Nref)</a> ⇒ <code>Node.&lt;(vec2|vec3|vec4)&gt;</code></dt>
<dd><p>Returns a vector pointing in the same direction as another.</p>
</dd>
<dt><a href="#rand">rand(uv)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>Returns a random value for the given uv.</p>
</dd>
<dt><a href="#mixElement">mixElement(t, e1, e2)</a> ⇒ <code>Node</code></dt>
<dd><p>Alias for <code>mix()</code> with a different parameter order.</p>
</dd>
<dt><a href="#smoothstepElement">smoothstepElement(x, low, high)</a> ⇒ <code>Node</code></dt>
<dd><p>Alias for <code>smoothstep()</code> with a different parameter order.</p>
</dd>
<dt><del><a href="#atan2">atan2(y, x)</a> ⇒ <code>Node</code></del></dt>
<dd><p>Returns the arc-tangent of the quotient of its parameters.</p>
</dd>
</dl>

<a name="MathNode"></a>

## MathNode ⇐ <code>TempNode</code>
This node represents a variety of mathematical methods available in shaders.
They are divided into three categories:

- Methods with one input like `sin`, `cos` or `normalize`.
- Methods with two inputs like `dot`, `cross` or `pow`.
- Methods with three inputs like `mix`, `clamp` or `smoothstep`.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [MathNode](#MathNode) ⇐ <code>TempNode</code>
    * [new MathNode(method, aNode, [bNode], [cNode])](#new_MathNode_new)
    * [.method](#MathNode+method) : <code>string</code>
    * [.aNode](#MathNode+aNode) : <code>Node</code>
    * [.bNode](#MathNode+bNode) : <code>Node</code>
    * [.cNode](#MathNode+cNode) : <code>Node</code>
    * [.isMathNode](#MathNode+isMathNode) : <code>boolean</code>
    * [.getInputType(builder)](#MathNode+getInputType) ⇒ <code>string</code>
    * [.getNodeType(builder)](#MathNode+getNodeType) ⇒ <code>string</code>

<a name="new_MathNode_new"></a>

### new MathNode(method, aNode, [bNode], [cNode])
Constructs a new math node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| method | <code>string</code> |  | The method name. |
| aNode | <code>Node</code> |  | The first input. |
| [bNode] | <code>Node</code> | <code></code> | The second input. |
| [cNode] | <code>Node</code> | <code></code> | The third input. |

<a name="MathNode+method"></a>

### mathNode.method : <code>string</code>
The method name.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
<a name="MathNode+aNode"></a>

### mathNode.aNode : <code>Node</code>
The first input.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
<a name="MathNode+bNode"></a>

### mathNode.bNode : <code>Node</code>
The second input.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
**Default**: <code>null</code>  
<a name="MathNode+cNode"></a>

### mathNode.cNode : <code>Node</code>
The third input.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
**Default**: <code>null</code>  
<a name="MathNode+isMathNode"></a>

### mathNode.isMathNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>MathNode</code>](#MathNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="MathNode+getInputType"></a>

### mathNode.getInputType(builder) ⇒ <code>string</code>
The input type is inferred from the node types of the input nodes.

**Kind**: instance method of [<code>MathNode</code>](#MathNode)  
**Returns**: <code>string</code> - The input type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="MathNode+getNodeType"></a>

### mathNode.getNodeType(builder) ⇒ <code>string</code>
The selected method as well as the input type determine the node type of this node.

**Kind**: instance method of [<code>MathNode</code>](#MathNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="EPSILON"></a>

## EPSILON : <code>Node.&lt;float&gt;</code>
A small value used to handle floating-point precision errors.

**Kind**: global constant  
**Tsl**:   
<a name="INFINITY"></a>

## INFINITY : <code>Node.&lt;float&gt;</code>
Represents infinity.

**Kind**: global constant  
**Tsl**:   
<a name="PI"></a>

## PI : <code>Node.&lt;float&gt;</code>
Represents PI.

**Kind**: global constant  
**Tsl**:   
<a name="PI2"></a>

## PI2 : <code>Node.&lt;float&gt;</code>
Represents PI * 2.

**Kind**: global constant  
**Tsl**:   
<a name="all"></a>

## all(x) ⇒ <code>Node.&lt;bool&gt;</code>
Returns `true` if all components of `x` are `true`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="any"></a>

## any(x) ⇒ <code>Node.&lt;bool&gt;</code>
Returns `true` if any components of `x` are `true`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="radians"></a>

## radians(x) ⇒ <code>Node</code>
Converts a quantity in degrees to radians.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The input in degrees. |

<a name="degrees"></a>

## degrees(x) ⇒ <code>Node</code>
Convert a quantity in radians to degrees.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The input in radians. |

<a name="exp"></a>

## exp(x) ⇒ <code>Node</code>
Returns the natural exponentiation of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="exp2"></a>

## exp2(x) ⇒ <code>Node</code>
Returns 2 raised to the power of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="log"></a>

## log(x) ⇒ <code>Node</code>
Returns the natural logarithm of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="log2"></a>

## log2(x) ⇒ <code>Node</code>
Returns the base 2 logarithm of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="sqrt"></a>

## sqrt(x) ⇒ <code>Node</code>
Returns the square root of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="inverseSqrt"></a>

## inverseSqrt(x) ⇒ <code>Node</code>
Returns the inverse of the square root of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="floor"></a>

## floor(x) ⇒ <code>Node</code>
Finds the nearest integer less than or equal to the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="ceil"></a>

## ceil(x) ⇒ <code>Node</code>
Finds the nearest integer that is greater than or equal to the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="normalize"></a>

## normalize(x) ⇒ <code>Node</code>
Calculates the unit vector in the same direction as the original vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> | The input vector. |

<a name="fract"></a>

## fract(x) ⇒ <code>Node</code>
Computes the fractional part of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="sin"></a>

## sin(x) ⇒ <code>Node</code>
Returns the sine of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="cos"></a>

## cos(x) ⇒ <code>Node</code>
Returns the cosine of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="tan"></a>

## tan(x) ⇒ <code>Node</code>
Returns the tangent of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="asin"></a>

## asin(x) ⇒ <code>Node</code>
Returns the arcsine of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="acos"></a>

## acos(x) ⇒ <code>Node</code>
Returns the arccosine of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="atan"></a>

## atan(y, x) ⇒ <code>Node</code>
Returns the arc-tangent of the parameter.
If two parameters are provided, the result is `atan2(y/x)`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| y | <code>Node</code> \| <code>number</code> | The y parameter. |
| x | <code>Node</code> \| <code>number</code> | The x parameter. |

<a name="abs"></a>

## abs(x) ⇒ <code>Node</code>
Returns the absolute value of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="sign"></a>

## sign(x) ⇒ <code>Node</code>
Extracts the sign of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="length"></a>

## length(x) ⇒ <code>Node.&lt;float&gt;</code>
Calculates the length of a vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> | The parameter. |

<a name="negate"></a>

## negate(x) ⇒ <code>Node</code>
Negates the value of the parameter (-x).

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="oneMinus"></a>

## oneMinus(x) ⇒ <code>Node</code>
Return `1` minus the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="dFdx"></a>

## dFdx(x) ⇒ <code>Node</code>
Returns the partial derivative of the parameter with respect to x.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="dFdy"></a>

## dFdy(x) ⇒ <code>Node</code>
Returns the partial derivative of the parameter with respect to y.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="round"></a>

## round(x) ⇒ <code>Node</code>
Rounds the parameter to the nearest integer.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="reciprocal"></a>

## reciprocal(x) ⇒ <code>Node</code>
Returns the reciprocal of the parameter `(1/x)`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="trunc"></a>

## trunc(x) ⇒ <code>Node</code>
Truncates the parameter, removing the fractional part.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="fwidth"></a>

## fwidth(x) ⇒ <code>Node</code>
Returns the sum of the absolute derivatives in x and y.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |

<a name="transpose"></a>

## transpose(x) ⇒ <code>Node</code>
Returns the transpose of a matrix.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;(mat2\|mat3\|mat4)&gt;</code> | The parameter. |

<a name="bitcast"></a>

## bitcast(x, y) ⇒ <code>Node</code>
Reinterpret the bit representation of a value in one type as a value in another type.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The parameter. |
| y | <code>string</code> | The new type. |

<a name="equals"></a>

## ~~equals(x, y) ⇒ <code>Node.&lt;bool&gt;</code>~~
***since r175. Use [equal](equal) instead.***

Returns `true` if `x` equals `y`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |
| y | <code>Node</code> \| <code>number</code> | The second parameter. |

<a name="min"></a>

## min(...values) ⇒ <code>Node</code>
Returns the least of the given values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...values | <code>Node</code> \| <code>number</code> | The values to compare. |

<a name="max"></a>

## max(...values) ⇒ <code>Node</code>
Returns the greatest of the given values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...values | <code>Node</code> \| <code>number</code> | The values to compare. |

<a name="step"></a>

## step(x, y) ⇒ <code>Node</code>
Generate a step function by comparing two values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The y parameter. |
| y | <code>Node</code> \| <code>number</code> | The x parameter. |

<a name="reflect"></a>

## reflect(I, N) ⇒ <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code>
Calculates the reflection direction for an incident vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| I | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The incident vector. |
| N | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The normal vector. |

<a name="distance"></a>

## distance(x, y) ⇒ <code>Node.&lt;float&gt;</code>
Calculates the distance between two points.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The first point. |
| y | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The second point. |

<a name="difference"></a>

## difference(x, y) ⇒ <code>Node</code>
Calculates the absolute difference between two values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |
| y | <code>Node</code> \| <code>number</code> | The second parameter. |

<a name="dot"></a>

## dot(x, y) ⇒ <code>Node.&lt;float&gt;</code>
Calculates the dot product of two vectors.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The first vector. |
| y | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The second vector. |

<a name="cross"></a>

## cross(x, y) ⇒ <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code>
Calculates the cross product of two vectors.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The first vector. |
| y | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The second vector. |

<a name="pow"></a>

## pow(x, y) ⇒ <code>Node</code>
Return the value of the first parameter raised to the power of the second one.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |
| y | <code>Node</code> \| <code>number</code> | The second parameter. |

<a name="pow2"></a>

## pow2(x) ⇒ <code>Node</code>
Returns the square of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |

<a name="pow3"></a>

## pow3(x) ⇒ <code>Node</code>
Returns the cube of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |

<a name="pow4"></a>

## pow4(x) ⇒ <code>Node</code>
Returns the fourth power of the parameter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The first parameter. |

<a name="transformDirection"></a>

## transformDirection(direction, matrix) ⇒ <code>Node</code>
Transforms the direction of a vector by a matrix and then normalizes the result.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| direction | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The direction vector. |
| matrix | <code>Node.&lt;(mat2\|mat3\|mat4)&gt;</code> | The transformation matrix. |

<a name="cbrt"></a>

## cbrt(a) ⇒ <code>Node</code>
Returns the cube root of a number.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> \| <code>number</code> | The first parameter. |

<a name="lengthSq"></a>

## lengthSq(a) ⇒ <code>Node.&lt;float&gt;</code>
Calculate the squared length of a vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The vector. |

<a name="mix"></a>

## mix(a, b, t) ⇒ <code>Node</code>
Linearly interpolates between two values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> \| <code>number</code> | The first parameter. |
| b | <code>Node</code> \| <code>number</code> | The second parameter. |
| t | <code>Node</code> \| <code>number</code> | The interpolation value. |

<a name="clamp"></a>

## clamp(value, [low], [high]) ⇒ <code>Node</code>
Constrains a value to lie between two further values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| value | <code>Node</code> \| <code>number</code> |  | The value to constrain. |
| [low] | <code>Node</code> \| <code>number</code> | <code>0</code> | The lower bound. |
| [high] | <code>Node</code> \| <code>number</code> | <code>1</code> | The upper bound. |

<a name="saturate"></a>

## saturate(value) ⇒ <code>Node</code>
Constrains a value between `0` and `1`.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Node</code> \| <code>number</code> | The value to constrain. |

<a name="refract"></a>

## refract(I, N, eta) ⇒ <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code>
Calculates the refraction direction for an incident vector.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| I | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The incident vector. |
| N | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The normal vector. |
| eta | <code>Node.&lt;float&gt;</code> | The ratio of indices of refraction. |

<a name="smoothstep"></a>

## smoothstep(low, high, x) ⇒ <code>Node</code>
Performs a Hermite interpolation between two values.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| low | <code>Node</code> \| <code>number</code> | The value of the lower edge of the Hermite function. |
| high | <code>Node</code> \| <code>number</code> | The value of the upper edge of the Hermite function. |
| x | <code>Node</code> \| <code>number</code> | The source value for interpolation. |

<a name="faceForward"></a>

## faceForward(N, I, Nref) ⇒ <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code>
Returns a vector pointing in the same direction as another.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| N | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The vector to orient. |
| I | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The incident vector. |
| Nref | <code>Node.&lt;(vec2\|vec3\|vec4)&gt;</code> | The reference vector. |

<a name="rand"></a>

## rand(uv) ⇒ <code>Node.&lt;float&gt;</code>
Returns a random value for the given uv.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The uv node. |

<a name="mixElement"></a>

## mixElement(t, e1, e2) ⇒ <code>Node</code>
Alias for `mix()` with a different parameter order.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| t | <code>Node</code> \| <code>number</code> | The interpolation value. |
| e1 | <code>Node</code> \| <code>number</code> | The first parameter. |
| e2 | <code>Node</code> \| <code>number</code> | The second parameter. |

<a name="smoothstepElement"></a>

## smoothstepElement(x, low, high) ⇒ <code>Node</code>
Alias for `smoothstep()` with a different parameter order.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node</code> \| <code>number</code> | The source value for interpolation. |
| low | <code>Node</code> \| <code>number</code> | The value of the lower edge of the Hermite function. |
| high | <code>Node</code> \| <code>number</code> | The value of the upper edge of the Hermite function. |

<a name="atan2"></a>

## ~~atan2(y, x) ⇒ <code>Node</code>~~
***since r172. Use [atan](#atan) instead.***

Returns the arc-tangent of the quotient of its parameters.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| y | <code>Node</code> \| <code>number</code> | The y parameter. |
| x | <code>Node</code> \| <code>number</code> | The x parameter. |

## Functions

<dl>
<dt><a href="#parabola">parabola(x, k)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A function that remaps the <code>[0,1]</code> interval into the <code>[0,1]</code> interval.
The corners are mapped to <code>0</code> and the center to <code>1</code>.
Reference: <a href="https://iquilezles.org/articles/functions/">https://iquilezles.org/articles/functions/</a>.</p>
</dd>
<dt><a href="#gain">gain(x, k)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A function that remaps the <code>[0,1]</code> interval into the <code>[0,1]</code> interval.
Expands the sides and compresses the center, and keeps <code>0.5</code> mapped to <code>0.5</code>.
Reference: <a href="https://iquilezles.org/articles/functions/">https://iquilezles.org/articles/functions/</a>.</p>
</dd>
<dt><a href="#pcurve">pcurve(x, a, b)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A function that remaps the <code>[0,1]</code> interval into the <code>[0,1]</code> interval.
A generalization of the <code>parabola()</code>. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.
Reference: <a href="https://iquilezles.org/articles/functions/">https://iquilezles.org/articles/functions/</a>.</p>
</dd>
<dt><a href="#sinc">sinc(x, k)</a> ⇒ <code>Node.&lt;float&gt;</code></dt>
<dd><p>A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.
Reference: <a href="https://iquilezles.org/articles/functions/">https://iquilezles.org/articles/functions/</a>.</p>
</dd>
</dl>

<a name="parabola"></a>

## parabola(x, k) ⇒ <code>Node.&lt;float&gt;</code>
A function that remaps the `[0,1]` interval into the `[0,1]` interval.
The corners are mapped to `0` and the center to `1`.
Reference: [https://iquilezles.org/articles/functions/](https://iquilezles.org/articles/functions/).

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The remapped value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;float&gt;</code> | The value to remap. |
| k | <code>Node.&lt;float&gt;</code> | Allows to control the remapping functions shape by rising the parabola to a power `k`. |

<a name="gain"></a>

## gain(x, k) ⇒ <code>Node.&lt;float&gt;</code>
A function that remaps the `[0,1]` interval into the `[0,1]` interval.
Expands the sides and compresses the center, and keeps `0.5` mapped to `0.5`.
Reference: [https://iquilezles.org/articles/functions/](https://iquilezles.org/articles/functions/).

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The remapped value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;float&gt;</code> | The value to remap. |
| k | <code>Node.&lt;float&gt;</code> | `k=1` is the identity curve,`k<1` produces the classic `gain()` shape, and `k>1` produces "s" shaped curves. |

<a name="pcurve"></a>

## pcurve(x, a, b) ⇒ <code>Node.&lt;float&gt;</code>
A function that remaps the `[0,1]` interval into the `[0,1]` interval.
A generalization of the `parabola()`. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.
Reference: [https://iquilezles.org/articles/functions/](https://iquilezles.org/articles/functions/).

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The remapped value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;float&gt;</code> | The value to remap. |
| a | <code>Node.&lt;float&gt;</code> | First control parameter. |
| b | <code>Node.&lt;float&gt;</code> | Second control parameter. |

<a name="sinc"></a>

## sinc(x, k) ⇒ <code>Node.&lt;float&gt;</code>
A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.
Reference: [https://iquilezles.org/articles/functions/](https://iquilezles.org/articles/functions/).

**Kind**: global function  
**Returns**: <code>Node.&lt;float&gt;</code> - The result value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| x | <code>Node.&lt;float&gt;</code> | The value to compute the sin for. |
| k | <code>Node.&lt;float&gt;</code> | Controls the amount of bounces. |

## Classes

<dl>
<dt><a href="#OperatorNode">OperatorNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>This node represents basic mathematical and logical operations like addition,
subtraction or comparisons (e.g. <code>equal()</code>).</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#add">add(a, b, ...params)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Returns the addition of two or more value.</p>
</dd>
<dt><a href="#sub">sub(a, b, ...params)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Returns the subtraction of two or more value.</p>
</dd>
<dt><a href="#mul">mul(a, b, ...params)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Returns the multiplication of two or more value.</p>
</dd>
<dt><a href="#div">div(a, b, ...params)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Returns the division of two or more value.</p>
</dd>
<dt><a href="#mod">mod(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Computes the remainder of dividing the first node by the second one.</p>
</dd>
<dt><a href="#equal">equal(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if two nodes are equal.</p>
</dd>
<dt><a href="#notEqual">notEqual(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if two nodes are not equal.</p>
</dd>
<dt><a href="#lessThan">lessThan(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if the first node is less than the second.</p>
</dd>
<dt><a href="#greaterThan">greaterThan(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if the first node is greater than the second.</p>
</dd>
<dt><a href="#lessThanEqual">lessThanEqual(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if the first node is less than or equal to the second.</p>
</dd>
<dt><a href="#greaterThanEqual">greaterThanEqual(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Checks if the first node is greater than or equal to the second.</p>
</dd>
<dt><a href="#and">and(...nodes)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs a logical AND operation on multiple nodes.</p>
</dd>
<dt><a href="#or">or(...nodes)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs a logical OR operation on multiple nodes.</p>
</dd>
<dt><a href="#not">not(value)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs logical NOT on a node.</p>
</dd>
<dt><a href="#xor">xor(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs logical XOR on two nodes.</p>
</dd>
<dt><a href="#bitAnd">bitAnd(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs bitwise AND on two nodes.</p>
</dd>
<dt><a href="#bitNot">bitNot(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs bitwise NOT on a node.</p>
</dd>
<dt><a href="#bitOr">bitOr(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs bitwise OR on two nodes.</p>
</dd>
<dt><a href="#bitXor">bitXor(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Performs bitwise XOR on two nodes.</p>
</dd>
<dt><a href="#shiftLeft">shiftLeft(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Shifts a node to the left.</p>
</dd>
<dt><a href="#shiftRight">shiftRight(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></dt>
<dd><p>Shifts a node to the right.</p>
</dd>
<dt><del><a href="#remainder">remainder(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></del></dt>
<dd></dd>
<dt><del><a href="#modInt">modInt(a, b)</a> ⇒ <code><a href="#OperatorNode">OperatorNode</a></code></del></dt>
<dd></dd>
</dl>

<a name="OperatorNode"></a>

## OperatorNode ⇐ <code>TempNode</code>
This node represents basic mathematical and logical operations like addition,
subtraction or comparisons (e.g. `equal()`).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [OperatorNode](#OperatorNode) ⇐ <code>TempNode</code>
    * [new OperatorNode(op, aNode, bNode, ...params)](#new_OperatorNode_new)
    * [.op](#OperatorNode+op) : <code>string</code>
    * [.aNode](#OperatorNode+aNode) : <code>Node</code>
    * [.bNode](#OperatorNode+bNode) : <code>Node</code>
    * [.isOperatorNode](#OperatorNode+isOperatorNode) : <code>boolean</code>
    * [.getNodeType(builder, output)](#OperatorNode+getNodeType) ⇒ <code>string</code>

<a name="new_OperatorNode_new"></a>

### new OperatorNode(op, aNode, bNode, ...params)
Constructs a new operator node.


| Param | Type | Description |
| --- | --- | --- |
| op | <code>string</code> | The operator. |
| aNode | <code>Node</code> | The first input. |
| bNode | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="OperatorNode+op"></a>

### operatorNode.op : <code>string</code>
The operator.

**Kind**: instance property of [<code>OperatorNode</code>](#OperatorNode)  
<a name="OperatorNode+aNode"></a>

### operatorNode.aNode : <code>Node</code>
The first input.

**Kind**: instance property of [<code>OperatorNode</code>](#OperatorNode)  
<a name="OperatorNode+bNode"></a>

### operatorNode.bNode : <code>Node</code>
The second input.

**Kind**: instance property of [<code>OperatorNode</code>](#OperatorNode)  
<a name="OperatorNode+isOperatorNode"></a>

### operatorNode.isOperatorNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>OperatorNode</code>](#OperatorNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="OperatorNode+getNodeType"></a>

### operatorNode.getNodeType(builder, output) ⇒ <code>string</code>
This method is overwritten since the node type is inferred from the operator
and the input node types.

**Kind**: instance method of [<code>OperatorNode</code>](#OperatorNode)  
**Returns**: <code>string</code> - The node type.  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| output | <code>string</code> | The current output string. |

<a name="add"></a>

## add(a, b, ...params) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Returns the addition of two or more value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="sub"></a>

## sub(a, b, ...params) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Returns the subtraction of two or more value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="mul"></a>

## mul(a, b, ...params) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Returns the multiplication of two or more value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="div"></a>

## div(a, b, ...params) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Returns the division of two or more value.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |
| ...params | <code>Node</code> | Additional input parameters. |

<a name="mod"></a>

## mod(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Computes the remainder of dividing the first node by the second one.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="equal"></a>

## equal(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if two nodes are equal.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="notEqual"></a>

## notEqual(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if two nodes are not equal.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="lessThan"></a>

## lessThan(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if the first node is less than the second.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="greaterThan"></a>

## greaterThan(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if the first node is greater than the second.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="lessThanEqual"></a>

## lessThanEqual(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if the first node is less than or equal to the second.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="greaterThanEqual"></a>

## greaterThanEqual(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Checks if the first node is greater than or equal to the second.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="and"></a>

## and(...nodes) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs a logical AND operation on multiple nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...nodes | <code>Node</code> | The input nodes to be combined using AND. |

<a name="or"></a>

## or(...nodes) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs a logical OR operation on multiple nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| ...nodes | <code>Node</code> | The input nodes to be combined using OR. |

<a name="not"></a>

## not(value) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs logical NOT on a node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Node</code> | The value. |

<a name="xor"></a>

## xor(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs logical XOR on two nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="bitAnd"></a>

## bitAnd(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs bitwise AND on two nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="bitNot"></a>

## bitNot(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs bitwise NOT on a node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="bitOr"></a>

## bitOr(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs bitwise OR on two nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| a | <code>Node</code> | The first input. |
| b | <code>Node</code> | The second input. |

<a name="bitXor"></a>

## bitXor(a, b) ⇒ [<code>OperatorNode</code>](#OperatorNode)
Performs bitwise XOR on two nodes.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
