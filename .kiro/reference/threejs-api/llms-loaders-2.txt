# three.js 

> JavaScript 3D Library. 

<a name="AnimationClipCreator"></a>

The combine pass uniforms.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
<a name="BloomPass+materialCombine"></a>

### bloomPass.materialCombine : <code>ShaderMaterial</code>
The combine pass material.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
<a name="BloomPass+convolutionUniforms"></a>

### bloomPass.convolutionUniforms : <code>Object</code>
The convolution pass uniforms.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
<a name="BloomPass+materialConvolution"></a>

### bloomPass.materialConvolution : <code>ShaderMaterial</code>
The convolution pass material.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
<a name="BloomPass+needsSwap"></a>

### bloomPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>BloomPass</code>](#BloomPass)  
**Default**: <code>false</code>  
<a name="BloomPass+render"></a>

### bloomPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the Bloom pass.

**Kind**: instance method of [<code>BloomPass</code>](#BloomPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="BloomPass+setSize"></a>

### bloomPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>BloomPass</code>](#BloomPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="BloomPass+dispose"></a>

### bloomPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>BloomPass</code>](#BloomPass)  
<a name="BokehPass"></a>

## BokehPass ⇐ <code>Pass</code>
Pass for creating depth of field (DOF) effect.

```js
const bokehPass = new BokehPass( scene, camera, {
	focus: 500
	aperture: 5,
	maxblur: 0.01
} );
composer.addPass( bokehPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [BokehPass](#BokehPass) ⇐ <code>Pass</code>
    * [new BokehPass(scene, camera, params)](#new_BokehPass_new)
    * _instance_
        * [.scene](#BokehPass+scene) : <code>Scene</code>
        * [.camera](#BokehPass+camera) : <code>Camera</code>
        * [.materialBokeh](#BokehPass+materialBokeh) : <code>ShaderMaterial</code>
        * [.uniforms](#BokehPass+uniforms) : <code>Object</code>
        * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#BokehPass+render)
        * [.setSize(width, height)](#BokehPass+setSize)
        * [.dispose()](#BokehPass+dispose)
    * _inner_
        * [~Options](#BokehPass..Options) : <code>Object</code>

<a name="new_BokehPass_new"></a>

### new BokehPass(scene, camera, params)
Constructs a new Bokeh pass.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render the DOF for. |
| camera | <code>Camera</code> | The camera. |
| params | [<code>Options</code>](#BokehPass..Options) | The pass options. |

<a name="BokehPass+scene"></a>

### bokehPass.scene : <code>Scene</code>
The scene to render the DOF for.

**Kind**: instance property of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass+camera"></a>

### bokehPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass+materialBokeh"></a>

### bokehPass.materialBokeh : <code>ShaderMaterial</code>
The pass bokeh material.

**Kind**: instance property of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass+uniforms"></a>

### bokehPass.uniforms : <code>Object</code>
The pass uniforms.  Use this object if you want to update the
`focus`, `aperture` or `maxblur` values at runtime.

```js
pass.uniforms.focus.value = focus;
pass.uniforms.aperture.value = aperture;
pass.uniforms.maxblur.value = maxblur;
```

**Kind**: instance property of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass+render"></a>

### bokehPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the Bokeh pass.

**Kind**: instance method of [<code>BokehPass</code>](#BokehPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="BokehPass+setSize"></a>

### bokehPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>BokehPass</code>](#BokehPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="BokehPass+dispose"></a>

### bokehPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>BokehPass</code>](#BokehPass)  
<a name="BokehPass..Options"></a>

### BokehPass~Options : <code>Object</code>
Constructor options of `BokehPass`.

**Kind**: inner typedef of [<code>BokehPass</code>](#BokehPass)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [focus] | <code>number</code> | <code>1</code> | Defines the effect's focus which is the distance along the camera's look direction in world units. |
| [aperture] | <code>number</code> | <code>0.025</code> | Defines the effect's aperture. |
| [maxblur] | <code>number</code> | <code>1</code> | Defines the effect's maximum blur. |

<a name="ClearPass"></a>

## ClearPass ⇐ <code>Pass</code>
This class can be used to force a clear operation for the current read or
default framebuffer (when rendering to screen).

```js
const clearPass = new ClearPass();
composer.addPass( clearPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [ClearPass](#ClearPass) ⇐ <code>Pass</code>
    * [new ClearPass([clearColor], [clearAlpha])](#new_ClearPass_new)
    * [.needsSwap](#ClearPass+needsSwap) : <code>boolean</code>
    * [.clearColor](#ClearPass+clearColor) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.clearAlpha](#ClearPass+clearAlpha) : <code>number</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#ClearPass+render)

<a name="new_ClearPass_new"></a>

### new ClearPass([clearColor], [clearAlpha])
Constructs a new clear pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [clearColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x000000</code> | The clear color. |
| [clearAlpha] | <code>number</code> | <code>0</code> | The clear alpha. |

<a name="ClearPass+needsSwap"></a>

### clearPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>ClearPass</code>](#ClearPass)  
**Default**: <code>false</code>  
<a name="ClearPass+clearColor"></a>

### clearPass.clearColor : <code>number</code> \| <code>Color</code> \| <code>string</code>
The clear color.

**Kind**: instance property of [<code>ClearPass</code>](#ClearPass)  
**Default**: <code>0x000000</code>  
<a name="ClearPass+clearAlpha"></a>

### clearPass.clearAlpha : <code>number</code>
The clear alpha.

**Kind**: instance property of [<code>ClearPass</code>](#ClearPass)  
**Default**: <code>0</code>  
<a name="ClearPass+render"></a>

### clearPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the clear operation. This affects the current read or the default framebuffer.

**Kind**: instance method of [<code>ClearPass</code>](#ClearPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="CubeTexturePass"></a>

## CubeTexturePass ⇐ <code>Pass</code>
This pass can be used to render a cube texture over the entire screen.

```js
const cubeMap = new THREE.CubeTextureLoader().load( urls );

const cubeTexturePass = new CubeTexturePass( camera, cubemap );
composer.addPass( cubeTexturePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [CubeTexturePass](#CubeTexturePass) ⇐ <code>Pass</code>
    * [new CubeTexturePass(camera, tCube, [opacity])](#new_CubeTexturePass_new)
    * [.camera](#CubeTexturePass+camera) : <code>PerspectiveCamera</code>
    * [.tCube](#CubeTexturePass+tCube) : <code>CubeTexture</code>
    * [.opacity](#CubeTexturePass+opacity) : <code>number</code>
    * [.needsSwap](#CubeTexturePass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#CubeTexturePass+render)
    * [.dispose()](#CubeTexturePass+dispose)

<a name="new_CubeTexturePass_new"></a>

### new CubeTexturePass(camera, tCube, [opacity])
Constructs a new cube texture pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>PerspectiveCamera</code> |  | The camera. |
| tCube | <code>CubeTexture</code> |  | The cube texture to render. |
| [opacity] | <code>number</code> | <code>1</code> | The opacity. |

<a name="CubeTexturePass+camera"></a>

### cubeTexturePass.camera : <code>PerspectiveCamera</code>
The camera.

**Kind**: instance property of [<code>CubeTexturePass</code>](#CubeTexturePass)  
<a name="CubeTexturePass+tCube"></a>

### cubeTexturePass.tCube : <code>CubeTexture</code>
The cube texture to render.

**Kind**: instance property of [<code>CubeTexturePass</code>](#CubeTexturePass)  
<a name="CubeTexturePass+opacity"></a>

### cubeTexturePass.opacity : <code>number</code>
The opacity.

**Kind**: instance property of [<code>CubeTexturePass</code>](#CubeTexturePass)  
**Default**: <code>1</code>  
<a name="CubeTexturePass+needsSwap"></a>

### cubeTexturePass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>CubeTexturePass</code>](#CubeTexturePass)  
**Default**: <code>false</code>  
<a name="CubeTexturePass+render"></a>

### cubeTexturePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the cube texture pass.

**Kind**: instance method of [<code>CubeTexturePass</code>](#CubeTexturePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="CubeTexturePass+dispose"></a>

### cubeTexturePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>CubeTexturePass</code>](#CubeTexturePass)  
<a name="DotScreenPass"></a>

## DotScreenPass ⇐ <code>Pass</code>
Pass for creating a dot-screen effect.

```js
const pass = new DotScreenPass( new THREE.Vector2( 0, 0 ), 0.5, 0.8 );
composer.addPass( pass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [DotScreenPass](#DotScreenPass) ⇐ <code>Pass</code>
    * [new DotScreenPass(center, angle, scale)](#new_DotScreenPass_new)
    * [.uniforms](#DotScreenPass+uniforms) : <code>Object</code>
    * [.material](#DotScreenPass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#DotScreenPass+render)
    * [.dispose()](#DotScreenPass+dispose)

<a name="new_DotScreenPass_new"></a>

### new DotScreenPass(center, angle, scale)
Constructs a new dot screen pass.


| Param | Type | Description |
| --- | --- | --- |
| center | <code>Vector2</code> | The center point. |
| angle | <code>number</code> | The rotation of the effect in radians. |
| scale | <code>number</code> | The scale of the effect. A higher value means smaller dots. |

<a name="DotScreenPass+uniforms"></a>

### dotScreenPass.uniforms : <code>Object</code>
The pass uniforms. Use this object if you want to update the
`center`, `angle` or `scale` values at runtime.
```js
pass.uniforms.center.value.copy( center );
pass.uniforms.angle.value = 0;
pass.uniforms.scale.value = 0.5;
```

**Kind**: instance property of [<code>DotScreenPass</code>](#DotScreenPass)  
<a name="DotScreenPass+material"></a>

### dotScreenPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>DotScreenPass</code>](#DotScreenPass)  
<a name="DotScreenPass+render"></a>

### dotScreenPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the dot screen pass.

**Kind**: instance method of [<code>DotScreenPass</code>](#DotScreenPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="DotScreenPass+dispose"></a>

### dotScreenPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>DotScreenPass</code>](#DotScreenPass)  
<a name="EffectComposer"></a>

## EffectComposer
Used to implement post-processing effects in three.js.
The class manages a chain of post-processing passes to produce the final visual result.
Post-processing passes are executed in order of their addition/insertion.
The last pass is automatically rendered to screen.

This module can only be used with [WebGLRenderer](WebGLRenderer).

```js
const composer = new EffectComposer( renderer );

// adding some passes
const renderPass = new RenderPass( scene, camera );
composer.addPass( renderPass );

const glitchPass = new GlitchPass();
composer.addPass( glitchPass );

const outputPass = new OutputPass()
composer.addPass( outputPass );

function animate() {

	composer.render(); // instead of renderer.render()

}
```

**Kind**: global class  

* [EffectComposer](#EffectComposer)
    * [new EffectComposer(renderer, [renderTarget])](#new_EffectComposer_new)
    * [.renderer](#EffectComposer+renderer) : <code>WebGLRenderer</code>
    * [.writeBuffer](#EffectComposer+writeBuffer) : <code>WebGLRenderTarget</code>
    * [.readBuffer](#EffectComposer+readBuffer) : <code>WebGLRenderTarget</code>
    * [.renderToScreen](#EffectComposer+renderToScreen) : <code>boolean</code>
    * [.passes](#EffectComposer+passes) : <code>Array.&lt;Pass&gt;</code>
    * [.swapBuffers()](#EffectComposer+swapBuffers)
    * [.addPass(pass)](#EffectComposer+addPass)
    * [.insertPass(pass, index)](#EffectComposer+insertPass)
    * [.removePass(pass)](#EffectComposer+removePass)
    * [.isLastEnabledPass(passIndex)](#EffectComposer+isLastEnabledPass) ⇒ <code>boolean</code>
    * [.render(deltaTime)](#EffectComposer+render)
    * [.reset([renderTarget])](#EffectComposer+reset)
    * [.setSize(width, height)](#EffectComposer+setSize)
    * [.setPixelRatio(pixelRatio)](#EffectComposer+setPixelRatio)
    * [.dispose()](#EffectComposer+dispose)

<a name="new_EffectComposer_new"></a>

### new EffectComposer(renderer, [renderTarget])
Constructs a new effect composer.


| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| [renderTarget] | <code>WebGLRenderTarget</code> | This render target and a clone will be used as the internal read and write buffers. If not given, the composer creates the buffers automatically. |

<a name="EffectComposer+renderer"></a>

### effectComposer.renderer : <code>WebGLRenderer</code>
The renderer.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+writeBuffer"></a>

### effectComposer.writeBuffer : <code>WebGLRenderTarget</code>
A reference to the internal write buffer. Passes usually write
their result into this buffer.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+readBuffer"></a>

### effectComposer.readBuffer : <code>WebGLRenderTarget</code>
A reference to the internal read buffer. Passes usually read
the previous render result from this buffer.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+renderToScreen"></a>

### effectComposer.renderToScreen : <code>boolean</code>
Whether the final pass is rendered to the screen (default framebuffer) or not.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
**Default**: <code>true</code>  
<a name="EffectComposer+passes"></a>

### effectComposer.passes : <code>Array.&lt;Pass&gt;</code>
An array representing the (ordered) chain of post-processing passes.

**Kind**: instance property of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+swapBuffers"></a>

### effectComposer.swapBuffers()
Swaps the internal read/write buffers.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  
<a name="EffectComposer+addPass"></a>

### effectComposer.addPass(pass)
Adds the given pass to the pass chain.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| pass | <code>Pass</code> | The pass to add. |

<a name="EffectComposer+insertPass"></a>

### effectComposer.insertPass(pass, index)
Inserts the given pass at a given index.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| pass | <code>Pass</code> | The pass to insert. |
| index | <code>number</code> | The index into the pass chain. |

<a name="EffectComposer+removePass"></a>

### effectComposer.removePass(pass)
Removes the given pass from the pass chain.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| pass | <code>Pass</code> | The pass to remove. |

<a name="EffectComposer+isLastEnabledPass"></a>

### effectComposer.isLastEnabledPass(passIndex) ⇒ <code>boolean</code>
Returns `true` if the pass for the given index is the last enabled pass in the pass chain.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  
**Returns**: <code>boolean</code> - Whether the the pass for the given index is the last pass in the pass chain.  

| Param | Type | Description |
| --- | --- | --- |
| passIndex | <code>number</code> | The pass index. |

<a name="EffectComposer+render"></a>

### effectComposer.render(deltaTime)
Executes all enabled post-processing passes in order to produce the final frame.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| deltaTime | <code>number</code> | The delta time in seconds. If not given, the composer computes its own time delta value. |

<a name="EffectComposer+reset"></a>

### effectComposer.reset([renderTarget])
Resets the internal state of the EffectComposer.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| [renderTarget] | <code>WebGLRenderTarget</code> | This render target has the same purpose like the one from the constructor. If set, it is used to setup the read and write buffers. |

<a name="EffectComposer+setSize"></a>

### effectComposer.setSize(width, height)
Resizes the internal read and write buffers as well as all passes. Similar to [WebGLRenderer#setSize](WebGLRenderer#setSize),
this method honors the current pixel ration.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width in logical pixels. |
| height | <code>number</code> | The height in logical pixels. |

<a name="EffectComposer+setPixelRatio"></a>

### effectComposer.setPixelRatio(pixelRatio)
Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
Setting the pixel ratio will automatically resize the composer.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  

| Param | Type | Description |
| --- | --- | --- |
| pixelRatio | <code>number</code> | The pixel ratio to set. |

<a name="EffectComposer+dispose"></a>

### effectComposer.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the composer is no longer used in your app.

**Kind**: instance method of [<code>EffectComposer</code>](#EffectComposer)  
<a name="FilmPass"></a>

## FilmPass ⇐ <code>Pass</code>
This pass can be used to create a film grain effect.

```js
const filmPass = new FilmPass();
composer.addPass( filmPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [FilmPass](#FilmPass) ⇐ <code>Pass</code>
    * [new FilmPass([intensity], [grayscale])](#new_FilmPass_new)
    * [.uniforms](#FilmPass+uniforms) : <code>Object</code>
    * [.material](#FilmPass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#FilmPass+render)
    * [.dispose()](#FilmPass+dispose)

<a name="new_FilmPass_new"></a>

### new FilmPass([intensity], [grayscale])
Constructs a new film pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [intensity] | <code>number</code> | <code>0.5</code> | The grain intensity in the range `[0,1]` (0 = no effect, 1 = full effect). |
| [grayscale] | <code>boolean</code> | <code>false</code> | Whether to apply a grayscale effect or not. |

<a name="FilmPass+uniforms"></a>

### filmPass.uniforms : <code>Object</code>
The pass uniforms. Use this object if you want to update the
`intensity` or `grayscale` values at runtime.
```js
pass.uniforms.intensity.value = 1;
pass.uniforms.grayscale.value = true;
```

**Kind**: instance property of [<code>FilmPass</code>](#FilmPass)  
<a name="FilmPass+material"></a>

### filmPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>FilmPass</code>](#FilmPass)  
<a name="FilmPass+render"></a>

### filmPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the film pass.

**Kind**: instance method of [<code>FilmPass</code>](#FilmPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="FilmPass+dispose"></a>

### filmPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>FilmPass</code>](#FilmPass)  
<a name="GTAOPass"></a>

## GTAOPass ⇐ <code>Pass</code>
A pass for an GTAO effect.

`GTAOPass` provides better quality than [SSAOPass](SSAOPass) but is also more expensive.

```js
const gtaoPass = new GTAOPass( scene, camera, width, height );
gtaoPass.output = GTAOPass.OUTPUT.Denoise;
composer.addPass( gtaoPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [GTAOPass](#GTAOPass) ⇐ <code>Pass</code>
    * [new GTAOPass(scene, camera, [width], [height], [parameters], [aoParameters], [pdParameters])](#new_GTAOPass_new)
    * [.width](#GTAOPass+width) : <code>number</code>
    * [.height](#GTAOPass+height) : <code>number</code>
    * [.clear](#GTAOPass+clear) : <code>boolean</code>
    * [.camera](#GTAOPass+camera) : <code>Camera</code>
    * [.scene](#GTAOPass+scene) : <code>Scene</code>
    * [.output](#GTAOPass+output) : <code>number</code>
    * [.blendIntensity](#GTAOPass+blendIntensity) : <code>number</code>
    * [.pdRings](#GTAOPass+pdRings) : <code>number</code>
    * [.pdRadiusExponent](#GTAOPass+pdRadiusExponent) : <code>number</code>
    * [.pdSamples](#GTAOPass+pdSamples) : <code>number</code>
    * [.gtaoMap](#GTAOPass+gtaoMap) : <code>Texture</code>
    * [.setSize(width, height)](#GTAOPass+setSize)
    * [.dispose()](#GTAOPass+dispose)
    * [.setGBuffer([depthTexture], [normalTexture])](#GTAOPass+setGBuffer)
    * [.setSceneClipBox(box)](#GTAOPass+setSceneClipBox)
    * [.updateGtaoMaterial(parameters)](#GTAOPass+updateGtaoMaterial)
    * [.updatePdMaterial(parameters)](#GTAOPass+updatePdMaterial)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#GTAOPass+render)

<a name="new_GTAOPass_new"></a>

### new GTAOPass(scene, camera, [width], [height], [parameters], [aoParameters], [pdParameters])
Constructs a new GTAO pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to compute the AO for. |
| camera | <code>Camera</code> |  | The camera. |
| [width] | <code>number</code> | <code>512</code> | The width of the effect. |
| [height] | <code>number</code> | <code>512</code> | The height of the effect. |
| [parameters] | <code>Object</code> |  | The pass parameters. |
| [aoParameters] | <code>Object</code> |  | The AO parameters. |
| [pdParameters] | <code>Object</code> |  | The denoise parameters. |

<a name="GTAOPass+width"></a>

### gtaoPass.width : <code>number</code>
The width of the effect.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>512</code>  
<a name="GTAOPass+height"></a>

### gtaoPass.height : <code>number</code>
The height of the effect.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>512</code>  
<a name="GTAOPass+clear"></a>

### gtaoPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>true</code>  
<a name="GTAOPass+camera"></a>

### gtaoPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
<a name="GTAOPass+scene"></a>

### gtaoPass.scene : <code>Scene</code>
The scene to render the AO for.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
<a name="GTAOPass+output"></a>

### gtaoPass.output : <code>number</code>
The output configuration.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>0</code>  
<a name="GTAOPass+blendIntensity"></a>

### gtaoPass.blendIntensity : <code>number</code>
The AO blend intensity.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>1</code>  
<a name="GTAOPass+pdRings"></a>

### gtaoPass.pdRings : <code>number</code>
The number of Poisson Denoise rings.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>2</code>  
<a name="GTAOPass+pdRadiusExponent"></a>

### gtaoPass.pdRadiusExponent : <code>number</code>
The Poisson Denoise radius exponent.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>2</code>  
<a name="GTAOPass+pdSamples"></a>

### gtaoPass.pdSamples : <code>number</code>
The Poisson Denoise sample count.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Default**: <code>16</code>  
<a name="GTAOPass+gtaoMap"></a>

### gtaoPass.gtaoMap : <code>Texture</code>
A texture holding the computed AO.

**Kind**: instance property of [<code>GTAOPass</code>](#GTAOPass)  
**Read only**: true  
<a name="GTAOPass+setSize"></a>

### gtaoPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="GTAOPass+dispose"></a>

### gtaoPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  
<a name="GTAOPass+setGBuffer"></a>

### gtaoPass.setGBuffer([depthTexture], [normalTexture])
Configures the GBuffer of this pass. If no arguments are passed,
the pass creates an internal render target for holding depth
and normal data.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| [depthTexture] | <code>DepthTexture</code> | The depth texture. |
| [normalTexture] | <code>DepthTexture</code> | The normal texture. |

<a name="GTAOPass+setSceneClipBox"></a>

### gtaoPass.setSceneClipBox(box)
Configures the clip box of the GTAO shader with the given AABB.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| box | <code>Box3</code> | The AABB enclosing the scene that should receive AO. When passing `null`, to clip box is used. |

<a name="GTAOPass+updateGtaoMaterial"></a>

### gtaoPass.updateGtaoMaterial(parameters)
Updates the GTAO material from the given paramter object.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| parameters | <code>Object</code> | The GTAO material parameters. |

<a name="GTAOPass+updatePdMaterial"></a>

### gtaoPass.updatePdMaterial(parameters)
Updates the Denoise material from the given paramter object.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| parameters | <code>Object</code> | The denoise parameters. |

<a name="GTAOPass+render"></a>

### gtaoPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the GTAO pass.

**Kind**: instance method of [<code>GTAOPass</code>](#GTAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="GlitchPass"></a>

## GlitchPass ⇐ <code>Pass</code>
Pass for creating a glitch effect.

```js
const glitchPass = new GlitchPass();
composer.addPass( glitchPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [GlitchPass](#GlitchPass) ⇐ <code>Pass</code>
    * [new GlitchPass([dt_size])](#new_GlitchPass_new)
    * [.uniforms](#GlitchPass+uniforms) : <code>Object</code>
    * [.material](#GlitchPass+material) : <code>ShaderMaterial</code>
    * [.goWild](#GlitchPass+goWild) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#GlitchPass+render)
    * [.dispose()](#GlitchPass+dispose)

<a name="new_GlitchPass_new"></a>

### new GlitchPass([dt_size])
Constructs a new glitch pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [dt_size] | <code>number</code> | <code>64</code> | The size of the displacement texture for digital glitch squares. |

<a name="GlitchPass+uniforms"></a>

### glitchPass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>GlitchPass</code>](#GlitchPass)  
<a name="GlitchPass+material"></a>

### glitchPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>GlitchPass</code>](#GlitchPass)  
<a name="GlitchPass+goWild"></a>

### glitchPass.goWild : <code>boolean</code>
Whether to noticeably increase the effect instensity or not.

**Kind**: instance property of [<code>GlitchPass</code>](#GlitchPass)  
**Default**: <code>false</code>  
<a name="GlitchPass+render"></a>

### glitchPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the glitch pass.

**Kind**: instance method of [<code>GlitchPass</code>](#GlitchPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="GlitchPass+dispose"></a>

### glitchPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>GlitchPass</code>](#GlitchPass)  
<a name="HalftonePass"></a>

## HalftonePass ⇐ <code>Pass</code>
Pass for creating a RGB halftone effect.

```js
const params = {
	shape: 1,
	radius: 4,
	rotateR: Math.PI / 12,
	rotateB: Math.PI / 12 * 2,
	rotateG: Math.PI / 12 * 3,
	scatter: 0,
	blending: 1,
	blendingMode: 1,
	greyscale: false,
	disable: false
};
const halftonePass = new HalftonePass( params );
composer.addPass( halftonePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [HalftonePass](#HalftonePass) ⇐ <code>Pass</code>
    * [new HalftonePass(params)](#new_HalftonePass_new)
    * [.uniforms](#HalftonePass+uniforms) : <code>Object</code>
    * [.material](#HalftonePass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#HalftonePass+render)
    * [.setSize(width, height)](#HalftonePass+setSize)
    * [.dispose()](#HalftonePass+dispose)

<a name="new_HalftonePass_new"></a>

### new HalftonePass(params)
Constructs a new halftone pass.


| Param | Type | Description |
| --- | --- | --- |
| params | <code>Object</code> | The halftone shader parameter. |

<a name="HalftonePass+uniforms"></a>

### halftonePass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>HalftonePass</code>](#HalftonePass)  
<a name="HalftonePass+material"></a>

### halftonePass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>HalftonePass</code>](#HalftonePass)  
<a name="HalftonePass+render"></a>

### halftonePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the halftone pass.

**Kind**: instance method of [<code>HalftonePass</code>](#HalftonePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="HalftonePass+setSize"></a>

### halftonePass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>HalftonePass</code>](#HalftonePass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="HalftonePass+dispose"></a>

### halftonePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>HalftonePass</code>](#HalftonePass)  
<a name="LUTPass"></a>

## LUTPass ⇐ <code>ShaderPass</code>
Pass for color grading via lookup tables.

```js
const lutPass = new LUTPass( { lut: lut.texture3D } );
composer.addPass( lutPass );
```

**Kind**: global class  
**Extends**: <code>ShaderPass</code>  

* [LUTPass](#LUTPass) ⇐ <code>ShaderPass</code>
    * [new LUTPass([options])](#new_LUTPass_new)
    * [.lut](#LUTPass+lut) : <code>Data3DTexture</code>
    * [.intensity](#LUTPass+intensity) : <code>number</code>

<a name="new_LUTPass_new"></a>

### new LUTPass([options])
Constructs a LUT pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [options] | <code>Object</code> | <code>{}</code> | The pass options. |

<a name="LUTPass+lut"></a>

### lutPass.lut : <code>Data3DTexture</code>
The LUT as a 3D texture.

**Kind**: instance property of [<code>LUTPass</code>](#LUTPass)  
**Default**: <code>null</code>  
<a name="LUTPass+intensity"></a>

### lutPass.intensity : <code>number</code>
The intensity.

**Kind**: instance property of [<code>LUTPass</code>](#LUTPass)  
**Default**: <code>1</code>  
## Classes

<dl>
<dt><a href="#MaskPass">MaskPass</a> ⇐ <code>Pass</code></dt>
<dd><p>This pass can be used to define a mask during post processing.
Meaning only areas of subsequent post processing are affected
which lie in the masking area of this pass. Internally, the masking
is implemented with the stencil buffer.</p>
<pre><code class="language-js">const maskPass = new MaskPass( scene, camera );
composer.addPass( maskPass );
</code></pre>
</dd>
<dt><a href="#ClearMaskPass">ClearMaskPass</a> ⇐ <code>Pass</code></dt>
<dd><p>This pass can be used to clear a mask previously defined with <a href="#MaskPass">MaskPass</a>.</p>
<pre><code class="language-js">const clearPass = new ClearMaskPass();
composer.addPass( clearPass );
</code></pre>
</dd>
</dl>

<a name="MaskPass"></a>

## MaskPass ⇐ <code>Pass</code>
This pass can be used to define a mask during post processing.
Meaning only areas of subsequent post processing are affected
which lie in the masking area of this pass. Internally, the masking
is implemented with the stencil buffer.

```js
const maskPass = new MaskPass( scene, camera );
composer.addPass( maskPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [MaskPass](#MaskPass) ⇐ <code>Pass</code>
    * [new MaskPass(scene, camera)](#new_MaskPass_new)
    * [.scene](#MaskPass+scene) : <code>Scene</code>
    * [.camera](#MaskPass+camera) : <code>Camera</code>
    * [.clear](#MaskPass+clear) : <code>boolean</code>
    * [.needsSwap](#MaskPass+needsSwap) : <code>boolean</code>
    * [.inverse](#MaskPass+inverse) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#MaskPass+render)

<a name="new_MaskPass_new"></a>

### new MaskPass(scene, camera)
Constructs a new mask pass.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The 3D objects in this scene will define the mask. |
| camera | <code>Camera</code> | The camera. |

<a name="MaskPass+scene"></a>

### maskPass.scene : <code>Scene</code>
The scene that defines the mask.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
<a name="MaskPass+camera"></a>

### maskPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
<a name="MaskPass+clear"></a>

### maskPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
**Default**: <code>true</code>  
<a name="MaskPass+needsSwap"></a>

### maskPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
**Default**: <code>false</code>  
<a name="MaskPass+inverse"></a>

### maskPass.inverse : <code>boolean</code>
Whether to inverse the mask or not.

**Kind**: instance property of [<code>MaskPass</code>](#MaskPass)  
**Default**: <code>false</code>  
<a name="MaskPass+render"></a>

### maskPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs a mask pass with the configured scene and camera.

**Kind**: instance method of [<code>MaskPass</code>](#MaskPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="ClearMaskPass"></a>

## ClearMaskPass ⇐ <code>Pass</code>
This pass can be used to clear a mask previously defined with [MaskPass](#MaskPass).

```js
const clearPass = new ClearMaskPass();
composer.addPass( clearPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [ClearMaskPass](#ClearMaskPass) ⇐ <code>Pass</code>
    * [new ClearMaskPass()](#new_ClearMaskPass_new)
    * [.needsSwap](#ClearMaskPass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#ClearMaskPass+render)

<a name="new_ClearMaskPass_new"></a>

### new ClearMaskPass()
Constructs a new clear mask pass.

<a name="ClearMaskPass+needsSwap"></a>

### clearMaskPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>ClearMaskPass</code>](#ClearMaskPass)  
**Default**: <code>false</code>  
<a name="ClearMaskPass+render"></a>

### clearMaskPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the clear of the currently defined mask.

**Kind**: instance method of [<code>ClearMaskPass</code>](#ClearMaskPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="OutlinePass"></a>

## OutlinePass ⇐ <code>Pass</code>
A pass for rendering outlines around selected objects.

```js
const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );
const outlinePass = new OutlinePass( resolution, scene, camera );
composer.addPass( outlinePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [OutlinePass](#OutlinePass) ⇐ <code>Pass</code>
    * [new OutlinePass([resolution], scene, camera, [selectedObjects])](#new_OutlinePass_new)
    * [.renderScene](#OutlinePass+renderScene) : <code>Object</code>
    * [.renderCamera](#OutlinePass+renderCamera) : <code>Object</code>
    * [.selectedObjects](#OutlinePass+selectedObjects) : <code>Array.&lt;Object3D&gt;</code>
    * [.visibleEdgeColor](#OutlinePass+visibleEdgeColor) : <code>Color</code>
    * [.hiddenEdgeColor](#OutlinePass+hiddenEdgeColor) : <code>Color</code>
    * [.edgeGlow](#OutlinePass+edgeGlow) : <code>number</code>
    * [.usePatternTexture](#OutlinePass+usePatternTexture) : <code>boolean</code>
    * [.patternTexture](#OutlinePass+patternTexture) : <code>Texture</code>
    * [.edgeThickness](#OutlinePass+edgeThickness) : <code>number</code>
    * [.edgeStrength](#OutlinePass+edgeStrength) : <code>number</code>
    * [.downSampleRatio](#OutlinePass+downSampleRatio) : <code>number</code>
    * [.pulsePeriod](#OutlinePass+pulsePeriod) : <code>number</code>
    * [.resolution](#OutlinePass+resolution) : <code>Vector2</code>
    * [.dispose()](#OutlinePass+dispose)
    * [.setSize(width, height)](#OutlinePass+setSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#OutlinePass+render)

<a name="new_OutlinePass_new"></a>

### new OutlinePass([resolution], scene, camera, [selectedObjects])
Constructs a new outline pass.


| Param | Type | Description |
| --- | --- | --- |
| [resolution] | <code>Vector2</code> | The effect's resolution. |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |
| [selectedObjects] | <code>Array.&lt;Object3D&gt;</code> | The selected 3D objects that should receive an outline. |

<a name="OutlinePass+renderScene"></a>

### outlinePass.renderScene : <code>Object</code>
The scene to render.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
<a name="OutlinePass+renderCamera"></a>

### outlinePass.renderCamera : <code>Object</code>
The camera.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
<a name="OutlinePass+selectedObjects"></a>

### outlinePass.selectedObjects : <code>Array.&lt;Object3D&gt;</code>
The selected 3D objects that should receive an outline.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
<a name="OutlinePass+visibleEdgeColor"></a>

### outlinePass.visibleEdgeColor : <code>Color</code>
The visible edge color.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>(1,1,1)</code>  
<a name="OutlinePass+hiddenEdgeColor"></a>

### outlinePass.hiddenEdgeColor : <code>Color</code>
The hidden edge color.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>(0.1,0.04,0.02)</code>  
<a name="OutlinePass+edgeGlow"></a>

### outlinePass.edgeGlow : <code>number</code>
Can be used for an animated glow/pulse effect.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>0</code>  
<a name="OutlinePass+usePatternTexture"></a>

### outlinePass.usePatternTexture : <code>boolean</code>
Whether to use a pattern texture for to highlight selected
3D objects or not.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>false</code>  
<a name="OutlinePass+patternTexture"></a>

### outlinePass.patternTexture : <code>Texture</code>
Can be used to highlight selected 3D objects. Requires to set
[usePatternTexture](#OutlinePass+usePatternTexture) to `true`.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>null</code>  
<a name="OutlinePass+edgeThickness"></a>

### outlinePass.edgeThickness : <code>number</code>
The edge thickness.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>1</code>  
<a name="OutlinePass+edgeStrength"></a>

### outlinePass.edgeStrength : <code>number</code>
The edge strength.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>3</code>  
<a name="OutlinePass+downSampleRatio"></a>

### outlinePass.downSampleRatio : <code>number</code>
The downsample ratio. The effect can be rendered in a much
lower resolution than the beauty pass.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>2</code>  
<a name="OutlinePass+pulsePeriod"></a>

### outlinePass.pulsePeriod : <code>number</code>
The pulse period.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>0</code>  
<a name="OutlinePass+resolution"></a>

### outlinePass.resolution : <code>Vector2</code>
The effect's resolution.

**Kind**: instance property of [<code>OutlinePass</code>](#OutlinePass)  
**Default**: <code>(256,256)</code>  
<a name="OutlinePass+dispose"></a>

### outlinePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>OutlinePass</code>](#OutlinePass)  
<a name="OutlinePass+setSize"></a>

### outlinePass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>OutlinePass</code>](#OutlinePass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="OutlinePass+render"></a>

### outlinePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the Outline pass.

**Kind**: instance method of [<code>OutlinePass</code>](#OutlinePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="OutputPass"></a>

## OutputPass ⇐ <code>Pass</code>
This pass is responsible for including tone mapping and color space conversion
into your pass chain. In most cases, this pass should be included at the end
of each pass chain. If a pass requires sRGB input (e.g. like FXAA), the pass
must follow `OutputPass` in the pass chain.

The tone mapping and color space settings are extracted from the renderer.

```js
const outputPass = new OutputPass();
composer.addPass( outputPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [OutputPass](#OutputPass) ⇐ <code>Pass</code>
    * [new OutputPass()](#new_OutputPass_new)
    * [.uniforms](#OutputPass+uniforms) : <code>Object</code>
    * [.material](#OutputPass+material) : <code>RawShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#OutputPass+render)
    * [.dispose()](#OutputPass+dispose)

<a name="new_OutputPass_new"></a>

### new OutputPass()
Constructs a new output pass.

<a name="OutputPass+uniforms"></a>

### outputPass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>OutputPass</code>](#OutputPass)  
<a name="OutputPass+material"></a>

### outputPass.material : <code>RawShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>OutputPass</code>](#OutputPass)  
<a name="OutputPass+render"></a>

### outputPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the output pass.

**Kind**: instance method of [<code>OutputPass</code>](#OutputPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="OutputPass+dispose"></a>

### outputPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>OutputPass</code>](#OutputPass)  
## Classes

<dl>
<dt><a href="#Pass">Pass</a></dt>
<dd><p>Abstract base class for all post processing passes.</p>
<p>This module is only relevant for post processing with <a href="WebGLRenderer">WebGLRenderer</a>.</p>
</dd>
<dt><a href="#FullScreenQuad">FullScreenQuad</a> ⇐ <code>Mesh</code></dt>
<dd><p>This module is a helper for passes which need to render a full
screen effect which is quite common in context of post processing.</p>
<p>The intended usage is to reuse a single full screen quad for rendering
subsequent passes by just reassigning the <code>material</code> reference.</p>
<p>This module can only be used with <a href="WebGLRenderer">WebGLRenderer</a>.</p>
</dd>
</dl>

<a name="Pass"></a>

## *Pass*
Abstract base class for all post processing passes.

This module is only relevant for post processing with [WebGLRenderer](WebGLRenderer).

**Kind**: global abstract class  

* *[Pass](#Pass)*
    * *[new Pass()](#new_Pass_new)*
    * *[.isPass](#Pass+isPass) : <code>boolean</code>*
    * *[.enabled](#Pass+enabled) : <code>boolean</code>*
    * *[.needsSwap](#Pass+needsSwap) : <code>boolean</code>*
    * *[.clear](#Pass+clear) : <code>boolean</code>*
    * *[.renderToScreen](#Pass+renderToScreen) : <code>boolean</code>*
    * **[.setSize(width, height)](#Pass+setSize)**
    * **[.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#Pass+render)**
    * **[.dispose()](#Pass+dispose)**

<a name="new_Pass_new"></a>

### *new Pass()*
Constructs a new pass.

<a name="Pass+isPass"></a>

### *pass.isPass : <code>boolean</code>*
This flag can be used for type testing.

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="Pass+enabled"></a>

### *pass.enabled : <code>boolean</code>*
If set to `true`, the pass is processed by the composer.

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>true</code>  
<a name="Pass+needsSwap"></a>

### *pass.needsSwap : <code>boolean</code>*
If set to `true`, the pass indicates to swap read and write buffer after rendering.

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>true</code>  
<a name="Pass+clear"></a>

### *pass.clear : <code>boolean</code>*
If set to `true`, the pass clears its buffer before rendering

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>false</code>  
<a name="Pass+renderToScreen"></a>

### *pass.renderToScreen : <code>boolean</code>*
If set to `true`, the result of the pass is rendered to screen. The last pass in the composers
pass chain gets automatically rendered to screen, no matter how this property is configured.

**Kind**: instance property of [<code>Pass</code>](#Pass)  
**Default**: <code>false</code>  
<a name="Pass+setSize"></a>

### **pass.setSize(width, height)**
Sets the size of the pass.

**Kind**: instance abstract method of [<code>Pass</code>](#Pass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="Pass+render"></a>

### **pass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)**
This method holds the render logic of a pass. It must be implemented in all derived classes.

**Kind**: instance abstract method of [<code>Pass</code>](#Pass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="Pass+dispose"></a>

### **pass.dispose()**
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance abstract method of [<code>Pass</code>](#Pass)  
<a name="FullScreenQuad"></a>

## FullScreenQuad ⇐ <code>Mesh</code>
This module is a helper for passes which need to render a full
screen effect which is quite common in context of post processing.

The intended usage is to reuse a single full screen quad for rendering
subsequent passes by just reassigning the `material` reference.

This module can only be used with [WebGLRenderer](WebGLRenderer).

**Kind**: global class  
**Extends**: <code>Mesh</code>  

* [FullScreenQuad](#FullScreenQuad) ⇐ <code>Mesh</code>
    * [new FullScreenQuad(material)](#new_FullScreenQuad_new)
    * [.material](#FullScreenQuad+material) : <code>Material</code>
    * [.dispose()](#FullScreenQuad+dispose)
    * [.render(renderer)](#FullScreenQuad+render)

<a name="new_FullScreenQuad_new"></a>

### new FullScreenQuad(material)
Constructs a new full screen quad.


| Param | Type | Description |
| --- | --- | --- |
| material | <code>Material</code> | The material to render te full screen quad with. |

<a name="FullScreenQuad+material"></a>

### fullScreenQuad.material : <code>Material</code>
The quad's material.

**Kind**: instance property of [<code>FullScreenQuad</code>](#FullScreenQuad)  
<a name="FullScreenQuad+dispose"></a>

### fullScreenQuad.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the instance is no longer used in your app.

**Kind**: instance method of [<code>FullScreenQuad</code>](#FullScreenQuad)  
<a name="FullScreenQuad+render"></a>

### fullScreenQuad.render(renderer)
Renders the full screen quad.

**Kind**: instance method of [<code>FullScreenQuad</code>](#FullScreenQuad)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |

<a name="RenderPass"></a>

## RenderPass ⇐ <code>Pass</code>
This class represents a render pass. It takes a camera and a scene and produces
a beauty pass for subsequent post processing effects.

```js
const renderPass = new RenderPass( scene, camera );
composer.addPass( renderPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [RenderPass](#RenderPass) ⇐ <code>Pass</code>
    * [new RenderPass(scene, camera, [overrideMaterial], [clearColor], [clearAlpha])](#new_RenderPass_new)
    * [.scene](#RenderPass+scene) : <code>Scene</code>
    * [.camera](#RenderPass+camera) : <code>Camera</code>
    * [.overrideMaterial](#RenderPass+overrideMaterial) : <code>Material</code>
    * [.clearColor](#RenderPass+clearColor) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.clearAlpha](#RenderPass+clearAlpha) : <code>number</code>
    * [.clear](#RenderPass+clear) : <code>boolean</code>
    * [.clearDepth](#RenderPass+clearDepth) : <code>boolean</code>
    * [.needsSwap](#RenderPass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#RenderPass+render)

<a name="new_RenderPass_new"></a>

### new RenderPass(scene, camera, [overrideMaterial], [clearColor], [clearAlpha])
Constructs a new render pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera. |
| [overrideMaterial] | <code>Material</code> | <code></code> | The override material. If set, this material is used for all objects in the scene. |
| [clearColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code></code> | The clear color of the render pass. |
| [clearAlpha] | <code>number</code> | <code></code> | The clear alpha of the render pass. |

<a name="RenderPass+scene"></a>

### renderPass.scene : <code>Scene</code>
The scene to render.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
<a name="RenderPass+camera"></a>

### renderPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
<a name="RenderPass+overrideMaterial"></a>

### renderPass.overrideMaterial : <code>Material</code>
The override material. If set, this material is used
for all objects in the scene.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>null</code>  
<a name="RenderPass+clearColor"></a>

### renderPass.clearColor : <code>number</code> \| <code>Color</code> \| <code>string</code>
The clear color of the render pass.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>null</code>  
<a name="RenderPass+clearAlpha"></a>

### renderPass.clearAlpha : <code>number</code>
The clear alpha of the render pass.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>null</code>  
<a name="RenderPass+clear"></a>

### renderPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>true</code>  
<a name="RenderPass+clearDepth"></a>

### renderPass.clearDepth : <code>boolean</code>
If set to `true`, only the depth can be cleared when `clear` is to `false`.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>false</code>  
<a name="RenderPass+needsSwap"></a>

### renderPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>RenderPass</code>](#RenderPass)  
**Default**: <code>false</code>  
<a name="RenderPass+render"></a>

### renderPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs a beauty pass with the configured scene and camera.

**Kind**: instance method of [<code>RenderPass</code>](#RenderPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="RenderPixelatedPass"></a>

## RenderPixelatedPass ⇐ <code>Pass</code>
A special type of render pass that produces a pixelated beauty pass.

```js
const renderPixelatedPass = new RenderPixelatedPass( 6, scene, camera );
composer.addPass( renderPixelatedPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [RenderPixelatedPass](#RenderPixelatedPass) ⇐ <code>Pass</code>
    * [new RenderPixelatedPass(pixelSize, scene, camera, options)](#new_RenderPixelatedPass_new)
    * [.pixelSize](#RenderPixelatedPass+pixelSize) : <code>number</code>
    * [.scene](#RenderPixelatedPass+scene) : <code>Scene</code>
    * [.camera](#RenderPixelatedPass+camera) : <code>Camera</code>
    * [.normalEdgeStrength](#RenderPixelatedPass+normalEdgeStrength) : <code>number</code>
    * [.depthEdgeStrength](#RenderPixelatedPass+depthEdgeStrength) : <code>number</code>
    * [.pixelatedMaterial](#RenderPixelatedPass+pixelatedMaterial) : <code>ShaderMaterial</code>
    * [.dispose()](#RenderPixelatedPass+dispose)
    * [.setSize(width, height)](#RenderPixelatedPass+setSize)
    * [.setPixelSize(pixelSize)](#RenderPixelatedPass+setPixelSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#RenderPixelatedPass+render)

<a name="new_RenderPixelatedPass_new"></a>

### new RenderPixelatedPass(pixelSize, scene, camera, options)
Constructs a new render pixelated pass.


| Param | Type | Description |
| --- | --- | --- |
| pixelSize | <code>number</code> | The effect's pixel size. |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera. |
| options | <code>Object</code> | The pass options. |

<a name="RenderPixelatedPass+pixelSize"></a>

### renderPixelatedPass.pixelSize : <code>number</code>
The effect's pixel size.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+scene"></a>

### renderPixelatedPass.scene : <code>Scene</code>
The scene to render.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+camera"></a>

### renderPixelatedPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+normalEdgeStrength"></a>

### renderPixelatedPass.normalEdgeStrength : <code>number</code>
The normal edge strength.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
**Default**: <code>0.3</code>  
<a name="RenderPixelatedPass+depthEdgeStrength"></a>

### renderPixelatedPass.depthEdgeStrength : <code>number</code>
The normal edge strength.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
**Default**: <code>0.4</code>  
<a name="RenderPixelatedPass+pixelatedMaterial"></a>

### renderPixelatedPass.pixelatedMaterial : <code>ShaderMaterial</code>
The pixelated material.

**Kind**: instance property of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+dispose"></a>

### renderPixelatedPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  
<a name="RenderPixelatedPass+setSize"></a>

### renderPixelatedPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="RenderPixelatedPass+setPixelSize"></a>

### renderPixelatedPass.setPixelSize(pixelSize)
Sets the effect's pixel size.

**Kind**: instance method of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  

| Param | Type | Description |
| --- | --- | --- |
| pixelSize | <code>number</code> | The pixel size to set. |

<a name="RenderPixelatedPass+render"></a>

### renderPixelatedPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the pixelation pass.

**Kind**: instance method of [<code>RenderPixelatedPass</code>](#RenderPixelatedPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="RenderTransitionPass"></a>

## RenderTransitionPass ⇐ <code>Pass</code>
A special type of render pass for implementing transition effects.
When active, the pass will transition from scene A to scene B.

```js
const renderTransitionPass = new RenderTransitionPass( fxSceneA.scene, fxSceneA.camera, fxSceneB.scene, fxSceneB.camera );
renderTransitionPass.setTexture( textures[ 0 ] );
composer.addPass( renderTransitionPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [RenderTransitionPass](#RenderTransitionPass) ⇐ <code>Pass</code>
    * [new RenderTransitionPass(sceneA, cameraA, sceneB, cameraB)](#new_RenderTransitionPass_new)
    * [.sceneA](#RenderTransitionPass+sceneA) : <code>Scene</code>
    * [.cameraA](#RenderTransitionPass+cameraA) : <code>Camera</code>
    * [.sceneB](#RenderTransitionPass+sceneB) : <code>Scene</code>
    * [.cameraB](#RenderTransitionPass+cameraB) : <code>Camera</code>
    * [.material](#RenderTransitionPass+material) : <code>ShaderMaterial</code>
    * [.setTransition(value)](#RenderTransitionPass+setTransition)
    * [.useTexture(value)](#RenderTransitionPass+useTexture)
    * [.setTexture(value)](#RenderTransitionPass+setTexture)
    * [.setTextureThreshold(value)](#RenderTransitionPass+setTextureThreshold)
    * [.setSize(width, height)](#RenderTransitionPass+setSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#RenderTransitionPass+render)
    * [.dispose()](#RenderTransitionPass+dispose)

<a name="new_RenderTransitionPass_new"></a>

### new RenderTransitionPass(sceneA, cameraA, sceneB, cameraB)
Constructs a render transition pass.


| Param | Type | Description |
| --- | --- | --- |
| sceneA | <code>Scene</code> | The first scene. |
| cameraA | <code>Camera</code> | The camera of the first scene. |
| sceneB | <code>Scene</code> | The second scene. |
| cameraB | <code>Camera</code> | The camera of the second scene. |

<a name="RenderTransitionPass+sceneA"></a>

### renderTransitionPass.sceneA : <code>Scene</code>
The first scene.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+cameraA"></a>

### renderTransitionPass.cameraA : <code>Camera</code>
The camera of the first scene.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+sceneB"></a>

### renderTransitionPass.sceneB : <code>Scene</code>
The second scene.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+cameraB"></a>

### renderTransitionPass.cameraB : <code>Camera</code>
The camera of the second scene.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+material"></a>

### renderTransitionPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="RenderTransitionPass+setTransition"></a>

### renderTransitionPass.setTransition(value)
Sets the transition factor. Must be in the range `[0,1]`.
This value determines to what degree both scenes are mixed.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolenumberan</code> | The transition factor. |

<a name="RenderTransitionPass+useTexture"></a>

### renderTransitionPass.useTexture(value)
Toggles the usage of a texture for the effect.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | Whether to use a texture for the transition effect or not. |

<a name="RenderTransitionPass+setTexture"></a>

### renderTransitionPass.setTexture(value)
Sets the effect texture.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>Texture</code> | The effect texture. |

<a name="RenderTransitionPass+setTextureThreshold"></a>

### renderTransitionPass.setTextureThreshold(value)
Sets the texture threshold. This value defined how strong the texture effects
the transition. Must be in the range `[0,1]` (0 means full effect, 1 means no effect).

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolenumberan</code> | The threshold value. |

<a name="RenderTransitionPass+setSize"></a>

### renderTransitionPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="RenderTransitionPass+render"></a>

### renderTransitionPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the transition pass.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="RenderTransitionPass+dispose"></a>

### renderTransitionPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>RenderTransitionPass</code>](#RenderTransitionPass)  
<a name="SAOPass"></a>

## SAOPass ⇐ <code>Pass</code>
A SAO implementation inspired from @bhouston previous SAO work.

`SAOPass` provides better quality than [SSAOPass](SSAOPass) but is also more expensive.

```js
const saoPass = new SAOPass( scene, camera );
composer.addPass( saoPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SAOPass](#SAOPass) ⇐ <code>Pass</code>
    * [new SAOPass(scene, camera, [resolution])](#new_SAOPass_new)
    * [.scene](#SAOPass+scene) : <code>Scene</code>
    * [.camera](#SAOPass+camera) : <code>Camera</code>
    * [.clear](#SAOPass+clear) : <code>boolean</code>
    * [.needsSwap](#SAOPass+needsSwap) : <code>boolean</code>
    * [.params](#SAOPass+params) : <code>Object</code>
    * [.resolution](#SAOPass+resolution) : <code>Vector2</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SAOPass+render)
    * [.setSize(width, height)](#SAOPass+setSize)
    * [.dispose()](#SAOPass+dispose)

<a name="new_SAOPass_new"></a>

### new SAOPass(scene, camera, [resolution])
Constructs a new SAO pass.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to compute the AO for. |
| camera | <code>Camera</code> | The camera. |
| [resolution] | <code>Vector2</code> | The effect's resolution. |

<a name="SAOPass+scene"></a>

### saoPass.scene : <code>Scene</code>
The scene to render the AO for.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
<a name="SAOPass+camera"></a>

### saoPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
<a name="SAOPass+clear"></a>

### saoPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
**Default**: <code>true</code>  
<a name="SAOPass+needsSwap"></a>

### saoPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
**Default**: <code>false</code>  
<a name="SAOPass+params"></a>

### saoPass.params : <code>Object</code>
The SAO paramter.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
<a name="SAOPass+resolution"></a>

### saoPass.resolution : <code>Vector2</code>
The effect's resolution.

**Kind**: instance property of [<code>SAOPass</code>](#SAOPass)  
**Default**: <code>(256,256)</code>  
<a name="SAOPass+render"></a>

### saoPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SAO pass.

**Kind**: instance method of [<code>SAOPass</code>](#SAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SAOPass+setSize"></a>

### saoPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SAOPass</code>](#SAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SAOPass+dispose"></a>

### saoPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SAOPass</code>](#SAOPass)  
<a name="SMAAPass"></a>

## SMAAPass ⇐ <code>Pass</code>
A pass for applying SMAA. Unlike [FXAAPass](FXAAPass), `SMAAPass` operates in
`linar-srgb` so this pass must be executed before [OutputPass](OutputPass).

```js
const smaaPass = new SMAAPass();
composer.addPass( smaaPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SMAAPass](#SMAAPass) ⇐ <code>Pass</code>
    * [new SMAAPass()](#new_SMAAPass_new)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SMAAPass+render)
    * [.setSize(width, height)](#SMAAPass+setSize)
    * [.dispose()](#SMAAPass+dispose)

<a name="new_SMAAPass_new"></a>

### new SMAAPass()
Constructs a new SMAA pass.

<a name="SMAAPass+render"></a>

### smaaPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SMAA pass.

**Kind**: instance method of [<code>SMAAPass</code>](#SMAAPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SMAAPass+setSize"></a>

### smaaPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SMAAPass</code>](#SMAAPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SMAAPass+dispose"></a>

### smaaPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SMAAPass</code>](#SMAAPass)  
<a name="SSAARenderPass"></a>

## SSAARenderPass ⇐ <code>Pass</code>
Supersample Anti-Aliasing Render Pass.

This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.

```js
const ssaaRenderPass = new SSAARenderPass( scene, camera );
ssaaRenderPass.sampleLevel = 3;
composer.addPass( ssaaRenderPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SSAARenderPass](#SSAARenderPass) ⇐ <code>Pass</code>
    * [new SSAARenderPass(scene, camera, [clearColor], [clearAlpha])](#new_SSAARenderPass_new)
    * [.scene](#SSAARenderPass+scene) : <code>Scene</code>
    * [.camera](#SSAARenderPass+camera) : <code>Camera</code>
    * [.sampleLevel](#SSAARenderPass+sampleLevel) : <code>number</code>
    * [.unbiased](#SSAARenderPass+unbiased) : <code>boolean</code>
    * [.stencilBuffer](#SSAARenderPass+stencilBuffer) : <code>boolean</code>
    * [.clearColor](#SSAARenderPass+clearColor) : <code>number</code> \| <code>Color</code> \| <code>string</code>
    * [.clearAlpha](#SSAARenderPass+clearAlpha) : <code>number</code>
    * [.dispose()](#SSAARenderPass+dispose)
    * [.setSize(width, height)](#SSAARenderPass+setSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SSAARenderPass+render)

<a name="new_SSAARenderPass_new"></a>

### new SSAARenderPass(scene, camera, [clearColor], [clearAlpha])
Constructs a new SSAA render pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera. |
| [clearColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x000000</code> | The clear color of the render pass. |
| [clearAlpha] | <code>number</code> | <code>0</code> | The clear alpha of the render pass. |

<a name="SSAARenderPass+scene"></a>

### ssaaRenderPass.scene : <code>Scene</code>
The scene to render.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
<a name="SSAARenderPass+camera"></a>

### ssaaRenderPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
<a name="SSAARenderPass+sampleLevel"></a>

### ssaaRenderPass.sampleLevel : <code>number</code>
The sample level. Specified as n, where the number of
samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>4</code>  
<a name="SSAARenderPass+unbiased"></a>

### ssaaRenderPass.unbiased : <code>boolean</code>
Whether the pass should be unbiased or not. This property has the most
visible effect when rendering to a RGBA8 buffer because it mitigates
rounding errors. By default RGBA16F is used.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>true</code>  
<a name="SSAARenderPass+stencilBuffer"></a>

### ssaaRenderPass.stencilBuffer : <code>boolean</code>
Whether to use a stencil buffer or not. This property can't
be changed after the first render.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>false</code>  
<a name="SSAARenderPass+clearColor"></a>

### ssaaRenderPass.clearColor : <code>number</code> \| <code>Color</code> \| <code>string</code>
The clear color of the render pass.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>0x000000</code>  
<a name="SSAARenderPass+clearAlpha"></a>

### ssaaRenderPass.clearAlpha : <code>number</code>
The clear alpha of the render pass.

**Kind**: instance property of [<code>SSAARenderPass</code>](#SSAARenderPass)  
**Default**: <code>0</code>  
<a name="SSAARenderPass+dispose"></a>

### ssaaRenderPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SSAARenderPass</code>](#SSAARenderPass)  
<a name="SSAARenderPass+setSize"></a>

### ssaaRenderPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SSAARenderPass</code>](#SSAARenderPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SSAARenderPass+render"></a>

### ssaaRenderPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SSAA render pass.

**Kind**: instance method of [<code>SSAARenderPass</code>](#SSAARenderPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SSAOPass"></a>

## SSAOPass ⇐ <code>Pass</code>
A pass for a basic SSAO effect.

[SAOPass](SAOPass) and [GTAPass](GTAPass) produce a more advanced AO but are also
more expensive.

```js
const ssaoPass = new SSAOPass( scene, camera, width, height );
composer.addPass( ssaoPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SSAOPass](#SSAOPass) ⇐ <code>Pass</code>
    * [new SSAOPass(scene, camera, [width], [height], [kernelSize])](#new_SSAOPass_new)
    * [.width](#SSAOPass+width) : <code>number</code>
    * [.height](#SSAOPass+height) : <code>number</code>
    * [.clear](#SSAOPass+clear) : <code>boolean</code>
    * [.needsSwap](#SSAOPass+needsSwap) : <code>boolean</code>
    * [.camera](#SSAOPass+camera) : <code>Camera</code>
    * [.scene](#SSAOPass+scene) : <code>Scene</code>
    * [.kernelRadius](#SSAOPass+kernelRadius) : <code>number</code>
    * [.output](#SSAOPass+output) : <code>number</code>
    * [.minDistance](#SSAOPass+minDistance) : <code>number</code>
    * [.maxDistance](#SSAOPass+maxDistance) : <code>number</code>
    * [.dispose()](#SSAOPass+dispose)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SSAOPass+render)
    * [.setSize(width, height)](#SSAOPass+setSize)

<a name="new_SSAOPass_new"></a>

### new SSAOPass(scene, camera, [width], [height], [kernelSize])
Constructs a new SSAO pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to compute the AO for. |
| camera | <code>Camera</code> |  | The camera. |
| [width] | <code>number</code> | <code>512</code> | The width of the effect. |
| [height] | <code>number</code> | <code>512</code> | The height of the effect. |
| [kernelSize] | <code>number</code> | <code>32</code> | The kernel size. |

<a name="SSAOPass+width"></a>

### ssaoPass.width : <code>number</code>
The width of the effect.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>512</code>  
<a name="SSAOPass+height"></a>

### ssaoPass.height : <code>number</code>
The height of the effect.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>512</code>  
<a name="SSAOPass+clear"></a>

### ssaoPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>true</code>  
<a name="SSAOPass+needsSwap"></a>

### ssaoPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>false</code>  
<a name="SSAOPass+camera"></a>

### ssaoPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
<a name="SSAOPass+scene"></a>

### ssaoPass.scene : <code>Scene</code>
The scene to render the AO for.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
<a name="SSAOPass+kernelRadius"></a>

### ssaoPass.kernelRadius : <code>number</code>
The kernel radius controls how wide the
AO spreads.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>8</code>  
<a name="SSAOPass+output"></a>

### ssaoPass.output : <code>number</code>
The output configuration.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>0</code>  
<a name="SSAOPass+minDistance"></a>

### ssaoPass.minDistance : <code>number</code>
Defines the minimum distance that should be
affected by the AO.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>0.005</code>  
<a name="SSAOPass+maxDistance"></a>

### ssaoPass.maxDistance : <code>number</code>
Defines the maximum distance that should be
affected by the AO.

**Kind**: instance property of [<code>SSAOPass</code>](#SSAOPass)  
**Default**: <code>0.1</code>  
<a name="SSAOPass+dispose"></a>

### ssaoPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SSAOPass</code>](#SSAOPass)  
<a name="SSAOPass+render"></a>

### ssaoPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SSAO pass.

**Kind**: instance method of [<code>SSAOPass</code>](#SSAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SSAOPass+setSize"></a>

### ssaoPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SSAOPass</code>](#SSAOPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SSRPass"></a>

## SSRPass ⇐ <code>Pass</code>
A pass for a basic SSR effect.

```js
const ssrPass = new SSRPass( {
	renderer,
	scene,
	camera,
	width: innerWidth,
	height: innerHeight
} );
composer.addPass( ssrPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SSRPass](#SSRPass) ⇐ <code>Pass</code>
    * [new SSRPass(options)](#new_SSRPass_new)
    * _instance_
        * [.width](#SSRPass+width) : <code>number</code>
        * [.height](#SSRPass+height) : <code>number</code>
        * [.clear](#SSRPass+clear) : <code>boolean</code>
        * [.renderer](#SSRPass+renderer) : <code>WebGLRenderer</code>
        * [.scene](#SSRPass+scene) : <code>Scene</code>
        * [.camera](#SSRPass+camera) : <code>Camera</code>
        * [.groundReflector](#SSRPass+groundReflector) : <code>ReflectorForSSRPass</code>
        * [.opacity](#SSRPass+opacity) : <code>number</code>
        * [.output](#SSRPass+output) : <code>number</code>
        * [.maxDistance](#SSRPass+maxDistance) : <code>number</code>
        * [.thickness](#SSRPass+thickness) : <code>number</code>
        * [.selective](#SSRPass+selective) : <code>boolean</code>
        * [.selects](#SSRPass+selects) : <code>Array.&lt;Object3D&gt;</code>
        * [.bouncing](#SSRPass+bouncing) : <code>boolean</code>
        * [.blur](#SSRPass+blur) : <code>boolean</code>
        * [.distanceAttenuation](#SSRPass+distanceAttenuation) : <code>boolean</code>
        * [.fresnel](#SSRPass+fresnel) : <code>boolean</code>
        * [.infiniteThick](#SSRPass+infiniteThick) : <code>boolean</code>
        * [.dispose()](#SSRPass+dispose)
        * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SSRPass+render)
        * [.setSize(width, height)](#SSRPass+setSize)
    * _inner_
        * [~Options](#SSRPass..Options) : <code>Object</code>

<a name="new_SSRPass_new"></a>

### new SSRPass(options)
Constructs a new SSR pass.


| Param | Type | Description |
| --- | --- | --- |
| options | [<code>Options</code>](#SSRPass..Options) | The pass options. |

<a name="SSRPass+width"></a>

### ssrPass.width : <code>number</code>
The width of the effect.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>512</code>  
<a name="SSRPass+height"></a>

### ssrPass.height : <code>number</code>
The height of the effect.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>512</code>  
<a name="SSRPass+clear"></a>

### ssrPass.clear : <code>boolean</code>
Overwritten to perform a clear operation by default.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>true</code>  
<a name="SSRPass+renderer"></a>

### ssrPass.renderer : <code>WebGLRenderer</code>
The renderer.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
<a name="SSRPass+scene"></a>

### ssrPass.scene : <code>Scene</code>
The scene to render.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
<a name="SSRPass+camera"></a>

### ssrPass.camera : <code>Camera</code>
The camera.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
<a name="SSRPass+groundReflector"></a>

### ssrPass.groundReflector : <code>ReflectorForSSRPass</code>
The ground reflector.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>0</code>  
<a name="SSRPass+opacity"></a>

### ssrPass.opacity : <code>number</code>
The opactiy.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>0.5</code>  
<a name="SSRPass+output"></a>

### ssrPass.output : <code>number</code>
The output configuration.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>0</code>  
<a name="SSRPass+maxDistance"></a>

### ssrPass.maxDistance : <code>number</code>
Controls how far a fragment can reflect.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>180</code>  
<a name="SSRPass+thickness"></a>

### ssrPass.thickness : <code>number</code>
Controls the cutoff between what counts as a
possible reflection hit and what does not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>.018</code>  
<a name="SSRPass+selective"></a>

### ssrPass.selective : <code>boolean</code>
Whether the pass is selective or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>false</code>  
<a name="SSRPass+selects"></a>

### ssrPass.selects : <code>Array.&lt;Object3D&gt;</code>
Which 3D objects should be affected by SSR. If not set, the entire scene is affected.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>null</code>  
<a name="SSRPass+bouncing"></a>

### ssrPass.bouncing : <code>boolean</code>
Whether bouncing is enabled or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>false</code>  
<a name="SSRPass+blur"></a>

### ssrPass.blur : <code>boolean</code>
Whether to blur reflections or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>true</code>  
<a name="SSRPass+distanceAttenuation"></a>

### ssrPass.distanceAttenuation : <code>boolean</code>
Whether to use distance attenutation or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>true</code>  
<a name="SSRPass+fresnel"></a>

### ssrPass.fresnel : <code>boolean</code>
Whether to use fresnel or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>true</code>  
<a name="SSRPass+infiniteThick"></a>

### ssrPass.infiniteThick : <code>boolean</code>
Whether to use infinite thickness or not.

**Kind**: instance property of [<code>SSRPass</code>](#SSRPass)  
**Default**: <code>false</code>  
<a name="SSRPass+dispose"></a>

### ssrPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SSRPass</code>](#SSRPass)  
<a name="SSRPass+render"></a>

### ssrPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the SSR pass.

**Kind**: instance method of [<code>SSRPass</code>](#SSRPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SSRPass+setSize"></a>

### ssrPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SSRPass</code>](#SSRPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SSRPass..Options"></a>

### SSRPass~Options : <code>Object</code>
Constructor options of `SSRPass`.

**Kind**: inner typedef of [<code>SSRPass</code>](#SSRPass)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| renderer | <code>WebGLRenderer</code> |  | The renderer. |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera. |
| [width] | <code>number</code> | <code>512</code> | The width of the effect. |
| [height] | <code>number</code> | <code>512</code> | The width of the effect. |
| [selects] | <code>Array.&lt;Object3D&gt;</code> | <code></code> | Which 3D objects should be affected by SSR. If not set, the entire scene is affected. |
| [bouncing] | <code>boolean</code> | <code>false</code> | Whether bouncing is enabled or not. |
| [groundReflector] | <code>ReflectorForSSRPass</code> | <code></code> | A ground reflector. |

<a name="SavePass"></a>

## SavePass ⇐ <code>Pass</code>
A pass that saves the contents of the current read buffer in a render target.

```js
const savePass = new SavePass( customRenderTarget );
composer.addPass( savePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [SavePass](#SavePass) ⇐ <code>Pass</code>
    * [new SavePass([renderTarget])](#new_SavePass_new)
    * [.uniforms](#SavePass+uniforms) : <code>Object</code>
    * [.material](#SavePass+material) : <code>ShaderMaterial</code>
    * [.renderTarget](#SavePass+renderTarget) : <code>WebGLRenderTarget</code>
    * [.needsSwap](#SavePass+needsSwap) : <code>boolean</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#SavePass+render)
    * [.setSize(width, height)](#SavePass+setSize)
    * [.dispose()](#SavePass+dispose)

<a name="new_SavePass_new"></a>

### new SavePass([renderTarget])
Constructs a new save pass.


| Param | Type | Description |
| --- | --- | --- |
| [renderTarget] | <code>WebGLRenderTarget</code> | The render target for saving the read buffer. If not provided, the pass automatically creates a render target. |

<a name="SavePass+uniforms"></a>

### savePass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>SavePass</code>](#SavePass)  
<a name="SavePass+material"></a>

### savePass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>SavePass</code>](#SavePass)  
<a name="SavePass+renderTarget"></a>

### savePass.renderTarget : <code>WebGLRenderTarget</code>
The render target which is used to save the read buffer.

**Kind**: instance property of [<code>SavePass</code>](#SavePass)  
<a name="SavePass+needsSwap"></a>

### savePass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>SavePass</code>](#SavePass)  
**Default**: <code>false</code>  
<a name="SavePass+render"></a>

### savePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the save pass.

**Kind**: instance method of [<code>SavePass</code>](#SavePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="SavePass+setSize"></a>

### savePass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>SavePass</code>](#SavePass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="SavePass+dispose"></a>

### savePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>SavePass</code>](#SavePass)  
<a name="ShaderPass"></a>

## ShaderPass ⇐ <code>Pass</code>
This pass can be used to create a post processing effect
with a raw GLSL shader object. Useful for implementing custom
effects.

```js
const fxaaPass = new ShaderPass( FXAAShader );
composer.addPass( fxaaPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [ShaderPass](#ShaderPass) ⇐ <code>Pass</code>
    * [new ShaderPass([shader], [textureID])](#new_ShaderPass_new)
    * [.textureID](#ShaderPass+textureID) : <code>string</code>
    * [.uniforms](#ShaderPass+uniforms) : <code>Object</code>
    * [.material](#ShaderPass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#ShaderPass+render)
    * [.dispose()](#ShaderPass+dispose)

<a name="new_ShaderPass_new"></a>

### new ShaderPass([shader], [textureID])
Constructs a new shader pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [shader] | <code>Object</code> \| <code>ShaderMaterial</code> |  | A shader object holding vertex and fragment shader as well as defines and uniforms. It's also valid to pass a custom shader material. |
| [textureID] | <code>string</code> | <code>&quot;&#x27;tDiffuse&#x27;&quot;</code> | The name of the texture uniform that should sample the read buffer. |

<a name="ShaderPass+textureID"></a>

### shaderPass.textureID : <code>string</code>
The name of the texture uniform that should sample the read buffer.

**Kind**: instance property of [<code>ShaderPass</code>](#ShaderPass)  
**Default**: <code>&quot;&#x27;tDiffuse&#x27;&quot;</code>  
<a name="ShaderPass+uniforms"></a>

### shaderPass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>ShaderPass</code>](#ShaderPass)  
<a name="ShaderPass+material"></a>

### shaderPass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>ShaderPass</code>](#ShaderPass)  
<a name="ShaderPass+render"></a>

### shaderPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the shader pass.

**Kind**: instance method of [<code>ShaderPass</code>](#ShaderPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="ShaderPass+dispose"></a>

### shaderPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>ShaderPass</code>](#ShaderPass)  
<a name="TAARenderPass"></a>

## TAARenderPass ⇐ <code>SSAARenderPass</code>
Temporal Anti-Aliasing Render Pass.

When there is no motion in the scene, the TAA render pass accumulates jittered camera
samples across frames to create a high quality anti-aliased result.

Note: This effect uses no reprojection so it is no TRAA implementation.

```js
const taaRenderPass = new TAARenderPass( scene, camera );
taaRenderPass.unbiased = false;
composer.addPass( taaRenderPass );
```

**Kind**: global class  
**Extends**: <code>SSAARenderPass</code>  

* [TAARenderPass](#TAARenderPass) ⇐ <code>SSAARenderPass</code>
    * [new TAARenderPass(scene, camera, [clearColor], [clearAlpha])](#new_TAARenderPass_new)
    * [.sampleLevel](#TAARenderPass+sampleLevel) : <code>number</code>
    * [.accumulate](#TAARenderPass+accumulate) : <code>boolean</code>
    * [.accumulateIndex](#TAARenderPass+accumulateIndex) : <code>number</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#TAARenderPass+render)
    * [.dispose()](#TAARenderPass+dispose)

<a name="new_TAARenderPass_new"></a>

### new TAARenderPass(scene, camera, [clearColor], [clearAlpha])
Constructs a new TAA render pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera. |
| [clearColor] | <code>number</code> \| <code>Color</code> \| <code>string</code> | <code>0x000000</code> | The clear color of the render pass. |
| [clearAlpha] | <code>number</code> | <code>0</code> | The clear alpha of the render pass. |

<a name="TAARenderPass+sampleLevel"></a>

### taaRenderPass.sampleLevel : <code>number</code>
Overwritten and set to 0 by default.

**Kind**: instance property of [<code>TAARenderPass</code>](#TAARenderPass)  
**Default**: <code>0</code>  
<a name="TAARenderPass+accumulate"></a>

### taaRenderPass.accumulate : <code>boolean</code>
Whether to accumulate frames or not. This enables
the TAA.

**Kind**: instance property of [<code>TAARenderPass</code>](#TAARenderPass)  
**Default**: <code>false</code>  
<a name="TAARenderPass+accumulateIndex"></a>

### taaRenderPass.accumulateIndex : <code>number</code>
The accumulation index.

**Kind**: instance property of [<code>TAARenderPass</code>](#TAARenderPass)  
**Default**: <code>-1</code>  
<a name="TAARenderPass+render"></a>

### taaRenderPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the TAA render pass.

**Kind**: instance method of [<code>TAARenderPass</code>](#TAARenderPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="TAARenderPass+dispose"></a>

### taaRenderPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>TAARenderPass</code>](#TAARenderPass)  
<a name="TexturePass"></a>

## TexturePass ⇐ <code>Pass</code>
This pass can be used to render a texture over the entire screen.

```js
const texture = new THREE.TextureLoader().load( 'textures/2294472375_24a3b8ef46_o.jpg' );
texture.colorSpace = THREE.SRGBColorSpace;

const texturePass = new TexturePass( texture );
composer.addPass( texturePass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [TexturePass](#TexturePass) ⇐ <code>Pass</code>
    * [new TexturePass(map, [opacity])](#new_TexturePass_new)
    * [.map](#TexturePass+map) : <code>Texture</code>
    * [.opacity](#TexturePass+opacity) : <code>number</code>
    * [.needsSwap](#TexturePass+needsSwap) : <code>boolean</code>
    * [.uniforms](#TexturePass+uniforms) : <code>Object</code>
    * [.material](#TexturePass+material) : <code>ShaderMaterial</code>
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#TexturePass+render)
    * [.dispose()](#TexturePass+dispose)

<a name="new_TexturePass_new"></a>

### new TexturePass(map, [opacity])
Constructs a new texture pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| map | <code>Texture</code> |  | The texture to render. |
| [opacity] | <code>number</code> | <code>1</code> | The opacity. |

<a name="TexturePass+map"></a>

### texturePass.map : <code>Texture</code>
The texture to render.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
<a name="TexturePass+opacity"></a>

### texturePass.opacity : <code>number</code>
The opacity.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
**Default**: <code>1</code>  
<a name="TexturePass+needsSwap"></a>

### texturePass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
**Default**: <code>false</code>  
<a name="TexturePass+uniforms"></a>

### texturePass.uniforms : <code>Object</code>
The pass uniforms.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
<a name="TexturePass+material"></a>

### texturePass.material : <code>ShaderMaterial</code>
The pass material.

**Kind**: instance property of [<code>TexturePass</code>](#TexturePass)  
<a name="TexturePass+render"></a>

### texturePass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the texture pass.

**Kind**: instance method of [<code>TexturePass</code>](#TexturePass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

<a name="TexturePass+dispose"></a>

### texturePass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>TexturePass</code>](#TexturePass)  
<a name="UnrealBloomPass"></a>

## UnrealBloomPass ⇐ <code>Pass</code>
This pass is inspired by the bloom pass of Unreal Engine. It creates a
mip map chain of bloom textures and blurs them with different radii. Because
of the weighted combination of mips, and because larger blurs are done on
higher mips, this effect provides good quality and performance.

When using this pass, tone mapping must be enabled in the renderer settings.

Reference:
- [Bloom in Unreal Engine](https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/)

```js
const resolution = new THREE.Vector2( window.innerWidth, window.innerHeight );
const bloomPass = new UnrealBloomPass( resolution, 1.5, 0.4, 0.85 );
composer.addPass( bloomPass );
```

**Kind**: global class  
**Extends**: <code>Pass</code>  

* [UnrealBloomPass](#UnrealBloomPass) ⇐ <code>Pass</code>
    * [new UnrealBloomPass([resolution], [strength], radius, threshold)](#new_UnrealBloomPass_new)
    * [.strength](#UnrealBloomPass+strength) : <code>number</code>
    * [.radius](#UnrealBloomPass+radius) : <code>number</code>
    * [.threshold](#UnrealBloomPass+threshold) : <code>number</code>
    * [.resolution](#UnrealBloomPass+resolution) : <code>Vector2</code>
    * [.clearColor](#UnrealBloomPass+clearColor) : <code>Color</code>
    * [.needsSwap](#UnrealBloomPass+needsSwap) : <code>boolean</code>
    * [.dispose()](#UnrealBloomPass+dispose)
    * [.setSize(width, height)](#UnrealBloomPass+setSize)
    * [.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)](#UnrealBloomPass+render)

<a name="new_UnrealBloomPass_new"></a>

### new UnrealBloomPass([resolution], [strength], radius, threshold)
Constructs a new Unreal Bloom pass.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [resolution] | <code>Vector2</code> |  | The effect's resolution. |
| [strength] | <code>number</code> | <code>1</code> | The Bloom strength. |
| radius | <code>number</code> |  | The Bloom radius. |
| threshold | <code>number</code> |  | The luminance threshold limits which bright areas contribute to the Bloom effect. |

<a name="UnrealBloomPass+strength"></a>

### unrealBloomPass.strength : <code>number</code>
The Bloom strength.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
**Default**: <code>1</code>  
<a name="UnrealBloomPass+radius"></a>

### unrealBloomPass.radius : <code>number</code>
The Bloom radius.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
<a name="UnrealBloomPass+threshold"></a>

### unrealBloomPass.threshold : <code>number</code>
The luminance threshold limits which bright areas contribute to the Bloom effect.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
<a name="UnrealBloomPass+resolution"></a>

### unrealBloomPass.resolution : <code>Vector2</code>
The effect's resolution.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
**Default**: <code>(256,256)</code>  
<a name="UnrealBloomPass+clearColor"></a>

### unrealBloomPass.clearColor : <code>Color</code>
The effect's clear color

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
**Default**: <code>(0,0,0)</code>  
<a name="UnrealBloomPass+needsSwap"></a>

### unrealBloomPass.needsSwap : <code>boolean</code>
Overwritten to disable the swap.

**Kind**: instance property of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
**Default**: <code>false</code>  
<a name="UnrealBloomPass+dispose"></a>

### unrealBloomPass.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever the pass is no longer used in your app.

**Kind**: instance method of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  
<a name="UnrealBloomPass+setSize"></a>

### unrealBloomPass.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width to set. |
| height | <code>number</code> | The width to set. |

<a name="UnrealBloomPass+render"></a>

### unrealBloomPass.render(renderer, writeBuffer, readBuffer, deltaTime, maskActive)
Performs the Bloom pass.

**Kind**: instance method of [<code>UnrealBloomPass</code>](#UnrealBloomPass)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |
| writeBuffer | <code>WebGLRenderTarget</code> | The write buffer. This buffer is intended as the rendering destination for the pass. |
| readBuffer | <code>WebGLRenderTarget</code> | The read buffer. The pass can access the result from the previous pass from this buffer. |
| deltaTime | <code>number</code> | The delta time in seconds. |
| maskActive | <code>boolean</code> | Whether masking is active or not. |

## Classes

<dl>
<dt><a href="#CSS2DObject">CSS2DObject</a> ⇐ <code>Object3D</code></dt>
<dd><p>The only type of 3D object that is supported by <a href="#CSS2DRenderer">CSS2DRenderer</a>.</p>
</dd>
<dt><a href="#CSS2DRenderer">CSS2DRenderer</a></dt>
<dd><p>This renderer is a simplified version of <a href="CSS3DRenderer">CSS3DRenderer</a>. The only transformation that is
supported is translation.</p>
<p>The renderer is very useful if you want to combine HTML based labels with 3D objects. Here too,
the respective DOM elements are wrapped into an instance of <a href="#CSS2DObject">CSS2DObject</a> and added to the
scene graph. All other types of renderable 3D objects (like meshes or point clouds) are ignored.</p>
<p><code>CSS2DRenderer</code> only supports 100% browser and display zoom.</p>
</dd>
</dl>

<a name="CSS2DObject"></a>

## CSS2DObject ⇐ <code>Object3D</code>
The only type of 3D object that is supported by [CSS2DRenderer](#CSS2DRenderer).

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [CSS2DObject](#CSS2DObject) ⇐ <code>Object3D</code>
    * [new CSS2DObject([element])](#new_CSS2DObject_new)
    * [.isCSS2DObject](#CSS2DObject+isCSS2DObject) : <code>boolean</code>
    * [.element](#CSS2DObject+element) : <code>DOMElement</code>
    * [.center](#CSS2DObject+center) : <code>Vector2</code>

<a name="new_CSS2DObject_new"></a>

### new CSS2DObject([element])
Constructs a new CSS2D object.


| Param | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | The DOM element. |

<a name="CSS2DObject+isCSS2DObject"></a>

### csS2DObject.isCSS2DObject : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CSS2DObject</code>](#CSS2DObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS2DObject+element"></a>

### csS2DObject.element : <code>DOMElement</code>
The DOM element which defines the appearance of this 3D object.

**Kind**: instance property of [<code>CSS2DObject</code>](#CSS2DObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS2DObject+center"></a>

### csS2DObject.center : <code>Vector2</code>
The 3D objects center point.
`( 0, 0 )` is the lower left, `( 1, 1 )` is the top right.

**Kind**: instance property of [<code>CSS2DObject</code>](#CSS2DObject)  
**Default**: <code>(0.5,0.5)</code>  
<a name="CSS2DRenderer"></a>

## CSS2DRenderer
This renderer is a simplified version of [CSS3DRenderer](CSS3DRenderer). The only transformation that is
supported is translation.

The renderer is very useful if you want to combine HTML based labels with 3D objects. Here too,
the respective DOM elements are wrapped into an instance of [CSS2DObject](#CSS2DObject) and added to the
scene graph. All other types of renderable 3D objects (like meshes or point clouds) are ignored.

`CSS2DRenderer` only supports 100% browser and display zoom.

**Kind**: global class  

* [CSS2DRenderer](#CSS2DRenderer)
    * [new CSS2DRenderer([parameters])](#new_CSS2DRenderer_new)
    * _instance_
        * [.domElement](#CSS2DRenderer+domElement) : <code>DOMElement</code>
        * [.getSize()](#CSS2DRenderer+getSize) ⇒ <code>Object</code>
        * [.render(scene, camera)](#CSS2DRenderer+render)
        * [.setSize(width, height)](#CSS2DRenderer+setSize)
    * _inner_
        * [~Parameters](#CSS2DRenderer..Parameters) : <code>Object</code>

<a name="new_CSS2DRenderer_new"></a>

### new CSS2DRenderer([parameters])
Constructs a new CSS2D renderer.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | [<code>Parameters</code>](#CSS2DRenderer..Parameters) | The parameters. |

<a name="CSS2DRenderer+domElement"></a>

### csS2DRenderer.domElement : <code>DOMElement</code>
The DOM where the renderer appends its child-elements.

**Kind**: instance property of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  
<a name="CSS2DRenderer+getSize"></a>

### csS2DRenderer.getSize() ⇒ <code>Object</code>
Returns an object containing the width and height of the renderer.

**Kind**: instance method of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  
**Returns**: <code>Object</code> - The size of the renderer.  
<a name="CSS2DRenderer+render"></a>

### csS2DRenderer.render(scene, camera)
Renders the given scene using the given camera.

**Kind**: instance method of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | A scene or any other type of 3D object. |
| camera | <code>Camera</code> | The camera. |

<a name="CSS2DRenderer+setSize"></a>

### csS2DRenderer.setSize(width, height)
Resizes the renderer to the given width and height.

**Kind**: instance method of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the renderer. |
| height | <code>number</code> | The height of the renderer. |

<a name="CSS2DRenderer..Parameters"></a>

### CSS2DRenderer~Parameters : <code>Object</code>
Constructor parameters of `CSS2DRenderer`.

**Kind**: inner typedef of [<code>CSS2DRenderer</code>](#CSS2DRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | A DOM element where the renderer appends its child-elements. If not passed in here, a new div element will be created. |

## Classes

<dl>
<dt><a href="#CSS3DObject">CSS3DObject</a> ⇐ <code>Object3D</code></dt>
<dd><p>The base 3D object that is supported by <a href="#CSS3DRenderer">CSS3DRenderer</a>.</p>
</dd>
<dt><a href="#CSS3DSprite">CSS3DSprite</a> ⇐ <code><a href="#CSS3DObject">CSS3DObject</a></code></dt>
<dd><p>A specialized version of <a href="#CSS3DObject">CSS3DObject</a> that represents
DOM elements as sprites.</p>
</dd>
<dt><a href="#CSS3DRenderer">CSS3DRenderer</a></dt>
<dd><p>This renderer can be used to apply hierarchical 3D transformations to DOM elements
via the CSS3 <a href="https://www.w3schools.com/cssref/css3_pr_transform.asp">transform</a> property.
<code>CSS3DRenderer</code> is particularly interesting if you want to apply 3D effects to a website without
canvas based rendering. It can also be used in order to combine DOM elements with WebGLcontent.</p>
<p>There are, however, some important limitations:</p>
<ul>
<li>It&#39;s not possible to use the material system of <em>three.js</em>.</li>
<li>It&#39;s also not possible to use geometries.</li>
<li>The renderer only supports 100% browser and display zoom.</li>
</ul>
<p>So <code>CSS3DRenderer</code> is just focused on ordinary DOM elements. These elements are wrapped into special
3D objects (<a href="#CSS3DObject">CSS3DObject</a> or <a href="#CSS3DSprite">CSS3DSprite</a>) and then added to the scene graph.</p>
</dd>
</dl>

<a name="CSS3DObject"></a>

## CSS3DObject ⇐ <code>Object3D</code>
The base 3D object that is supported by [CSS3DRenderer](#CSS3DRenderer).

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [CSS3DObject](#CSS3DObject) ⇐ <code>Object3D</code>
    * [new CSS3DObject([element])](#new_CSS3DObject_new)
    * [.isCSS3DObject](#CSS3DObject+isCSS3DObject) : <code>boolean</code>
    * [.element](#CSS3DObject+element) : <code>DOMElement</code>

<a name="new_CSS3DObject_new"></a>

### new CSS3DObject([element])
Constructs a new CSS3D object.


| Param | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | The DOM element. |

<a name="CSS3DObject+isCSS3DObject"></a>

### csS3DObject.isCSS3DObject : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CSS3DObject</code>](#CSS3DObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS3DObject+element"></a>

### csS3DObject.element : <code>DOMElement</code>
The DOM element which defines the appearance of this 3D object.

**Kind**: instance property of [<code>CSS3DObject</code>](#CSS3DObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS3DSprite"></a>

## CSS3DSprite ⇐ [<code>CSS3DObject</code>](#CSS3DObject)
A specialized version of [CSS3DObject](#CSS3DObject) that represents
DOM elements as sprites.

**Kind**: global class  
**Extends**: [<code>CSS3DObject</code>](#CSS3DObject)  

* [CSS3DSprite](#CSS3DSprite) ⇐ [<code>CSS3DObject</code>](#CSS3DObject)
    * [new CSS3DSprite([element])](#new_CSS3DSprite_new)
    * [.isCSS3DSprite](#CSS3DSprite+isCSS3DSprite) : <code>boolean</code>
    * [.rotation2D](#CSS3DSprite+rotation2D) : <code>number</code>
    * [.isCSS3DObject](#CSS3DObject+isCSS3DObject) : <code>boolean</code>
    * [.element](#CSS3DObject+element) : <code>DOMElement</code>

<a name="new_CSS3DSprite_new"></a>

### new CSS3DSprite([element])
Constructs a new CSS3D sprite object.


| Param | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | The DOM element. |

<a name="CSS3DSprite+isCSS3DSprite"></a>

### csS3DSprite.isCSS3DSprite : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CSS3DSprite</code>](#CSS3DSprite)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="CSS3DSprite+rotation2D"></a>

### csS3DSprite.rotation2D : <code>number</code>
The sprite's rotation in radians.

**Kind**: instance property of [<code>CSS3DSprite</code>](#CSS3DSprite)  
**Default**: <code>0</code>  
<a name="CSS3DObject+isCSS3DObject"></a>

### csS3DSprite.isCSS3DObject : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>CSS3DSprite</code>](#CSS3DSprite)  
**Default**: <code>true</code>  
**Overrides**: [<code>isCSS3DObject</code>](#CSS3DObject+isCSS3DObject)  
**Read only**: true  
<a name="CSS3DObject+element"></a>

### csS3DSprite.element : <code>DOMElement</code>
The DOM element which defines the appearance of this 3D object.

**Kind**: instance property of [<code>CSS3DSprite</code>](#CSS3DSprite)  
**Default**: <code>true</code>  
**Overrides**: [<code>element</code>](#CSS3DObject+element)  
**Read only**: true  
<a name="CSS3DRenderer"></a>

## CSS3DRenderer
This renderer can be used to apply hierarchical 3D transformations to DOM elements
via the CSS3 [transform](https://www.w3schools.com/cssref/css3_pr_transform.asp) property.
`CSS3DRenderer` is particularly interesting if you want to apply 3D effects to a website without
canvas based rendering. It can also be used in order to combine DOM elements with WebGLcontent.

There are, however, some important limitations:

- It's not possible to use the material system of *three.js*.
- It's also not possible to use geometries.
- The renderer only supports 100% browser and display zoom.

So `CSS3DRenderer` is just focused on ordinary DOM elements. These elements are wrapped into special
3D objects ([CSS3DObject](#CSS3DObject) or [CSS3DSprite](#CSS3DSprite)) and then added to the scene graph.

**Kind**: global class  

* [CSS3DRenderer](#CSS3DRenderer)
    * [new CSS3DRenderer([parameters])](#new_CSS3DRenderer_new)
    * _instance_
        * [.domElement](#CSS3DRenderer+domElement) : <code>DOMElement</code>
        * [.getSize()](#CSS3DRenderer+getSize) ⇒ <code>Object</code>
        * [.render(scene, camera)](#CSS3DRenderer+render)
        * [.setSize(width, height)](#CSS3DRenderer+setSize)
    * _inner_
        * [~Parameters](#CSS3DRenderer..Parameters) : <code>Object</code>

<a name="new_CSS3DRenderer_new"></a>

### new CSS3DRenderer([parameters])
Constructs a new CSS3D renderer.


| Param | Type | Description |
| --- | --- | --- |
| [parameters] | [<code>Parameters</code>](#CSS3DRenderer..Parameters) | The parameters. |

<a name="CSS3DRenderer+domElement"></a>

### csS3DRenderer.domElement : <code>DOMElement</code>
The DOM where the renderer appends its child-elements.

**Kind**: instance property of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  
<a name="CSS3DRenderer+getSize"></a>

### csS3DRenderer.getSize() ⇒ <code>Object</code>
Returns an object containing the width and height of the renderer.

**Kind**: instance method of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  
**Returns**: <code>Object</code> - The size of the renderer.  
<a name="CSS3DRenderer+render"></a>

### csS3DRenderer.render(scene, camera)
Renders the given scene using the given camera.

**Kind**: instance method of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | A scene or any other type of 3D object. |
| camera | <code>Camera</code> | The camera. |

<a name="CSS3DRenderer+setSize"></a>

### csS3DRenderer.setSize(width, height)
Resizes the renderer to the given width and height.

**Kind**: instance method of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the renderer. |
| height | <code>number</code> | The height of the renderer. |

<a name="CSS3DRenderer..Parameters"></a>

### CSS3DRenderer~Parameters : <code>Object</code>
Constructor parameters of `CSS3DRenderer`.

**Kind**: inner typedef of [<code>CSS3DRenderer</code>](#CSS3DRenderer)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [element] | <code>DOMElement</code> | A DOM element where the renderer appends its child-elements. If not passed in here, a new div element will be created. |

<a name="Projector"></a>

## Projector
This class can project a given scene in 3D space into a 2D representation
used for rendering with a 2D API. `Projector` is currently used by [SVGRenderer](SVGRenderer)
and was previously used by the legacy `CanvasRenderer`.

**Kind**: global class  

* [Projector](#Projector)
    * [new Projector()](#new_Projector_new)
    * [.projectScene(scene, camera, sortObjects, sortElements)](#Projector+projectScene) ⇒ <code>Object</code>

<a name="new_Projector_new"></a>

### new Projector()
Constructs a new projector.

<a name="Projector+projectScene"></a>

### projector.projectScene(scene, camera, sortObjects, sortElements) ⇒ <code>Object</code>
Projects the given scene in 3D space into a 2D representation. The result
is an object with renderable items.

**Kind**: instance method of [<code>Projector</code>](#Projector)  
**Returns**: <code>Object</code> - The projected scene as renderable objects.  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | A scene or any other type of 3D object. |
| camera | <code>Camera</code> | The camera. |
| sortObjects | <code>boolean</code> | Whether to sort objects or not. |
| sortElements | <code>boolean</code> | Whether to sort elements (faces, lines and sprites) or not. |

## Classes

<dl>
<dt><a href="#SVGObject">SVGObject</a> ⇐ <code>Object3D</code></dt>
<dd><p>Can be used to wrap SVG elements into a 3D object.</p>
</dd>
<dt><a href="#SVGRenderer">SVGRenderer</a></dt>
<dd><p>This renderer an be used to render geometric data using SVG. The produced vector
graphics are particular useful in the following use cases:</p>
<ul>
<li>Animated logos or icons.</li>
<li>Interactive 2D/3D diagrams or graphs.</li>
<li>Interactive maps.</li>
<li>Complex or animated user interfaces.</li>
</ul>
<p><code>SVGRenderer</code> has various advantages. It produces crystal-clear and sharp output which
is independent of the actual viewport resolution.SVG elements can be styled via CSS.
And they have good accessibility since it&#39;s possible to add metadata like title or description
(useful for search engines or screen readers).</p>
<p>There are, however, some important limitations:</p>
<ul>
<li>No advanced shading.</li>
<li>No texture support.</li>
<li>No shadow support.</li>
</ul>
</dd>
</dl>

<a name="SVGObject"></a>

## SVGObject ⇐ <code>Object3D</code>
Can be used to wrap SVG elements into a 3D object.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [SVGObject](#SVGObject) ⇐ <code>Object3D</code>
    * [new SVGObject(node)](#new_SVGObject_new)
    * [.isSVGObject](#SVGObject+isSVGObject) : <code>boolean</code>
    * [.node](#SVGObject+node) : <code>SVGElement</code>

<a name="new_SVGObject_new"></a>

### new SVGObject(node)
Constructs a new SVG object.


| Param | Type | Description |
| --- | --- | --- |
| node | <code>SVGElement</code> | The SVG element. |

<a name="SVGObject+isSVGObject"></a>

### svgObject.isSVGObject : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SVGObject</code>](#SVGObject)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SVGObject+node"></a>

### svgObject.node : <code>SVGElement</code>
This SVG element.

**Kind**: instance property of [<code>SVGObject</code>](#SVGObject)  
<a name="SVGRenderer"></a>

## SVGRenderer
This renderer an be used to render geometric data using SVG. The produced vector
graphics are particular useful in the following use cases:

- Animated logos or icons.
- Interactive 2D/3D diagrams or graphs.
- Interactive maps.
- Complex or animated user interfaces.

`SVGRenderer` has various advantages. It produces crystal-clear and sharp output which
is independent of the actual viewport resolution.SVG elements can be styled via CSS.
And they have good accessibility since it's possible to add metadata like title or description
(useful for search engines or screen readers).

There are, however, some important limitations:
- No advanced shading.
- No texture support.
- No shadow support.

**Kind**: global class  

* [SVGRenderer](#SVGRenderer)
    * [new SVGRenderer()](#new_SVGRenderer_new)
    * [.domElement](#SVGRenderer+domElement) : <code>DOMElement</code>
    * [.autoClear](#SVGRenderer+autoClear) : <code>boolean</code>
    * [.sortObjects](#SVGRenderer+sortObjects) : <code>boolean</code>
    * [.sortElements](#SVGRenderer+sortElements) : <code>boolean</code>
    * [.overdraw](#SVGRenderer+overdraw) : <code>number</code>
    * [.outputColorSpace](#SVGRenderer+outputColorSpace) : <code>SRGBColorSpace</code> \| <code>LinearSRGBColorSpace</code>
    * [.info](#SVGRenderer+info) : <code>Object</code>
    * [.setQuality(quality)](#SVGRenderer+setQuality)
    * [.setClearColor(color)](#SVGRenderer+setClearColor)
    * [.setSize(width, height)](#SVGRenderer+setSize)
    * [.getSize()](#SVGRenderer+getSize) ⇒ <code>Object</code>
    * [.setPrecision(precision)](#SVGRenderer+setPrecision)
    * [.clear()](#SVGRenderer+clear)
    * [.render(scene, camera)](#SVGRenderer+render)

<a name="new_SVGRenderer_new"></a>

### new SVGRenderer()
Constructs a new SVG renderer.

<a name="SVGRenderer+domElement"></a>

### svgRenderer.domElement : <code>DOMElement</code>
The DOM where the renderer appends its child-elements.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
<a name="SVGRenderer+autoClear"></a>

### svgRenderer.autoClear : <code>boolean</code>
Whether to automatically perform a clear before a render call or not.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>true</code>  
<a name="SVGRenderer+sortObjects"></a>

### svgRenderer.sortObjects : <code>boolean</code>
Whether to sort 3D objects or not.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>true</code>  
<a name="SVGRenderer+sortElements"></a>

### svgRenderer.sortElements : <code>boolean</code>
Whether to sort elements or not.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>true</code>  
<a name="SVGRenderer+overdraw"></a>

### svgRenderer.overdraw : <code>number</code>
Number of fractional pixels to enlarge polygons in order to
prevent anti-aliasing gaps. Range is `[0,1]`.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>0.5</code>  
<a name="SVGRenderer+outputColorSpace"></a>

### svgRenderer.outputColorSpace : <code>SRGBColorSpace</code> \| <code>LinearSRGBColorSpace</code>
The output color space.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
**Default**: <code>SRGBColorSpace</code>  
<a name="SVGRenderer+info"></a>

### svgRenderer.info : <code>Object</code>
Provides information about the number of
rendered vertices and faces.

**Kind**: instance property of [<code>SVGRenderer</code>](#SVGRenderer)  
<a name="SVGRenderer+setQuality"></a>

### svgRenderer.setQuality(quality)
Sets the render quality. Setting to `high` means This value indicates that the browser
tries to improve the SVG quality over rendering speed and geometric precision.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| quality | <code>&#x27;low&#x27;</code> \| <code>&#x27;high&#x27;</code> | The quality. |

<a name="SVGRenderer+setClearColor"></a>

### svgRenderer.setClearColor(color)
Sets the clear color.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| color | <code>number</code> \| <code>Color</code> \| <code>string</code> | The clear color to set. |

<a name="SVGRenderer+setSize"></a>

### svgRenderer.setSize(width, height)
Resizes the renderer to the given width and height.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the renderer. |
| height | <code>number</code> | The height of the renderer. |

<a name="SVGRenderer+getSize"></a>

### svgRenderer.getSize() ⇒ <code>Object</code>
Returns an object containing the width and height of the renderer.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  
**Returns**: <code>Object</code> - The size of the renderer.  
<a name="SVGRenderer+setPrecision"></a>

### svgRenderer.setPrecision(precision)
Sets the precision of the data used to create a paths.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| precision | <code>number</code> | The precision to set. |

<a name="SVGRenderer+clear"></a>

### svgRenderer.clear()
Performs a manual clear with the defined clear color.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  
<a name="SVGRenderer+render"></a>

### svgRenderer.render(scene, camera)
Renders the given scene using the given camera.

**Kind**: instance method of [<code>SVGRenderer</code>](#SVGRenderer)  

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Object3D</code> | A scene or any other type of 3D object. |
| camera | <code>Camera</code> | The camera. |

<a name="module_ACESFilmicToneMappingShader"></a>

## ACESFilmicToneMappingShader
<a name="module_ACESFilmicToneMappingShader..ACESFilmicToneMappingShader"></a>

### ACESFilmicToneMappingShader~ACESFilmicToneMappingShader : <code>ShaderMaterial~Shader</code>
ACES Filmic Tone Mapping Shader by Stephen Hill.
Reference: [ltc_blit.fs](https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs)

This implementation of ACES is modified to accommodate a brighter viewing environment.
The scale factor of 1/0.6 is subjective. See discussion in #19621.

**Kind**: inner constant of [<code>ACESFilmicToneMappingShader</code>](#module_ACESFilmicToneMappingShader)  
<a name="module_AfterimageShader"></a>

## AfterimageShader
<a name="module_AfterimageShader..AfterimageShader"></a>

### AfterimageShader~AfterimageShader : <code>ShaderMaterial~Shader</code>
Inspired by [Three.js FBO motion trails](https://codepen.io/brunoimbrizi/pen/MoRJaN?page=1&).

**Kind**: inner constant of [<code>AfterimageShader</code>](#module_AfterimageShader)  
<a name="module_BasicShader"></a>

## BasicShader
<a name="module_BasicShader..BasicShader"></a>

### BasicShader~BasicShader : <code>ShaderMaterial~Shader</code>
Simple shader for testing.

**Kind**: inner constant of [<code>BasicShader</code>](#module_BasicShader)  
<a name="module_BleachBypassShader"></a>

## BleachBypassShader
<a name="module_BleachBypassShader..BleachBypassShader"></a>

### BleachBypassShader~BleachBypassShader : <code>ShaderMaterial~Shader</code>
Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass] based on
[Nvidia Shader library](http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass).

**Kind**: inner constant of [<code>BleachBypassShader</code>](#module_BleachBypassShader)  
<a name="module_BlendShader"></a>

## BlendShader
<a name="module_BlendShader..BlendShader"></a>

### BlendShader~BlendShader : <code>ShaderMaterial~Shader</code>
Blends two textures.

**Kind**: inner constant of [<code>BlendShader</code>](#module_BlendShader)  
<a name="module_BokehShader"></a>

## BokehShader
<a name="module_BokehShader..BokehShader"></a>

### BokehShader~BokehShader : <code>ShaderMaterial~Shader</code>
Depth-of-field shader with bokeh ported from
[GLSL shader by Martins Upitis](http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html).

**Kind**: inner constant of [<code>BokehShader</code>](#module_BokehShader)  
<a name="module_BokehShader2"></a>

## BokehShader2
<a name="module_BokehShader2..BokehShader"></a>

### BokehShader2~BokehShader : <code>ShaderMaterial~Shader</code>
Depth-of-field shader with bokeh ported from
[GLSL shader by Martins Upitis](http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)).

Requires #define RINGS and SAMPLES integers

**Kind**: inner constant of [<code>BokehShader2</code>](#module_BokehShader2)  
<a name="module_BrightnessContrastShader"></a>

## BrightnessContrastShader
<a name="module_BrightnessContrastShader..BrightnessContrastShader"></a>

### BrightnessContrastShader~BrightnessContrastShader : <code>ShaderMaterial~Shader</code>
Brightness and contrast adjustment [https://github.com/evanw/glfx.js](https://github.com/evanw/glfx.js).
Brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)
Contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)

**Kind**: inner constant of [<code>BrightnessContrastShader</code>](#module_BrightnessContrastShader)  
<a name="module_ColorCorrectionShader"></a>

## ColorCorrectionShader
<a name="module_ColorCorrectionShader..ColorCorrectionShader"></a>

### ColorCorrectionShader~ColorCorrectionShader : <code>ShaderMaterial~Shader</code>
Color correction shader.

**Kind**: inner constant of [<code>ColorCorrectionShader</code>](#module_ColorCorrectionShader)  
<a name="module_ColorifyShader"></a>

## ColorifyShader
<a name="module_ColorifyShader..ColorifyShader"></a>

### ColorifyShader~ColorifyShader : <code>ShaderMaterial~Shader</code>
Colorify shader.

**Kind**: inner constant of [<code>ColorifyShader</code>](#module_ColorifyShader)  
<a name="module_ConvolutionShader"></a>

## ConvolutionShader
<a name="module_ConvolutionShader..ConvolutionShader"></a>

### ConvolutionShader~ConvolutionShader : <code>ShaderMaterial~Shader</code>
Convolution shader ported from o3d sample to WebGL / GLSL.

**Kind**: inner constant of [<code>ConvolutionShader</code>](#module_ConvolutionShader)  
<a name="module_CopyShader"></a>

## CopyShader
<a name="module_CopyShader..CopyShader"></a>

### CopyShader~CopyShader : <code>ShaderMaterial~Shader</code>
Full-screen copy shader pass.

**Kind**: inner constant of [<code>CopyShader</code>](#module_CopyShader)  
<a name="module_DOFMipMapShader"></a>

## DOFMipMapShader
<a name="module_DOFMipMapShader..DOFMipMapShader"></a>

### DOFMipMapShader~DOFMipMapShader : <code>ShaderMaterial~Shader</code>
Depth-of-field shader using mipmaps from Matt Handley @applmak.

Requires power-of-2 sized render target with enabled mipmaps.

**Kind**: inner constant of [<code>DOFMipMapShader</code>](#module_DOFMipMapShader)  
<a name="module_DepthLimitedBlurShader"></a>

## DepthLimitedBlurShader
<a name="module_DepthLimitedBlurShader..DepthLimitedBlurShader"></a>

### DepthLimitedBlurShader~DepthLimitedBlurShader : <code>ShaderMaterial~Shader</code>
TODO

Used by [SAOPass](SAOPass).

**Kind**: inner constant of [<code>DepthLimitedBlurShader</code>](#module_DepthLimitedBlurShader)  
<a name="module_DigitalGlitch"></a>

## DigitalGlitch
<a name="module_DigitalGlitch..DigitalGlitch"></a>

### DigitalGlitch~DigitalGlitch : <code>ShaderMaterial~Shader</code>
Digital glitch shader.

**Kind**: inner constant of [<code>DigitalGlitch</code>](#module_DigitalGlitch)  
<a name="module_DotScreenShader"></a>

## DotScreenShader
<a name="module_DotScreenShader..DotScreenShader"></a>

### DotScreenShader~DotScreenShader : <code>ShaderMaterial~Shader</code>
Dot screen shader based on [glfx.js sepia shader](https://github.com/evanw/glfx.js).

**Kind**: inner constant of [<code>DotScreenShader</code>](#module_DotScreenShader)  
<a name="module_ExposureShader"></a>

## ExposureShader
<a name="module_ExposureShader..ExposureShader"></a>

### ExposureShader~ExposureShader : <code>ShaderMaterial~Shader</code>
TODO

**Kind**: inner constant of [<code>ExposureShader</code>](#module_ExposureShader)  
<a name="module_FXAAShader"></a>

## FXAAShader
<a name="module_FXAAShader..FXAAShader"></a>

### FXAAShader~FXAAShader : <code>ShaderMaterial~Shader</code>
FXAA algorithm from NVIDIA, C# implementation by Jasper Flick, GLSL port by Dave Hoskins.

References:
- [http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf](http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf).
- [https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/](https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/).

**Kind**: inner constant of [<code>FXAAShader</code>](#module_FXAAShader)  
<a name="module_FilmShader"></a>

## FilmShader
<a name="module_FilmShader..FilmShader"></a>

### FilmShader~FilmShader : <code>ShaderMaterial~Shader</code>
TODO

Used by [FilmPass](FilmPass).

**Kind**: inner constant of [<code>FilmShader</code>](#module_FilmShader)  
<a name="module_FocusShader"></a>

## FocusShader
<a name="module_FocusShader..FocusShader"></a>

### FocusShader~FocusShader : <code>ShaderMaterial~Shader</code>
Focus shader based on [PaintEffect postprocess from ro.me](http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js).

**Kind**: inner constant of [<code>FocusShader</code>](#module_FocusShader)  
<a name="module_FreiChenShader"></a>

## FreiChenShader
<a name="module_FreiChenShader..FreiChenShader"></a>

### FreiChenShader~FreiChenShader : <code>ShaderMaterial~Shader</code>
Edge Detection Shader using Frei-Chen filter.
Based on [http://rastergrid.com/blog/2011/01/frei-chen-edge-detector](http://rastergrid.com/blog/2011/01/frei-chen-edge-detector).

aspect: vec2 of (1/width, 1/height)

**Kind**: inner constant of [<code>FreiChenShader</code>](#module_FreiChenShader)  
<a name="module_GTAOShader"></a>

## GTAOShader

* [GTAOShader](#module_GTAOShader)
    * [~GTAOShader](#module_GTAOShader..GTAOShader) : <code>ShaderMaterial~Shader</code>
    * [~GTAODepthShader](#module_GTAOShader..GTAODepthShader) : <code>Object</code>
    * [~GTAOBlendShader](#module_GTAOShader..GTAOBlendShader) : <code>Object</code>

<a name="module_GTAOShader..GTAOShader"></a>

### GTAOShader~GTAOShader : <code>ShaderMaterial~Shader</code>
GTAO shader. Use by [GTAOPass](GTAOPass).

References:
- [Practical Realtime Strategies for Accurate Indirect Occlusion](https://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf).
- [Horizon-Based Indirect Lighting (HBIL)](https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf)

**Kind**: inner constant of [<code>GTAOShader</code>](#module_GTAOShader)  
<a name="module_GTAOShader..GTAODepthShader"></a>

### GTAOShader~GTAODepthShader : <code>Object</code>
GTAO depth shader. Use by [GTAOPass](GTAOPass).

**Kind**: inner constant of [<code>GTAOShader</code>](#module_GTAOShader)  
<a name="module_GTAOShader..GTAOBlendShader"></a>

### GTAOShader~GTAOBlendShader : <code>Object</code>
GTAO blend shader. Use by [GTAOPass](GTAOPass).

**Kind**: inner constant of [<code>GTAOShader</code>](#module_GTAOShader)  
<a name="module_GammaCorrectionShader"></a>

## GammaCorrectionShader
<a name="module_GammaCorrectionShader..GammaCorrectionShader"></a>

### GammaCorrectionShader~GammaCorrectionShader : <code>ShaderMaterial~Shader</code>
Gamma Correction Shader

References:
- [http://en.wikipedia.org/wiki/gamma_correction](http://en.wikipedia.org/wiki/gamma_correction).

**Kind**: inner constant of [<code>GammaCorrectionShader</code>](#module_GammaCorrectionShader)  
<a name="module_GodRaysShader"></a>

## GodRaysShader

* [GodRaysShader](#module_GodRaysShader)
    * [~GodRaysDepthMaskShader](#module_GodRaysShader..GodRaysDepthMaskShader) : <code>ShaderMaterial~Shader</code>
    * [~GodRaysGenerateShader](#module_GodRaysShader..GodRaysGenerateShader) : <code>ShaderMaterial~Shader</code>
    * [~GodRaysCombineShader](#module_GodRaysShader..GodRaysCombineShader) : <code>ShaderMaterial~Shader</code>
    * [~GodRaysFakeSunShader](#module_GodRaysShader..GodRaysFakeSunShader) : <code>Object</code>

<a name="module_GodRaysShader..GodRaysDepthMaskShader"></a>

### GodRaysShader~GodRaysDepthMaskShader : <code>ShaderMaterial~Shader</code>
God-rays (crepuscular rays)

Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].
Blurs a mask generated from the depth map along radial lines emanating from the light
source. The blur repeatedly applies a blur filter of increasing support but constant
sample count to produce a blur filter with large support.

My implementation performs 3 passes, similar to the implementation from Sousa. I found
just 6 samples per pass produced acceptable results. The blur is applied three times,
with decreasing filter support. The result is equivalent to a single pass with
6*6*6 = 216 samples.

References:
- [Sousa2008, Crysis Next Gen Effects, GDC2008](http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt).

**Kind**: inner constant of [<code>GodRaysShader</code>](#module_GodRaysShader)  
<a name="module_GodRaysShader..GodRaysGenerateShader"></a>

### GodRaysShader~GodRaysGenerateShader : <code>ShaderMaterial~Shader</code>
The god-ray generation shader.

First pass:

The depth map is blurred along radial lines towards the "sun". The
output is written to a temporary render target (I used a 1/4 sized
target).

Pass two & three:

The results of the previous pass are re-blurred, each time with a
decreased distance between samples.

**Kind**: inner constant of [<code>GodRaysShader</code>](#module_GodRaysShader)  
<a name="module_GodRaysShader..GodRaysCombineShader"></a>

### GodRaysShader~GodRaysCombineShader : <code>ShaderMaterial~Shader</code>
Additively applies god rays from texture tGodRays to a background (tColors).
fGodRayIntensity attenuates the god rays.

**Kind**: inner constant of [<code>GodRaysShader</code>](#module_GodRaysShader)  
<a name="module_GodRaysShader..GodRaysFakeSunShader"></a>

### GodRaysShader~GodRaysFakeSunShader : <code>Object</code>
A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be
cheaper/faster/simpler to implement this as a simple sun sprite.

**Kind**: inner constant of [<code>GodRaysShader</code>](#module_GodRaysShader)  
<a name="module_HalftoneShader"></a>

## HalftoneShader
<a name="module_HalftoneShader..HalftoneShader"></a>

### HalftoneShader~HalftoneShader : <code>ShaderMaterial~Shader</code>
RGB Halftone shader.

Used by [HalftonePass](HalftonePass).

Shape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)
Blending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)

**Kind**: inner constant of [<code>HalftoneShader</code>](#module_HalftoneShader)  
<a name="module_HorizontalBlurShader"></a>

## HorizontalBlurShader
<a name="module_HorizontalBlurShader..HorizontalBlurShader"></a>

### HorizontalBlurShader~HorizontalBlurShader : <code>ShaderMaterial~Shader</code>
Two pass Gaussian blur filter (horizontal and vertical blur shaders).

References:
- [http://www.cake23.de/traveling-wavefronts-lit-up.html](http://www.cake23.de/traveling-wavefronts-lit-up.html).

- 9 samples per pass
- standard deviation 2.7
- "h" and "v" parameters should be set to "1 / width" and "1 / height"

**Kind**: inner constant of [<code>HorizontalBlurShader</code>](#module_HorizontalBlurShader)  
<a name="module_HorizontalTiltShiftShader"></a>

## HorizontalTiltShiftShader
<a name="module_HorizontalTiltShiftShader..HorizontalTiltShiftShader"></a>

### HorizontalTiltShiftShader~HorizontalTiltShiftShader : <code>ShaderMaterial~Shader</code>
Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position.

- 9 samples per pass
- standard deviation 2.7
- "h" and "v" parameters should be set to "1 / width" and "1 / height"
- "r" parameter control where "focused" horizontal line lies

**Kind**: inner constant of [<code>HorizontalTiltShiftShader</code>](#module_HorizontalTiltShiftShader)  
<a name="module_HueSaturationShader"></a>

## HueSaturationShader
<a name="module_HueSaturationShader..HueSaturationShader"></a>

### HueSaturationShader~HueSaturationShader : <code>ShaderMaterial~Shader</code>
Hue and saturation adjustment, [https://github.com/evanw/glfx.js](https://github.com/evanw/glfx.js).

hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.
saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)

**Kind**: inner constant of [<code>HueSaturationShader</code>](#module_HueSaturationShader)  
<a name="module_KaleidoShader"></a>

## KaleidoShader
<a name="module_KaleidoShader..KaleidoShader"></a>

### KaleidoShader~KaleidoShader : <code>ShaderMaterial~Shader</code>
Kaleidoscope Shader.
Radial reflection around center point
Ported from: [http://pixelshaders.com/editor/](http://pixelshaders.com/editor/)
by [Toby Schachman](http://tobyschachman.com/)

sides: number of reflections
angle: initial angle in radians

**Kind**: inner constant of [<code>KaleidoShader</code>](#module_KaleidoShader)  
<a name="module_LuminosityHighPassShader"></a>

## LuminosityHighPassShader
<a name="module_LuminosityHighPassShader..LuminosityHighPassShader"></a>

### LuminosityHighPassShader~LuminosityHighPassShader : <code>ShaderMaterial~Shader</code>
Luminosity high pass shader.

**Kind**: inner constant of [<code>LuminosityHighPassShader</code>](#module_LuminosityHighPassShader)  
<a name="module_LuminosityShader"></a>

## LuminosityShader
<a name="module_LuminosityShader..LuminosityShader"></a>

### LuminosityShader~LuminosityShader : <code>ShaderMaterial~Shader</code>
Luminosity shader.

**Kind**: inner constant of [<code>LuminosityShader</code>](#module_LuminosityShader)  
<a name="module_MirrorShader"></a>

## MirrorShader
<a name="module_MirrorShader..MirrorShader"></a>

### MirrorShader~MirrorShader : <code>ShaderMaterial~Shader</code>
Copies half the input to the other half.

side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom).

**Kind**: inner constant of [<code>MirrorShader</code>](#module_MirrorShader)  
<a name="module_NormalMapShader"></a>

## NormalMapShader
<a name="module_NormalMapShader..NormalMapShader"></a>

### NormalMapShader~NormalMapShader : <code>ShaderMaterial~Shader</code>
Normal map shader, compute normals from heightmap.

**Kind**: inner constant of [<code>NormalMapShader</code>](#module_NormalMapShader)  
<a name="module_OutputShader"></a>

## OutputShader
<a name="module_OutputShader..OutputShader"></a>

### OutputShader~OutputShader : <code>ShaderMaterial~Shader</code>
Performs tone mapping and color space conversion for
FX workflows.

Used by [OutputPass](OutputPass).

**Kind**: inner constant of [<code>OutputShader</code>](#module_OutputShader)  
<a name="module_PoissonDenoiseShader"></a>

## PoissonDenoiseShader
<a name="module_PoissonDenoiseShader..PoissonDenoiseShader"></a>

### PoissonDenoiseShader~PoissonDenoiseShader : <code>ShaderMaterial~Shader</code>
Poisson Denoise Shader.

References:
- [Self-Supervised Poisson-Gaussian Denoising](https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf).
- [Poisson2Sparse: Self-Supervised Poisson Denoising From a Single Image](https://arxiv.org/pdf/2206.01856.pdf)

**Kind**: inner constant of [<code>PoissonDenoiseShader</code>](#module_PoissonDenoiseShader)  
<a name="module_RGBShiftShader"></a>

## RGBShiftShader
<a name="module_RGBShiftShader..RGBShiftShader"></a>

### RGBShiftShader~RGBShiftShader : <code>ShaderMaterial~Shader</code>
RGB Shift Shader
Shifts red and blue channels from center in opposite directions
Ported from https://web.archive.org/web/20090820185047/http://kriss.cx/tom/2009/05/rgb-shift/
by Tom Butterworth / https://web.archive.org/web/20090810054752/http://kriss.cx/tom/

amount: shift distance (1 is width of input)
angle: shift angle in radians

**Kind**: inner constant of [<code>RGBShiftShader</code>](#module_RGBShiftShader)  
<a name="module_SAOShader"></a>

## SAOShader
<a name="module_SAOShader..SAOShader"></a>

### SAOShader~SAOShader : <code>ShaderMaterial~Shader</code>
SAO shader.

Used by [SAOPass](SAOPass).

**Kind**: inner constant of [<code>SAOShader</code>](#module_SAOShader)  
<a name="module_SMAAShader"></a>

## SMAAShader
WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8
Preset: SMAA 1x Medium (with color edge detection)

References:
- [https://github.com/iryoku/smaa/releases/tag/v2.8](https://github.com/iryoku/smaa/releases/tag/v2.8)


* [SMAAShader](#module_SMAAShader)
    * [~SMAAEdgesShader](#module_SMAAShader..SMAAEdgesShader) : <code>ShaderMaterial~Shader</code>
    * [~SMAAWeightsShader](#module_SMAAShader..SMAAWeightsShader) : <code>ShaderMaterial~Shader</code>
    * [~SMAABlendShader](#module_SMAAShader..SMAABlendShader) : <code>ShaderMaterial~Shader</code>

<a name="module_SMAAShader..SMAAEdgesShader"></a>

### SMAAShader~SMAAEdgesShader : <code>ShaderMaterial~Shader</code>
SMAA Edges shader.

**Kind**: inner constant of [<code>SMAAShader</code>](#module_SMAAShader)  
<a name="module_SMAAShader..SMAAWeightsShader"></a>

### SMAAShader~SMAAWeightsShader : <code>ShaderMaterial~Shader</code>
SMAA Weights shader.

**Kind**: inner constant of [<code>SMAAShader</code>](#module_SMAAShader)  
<a name="module_SMAAShader..SMAABlendShader"></a>

### SMAAShader~SMAABlendShader : <code>ShaderMaterial~Shader</code>
SMAA Blend shader.

**Kind**: inner constant of [<code>SMAAShader</code>](#module_SMAAShader)  
<a name="module_SSAOShader"></a>

## SSAOShader

* [SSAOShader](#module_SSAOShader)
    * [~SSAOShader](#module_SSAOShader..SSAOShader) : <code>ShaderMaterial~Shader</code>
    * [~SSAODepthShader](#module_SSAOShader..SSAODepthShader) : <code>ShaderMaterial~Shader</code>
    * [~SSAOBlurShader](#module_SSAOShader..SSAOBlurShader) : <code>Object</code>

<a name="module_SSAOShader..SSAOShader"></a>

### SSAOShader~SSAOShader : <code>ShaderMaterial~Shader</code>
SSAO shader.

References:
- [http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html](http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html)
- [https://learnopengl.com/Advanced-Lighting/SSAO](https://learnopengl.com/Advanced-Lighting/SSAO)
- [https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl](https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl)

**Kind**: inner constant of [<code>SSAOShader</code>](#module_SSAOShader)  
<a name="module_SSAOShader..SSAODepthShader"></a>

### SSAOShader~SSAODepthShader : <code>ShaderMaterial~Shader</code>
SSAO depth shader.

**Kind**: inner constant of [<code>SSAOShader</code>](#module_SSAOShader)  
<a name="module_SSAOShader..SSAOBlurShader"></a>

### SSAOShader~SSAOBlurShader : <code>Object</code>
SSAO blur shader.

**Kind**: inner constant of [<code>SSAOShader</code>](#module_SSAOShader)  
<a name="module_SSRShader"></a>

## SSRShader
A collection of shaders used for SSR.

References:
- [3D Game Shaders For Beginners, Screen Space Reflection (SSR)](https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html).


* [SSRShader](#module_SSRShader)
    * [~SSRShader](#module_SSRShader..SSRShader) : <code>ShaderMaterial~Shader</code>
    * [~SSRDepthShader](#module_SSRShader..SSRDepthShader) : <code>ShaderMaterial~Shader</code>
    * [~SSRBlurShader](#module_SSRShader..SSRBlurShader) : <code>ShaderMaterial~Shader</code>

<a name="module_SSRShader..SSRShader"></a>

### SSRShader~SSRShader : <code>ShaderMaterial~Shader</code>
SSR shader.

**Kind**: inner constant of [<code>SSRShader</code>](#module_SSRShader)  
<a name="module_SSRShader..SSRDepthShader"></a>

### SSRShader~SSRDepthShader : <code>ShaderMaterial~Shader</code>
SSR Depth shader.

**Kind**: inner constant of [<code>SSRShader</code>](#module_SSRShader)  
<a name="module_SSRShader..SSRBlurShader"></a>

### SSRShader~SSRBlurShader : <code>ShaderMaterial~Shader</code>
SSR Blur shader.

**Kind**: inner constant of [<code>SSRShader</code>](#module_SSRShader)  
<a name="module_SepiaShader"></a>

## SepiaShader
<a name="module_SepiaShader..SepiaShader"></a>

### SepiaShader~SepiaShader : <code>ShaderMaterial~Shader</code>
Sepia tone shader based on [glfx.js sepia shader](https://github.com/evanw/glfx.js).

**Kind**: inner constant of [<code>SepiaShader</code>](#module_SepiaShader)  
<a name="module_SobelOperatorShader"></a>

## SobelOperatorShader
<a name="module_SobelOperatorShader..SobelOperatorShader"></a>

### SobelOperatorShader~SobelOperatorShader : <code>ShaderMaterial~Shader</code>
Sobel Edge Detection (see [https://youtu.be/uihBwtPIBxM](https://youtu.be/uihBwtPIBxM)).

As mentioned in the video the Sobel operator expects a grayscale image as input.

**Kind**: inner constant of [<code>SobelOperatorShader</code>](#module_SobelOperatorShader)  
<a name="module_SubsurfaceScatteringShader"></a>

## SubsurfaceScatteringShader
<a name="module_SubsurfaceScatteringShader..SubsurfaceScatteringShader"></a>

### SubsurfaceScatteringShader~SubsurfaceScatteringShader : <code>ShaderMaterial~Shader</code>
Subsurface Scattering shader.

Based on GDC 2011 – [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look](https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/)

**Kind**: inner constant of [<code>SubsurfaceScatteringShader</code>](#module_SubsurfaceScatteringShader)  
<a name="module_TriangleBlurShader"></a>

## TriangleBlurShader
<a name="module_TriangleBlurShader..TechnicolorShader"></a>

### TriangleBlurShader~TechnicolorShader : <code>ShaderMaterial~Shader</code>
Simulates the look of the two-strip technicolor process popular in early 20th century films.
More historical info here: [http://www.widescreenmuseum.com/oldcolor/technicolor1.htm](http://www.widescreenmuseum.com/oldcolor/technicolor1.htm)
Demo here: [http://charliehoey.com/technicolor_shader/shader_test.html](http://charliehoey.com/technicolor_shader/shader_test.html)

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader"></a>

## TriangleBlurShader
Collection of toon shaders.


* [TriangleBlurShader](#module_TriangleBlurShader)
    * [~ToonShader1](#module_TriangleBlurShader..ToonShader1) : <code>ShaderMaterial~Shader</code>
    * [~ToonShader2](#module_TriangleBlurShader..ToonShader2) : <code>Object</code>
    * [~ToonShaderHatching](#module_TriangleBlurShader..ToonShaderHatching) : <code>Object</code>
    * [~ToonShaderDotted](#module_TriangleBlurShader..ToonShaderDotted) : <code>Object</code>

<a name="module_TriangleBlurShader..ToonShader1"></a>

### TriangleBlurShader~ToonShader1 : <code>ShaderMaterial~Shader</code>
Toon1 shader.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader..ToonShader2"></a>

### TriangleBlurShader~ToonShader2 : <code>Object</code>
Toon2 shader.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader..ToonShaderHatching"></a>

### TriangleBlurShader~ToonShaderHatching : <code>Object</code>
Toon Hatching shader.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader..ToonShaderDotted"></a>

### TriangleBlurShader~ToonShaderDotted : <code>Object</code>
Toon Dotted shader.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_TriangleBlurShader"></a>

## TriangleBlurShader
<a name="module_TriangleBlurShader..TriangleBlurShader"></a>

### TriangleBlurShader~TriangleBlurShader : <code>ShaderMaterial~Shader</code>
Triangle blur shader based on [glfx.js triangle blur shader](https://github.com/evanw/glfx.js).

A basic blur filter, which convolves the image with a
pyramid filter. The pyramid filter is separable and is applied as two
perpendicular triangle filters.

**Kind**: inner constant of [<code>TriangleBlurShader</code>](#module_TriangleBlurShader)  
<a name="module_UnpackDepthRGBAShader"></a>

## UnpackDepthRGBAShader
<a name="module_UnpackDepthRGBAShader..UnpackDepthRGBAShader"></a>

### UnpackDepthRGBAShader~UnpackDepthRGBAShader : <code>ShaderMaterial~Shader</code>
Unpack RGBA depth shader that shows RGBA encoded depth as monochrome color.

**Kind**: inner constant of [<code>UnpackDepthRGBAShader</code>](#module_UnpackDepthRGBAShader)  
<a name="module_VelocityShader"></a>

## VelocityShader
<a name="module_VelocityShader..VelocityShader"></a>

### VelocityShader~VelocityShader : <code>ShaderMaterial~Shader</code>
Mesh velocity shader by @bhouston.

**Kind**: inner constant of [<code>VelocityShader</code>](#module_VelocityShader)  
<a name="module_VerticalBlurShader"></a>

## VerticalBlurShader
<a name="module_VerticalBlurShader..VerticalBlurShader"></a>

### VerticalBlurShader~VerticalBlurShader : <code>ShaderMaterial~Shader</code>
Two pass Gaussian blur filter (horizontal and vertical blur shaders)
- see [http://www.cake23.de/traveling-wavefronts-lit-up.html](http://www.cake23.de/traveling-wavefronts-lit-up.html)

- 9 samples per pass
- standard deviation 2.7
- "h" and "v" parameters should be set to "1 / width" and "1 / height"

**Kind**: inner constant of [<code>VerticalBlurShader</code>](#module_VerticalBlurShader)  
<a name="module_VerticalTiltShiftShader"></a>

## VerticalTiltShiftShader
<a name="module_VerticalTiltShiftShader..VerticalTiltShiftShader"></a>

### VerticalTiltShiftShader~VerticalTiltShiftShader : <code>ShaderMaterial~Shader</code>
Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position

- 9 samples per pass
- standard deviation 2.7
- "h" and "v" parameters should be set to "1 / width" and "1 / height"
- "r" parameter control where "focused" horizontal line lies

**Kind**: inner constant of [<code>VerticalTiltShiftShader</code>](#module_VerticalTiltShiftShader)  
<a name="module_VignetteShader"></a>

## VignetteShader
<a name="module_VignetteShader..VignetteShader"></a>

### VignetteShader~VignetteShader : <code>ShaderMaterial~Shader</code>
Based on [PaintEffect postprocess from ro.me](http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js).

**Kind**: inner constant of [<code>VignetteShader</code>](#module_VignetteShader)  
<a name="module_VolumeShader"></a>

## VolumeShader
<a name="module_VolumeShader..VolumeRenderShader1"></a>

### VolumeShader~VolumeRenderShader1 : <code>ShaderMaterial~Shader</code>
Shaders to render 3D volumes using raycasting.
The applied techniques are based on similar implementations in the Visvis and Vispy projects.
This is not the only approach, therefore it's marked 1.

**Kind**: inner constant of [<code>VolumeShader</code>](#module_VolumeShader)  
<a name="module_WaterRefractionShader"></a>

## WaterRefractionShader
<a name="module_WaterRefractionShader..WaterRefractionShader"></a>

### WaterRefractionShader~WaterRefractionShader : <code>ShaderMaterial~Shader</code>
Basic water refraction shader.

**Kind**: inner constant of [<code>WaterRefractionShader</code>](#module_WaterRefractionShader)  
<a name="FlakesTexture"></a>

## FlakesTexture
Utility class for generating a flakes texture image. This image might be used
as a normal map to produce a car paint like effect.

**Kind**: global class  
<a name="new_FlakesTexture_new"></a>

### new FlakesTexture([width], [height])
Generates a new flakes texture image. The result is a canvas
that can be used as an input for [CanvasTexture](CanvasTexture).

**Returns**: <code>HTMLCanvasElement</code> - The generated image.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [width] | <code>number</code> | <code>512</code> | The width of the image. |
| [height] | <code>number</code> | <code>512</code> | The height of the image. |

<a name="Transpiler"></a>

## Transpiler
A class that transpiles shader code from one language into another.

`Transpiler` can only be used to convert GLSL into TSL right now. It is intended
to support developers when they want to migrate their custom materials from the
current to the new node-based material system.

**Kind**: global class  

* [Transpiler](#Transpiler)
    * [new Transpiler(decoder, encoder)](#new_Transpiler_new)
    * [.decoder](#Transpiler+decoder) : <code>GLSLDecoder</code>
    * [.encoder](#Transpiler+encoder) : <code>TSLEncoder</code>
    * [.parse(source)](#Transpiler+parse) ⇒ <code>string</code>

<a name="new_Transpiler_new"></a>

### new Transpiler(decoder, encoder)
Constructs a new transpiler.


| Param | Type | Description |
| --- | --- | --- |
| decoder | <code>GLSLDecoder</code> | The GLSL decoder. |
| encoder | <code>TSLEncoder</code> | The TSL encoder. |

<a name="Transpiler+decoder"></a>

### transpiler.decoder : <code>GLSLDecoder</code>
The GLSL decoder. This component parse GLSL and produces
a language-independent AST for further processing.

**Kind**: instance property of [<code>Transpiler</code>](#Transpiler)  
<a name="Transpiler+encoder"></a>

### transpiler.encoder : <code>TSLEncoder</code>
The TSL encoder. It takes the AST and emits TSL code.

**Kind**: instance property of [<code>Transpiler</code>](#Transpiler)  
<a name="Transpiler+parse"></a>

### transpiler.parse(source) ⇒ <code>string</code>
Parses the given GLSL source and returns TSL syntax.

**Kind**: instance method of [<code>Transpiler</code>](#Transpiler)  
**Returns**: <code>string</code> - The TSL code.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>string</code> | The GLSL source. |

## Classes

<dl>
<dt><a href="#AfterImageNode">AfterImageNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating an after image effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#afterImage">afterImage(node, [damp])</a> ⇒ <code><a href="#AfterImageNode">AfterImageNode</a></code></dt>
<dd><p>TSL function for creating an after image node for post processing.</p>
</dd>
</dl>

<a name="AfterImageNode"></a>

## AfterImageNode ⇐ <code>TempNode</code>
Post processing node for creating an after image effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [AfterImageNode](#AfterImageNode) ⇐ <code>TempNode</code>
    * [new AfterImageNode(textureNode, [damp])](#new_AfterImageNode_new)
    * [.textureNode](#AfterImageNode+textureNode) : <code>TextureNode</code>
    * [.textureNodeOld](#AfterImageNode+textureNodeOld) : <code>TextureNode</code>
    * [.damp](#AfterImageNode+damp) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateBeforeType](#AfterImageNode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#AfterImageNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#AfterImageNode+setSize)
    * [.updateBefore(frame)](#AfterImageNode+updateBefore)
    * [.setup(builder)](#AfterImageNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#AfterImageNode+dispose)

<a name="new_AfterImageNode_new"></a>

### new AfterImageNode(textureNode, [damp])
Constructs a new after image node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that represents the input of the effect. |
| [damp] | <code>number</code> | <code>0.96</code> | The damping intensity. A higher value means a stronger after image effect. |

<a name="AfterImageNode+textureNode"></a>

### afterImageNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>AfterImageNode</code>](#AfterImageNode)  
<a name="AfterImageNode+textureNodeOld"></a>

### afterImageNode.textureNodeOld : <code>TextureNode</code>
The texture represents the pervious frame.

**Kind**: instance property of [<code>AfterImageNode</code>](#AfterImageNode)  
<a name="AfterImageNode+damp"></a>

### afterImageNode.damp : <code>UniformNode.&lt;float&gt;</code>
How quickly the after-image fades. A higher value means the after-image
persists longer, while a lower value means it fades faster. Should be in
the range `[0, 1]`.

**Kind**: instance property of [<code>AfterImageNode</code>](#AfterImageNode)  
<a name="AfterImageNode+updateBeforeType"></a>

### afterImageNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>AfterImageNode</code>](#AfterImageNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="AfterImageNode+getTextureNode"></a>

### afterImageNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="AfterImageNode+setSize"></a>

### afterImageNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="AfterImageNode+updateBefore"></a>

### afterImageNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="AfterImageNode+setup"></a>

### afterImageNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AfterImageNode+dispose"></a>

### afterImageNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>AfterImageNode</code>](#AfterImageNode)  
<a name="afterImage"></a>

## afterImage(node, [damp]) ⇒ [<code>AfterImageNode</code>](#AfterImageNode)
TSL function for creating an after image node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [damp] | <code>number</code> | <code>0.96</code> | The damping intensity. A higher value means a stronger after image effect. |

## Classes

<dl>
<dt><a href="#AnaglyphPassNode">AnaglyphPassNode</a> ⇐ <code>StereoCompositePassNode</code></dt>
<dd><p>A render pass node that creates an anaglyph effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#anaglyphPass">anaglyphPass(scene, camera)</a> ⇒ <code><a href="#AnaglyphPassNode">AnaglyphPassNode</a></code></dt>
<dd><p>TSL function for creating an anaglyph pass node.</p>
</dd>
</dl>

<a name="AnaglyphPassNode"></a>

## AnaglyphPassNode ⇐ <code>StereoCompositePassNode</code>
A render pass node that creates an anaglyph effect.

**Kind**: global class  
**Extends**: <code>StereoCompositePassNode</code>  

* [AnaglyphPassNode](#AnaglyphPassNode) ⇐ <code>StereoCompositePassNode</code>
    * [new AnaglyphPassNode(scene, camera)](#new_AnaglyphPassNode_new)
    * [.isAnaglyphPassNode](#AnaglyphPassNode+isAnaglyphPassNode) : <code>boolean</code>
    * [._colorMatrixLeft](#AnaglyphPassNode+_colorMatrixLeft) : <code>UniformNode.&lt;mat3&gt;</code>
    * [._colorMatrixRight](#AnaglyphPassNode+_colorMatrixRight) : <code>UniformNode.&lt;mat3&gt;</code>
    * [.setup(builder)](#AnaglyphPassNode+setup) ⇒ <code>PassTextureNode</code>

<a name="new_AnaglyphPassNode_new"></a>

### new AnaglyphPassNode(scene, camera)
Constructs a new anaglyph pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="AnaglyphPassNode+isAnaglyphPassNode"></a>

### anaglyphPassNode.isAnaglyphPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="AnaglyphPassNode+_colorMatrixLeft"></a>

### anaglyphPassNode.\_colorMatrixLeft : <code>UniformNode.&lt;mat3&gt;</code>
Color matrix node for the left eye.

**Kind**: instance property of [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)  
<a name="AnaglyphPassNode+_colorMatrixRight"></a>

### anaglyphPassNode.\_colorMatrixRight : <code>UniformNode.&lt;mat3&gt;</code>
Color matrix node for the right eye.

**Kind**: instance property of [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)  
<a name="AnaglyphPassNode+setup"></a>

### anaglyphPassNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="anaglyphPass"></a>

## anaglyphPass(scene, camera) ⇒ [<code>AnaglyphPassNode</code>](#AnaglyphPassNode)
TSL function for creating an anaglyph pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#AnamorphicNode">AnamorphicNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for adding an anamorphic flare effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#anamorphic">anamorphic(node, [threshold], [scale], [samples])</a> ⇒ <code><a href="#AnamorphicNode">AnamorphicNode</a></code></dt>
<dd><p>TSL function for creating an anamorphic flare effect.</p>
</dd>
</dl>

<a name="AnamorphicNode"></a>

## AnamorphicNode ⇐ <code>TempNode</code>
Post processing node for adding an anamorphic flare effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [AnamorphicNode](#AnamorphicNode) ⇐ <code>TempNode</code>
    * [new AnamorphicNode(textureNode, tresholdNode, scaleNode, samples)](#new_AnamorphicNode_new)
    * [.textureNode](#AnamorphicNode+textureNode) : <code>TextureNode</code>
    * [.tresholdNode](#AnamorphicNode+tresholdNode) : <code>Node.&lt;float&gt;</code>
    * [.scaleNode](#AnamorphicNode+scaleNode) : <code>Node.&lt;float&gt;</code>
    * [.colorNode](#AnamorphicNode+colorNode) : <code>Node.&lt;vec3&gt;</code>
    * [.samples](#AnamorphicNode+samples) : <code>Node.&lt;float&gt;</code>
    * [.resolution](#AnamorphicNode+resolution) : <code>Vector2</code>
    * [.updateBeforeType](#AnamorphicNode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#AnamorphicNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#AnamorphicNode+setSize)
    * [.updateBefore(frame)](#AnamorphicNode+updateBefore)
    * [.setup(builder)](#AnamorphicNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#AnamorphicNode+dispose)

<a name="new_AnamorphicNode_new"></a>

### new AnamorphicNode(textureNode, tresholdNode, scaleNode, samples)
Constructs a new anamorphic node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |
| tresholdNode | <code>Node.&lt;float&gt;</code> | The threshold is one option to control the intensity and size of the effect. |
| scaleNode | <code>Node.&lt;float&gt;</code> | Defines the vertical scale of the flares. |
| samples | <code>number</code> | More samples result in larger flares and a more expensive runtime behavior. |

<a name="AnamorphicNode+textureNode"></a>

### anamorphicNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+tresholdNode"></a>

### anamorphicNode.tresholdNode : <code>Node.&lt;float&gt;</code>
The threshold is one option to control the intensity and size of the effect.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+scaleNode"></a>

### anamorphicNode.scaleNode : <code>Node.&lt;float&gt;</code>
Defines the vertical scale of the flares.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+colorNode"></a>

### anamorphicNode.colorNode : <code>Node.&lt;vec3&gt;</code>
The color of the flares.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+samples"></a>

### anamorphicNode.samples : <code>Node.&lt;float&gt;</code>
More samples result in larger flares and a more expensive runtime behavior.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+resolution"></a>

### anamorphicNode.resolution : <code>Vector2</code>
The resolution scale.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="AnamorphicNode+updateBeforeType"></a>

### anamorphicNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>AnamorphicNode</code>](#AnamorphicNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="AnamorphicNode+getTextureNode"></a>

### anamorphicNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="AnamorphicNode+setSize"></a>

### anamorphicNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="AnamorphicNode+updateBefore"></a>

### anamorphicNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="AnamorphicNode+setup"></a>

### anamorphicNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="AnamorphicNode+dispose"></a>

### anamorphicNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>AnamorphicNode</code>](#AnamorphicNode)  
<a name="anamorphic"></a>

## anamorphic(node, [threshold], [scale], [samples]) ⇒ [<code>AnamorphicNode</code>](#AnamorphicNode)
TSL function for creating an anamorphic flare effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>TextureNode</code> |  | The node that represents the input of the effect. |
| [threshold] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.9</code> | The threshold is one option to control the intensity and size of the effect. |
| [scale] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>3</code> | Defines the vertical scale of the flares. |
| [samples] | <code>number</code> | <code>32</code> | More samples result in larger flares and a more expensive runtime behavior. |

<a name="bleach"></a>

## bleach(color, [opacity]) ⇒ <code>Node.&lt;vec4&gt;</code>
Applies a bleach bypass effect to the given color node.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The updated color node.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| color | <code>Node.&lt;vec4&gt;</code> |  | The color node to apply the sepia for. |
| [opacity] | <code>Node.&lt;float&gt;</code> | <code>1</code> | Influences how strong the effect is blended with the original color. |

## Classes

<dl>
<dt><a href="#BloomNode">BloomNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating a bloom effect.</p>
<pre><code class="language-js">const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
const scenePassColor = scenePass.getTextureNode( &#39;output&#39; );

const bloomPass = bloom( scenePassColor );

postProcessing.outputNode = scenePassColor.add( bloomPass );
</code></pre>
<p>By default, the node affects the entire image. For a selective bloom,
use the <code>emissive</code> material property to control which objects should
contribute to bloom or not. This can be achieved via MRT.</p>
<pre><code class="language-js">const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
scenePass.setMRT( mrt( {
    output,
    emissive
} ) );

const scenePassColor = scenePass.getTextureNode( &#39;output&#39; );
const emissivePass = scenePass.getTextureNode( &#39;emissive&#39; );

const bloomPass = bloom( emissivePass );
postProcessing.outputNode = scenePassColor.add( bloomPass );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#bloom">bloom(node, [strength], [radius], [threshold])</a> ⇒ <code><a href="#BloomNode">BloomNode</a></code></dt>
<dd><p>TSL function for creating a bloom effect.</p>
</dd>
</dl>

<a name="BloomNode"></a>

## BloomNode ⇐ <code>TempNode</code>
Post processing node for creating a bloom effect.
```js
const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
const scenePassColor = scenePass.getTextureNode( 'output' );

const bloomPass = bloom( scenePassColor );

postProcessing.outputNode = scenePassColor.add( bloomPass );
```
By default, the node affects the entire image. For a selective bloom,
use the `emissive` material property to control which objects should
contribute to bloom or not. This can be achieved via MRT.
```js
const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
scenePass.setMRT( mrt( {
	output,
	emissive
} ) );

const scenePassColor = scenePass.getTextureNode( 'output' );
const emissivePass = scenePass.getTextureNode( 'emissive' );

const bloomPass = bloom( emissivePass );
postProcessing.outputNode = scenePassColor.add( bloomPass );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [BloomNode](#BloomNode) ⇐ <code>TempNode</code>
    * [new BloomNode(inputNode, [strength], [radius], [threshold])](#new_BloomNode_new)
    * [.inputNode](#BloomNode+inputNode) : <code>Node.&lt;vec4&gt;</code>
    * [.strength](#BloomNode+strength) : <code>UniformNode.&lt;float&gt;</code>
    * [.radius](#BloomNode+radius) : <code>UniformNode.&lt;float&gt;</code>
    * [.threshold](#BloomNode+threshold) : <code>UniformNode.&lt;float&gt;</code>
    * [.smoothWidth](#BloomNode+smoothWidth) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateBeforeType](#BloomNode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#BloomNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#BloomNode+setSize)
    * [.updateBefore(frame)](#BloomNode+updateBefore)
    * [.setup(builder)](#BloomNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#BloomNode+dispose)
    * [._getSeparableBlurMaterial(builder, kernelRadius)](#BloomNode+_getSeparableBlurMaterial) ⇒ <code>NodeMaterial</code>

<a name="new_BloomNode_new"></a>

### new BloomNode(inputNode, [strength], [radius], [threshold])
Constructs a new bloom node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [strength] | <code>number</code> | <code>1</code> | The strength of the bloom. |
| [radius] | <code>number</code> | <code>0</code> | The radius of the bloom. |
| [threshold] | <code>number</code> | <code>0</code> | The luminance threshold limits which bright areas contribute to the bloom effect. |

<a name="BloomNode+inputNode"></a>

### bloomNode.inputNode : <code>Node.&lt;vec4&gt;</code>
The node that represents the input of the effect.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+strength"></a>

### bloomNode.strength : <code>UniformNode.&lt;float&gt;</code>
The strength of the bloom.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+radius"></a>

### bloomNode.radius : <code>UniformNode.&lt;float&gt;</code>
The radius of the bloom.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+threshold"></a>

### bloomNode.threshold : <code>UniformNode.&lt;float&gt;</code>
The luminance threshold limits which bright areas contribute to the bloom effect.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+smoothWidth"></a>

### bloomNode.smoothWidth : <code>UniformNode.&lt;float&gt;</code>
Can be used to tweak the extracted luminance from the scene.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+updateBeforeType"></a>

### bloomNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>BloomNode</code>](#BloomNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="BloomNode+getTextureNode"></a>

### bloomNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="BloomNode+setSize"></a>

### bloomNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="BloomNode+updateBefore"></a>

### bloomNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="BloomNode+setup"></a>

### bloomNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="BloomNode+dispose"></a>

### bloomNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  
<a name="BloomNode+_getSeparableBlurMaterial"></a>

### bloomNode.\_getSeparableBlurMaterial(builder, kernelRadius) ⇒ <code>NodeMaterial</code>
Create a separable blur material for the given kernel radius.

**Kind**: instance method of [<code>BloomNode</code>](#BloomNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |
| kernelRadius | <code>number</code> | The kernel radius. |

<a name="bloom"></a>

## bloom(node, [strength], [radius], [threshold]) ⇒ [<code>BloomNode</code>](#BloomNode)
TSL function for creating a bloom effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [strength] | <code>number</code> | <code>1</code> | The strength of the bloom. |
| [radius] | <code>number</code> | <code>0</code> | The radius of the bloom. |
| [threshold] | <code>number</code> | <code>0</code> | The luminance threshold limits which bright areas contribute to the bloom effect. |

## Classes

<dl>
<dt><a href="#DenoiseNode">DenoiseNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for denoising data like raw screen-space ambient occlusion output.
Denoise can noticeably improve the quality of ambient occlusion but also add quite some
overhead to the post processing setup. It&#39;s best to make its usage optional (e.g. via
graphic settings).</p>
<p>Reference: <a href="https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf">https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#generateDenoiseSamples">generateDenoiseSamples(numSamples, numRings, radiusExponent)</a> ⇒ <code>Array.&lt;Vector3&gt;</code></dt>
<dd><p>Generates denoise samples based on the given parameters.</p>
</dd>
<dt><a href="#generateDefaultNoise">generateDefaultNoise([size])</a> ⇒ <code>DataTexture</code></dt>
<dd><p>Generates a default noise texture for the given size.</p>
</dd>
<dt><a href="#denoise">denoise(node, depthNode, normalNode, camera)</a> ⇒ <code><a href="#DenoiseNode">DenoiseNode</a></code></dt>
<dd><p>TSL function for creating a denoise effect.</p>
</dd>
</dl>

<a name="DenoiseNode"></a>

## DenoiseNode ⇐ <code>TempNode</code>
Post processing node for denoising data like raw screen-space ambient occlusion output.
Denoise can noticeably improve the quality of ambient occlusion but also add quite some
overhead to the post processing setup. It's best to make its usage optional (e.g. via
graphic settings).

Reference: [https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf](https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [DenoiseNode](#DenoiseNode) ⇐ <code>TempNode</code>
    * [new DenoiseNode(textureNode, depthNode, normalNode, camera)](#new_DenoiseNode_new)
    * [.textureNode](#DenoiseNode+textureNode) : <code>TextureNode</code>
    * [.depthNode](#DenoiseNode+depthNode) : <code>Node.&lt;float&gt;</code>
    * [.normalNode](#DenoiseNode+normalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.noiseNode](#DenoiseNode+noiseNode) : <code>TextureNode</code>
    * [.lumaPhi](#DenoiseNode+lumaPhi) : <code>UniformNode.&lt;float&gt;</code>
    * [.depthPhi](#DenoiseNode+depthPhi) : <code>UniformNode.&lt;float&gt;</code>
    * [.normalPhi](#DenoiseNode+normalPhi) : <code>UniformNode.&lt;float&gt;</code>
    * [.radius](#DenoiseNode+radius) : <code>UniformNode.&lt;float&gt;</code>
    * [.index](#DenoiseNode+index) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateBeforeType](#DenoiseNode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#DenoiseNode+updateBefore)
    * [.setup(builder)](#DenoiseNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_DenoiseNode_new"></a>

### new DenoiseNode(textureNode, depthNode, normalNode, camera)
Constructs a new denoise node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect (e.g. AO). |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the scene's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the scene's normals. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="DenoiseNode+textureNode"></a>

### denoiseNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect (e.g. AO).

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+depthNode"></a>

### denoiseNode.depthNode : <code>Node.&lt;float&gt;</code>
A node that represents the scene's depth.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+normalNode"></a>

### denoiseNode.normalNode : <code>Node.&lt;vec3&gt;</code>
A node that represents the scene's normals. If no normals are passed to the
constructor (because MRT is not available), normals can be automatically
reconstructed from depth values in the shader.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+noiseNode"></a>

### denoiseNode.noiseNode : <code>TextureNode</code>
The node represents the internal noise texture.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+lumaPhi"></a>

### denoiseNode.lumaPhi : <code>UniformNode.&lt;float&gt;</code>
The luma Phi value.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+depthPhi"></a>

### denoiseNode.depthPhi : <code>UniformNode.&lt;float&gt;</code>
The depth Phi value.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+normalPhi"></a>

### denoiseNode.normalPhi : <code>UniformNode.&lt;float&gt;</code>
The normal Phi value.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+radius"></a>

### denoiseNode.radius : <code>UniformNode.&lt;float&gt;</code>
The radius.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+index"></a>

### denoiseNode.index : <code>UniformNode.&lt;float&gt;</code>
The index.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
<a name="DenoiseNode+updateBeforeType"></a>

### denoiseNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>DenoiseNode</code>](#DenoiseNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="DenoiseNode+updateBefore"></a>

### denoiseNode.updateBefore(frame)
This method is used to update internal uniforms once per frame.

**Kind**: instance method of [<code>DenoiseNode</code>](#DenoiseNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="DenoiseNode+setup"></a>

### denoiseNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>DenoiseNode</code>](#DenoiseNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="generateDenoiseSamples"></a>

## generateDenoiseSamples(numSamples, numRings, radiusExponent) ⇒ <code>Array.&lt;Vector3&gt;</code>
Generates denoise samples based on the given parameters.

**Kind**: global function  
**Returns**: <code>Array.&lt;Vector3&gt;</code> - The denoise samples.  

| Param | Type | Description |
| --- | --- | --- |
| numSamples | <code>number</code> | The number of samples. |
| numRings | <code>number</code> | The number of rings. |
| radiusExponent | <code>number</code> | The radius exponent. |

<a name="generateDefaultNoise"></a>

## generateDefaultNoise([size]) ⇒ <code>DataTexture</code>
Generates a default noise texture for the given size.

**Kind**: global function  
**Returns**: <code>DataTexture</code> - The generated noise texture.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>64</code> | The texture size. |

<a name="denoise"></a>

## denoise(node, depthNode, normalNode, camera) ⇒ [<code>DenoiseNode</code>](#DenoiseNode)
TSL function for creating a denoise effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that represents the input of the effect (e.g. AO). |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the scene's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the scene's normals. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

## Classes

<dl>
<dt><a href="#DepthOfFieldNode">DepthOfFieldNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating depth of field (DOF) effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#dof">dof(node, viewZNode, focus, aperture, maxblur)</a> ⇒ <code><a href="#DepthOfFieldNode">DepthOfFieldNode</a></code></dt>
<dd><p>TSL function for creating a depth-of-field effect (DOF) for post processing.</p>
</dd>
</dl>

<a name="DepthOfFieldNode"></a>

## DepthOfFieldNode ⇐ <code>TempNode</code>
Post processing node for creating depth of field (DOF) effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [DepthOfFieldNode](#DepthOfFieldNode) ⇐ <code>TempNode</code>
    * [new DepthOfFieldNode(textureNode, viewZNode, focusNode, apertureNode, maxblurNode)](#new_DepthOfFieldNode_new)
    * [.textureNode](#DepthOfFieldNode+textureNode) : <code>TextureNode</code>
    * [.viewZNode](#DepthOfFieldNode+viewZNode) : <code>Node.&lt;float&gt;</code>
    * [.focusNode](#DepthOfFieldNode+focusNode) : <code>Node.&lt;float&gt;</code>
    * [.apertureNode](#DepthOfFieldNode+apertureNode) : <code>Node.&lt;float&gt;</code>
    * [.maxblurNode](#DepthOfFieldNode+maxblurNode) : <code>Node.&lt;float&gt;</code>
    * [.updateBeforeType](#DepthOfFieldNode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#DepthOfFieldNode+updateBefore)
    * [.setup(builder)](#DepthOfFieldNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_DepthOfFieldNode_new"></a>

### new DepthOfFieldNode(textureNode, viewZNode, focusNode, apertureNode, maxblurNode)
Constructs a new DOF node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |
| viewZNode | <code>Node.&lt;float&gt;</code> | Represents the viewZ depth values of the scene. |
| focusNode | <code>Node.&lt;float&gt;</code> | Defines the effect's focus which is the distance along the camera's look direction in world units. |
| apertureNode | <code>Node.&lt;float&gt;</code> | Defines the effect's aperture. |
| maxblurNode | <code>Node.&lt;float&gt;</code> | Defines the effect's maximum blur. |

<a name="DepthOfFieldNode+textureNode"></a>

### depthOfFieldNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+viewZNode"></a>

### depthOfFieldNode.viewZNode : <code>Node.&lt;float&gt;</code>
Represents the viewZ depth values of the scene.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+focusNode"></a>

### depthOfFieldNode.focusNode : <code>Node.&lt;float&gt;</code>
Defines the effect's focus which is the distance along the camera's look direction in world units.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+apertureNode"></a>

### depthOfFieldNode.apertureNode : <code>Node.&lt;float&gt;</code>
Defines the effect's aperture.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+maxblurNode"></a>

### depthOfFieldNode.maxblurNode : <code>Node.&lt;float&gt;</code>
Defines the effect's maximum blur.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
<a name="DepthOfFieldNode+updateBeforeType"></a>

### depthOfFieldNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="DepthOfFieldNode+updateBefore"></a>

### depthOfFieldNode.updateBefore(frame)
This method is used to update the effect's uniforms once per frame.

**Kind**: instance method of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="DepthOfFieldNode+setup"></a>

### depthOfFieldNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="dof"></a>

## dof(node, viewZNode, focus, aperture, maxblur) ⇒ [<code>DepthOfFieldNode</code>](#DepthOfFieldNode)
TSL function for creating a depth-of-field effect (DOF) for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |
| viewZNode | <code>Node.&lt;float&gt;</code> | Represents the viewZ depth values of the scene. |
| focus | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Defines the effect's focus which is the distance along the camera's look direction in world units. |
| aperture | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Defines the effect's aperture. |
| maxblur | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Defines the effect's maximum blur. |

## Classes

<dl>
<dt><a href="#DotScreenNode">DotScreenNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating dot-screen effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#dotScreen">dotScreen(node, [angle], [scale])</a> ⇒ <code><a href="#DotScreenNode">DotScreenNode</a></code></dt>
<dd><p>TSL function for creating a dot-screen node for post processing.</p>
</dd>
</dl>

<a name="DotScreenNode"></a>

## DotScreenNode ⇐ <code>TempNode</code>
Post processing node for creating dot-screen effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [DotScreenNode](#DotScreenNode) ⇐ <code>TempNode</code>
    * [new DotScreenNode(inputNode, [angle], [scale])](#new_DotScreenNode_new)
    * [.inputNode](#DotScreenNode+inputNode) : <code>Node</code>
    * [.angle](#DotScreenNode+angle) : <code>UniformNode.&lt;float&gt;</code>
    * [.scale](#DotScreenNode+scale) : <code>UniformNode.&lt;float&gt;</code>
    * [.setup(builder)](#DotScreenNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_DotScreenNode_new"></a>

### new DotScreenNode(inputNode, [angle], [scale])
Constructs a new dot screen node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node</code> |  | The node that represents the input of the effect. |
| [angle] | <code>number</code> | <code>1.57</code> | The rotation of the effect in radians. |
| [scale] | <code>number</code> | <code>1</code> | The scale of the effect. A higher value means smaller dots. |

<a name="DotScreenNode+inputNode"></a>

### dotScreenNode.inputNode : <code>Node</code>
The node that represents the input of the effect.

**Kind**: instance property of [<code>DotScreenNode</code>](#DotScreenNode)  
<a name="DotScreenNode+angle"></a>

### dotScreenNode.angle : <code>UniformNode.&lt;float&gt;</code>
A uniform node that represents the rotation of the effect in radians.

**Kind**: instance property of [<code>DotScreenNode</code>](#DotScreenNode)  
<a name="DotScreenNode+scale"></a>

### dotScreenNode.scale : <code>UniformNode.&lt;float&gt;</code>
A uniform node that represents the scale of the effect. A higher value means smaller dots.

**Kind**: instance property of [<code>DotScreenNode</code>](#DotScreenNode)  
<a name="DotScreenNode+setup"></a>

### dotScreenNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>DotScreenNode</code>](#DotScreenNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="dotScreen"></a>

## dotScreen(node, [angle], [scale]) ⇒ [<code>DotScreenNode</code>](#DotScreenNode)
TSL function for creating a dot-screen node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [angle] | <code>number</code> | <code>1.57</code> | The rotation of the effect in radians. |
| [scale] | <code>number</code> | <code>1</code> | The scale of the effect. A higher value means smaller dots. |

## Classes

<dl>
<dt><a href="#FXAANode">FXAANode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for applying FXAA. This node requires sRGB input
so tone mapping and color space conversion must happen before the anti-aliasing.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#fxaa">fxaa(node)</a> ⇒ <code><a href="#FXAANode">FXAANode</a></code></dt>
<dd><p>TSL function for creating a FXAA node for anti-aliasing via post processing.</p>
</dd>
</dl>

<a name="FXAANode"></a>

## FXAANode ⇐ <code>TempNode</code>
Post processing node for applying FXAA. This node requires sRGB input
so tone mapping and color space conversion must happen before the anti-aliasing.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [FXAANode](#FXAANode) ⇐ <code>TempNode</code>
    * [new FXAANode(textureNode)](#new_FXAANode_new)
    * [.textureNode](#FXAANode+textureNode) : <code>TextureNode</code>
    * [.updateBeforeType](#FXAANode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#FXAANode+updateBefore)
    * [.setup(builder)](#FXAANode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_FXAANode_new"></a>

### new FXAANode(textureNode)
Constructs a new FXAA node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |

<a name="FXAANode+textureNode"></a>

### fxaaNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>FXAANode</code>](#FXAANode)  
<a name="FXAANode+updateBeforeType"></a>

### fxaaNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>FXAANode</code>](#FXAANode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="FXAANode+updateBefore"></a>

### fxaaNode.updateBefore(frame)
This method is used to update the effect's uniforms once per frame.

**Kind**: instance method of [<code>FXAANode</code>](#FXAANode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="FXAANode+setup"></a>

### fxaaNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>FXAANode</code>](#FXAANode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="fxaa"></a>

## fxaa(node) ⇒ [<code>FXAANode</code>](#FXAANode)
TSL function for creating a FXAA node for anti-aliasing via post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |

## Classes

<dl>
<dt><a href="#FilmNode">FilmNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating a film grain effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#film">film(inputNode, [intensityNode], [uvNode])</a> ⇒ <code><a href="#FilmNode">FilmNode</a></code></dt>
<dd><p>TSL function for creating a film node for post processing.</p>
</dd>
</dl>

<a name="FilmNode"></a>

## FilmNode ⇐ <code>TempNode</code>
Post processing node for creating a film grain effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [FilmNode](#FilmNode) ⇐ <code>TempNode</code>
    * [new FilmNode(inputNode, [intensityNode], [uvNode])](#new_FilmNode_new)
    * [.inputNode](#FilmNode+inputNode) : <code>Node</code>
    * [.intensityNode](#FilmNode+intensityNode) : <code>Node.&lt;float&gt;</code>
    * [.uvNode](#FilmNode+uvNode) : <code>Node.&lt;vec2&gt;</code>
    * [.setup(builder)](#FilmNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_FilmNode_new"></a>

### new FilmNode(inputNode, [intensityNode], [uvNode])
Constructs a new film node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node</code> |  | The node that represents the input of the effect. |
| [intensityNode] | <code>Node.&lt;float&gt;</code> | <code></code> | A node that represents the effect's intensity. |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | A node that allows to pass custom (e.g. animated) uv data. |

<a name="FilmNode+inputNode"></a>

### filmNode.inputNode : <code>Node</code>
The node that represents the input of the effect.

**Kind**: instance property of [<code>FilmNode</code>](#FilmNode)  
<a name="FilmNode+intensityNode"></a>

### filmNode.intensityNode : <code>Node.&lt;float&gt;</code>
A node that represents the effect's intensity.

**Kind**: instance property of [<code>FilmNode</code>](#FilmNode)  
**Default**: <code>null</code>  
<a name="FilmNode+uvNode"></a>

### filmNode.uvNode : <code>Node.&lt;vec2&gt;</code>
A node that allows to pass custom (e.g. animated) uv data.

**Kind**: instance property of [<code>FilmNode</code>](#FilmNode)  
**Default**: <code>null</code>  
<a name="FilmNode+setup"></a>

### filmNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>FilmNode</code>](#FilmNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="film"></a>

## film(inputNode, [intensityNode], [uvNode]) ⇒ [<code>FilmNode</code>](#FilmNode)
TSL function for creating a film node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [intensityNode] | <code>Node.&lt;float&gt;</code> | <code></code> | A node that represents the effect's intensity. |
| [uvNode] | <code>Node.&lt;vec2&gt;</code> | <code></code> | A node that allows to pass custom (e.g. animated) uv data. |

## Classes

<dl>
<dt><a href="#GTAONode">GTAONode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for applying Ground Truth Ambient Occlusion (GTAO) to a scene.</p>
<pre><code class="language-js">const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
scenePass.setMRT( mrt( {
    output: output,
    normal: normalView
} ) );

const scenePassColor = scenePass.getTextureNode( &#39;output&#39; );
const scenePassNormal = scenePass.getTextureNode( &#39;normal&#39; );
const scenePassDepth = scenePass.getTextureNode( &#39;depth&#39; );

const aoPass = ao( scenePassDepth, scenePassNormal, camera );

postProcessing.outputNod = aoPass.getTextureNode().mul( scenePassColor );
</code></pre>
<p>Reference: <a href="https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf">https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#generateMagicSquareNoise">generateMagicSquareNoise([size])</a> ⇒ <code>DataTexture</code></dt>
<dd><p>Generates the AO&#39;s noise texture for the given size.</p>
</dd>
<dt><a href="#generateMagicSquare">generateMagicSquare(size)</a> ⇒ <code>Array.&lt;number&gt;</code></dt>
<dd><p>Computes an array of magic square values required to generate the noise texture.</p>
</dd>
<dt><a href="#ao">ao(depthNode, normalNode, camera)</a> ⇒ <code><a href="#GTAONode">GTAONode</a></code></dt>
<dd><p>TSL function for creating a Ground Truth Ambient Occlusion (GTAO) effect.</p>
</dd>
</dl>

<a name="GTAONode"></a>

## GTAONode ⇐ <code>TempNode</code>
Post processing node for applying Ground Truth Ambient Occlusion (GTAO) to a scene.
```js
const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );
scenePass.setMRT( mrt( {
	output: output,
	normal: normalView
} ) );

const scenePassColor = scenePass.getTextureNode( 'output' );
const scenePassNormal = scenePass.getTextureNode( 'normal' );
const scenePassDepth = scenePass.getTextureNode( 'depth' );

const aoPass = ao( scenePassDepth, scenePassNormal, camera );

postProcessing.outputNod = aoPass.getTextureNode().mul( scenePassColor );
```

Reference: [https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf](https://www.activision.com/cdn/research/Practical_Real_Time_Strategies_for_Accurate_Indirect_Occlusion_NEW%20VERSION_COLOR.pdf).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [GTAONode](#GTAONode) ⇐ <code>TempNode</code>
    * [new GTAONode(depthNode, normalNode, camera)](#new_GTAONode_new)
    * [.depthNode](#GTAONode+depthNode) : <code>Node.&lt;float&gt;</code>
    * [.normalNode](#GTAONode+normalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.resolutionScale](#GTAONode+resolutionScale) : <code>number</code>
    * [.updateBeforeType](#GTAONode+updateBeforeType) : <code>string</code>
    * [.radius](#GTAONode+radius) : <code>UniformNode.&lt;float&gt;</code>
    * [.resolution](#GTAONode+resolution) : <code>UniformNode.&lt;vec2&gt;</code>
    * [.thickness](#GTAONode+thickness) : <code>UniformNode.&lt;float&gt;</code>
    * [.distanceExponent](#GTAONode+distanceExponent) : <code>UniformNode.&lt;float&gt;</code>
    * [.distanceFallOff](#GTAONode+distanceFallOff) : <code>UniformNode.&lt;float&gt;</code>
    * [.scale](#GTAONode+scale) : <code>UniformNode.&lt;float&gt;</code>
    * [.samples](#GTAONode+samples) : <code>UniformNode.&lt;float&gt;</code>
    * [.getTextureNode()](#GTAONode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#GTAONode+setSize)
    * [.updateBefore(frame)](#GTAONode+updateBefore)
    * [.setup(builder)](#GTAONode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#GTAONode+dispose)

<a name="new_GTAONode_new"></a>

### new GTAONode(depthNode, normalNode, camera)
Constructs a new GTAO node.


| Param | Type | Description |
| --- | --- | --- |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the scene's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the scene's normals. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="GTAONode+depthNode"></a>

### gtaoNode.depthNode : <code>Node.&lt;float&gt;</code>
A node that represents the scene's depth.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+normalNode"></a>

### gtaoNode.normalNode : <code>Node.&lt;vec3&gt;</code>
A node that represents the scene's normals. If no normals are passed to the
constructor (because MRT is not available), normals can be automatically
reconstructed from depth values in the shader.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+resolutionScale"></a>

### gtaoNode.resolutionScale : <code>number</code>
The resolution scale. By default the effect is rendered in full resolution
for best quality but a value of `0.5` should be sufficient for most scenes.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
**Default**: <code>1</code>  
<a name="GTAONode+updateBeforeType"></a>

### gtaoNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="GTAONode+radius"></a>

### gtaoNode.radius : <code>UniformNode.&lt;float&gt;</code>
The radius of the ambient occlusion.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+resolution"></a>

### gtaoNode.resolution : <code>UniformNode.&lt;vec2&gt;</code>
The resolution of the effect. Can be scaled via
`resolutionScale`.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+thickness"></a>

### gtaoNode.thickness : <code>UniformNode.&lt;float&gt;</code>
The thickness of the ambient occlusion.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+distanceExponent"></a>

### gtaoNode.distanceExponent : <code>UniformNode.&lt;float&gt;</code>
Another option to tweak the occlusion. The recommended range is
`[1,2]` for attenuating the AO.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+distanceFallOff"></a>

### gtaoNode.distanceFallOff : <code>UniformNode.&lt;float&gt;</code>
The distance fall off value of the ambient occlusion.
A lower value leads to a larger AO effect. The value
should lie in the range `[0,1]`.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+scale"></a>

### gtaoNode.scale : <code>UniformNode.&lt;float&gt;</code>
The scale of the ambient occlusion.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+samples"></a>

### gtaoNode.samples : <code>UniformNode.&lt;float&gt;</code>
How many samples are used to compute the AO.
A higher value results in better quality but also
in a more expensive runtime behavior.

**Kind**: instance property of [<code>GTAONode</code>](#GTAONode)  
<a name="GTAONode+getTextureNode"></a>

### gtaoNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="GTAONode+setSize"></a>

### gtaoNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="GTAONode+updateBefore"></a>

### gtaoNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="GTAONode+setup"></a>

### gtaoNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="GTAONode+dispose"></a>

### gtaoNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>GTAONode</code>](#GTAONode)  
<a name="generateMagicSquareNoise"></a>

## generateMagicSquareNoise([size]) ⇒ <code>DataTexture</code>
Generates the AO's noise texture for the given size.

**Kind**: global function  
**Returns**: <code>DataTexture</code> - The generated noise texture.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>5</code> | The noise size. |

<a name="generateMagicSquare"></a>

## generateMagicSquare(size) ⇒ <code>Array.&lt;number&gt;</code>
Computes an array of magic square values required to generate the noise texture.

**Kind**: global function  
**Returns**: <code>Array.&lt;number&gt;</code> - The magic square values.  

| Param | Type | Description |
| --- | --- | --- |
| size | <code>number</code> | The noise size. |

<a name="ao"></a>

## ao(depthNode, normalNode, camera) ⇒ [<code>GTAONode</code>](#GTAONode)
TSL function for creating a Ground Truth Ambient Occlusion (GTAO) effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the scene's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the scene's normals. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

## Classes

<dl>
<dt><a href="#GaussianBlurNode">GaussianBlurNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating a gaussian blur effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#gaussianBlur">gaussianBlur(node, directionNode, sigma)</a> ⇒ <code><a href="#GaussianBlurNode">GaussianBlurNode</a></code></dt>
<dd><p>TSL function for creating a gaussian blur node for post processing.</p>
</dd>
<dt><a href="#premultipliedGaussianBlur">premultipliedGaussianBlur(node, directionNode, sigma)</a> ⇒ <code><a href="#GaussianBlurNode">GaussianBlurNode</a></code></dt>
<dd><p>TSL function for creating a gaussian blur node for post processing with enabled premultiplied alpha.</p>
</dd>
</dl>

<a name="GaussianBlurNode"></a>

## GaussianBlurNode ⇐ <code>TempNode</code>
Post processing node for creating a gaussian blur effect.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [GaussianBlurNode](#GaussianBlurNode) ⇐ <code>TempNode</code>
    * [new GaussianBlurNode(textureNode, directionNode, sigma)](#new_GaussianBlurNode_new)
    * [.textureNode](#GaussianBlurNode+textureNode) : <code>TextureNode</code>
    * [.directionNode](#GaussianBlurNode+directionNode) : <code>Node.&lt;(vec2\|float)&gt;</code>
    * [.sigma](#GaussianBlurNode+sigma) : <code>number</code>
    * [.updateBeforeType](#GaussianBlurNode+updateBeforeType) : <code>string</code>
    * [.resolution](#GaussianBlurNode+resolution) : <code>Vector2</code>
    * [.premultipliedAlpha](#GaussianBlurNode+premultipliedAlpha) : <code>boolean</code>
    * [.setPremultipliedAlpha(value)](#GaussianBlurNode+setPremultipliedAlpha) ⇒ [<code>GaussianBlurNode</code>](#GaussianBlurNode)
    * [.getPremultipliedAlpha()](#GaussianBlurNode+getPremultipliedAlpha) ⇒ <code>boolean</code>
    * [.setSize(width, height)](#GaussianBlurNode+setSize)
    * [.updateBefore(frame)](#GaussianBlurNode+updateBefore)
    * [.getTextureNode()](#GaussianBlurNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setup(builder)](#GaussianBlurNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#GaussianBlurNode+dispose)

<a name="new_GaussianBlurNode_new"></a>

### new GaussianBlurNode(textureNode, directionNode, sigma)
Constructs a new gaussian blur node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that represents the input of the effect. |
| directionNode | <code>Node.&lt;(vec2\|float)&gt;</code> | <code></code> | Defines the direction and radius of the blur. |
| sigma | <code>number</code> | <code>2</code> | Controls the kernel of the blur filter. Higher values mean a wider blur radius. |

<a name="GaussianBlurNode+textureNode"></a>

### gaussianBlurNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
<a name="GaussianBlurNode+directionNode"></a>

### gaussianBlurNode.directionNode : <code>Node.&lt;(vec2\|float)&gt;</code>
Defines the direction and radius of the blur.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
<a name="GaussianBlurNode+sigma"></a>

### gaussianBlurNode.sigma : <code>number</code>
Controls the kernel of the blur filter. Higher values mean a wider blur radius.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
<a name="GaussianBlurNode+updateBeforeType"></a>

### gaussianBlurNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="GaussianBlurNode+resolution"></a>

### gaussianBlurNode.resolution : <code>Vector2</code>
Controls the resolution of the effect.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Default**: <code>(1,1)</code>  
<a name="GaussianBlurNode+premultipliedAlpha"></a>

### gaussianBlurNode.premultipliedAlpha : <code>boolean</code>
Whether the effect should use premultiplied alpha or not. Set this to `true`
if you are going to blur texture input with transparency.

**Kind**: instance property of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Default**: <code>false</code>  
<a name="GaussianBlurNode+setPremultipliedAlpha"></a>

### gaussianBlurNode.setPremultipliedAlpha(value) ⇒ [<code>GaussianBlurNode</code>](#GaussianBlurNode)
Sets the given premultiplied alpha value.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Returns**: [<code>GaussianBlurNode</code>](#GaussianBlurNode) - height - A reference to this node.  

| Param | Type | Description |
| --- | --- | --- |
| value | <code>boolean</code> | Whether the effect should use premultiplied alpha or not. |

<a name="GaussianBlurNode+getPremultipliedAlpha"></a>

### gaussianBlurNode.getPremultipliedAlpha() ⇒ <code>boolean</code>
Returns the premultiplied alpha value.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Returns**: <code>boolean</code> - Whether the effect should use premultiplied alpha or not.  
<a name="GaussianBlurNode+setSize"></a>

### gaussianBlurNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="GaussianBlurNode+updateBefore"></a>

### gaussianBlurNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="GaussianBlurNode+getTextureNode"></a>

### gaussianBlurNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="GaussianBlurNode+setup"></a>

### gaussianBlurNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="GaussianBlurNode+dispose"></a>

### gaussianBlurNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>GaussianBlurNode</code>](#GaussianBlurNode)  
<a name="gaussianBlur"></a>

## gaussianBlur(node, directionNode, sigma) ⇒ [<code>GaussianBlurNode</code>](#GaussianBlurNode)
TSL function for creating a gaussian blur node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |
| directionNode | <code>Node.&lt;(vec2\|float)&gt;</code> | Defines the direction and radius of the blur. |
| sigma | <code>number</code> | Controls the kernel of the blur filter. Higher values mean a wider blur radius. |

<a name="premultipliedGaussianBlur"></a>

## premultipliedGaussianBlur(node, directionNode, sigma) ⇒ [<code>GaussianBlurNode</code>](#GaussianBlurNode)
TSL function for creating a gaussian blur node for post processing with enabled premultiplied alpha.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |
| directionNode | <code>Node.&lt;(vec2\|float)&gt;</code> | Defines the direction and radius of the blur. |
| sigma | <code>number</code> | Controls the kernel of the blur filter. Higher values mean a wider blur radius. |

## Classes

<dl>
<dt><a href="#LensflareNode">LensflareNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for adding a bloom-based lens flare effect. This effect
requires that you extract the bloom of the scene via a bloom pass first.</p>
<p>References:</p>
<ul>
<li><a href="https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html">https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html</a>.</li>
<li><a href="https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html">https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html</a>.</li>
</ul>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#lensflare">lensflare(node, params)</a> ⇒ <code><a href="#LensflareNode">LensflareNode</a></code></dt>
<dd><p>TSL function for creating a bloom-based lens flare effect.</p>
</dd>
</dl>

<a name="LensflareNode"></a>

## LensflareNode ⇐ <code>TempNode</code>
Post processing node for adding a bloom-based lens flare effect. This effect
requires that you extract the bloom of the scene via a bloom pass first.

References:
- [https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html](https://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html).
- [https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html](https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [LensflareNode](#LensflareNode) ⇐ <code>TempNode</code>
    * [new LensflareNode(textureNode, params)](#new_LensflareNode_new)
    * [.textureNode](#LensflareNode+textureNode) : <code>TextureNode</code>
    * [.ghostTintNode](#LensflareNode+ghostTintNode) : <code>Node.&lt;vec3&gt;</code>
    * [.thresholdNode](#LensflareNode+thresholdNode) : <code>Node.&lt;float&gt;</code>
    * [.ghostSamplesNode](#LensflareNode+ghostSamplesNode) : <code>Node.&lt;float&gt;</code>
    * [.ghostSpacingNode](#LensflareNode+ghostSpacingNode) : <code>Node.&lt;float&gt;</code>
    * [.ghostAttenuationFactorNode](#LensflareNode+ghostAttenuationFactorNode) : <code>Node.&lt;float&gt;</code>
    * [.downSampleRatio](#LensflareNode+downSampleRatio) : <code>number</code>
    * [.updateBeforeType](#LensflareNode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#LensflareNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#LensflareNode+setSize)
    * [.updateBefore(frame)](#LensflareNode+updateBefore)
    * [.setup(builder)](#LensflareNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#LensflareNode+dispose)

<a name="new_LensflareNode_new"></a>

### new LensflareNode(textureNode, params)
Constructs a new lens flare node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that represents the scene's bloom. |
| params | <code>Object</code> |  | The parameter object for configuring the effect. |
| [params.ghostTint] | <code>Node.&lt;vec3&gt;</code> \| <code>Color</code> | <code>vec3(1, 1, 1)</code> | Defines the tint of the flare/ghosts. |
| [params.threshold] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(0.5)</code> | Controls the size and strength of the effect. A higher threshold results in smaller flares. |
| [params.ghostSamples] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(4)</code> | Represents the number of flares/ghosts per bright spot which pivot around the center. |
| [params.ghostSpacing] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(0.25)</code> | Defines the spacing of the flares/ghosts. |
| [params.ghostAttenuationFactor] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(25)</code> | Defines the attenuation factor of flares/ghosts. |
| [params.downSampleRatio] | <code>number</code> | <code>4</code> | Defines how downsampling since the effect is usually not rendered at full resolution. |

<a name="LensflareNode+textureNode"></a>

### lensflareNode.textureNode : <code>TextureNode</code>
The texture node that represents the scene's bloom.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+ghostTintNode"></a>

### lensflareNode.ghostTintNode : <code>Node.&lt;vec3&gt;</code>
Defines the tint of the flare/ghosts.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+thresholdNode"></a>

### lensflareNode.thresholdNode : <code>Node.&lt;float&gt;</code>
Controls the size and strength of the effect. A higher threshold results in smaller flares.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+ghostSamplesNode"></a>

### lensflareNode.ghostSamplesNode : <code>Node.&lt;float&gt;</code>
Represents the number of flares/ghosts per bright spot which pivot around the center.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+ghostSpacingNode"></a>

### lensflareNode.ghostSpacingNode : <code>Node.&lt;float&gt;</code>
Defines the spacing of the flares/ghosts.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+ghostAttenuationFactorNode"></a>

### lensflareNode.ghostAttenuationFactorNode : <code>Node.&lt;float&gt;</code>
Defines the attenuation factor of flares/ghosts.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+downSampleRatio"></a>

### lensflareNode.downSampleRatio : <code>number</code>
Defines how downsampling since the effect is usually not rendered at full resolution.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
<a name="LensflareNode+updateBeforeType"></a>

### lensflareNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>LensflareNode</code>](#LensflareNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="LensflareNode+getTextureNode"></a>

### lensflareNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="LensflareNode+setSize"></a>

### lensflareNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="LensflareNode+updateBefore"></a>

### lensflareNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="LensflareNode+setup"></a>

### lensflareNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="LensflareNode+dispose"></a>

### lensflareNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>LensflareNode</code>](#LensflareNode)  
<a name="lensflare"></a>

## lensflare(node, params) ⇒ [<code>LensflareNode</code>](#LensflareNode)
TSL function for creating a bloom-based lens flare effect.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>TextureNode</code> |  | The node that represents the scene's bloom. |
| params | <code>Object</code> |  | The parameter object for configuring the effect. |
| [params.ghostTint] | <code>Node.&lt;vec3&gt;</code> \| <code>Color</code> | <code>vec3(1, 1, 1)</code> | Defines the tint of the flare/ghosts. |
| [params.threshold] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(0.5)</code> | Controls the size and strength of the effect. A higher threshold results in smaller flares. |
| [params.ghostSamples] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(4)</code> | Represents the number of flares/ghosts per bright spot which pivot around the center. |
| [params.ghostSpacing] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(0.25)</code> | Defines the spacing of the flares/ghosts. |
| [params.ghostAttenuationFactor] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>float(25)</code> | Defines the attenuation factor of flares/ghosts. |
| [params.downSampleRatio] | <code>number</code> | <code>4</code> | Defines how downsampling since the effect is usually not rendered at full resolution. |

## Classes

<dl>
<dt><a href="#Lut3DNode">Lut3DNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>A post processing node for color grading via lookup tables.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#lut3D">lut3D(node, lut, size, intensity)</a> ⇒ <code><a href="#Lut3DNode">Lut3DNode</a></code></dt>
<dd><p>TSL function for creating a LUT node for color grading via post processing.</p>
</dd>
</dl>

<a name="Lut3DNode"></a>

## Lut3DNode ⇐ <code>TempNode</code>
A post processing node for color grading via lookup tables.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [Lut3DNode](#Lut3DNode) ⇐ <code>TempNode</code>
    * [new Lut3DNode(inputNode, lutNode, size, intensityNode)](#new_Lut3DNode_new)
    * [.inputNode](#Lut3DNode+inputNode) : <code>Node</code>
    * [.lutNode](#Lut3DNode+lutNode) : <code>TextureNode</code>
    * [.size](#Lut3DNode+size) : <code>UniformNode.&lt;float&gt;</code>
    * [.intensityNode](#Lut3DNode+intensityNode) : <code>Node.&lt;float&gt;</code>
    * [.setup(builder)](#Lut3DNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_Lut3DNode_new"></a>

### new Lut3DNode(inputNode, lutNode, size, intensityNode)
Constructs a new LUT node.


| Param | Type | Description |
| --- | --- | --- |
| inputNode | <code>Node</code> | The node that represents the input of the effect. |
| lutNode | <code>TextureNode</code> | A texture node that represents the lookup table. |
| size | <code>number</code> | The size of the lookup table. |
| intensityNode | <code>Node.&lt;float&gt;</code> | Controls the intensity of the effect. |

<a name="Lut3DNode+inputNode"></a>

### lut3DNode.inputNode : <code>Node</code>
The node that represents the input of the effect.

**Kind**: instance property of [<code>Lut3DNode</code>](#Lut3DNode)  
<a name="Lut3DNode+lutNode"></a>

### lut3DNode.lutNode : <code>TextureNode</code>
A texture node that represents the lookup table.

**Kind**: instance property of [<code>Lut3DNode</code>](#Lut3DNode)  
<a name="Lut3DNode+size"></a>

### lut3DNode.size : <code>UniformNode.&lt;float&gt;</code>
The size of the lookup table.

**Kind**: instance property of [<code>Lut3DNode</code>](#Lut3DNode)  
<a name="Lut3DNode+intensityNode"></a>

### lut3DNode.intensityNode : <code>Node.&lt;float&gt;</code>
Controls the intensity of the effect.

**Kind**: instance property of [<code>Lut3DNode</code>](#Lut3DNode)  
<a name="Lut3DNode+setup"></a>

### lut3DNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>Lut3DNode</code>](#Lut3DNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="lut3D"></a>

## lut3D(node, lut, size, intensity) ⇒ [<code>Lut3DNode</code>](#Lut3DNode)
TSL function for creating a LUT node for color grading via post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node</code> | The node that represents the input of the effect. |
| lut | <code>TextureNode</code> | A texture node that represents the lookup table. |
| size | <code>number</code> | The size of the lookup table. |
| intensity | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Controls the intensity of the effect. |

<a name="motionBlur"></a>

## motionBlur(inputNode, velocity, [numSamples]) ⇒ <code>Node.&lt;vec4&gt;</code>
Applies a motion blur effect to the given input node.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The input node with the motion blur effect applied.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| inputNode | <code>Node.&lt;vec4&gt;</code> |  | The input node to apply the motion blur for. |
| velocity | <code>Node.&lt;vec2&gt;</code> |  | The motion vectors of the beauty pass. |
| [numSamples] | <code>Node.&lt;int&gt;</code> | <code>int(16)</code> | How many samples the effect should use. A higher value results in better quality but is also more expensive. |

## Classes

<dl>
<dt><a href="#OutlineNode">OutlineNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for rendering outlines around selected objects. The node
gives you great flexibility in composing the final outline look depending on
your requirements.</p>
<pre><code class="language-js">const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );

// outline parameter

const edgeStrength = uniform( 3.0 );
const edgeGlow = uniform( 0.0 );
const edgeThickness = uniform( 1.0 );
const visibleEdgeColor = uniform( new THREE.Color( 0xffffff ) );
const hiddenEdgeColor = uniform( new THREE.Color( 0x4e3636 ) );

outlinePass = outline( scene, camera, {
    selectedObjects,
    edgeGlow,
    edgeThickness
} );

// compose custom outline

const { visibleEdge, hiddenEdge } = outlinePass;
const outlineColor = visibleEdge.mul( visibleEdgeColor ).add( hiddenEdge.mul( hiddenEdgeColor ) ).mul( edgeStrength );

postProcessing.outputNode = outlineColor.add( scenePass );
</code></pre>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#outline">outline(scene, camera, params)</a> ⇒ <code><a href="#OutlineNode">OutlineNode</a></code></dt>
<dd><p>TSL function for creating an outline effect around selected objects.</p>
</dd>
</dl>

<a name="OutlineNode"></a>

## OutlineNode ⇐ <code>TempNode</code>
Post processing node for rendering outlines around selected objects. The node
gives you great flexibility in composing the final outline look depending on
your requirements.
```js
const postProcessing = new THREE.PostProcessing( renderer );

const scenePass = pass( scene, camera );

// outline parameter

const edgeStrength = uniform( 3.0 );
const edgeGlow = uniform( 0.0 );
const edgeThickness = uniform( 1.0 );
const visibleEdgeColor = uniform( new THREE.Color( 0xffffff ) );
const hiddenEdgeColor = uniform( new THREE.Color( 0x4e3636 ) );

outlinePass = outline( scene, camera, {
	selectedObjects,
	edgeGlow,
	edgeThickness
} );

// compose custom outline

const { visibleEdge, hiddenEdge } = outlinePass;
const outlineColor = visibleEdge.mul( visibleEdgeColor ).add( hiddenEdge.mul( hiddenEdgeColor ) ).mul( edgeStrength );

postProcessing.outputNode = outlineColor.add( scenePass );
```

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [OutlineNode](#OutlineNode) ⇐ <code>TempNode</code>
    * [new OutlineNode(scene, camera, params)](#new_OutlineNode_new)
    * [.scene](#OutlineNode+scene) : <code>Scene</code>
    * [.camera](#OutlineNode+camera) : <code>Camera</code>
    * [.selectedObjects](#OutlineNode+selectedObjects) : <code>Array.&lt;Object3D&gt;</code>
    * [.edgeThicknessNode](#OutlineNode+edgeThicknessNode) : <code>Node.&lt;float&gt;</code>
    * [.edgeGlowNode](#OutlineNode+edgeGlowNode) : <code>Node.&lt;float&gt;</code>
    * [.downSampleRatio](#OutlineNode+downSampleRatio) : <code>number</code>
    * [.updateBeforeType](#OutlineNode+updateBeforeType) : <code>string</code>
    * [.visibleEdge](#OutlineNode+visibleEdge) ⇒ <code>Node.&lt;float&gt;</code>
    * [.hiddenEdge](#OutlineNode+hiddenEdge) ⇒ <code>Node.&lt;float&gt;</code>
    * [.getTextureNode()](#OutlineNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#OutlineNode+setSize)
    * [.updateBefore(frame)](#OutlineNode+updateBefore)
    * [.setup(builder)](#OutlineNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#OutlineNode+dispose)

<a name="new_OutlineNode_new"></a>

### new OutlineNode(scene, camera, params)
Constructs a new outline node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | A reference to the scene. |
| camera | <code>Camera</code> |  | The camera the scene is rendered with. |
| params | <code>Object</code> |  | The configuration parameters. |
| params.selectedObjects | <code>Array.&lt;Object3D&gt;</code> |  | An array of selected objects. |
| [params.edgeThickness] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The thickness of the edges. |
| [params.edgeGlow] | <code>Node.&lt;float&gt;</code> | <code>float(0)</code> | Can be used for an animated glow/pulse effects. |
| [params.downSampleRatio] | <code>number</code> | <code>2</code> | The downsample ratio. |

<a name="OutlineNode+scene"></a>

### outlineNode.scene : <code>Scene</code>
A reference to the scene.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+camera"></a>

### outlineNode.camera : <code>Camera</code>
The camera the scene is rendered with.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+selectedObjects"></a>

### outlineNode.selectedObjects : <code>Array.&lt;Object3D&gt;</code>
An array of selected objects.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+edgeThicknessNode"></a>

### outlineNode.edgeThicknessNode : <code>Node.&lt;float&gt;</code>
The thickness of the edges.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+edgeGlowNode"></a>

### outlineNode.edgeGlowNode : <code>Node.&lt;float&gt;</code>
Can be used for an animated glow/pulse effect.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
<a name="OutlineNode+downSampleRatio"></a>

### outlineNode.downSampleRatio : <code>number</code>
The downsample ratio.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
**Default**: <code>2</code>  
<a name="OutlineNode+updateBeforeType"></a>

### outlineNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="OutlineNode+visibleEdge"></a>

### outlineNode.visibleEdge ⇒ <code>Node.&lt;float&gt;</code>
A mask value that represents the visible edge.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The visible edge.  
<a name="OutlineNode+hiddenEdge"></a>

### outlineNode.hiddenEdge ⇒ <code>Node.&lt;float&gt;</code>
A mask value that represents the hidden edge.

**Kind**: instance property of [<code>OutlineNode</code>](#OutlineNode)  
**Returns**: <code>Node.&lt;float&gt;</code> - The hidden edge.  
<a name="OutlineNode+getTextureNode"></a>

### outlineNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="OutlineNode+setSize"></a>

### outlineNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="OutlineNode+updateBefore"></a>

### outlineNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="OutlineNode+setup"></a>

### outlineNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="OutlineNode+dispose"></a>

### outlineNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>OutlineNode</code>](#OutlineNode)  
<a name="outline"></a>

## outline(scene, camera, params) ⇒ [<code>OutlineNode</code>](#OutlineNode)
TSL function for creating an outline effect around selected objects.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | A reference to the scene. |
| camera | <code>Camera</code> |  | The camera the scene is rendered with. |
| params | <code>Object</code> |  | The configuration parameters. |
| params.selectedObjects | <code>Array.&lt;Object3D&gt;</code> |  | An array of selected objects. |
| [params.edgeThickness] | <code>Node.&lt;float&gt;</code> | <code>float(1)</code> | The thickness of the edges. |
| [params.edgeGlow] | <code>Node.&lt;float&gt;</code> | <code>float(0)</code> | Can be used for animated glow/pulse effects. |
| [params.downSampleRatio] | <code>number</code> | <code>2</code> | The downsample ratio. |

## Classes

<dl>
<dt><a href="#ParallaxBarrierPassNode">ParallaxBarrierPassNode</a> ⇐ <code>StereoCompositePassNode</code></dt>
<dd><p>A render pass node that creates a parallax barrier effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#parallaxBarrierPass">parallaxBarrierPass(scene, camera)</a> ⇒ <code><a href="#ParallaxBarrierPassNode">ParallaxBarrierPassNode</a></code></dt>
<dd><p>TSL function for creating an parallax barrier pass node.</p>
</dd>
</dl>

<a name="ParallaxBarrierPassNode"></a>

## ParallaxBarrierPassNode ⇐ <code>StereoCompositePassNode</code>
A render pass node that creates a parallax barrier effect.

**Kind**: global class  
**Extends**: <code>StereoCompositePassNode</code>  

* [ParallaxBarrierPassNode](#ParallaxBarrierPassNode) ⇐ <code>StereoCompositePassNode</code>
    * [new ParallaxBarrierPassNode(scene, camera)](#new_ParallaxBarrierPassNode_new)
    * [.isParallaxBarrierPassNode](#ParallaxBarrierPassNode+isParallaxBarrierPassNode) : <code>boolean</code>
    * [.setup(builder)](#ParallaxBarrierPassNode+setup) ⇒ <code>PassTextureNode</code>

<a name="new_ParallaxBarrierPassNode_new"></a>

### new ParallaxBarrierPassNode(scene, camera)
Constructs a new parallax barrier pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="ParallaxBarrierPassNode+isParallaxBarrierPassNode"></a>

### parallaxBarrierPassNode.isParallaxBarrierPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>ParallaxBarrierPassNode</code>](#ParallaxBarrierPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="ParallaxBarrierPassNode+setup"></a>

### parallaxBarrierPassNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>ParallaxBarrierPassNode</code>](#ParallaxBarrierPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="parallaxBarrierPass"></a>

## parallaxBarrierPass(scene, camera) ⇒ [<code>ParallaxBarrierPassNode</code>](#ParallaxBarrierPassNode)
TSL function for creating an parallax barrier pass node.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#PixelationNode">PixelationNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>A inner node definition that implements the actual pixelation TSL code.</p>
</dd>
<dt><a href="#PixelationPassNode">PixelationPassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>A special render pass node that renders the scene with a pixelation effect.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#pixelationPass">pixelationPass(scene, camera, [pixelSize], [normalEdgeStrength], [depthEdgeStrength])</a> ⇒ <code><a href="#PixelationPassNode">PixelationPassNode</a></code></dt>
<dd><p>TSL function for creating a pixelation render pass node for post processing.</p>
</dd>
</dl>

<a name="PixelationNode"></a>

## PixelationNode ⇐ <code>TempNode</code>
A inner node definition that implements the actual pixelation TSL code.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [PixelationNode](#PixelationNode) ⇐ <code>TempNode</code>
    * [new PixelationNode(textureNode, depthNode, normalNode, pixelSize, normalEdgeStrength, depthEdgeStrength)](#new_PixelationNode_new)
    * [.textureNode](#PixelationNode+textureNode) : <code>TextureNode</code>
    * [.depthNode](#PixelationNode+depthNode) : <code>TextureNode</code>
    * [.normalNode](#PixelationNode+normalNode) : <code>TextureNode</code>
    * [.pixelSize](#PixelationNode+pixelSize) : <code>Node.&lt;float&gt;</code>
    * [.normalEdgeStrength](#PixelationNode+normalEdgeStrength) : <code>Node.&lt;float&gt;</code>
    * [.depthEdgeStrength](#PixelationNode+depthEdgeStrength) : <code>Node.&lt;float&gt;</code>
    * [._resolution](#PixelationNode+_resolution) : <code>Node.&lt;vec4&gt;</code>
    * [.updateBeforeType](#PixelationNode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#PixelationNode+updateBefore)
    * [.setup(builder)](#PixelationNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_PixelationNode_new"></a>

### new PixelationNode(textureNode, depthNode, normalNode, pixelSize, normalEdgeStrength, depthEdgeStrength)
Constructs a new pixelation node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the beauty pass. |
| depthNode | <code>TextureNode</code> | The texture that represents the beauty's depth. |
| normalNode | <code>TextureNode</code> | The texture that represents the beauty's normals. |
| pixelSize | <code>Node.&lt;float&gt;</code> | The pixel size. |
| normalEdgeStrength | <code>Node.&lt;float&gt;</code> | The normal edge strength. |
| depthEdgeStrength | <code>Node.&lt;float&gt;</code> | The depth edge strength. |

<a name="PixelationNode+textureNode"></a>

### pixelationNode.textureNode : <code>TextureNode</code>
The texture node that represents the beauty pass.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+depthNode"></a>

### pixelationNode.depthNode : <code>TextureNode</code>
The texture that represents the beauty's depth.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+normalNode"></a>

### pixelationNode.normalNode : <code>TextureNode</code>
The texture that represents the beauty's normals.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+pixelSize"></a>

### pixelationNode.pixelSize : <code>Node.&lt;float&gt;</code>
The pixel size.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+normalEdgeStrength"></a>

### pixelationNode.normalEdgeStrength : <code>Node.&lt;float&gt;</code>
The pixel size.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+depthEdgeStrength"></a>

### pixelationNode.depthEdgeStrength : <code>Node.&lt;float&gt;</code>
The depth edge strength.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+_resolution"></a>

### pixelationNode.\_resolution : <code>Node.&lt;vec4&gt;</code>
Uniform node that represents the resolution.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
<a name="PixelationNode+updateBeforeType"></a>

### pixelationNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>PixelationNode</code>](#PixelationNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="PixelationNode+updateBefore"></a>

### pixelationNode.updateBefore(frame)
This method is used to update uniforms once per frame.

**Kind**: instance method of [<code>PixelationNode</code>](#PixelationNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="PixelationNode+setup"></a>

### pixelationNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>PixelationNode</code>](#PixelationNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="PixelationPassNode"></a>

## PixelationPassNode ⇐ <code>PassNode</code>
A special render pass node that renders the scene with a pixelation effect.

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [PixelationPassNode](#PixelationPassNode) ⇐ <code>PassNode</code>
    * [new PixelationPassNode(scene, camera, [pixelSize], [normalEdgeStrength], [depthEdgeStrength])](#new_PixelationPassNode_new)
    * [.pixelSize](#PixelationPassNode+pixelSize) : <code>number</code>
    * [.normalEdgeStrength](#PixelationPassNode+normalEdgeStrength) : <code>number</code>
    * [.depthEdgeStrength](#PixelationPassNode+depthEdgeStrength) : <code>number</code>
    * [.isPixelationPassNode](#PixelationPassNode+isPixelationPassNode) : <code>boolean</code>
    * [.setSize(width, height)](#PixelationPassNode+setSize)
    * [.setup(builder)](#PixelationPassNode+setup) ⇒ [<code>PixelationNode</code>](#PixelationNode)

<a name="new_PixelationPassNode_new"></a>

### new PixelationPassNode(scene, camera, [pixelSize], [normalEdgeStrength], [depthEdgeStrength])
Constructs a new pixelation pass node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera to render the scene with. |
| [pixelSize] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>6</code> | The pixel size. |
| [normalEdgeStrength] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.3</code> | The normal edge strength. |
| [depthEdgeStrength] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.4</code> | The depth edge strength. |

<a name="PixelationPassNode+pixelSize"></a>

### pixelationPassNode.pixelSize : <code>number</code>
The pixel size.

**Kind**: instance property of [<code>PixelationPassNode</code>](#PixelationPassNode)  
**Default**: <code>6</code>  
<a name="PixelationPassNode+normalEdgeStrength"></a>

### pixelationPassNode.normalEdgeStrength : <code>number</code>
The normal edge strength.

**Kind**: instance property of [<code>PixelationPassNode</code>](#PixelationPassNode)  
**Default**: <code>0.3</code>  
<a name="PixelationPassNode+depthEdgeStrength"></a>

### pixelationPassNode.depthEdgeStrength : <code>number</code>
The depth edge strength.

**Kind**: instance property of [<code>PixelationPassNode</code>](#PixelationPassNode)  
**Default**: <code>0.4</code>  
<a name="PixelationPassNode+isPixelationPassNode"></a>

### pixelationPassNode.isPixelationPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>PixelationPassNode</code>](#PixelationPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="PixelationPassNode+setSize"></a>

### pixelationPassNode.setSize(width, height)
Sets the size of the pass.

**Kind**: instance method of [<code>PixelationPassNode</code>](#PixelationPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the pass. |
| height | <code>number</code> | The height of the pass. |

<a name="PixelationPassNode+setup"></a>

### pixelationPassNode.setup(builder) ⇒ [<code>PixelationNode</code>](#PixelationNode)
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>PixelationPassNode</code>](#PixelationPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="pixelationPass"></a>

## pixelationPass(scene, camera, [pixelSize], [normalEdgeStrength], [depthEdgeStrength]) ⇒ [<code>PixelationPassNode</code>](#PixelationPassNode)
TSL function for creating a pixelation render pass node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| scene | <code>Scene</code> |  | The scene to render. |
| camera | <code>Camera</code> |  | The camera to render the scene with. |
| [pixelSize] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>6</code> | The pixel size. |
| [normalEdgeStrength] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.3</code> | The normal edge strength. |
| [depthEdgeStrength] | <code>Node.&lt;float&gt;</code> \| <code>number</code> | <code>0.4</code> | The depth edge strength. |

## Classes

<dl>
<dt><a href="#RGBShiftNode">RGBShiftNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for shifting/splitting RGB color channels. The effect
separates color channels and offsets them from each other.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#rgbShift">rgbShift(node, [amount], [angle])</a> ⇒ <code><a href="#RGBShiftNode">RGBShiftNode</a></code></dt>
<dd><p>TSL function for creating a RGB shift or split effect for post processing.</p>
</dd>
</dl>

<a name="RGBShiftNode"></a>

## RGBShiftNode ⇐ <code>TempNode</code>
Post processing node for shifting/splitting RGB color channels. The effect
separates color channels and offsets them from each other.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [RGBShiftNode](#RGBShiftNode) ⇐ <code>TempNode</code>
    * [new RGBShiftNode(textureNode, [amount], [angle])](#new_RGBShiftNode_new)
    * [.textureNode](#RGBShiftNode+textureNode) : <code>TextureNode</code>
    * [.amount](#RGBShiftNode+amount) : <code>UniformNode.&lt;float&gt;</code>
    * [.angle](#RGBShiftNode+angle) : <code>UniformNode.&lt;float&gt;</code>
    * [.setup(builder)](#RGBShiftNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_RGBShiftNode_new"></a>

### new RGBShiftNode(textureNode, [amount], [angle])
Constructs a new RGB shift node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>TextureNode</code> |  | The texture node that represents the input of the effect. |
| [amount] | <code>number</code> | <code>0.005</code> | The amount of the RGB shift. |
| [angle] | <code>number</code> | <code>0</code> | Defines the orientation in which colors are shifted. |

<a name="RGBShiftNode+textureNode"></a>

### rgbShiftNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>RGBShiftNode</code>](#RGBShiftNode)  
<a name="RGBShiftNode+amount"></a>

### rgbShiftNode.amount : <code>UniformNode.&lt;float&gt;</code>
The amount of the RGB shift.

**Kind**: instance property of [<code>RGBShiftNode</code>](#RGBShiftNode)  
<a name="RGBShiftNode+angle"></a>

### rgbShiftNode.angle : <code>UniformNode.&lt;float&gt;</code>
Defines in which direction colors are shifted.

**Kind**: instance property of [<code>RGBShiftNode</code>](#RGBShiftNode)  
<a name="RGBShiftNode+setup"></a>

### rgbShiftNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>RGBShiftNode</code>](#RGBShiftNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="rgbShift"></a>

## rgbShift(node, [amount], [angle]) ⇒ [<code>RGBShiftNode</code>](#RGBShiftNode)
TSL function for creating a RGB shift or split effect for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> |  | The node that represents the input of the effect. |
| [amount] | <code>number</code> | <code>0.005</code> | The amount of the RGB shift. |
| [angle] | <code>number</code> | <code>0</code> | Defines in which direction colors are shifted. |

## Classes

<dl>
<dt><a href="#SMAANode">SMAANode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for applying SMAA. Unlike FXAA, this node
should be applied before converting colors to sRGB. SMAA should produce
better results than FXAA but is also more expensive to execute.</p>
<p>Used Preset: SMAA 1x Medium (with color edge detection)
Reference: <a href="https://github.com/iryoku/smaa/releases/tag/v2.8">https://github.com/iryoku/smaa/releases/tag/v2.8</a>.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#smaa">smaa(node)</a> ⇒ <code><a href="#SMAANode">SMAANode</a></code></dt>
<dd><p>TSL function for creating a SMAA node for anti-aliasing via post processing.</p>
</dd>
</dl>

<a name="SMAANode"></a>

## SMAANode ⇐ <code>TempNode</code>
Post processing node for applying SMAA. Unlike FXAA, this node
should be applied before converting colors to sRGB. SMAA should produce
better results than FXAA but is also more expensive to execute.

Used Preset: SMAA 1x Medium (with color edge detection)
Reference: [https://github.com/iryoku/smaa/releases/tag/v2.8](https://github.com/iryoku/smaa/releases/tag/v2.8).

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [SMAANode](#SMAANode) ⇐ <code>TempNode</code>
    * [new SMAANode(textureNode)](#new_SMAANode_new)
    * [.textureNode](#SMAANode+textureNode) : <code>TextureNode</code>
    * [.updateBeforeType](#SMAANode+updateBeforeType) : <code>string</code>
    * [.getTextureNode()](#SMAANode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#SMAANode+setSize)
    * [.updateBefore(frame)](#SMAANode+updateBefore)
    * [.setup(builder)](#SMAANode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#SMAANode+dispose)

<a name="new_SMAANode_new"></a>

### new SMAANode(textureNode)
Constructs a new SMAA node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |

<a name="SMAANode+textureNode"></a>

### smaaNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>SMAANode</code>](#SMAANode)  
<a name="SMAANode+updateBeforeType"></a>

### smaaNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>SMAANode</code>](#SMAANode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="SMAANode+getTextureNode"></a>

### smaaNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="SMAANode+setSize"></a>

### smaaNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="SMAANode+updateBefore"></a>

### smaaNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="SMAANode+setup"></a>

### smaaNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SMAANode+dispose"></a>

### smaaNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>SMAANode</code>](#SMAANode)  
<a name="smaa"></a>

## smaa(node) ⇒ [<code>SMAANode</code>](#SMAANode)
TSL function for creating a SMAA node for anti-aliasing via post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |

## Classes

<dl>
<dt><a href="#SSAAPassNode">SSAAPassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>A special render pass node that renders the scene with SSAA (Supersampling Anti-Aliasing).
This manual SSAA approach re-renders the scene ones for each sample with camera jitter and accumulates the results.</p>
<p>This node produces a high-quality anti-aliased output but is also extremely expensive because of
its brute-force approach of re-rendering the entire scene multiple times.</p>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Supersampling">https://en.wikipedia.org/wiki/Supersampling</a></p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#ssaaPass">ssaaPass(scene, camera)</a> ⇒ <code><a href="#SSAAPassNode">SSAAPassNode</a></code></dt>
<dd><p>TSL function for creating a SSAA pass node for Supersampling Anti-Aliasing.</p>
</dd>
</dl>

<a name="SSAAPassNode"></a>

## SSAAPassNode ⇐ <code>PassNode</code>
A special render pass node that renders the scene with SSAA (Supersampling Anti-Aliasing).
This manual SSAA approach re-renders the scene ones for each sample with camera jitter and accumulates the results.

This node produces a high-quality anti-aliased output but is also extremely expensive because of
its brute-force approach of re-rendering the entire scene multiple times.

Reference: [https://en.wikipedia.org/wiki/Supersampling](https://en.wikipedia.org/wiki/Supersampling)

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [SSAAPassNode](#SSAAPassNode) ⇐ <code>PassNode</code>
    * [new SSAAPassNode(scene, camera)](#new_SSAAPassNode_new)
    * [.isSSAAPassNode](#SSAAPassNode+isSSAAPassNode) : <code>boolean</code>
    * [.sampleLevel](#SSAAPassNode+sampleLevel) : <code>number</code>
    * [.unbiased](#SSAAPassNode+unbiased) : <code>boolean</code>
    * [.clearColor](#SSAAPassNode+clearColor) : <code>Color</code>
    * [.clearAlpha](#SSAAPassNode+clearAlpha) : <code>number</code>
    * [.sampleWeight](#SSAAPassNode+sampleWeight) : <code>UniformNode.&lt;float&gt;</code>
    * [.updateBefore(frame)](#SSAAPassNode+updateBefore)
    * [.setup(builder)](#SSAAPassNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#SSAAPassNode+dispose)

<a name="new_SSAAPassNode_new"></a>

### new SSAAPassNode(scene, camera)
Constructs a new SSAA pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="SSAAPassNode+isSSAAPassNode"></a>

### ssaaPassNode.isSSAAPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="SSAAPassNode+sampleLevel"></a>

### ssaaPassNode.sampleLevel : <code>number</code>
The sample level specified  as n, where the number of samples is 2^n,
so sampleLevel = 4, is 2^4 samples, 16.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>4</code>  
<a name="SSAAPassNode+unbiased"></a>

### ssaaPassNode.unbiased : <code>boolean</code>
Whether rounding errors should be mitigated or not.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>true</code>  
<a name="SSAAPassNode+clearColor"></a>

### ssaaPassNode.clearColor : <code>Color</code>
The clear color of the pass.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>0x000000</code>  
<a name="SSAAPassNode+clearAlpha"></a>

### ssaaPassNode.clearAlpha : <code>number</code>
The clear alpha of the pass.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>0</code>  
<a name="SSAAPassNode+sampleWeight"></a>

### ssaaPassNode.sampleWeight : <code>UniformNode.&lt;float&gt;</code>
A uniform node representing the sample weight.

**Kind**: instance property of [<code>SSAAPassNode</code>](#SSAAPassNode)  
**Default**: <code>1</code>  
<a name="SSAAPassNode+updateBefore"></a>

### ssaaPassNode.updateBefore(frame)
This method is used to render the SSAA effect once per frame.

**Kind**: instance method of [<code>SSAAPassNode</code>](#SSAAPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="SSAAPassNode+setup"></a>

### ssaaPassNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's MRT configuration and quad mesh.

**Kind**: instance method of [<code>SSAAPassNode</code>](#SSAAPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SSAAPassNode+dispose"></a>

### ssaaPassNode.dispose()
Frees internal resources. This method should be called
when the pass is no longer required.

**Kind**: instance method of [<code>SSAAPassNode</code>](#SSAAPassNode)  
<a name="ssaaPass"></a>

## ssaaPass(scene, camera) ⇒ [<code>SSAAPassNode</code>](#SSAAPassNode)
TSL function for creating a SSAA pass node for Supersampling Anti-Aliasing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#SSRNode">SSRNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for computing screen space reflections (SSR).</p>
<p>Reference: <a href="https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html">https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html</a></p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#ssr">ssr(colorNode, depthNode, normalNode, metalnessNode, camera)</a> ⇒ <code><a href="#SSRNode">SSRNode</a></code></dt>
<dd><p>TSL function for creating screen space reflections (SSR).</p>
</dd>
</dl>

<a name="SSRNode"></a>

## SSRNode ⇐ <code>TempNode</code>
Post processing node for computing screen space reflections (SSR).

Reference: [https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html](https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html)

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [SSRNode](#SSRNode) ⇐ <code>TempNode</code>
    * [new SSRNode(colorNode, depthNode, normalNode, metalnessNode, camera)](#new_SSRNode_new)
    * [.colorNode](#SSRNode+colorNode) : <code>Node.&lt;vec4&gt;</code>
    * [.depthNode](#SSRNode+depthNode) : <code>Node.&lt;float&gt;</code>
    * [.normalNode](#SSRNode+normalNode) : <code>Node.&lt;vec3&gt;</code>
    * [.metalnessNode](#SSRNode+metalnessNode) : <code>Node.&lt;float&gt;</code>
    * [.camera](#SSRNode+camera) : <code>Camera</code>
    * [.resolutionScale](#SSRNode+resolutionScale) : <code>number</code>
    * [.updateBeforeType](#SSRNode+updateBeforeType) : <code>string</code>
    * [.maxDistance](#SSRNode+maxDistance) : <code>UniformNode.&lt;float&gt;</code>
    * [.thickness](#SSRNode+thickness) : <code>UniformNode.&lt;float&gt;</code>
    * [.opacity](#SSRNode+opacity) : <code>UniformNode.&lt;float&gt;</code>
    * [.getTextureNode()](#SSRNode+getTextureNode) ⇒ <code>PassTextureNode</code>
    * [.setSize(width, height)](#SSRNode+setSize)
    * [.updateBefore(frame)](#SSRNode+updateBefore)
    * [.setup(builder)](#SSRNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#SSRNode+dispose)

<a name="new_SSRNode_new"></a>

### new SSRNode(colorNode, depthNode, normalNode, metalnessNode, camera)
Constructs a new SSR node.


| Param | Type | Description |
| --- | --- | --- |
| colorNode | <code>Node.&lt;vec4&gt;</code> | The node that represents the beauty pass. |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the beauty pass's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the beauty pass's normals. |
| metalnessNode | <code>Node.&lt;float&gt;</code> | A node that represents the beauty pass's metalness. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="SSRNode+colorNode"></a>

### ssrNode.colorNode : <code>Node.&lt;vec4&gt;</code>
The node that represents the beauty pass.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+depthNode"></a>

### ssrNode.depthNode : <code>Node.&lt;float&gt;</code>
A node that represents the beauty pass's depth.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+normalNode"></a>

### ssrNode.normalNode : <code>Node.&lt;vec3&gt;</code>
A node that represents the beauty pass's normals.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+metalnessNode"></a>

### ssrNode.metalnessNode : <code>Node.&lt;float&gt;</code>
A node that represents the beauty pass's metalness.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+camera"></a>

### ssrNode.camera : <code>Camera</code>
The camera the scene is rendered with.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+resolutionScale"></a>

### ssrNode.resolutionScale : <code>number</code>
The resolution scale. By default SSR reflections
are computed in half resolutions. Setting the value
to `1` improves quality but also results in more
computational overhead.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
**Default**: <code>0.5</code>  
<a name="SSRNode+updateBeforeType"></a>

### ssrNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
its effect once per frame in `updateBefore()`.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="SSRNode+maxDistance"></a>

### ssrNode.maxDistance : <code>UniformNode.&lt;float&gt;</code>
Controls how far a fragment can reflect.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+thickness"></a>

### ssrNode.thickness : <code>UniformNode.&lt;float&gt;</code>
Controls the cutoff between what counts as a possible reflection hit and what does not.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+opacity"></a>

### ssrNode.opacity : <code>UniformNode.&lt;float&gt;</code>
Controls the transparency of the reflected colors.

**Kind**: instance property of [<code>SSRNode</code>](#SSRNode)  
<a name="SSRNode+getTextureNode"></a>

### ssrNode.getTextureNode() ⇒ <code>PassTextureNode</code>
Returns the result of the effect as a texture node.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  
**Returns**: <code>PassTextureNode</code> - A texture node that represents the result of the effect.  
<a name="SSRNode+setSize"></a>

### ssrNode.setSize(width, height)
Sets the size of the effect.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="SSRNode+updateBefore"></a>

### ssrNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="SSRNode+setup"></a>

### ssrNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="SSRNode+dispose"></a>

### ssrNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>SSRNode</code>](#SSRNode)  
<a name="ssr"></a>

## ssr(colorNode, depthNode, normalNode, metalnessNode, camera) ⇒ [<code>SSRNode</code>](#SSRNode)
TSL function for creating screen space reflections (SSR).

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| colorNode | <code>Node.&lt;vec4&gt;</code> | The node that represents the beauty pass. |
| depthNode | <code>Node.&lt;float&gt;</code> | A node that represents the beauty pass's depth. |
| normalNode | <code>Node.&lt;vec3&gt;</code> | A node that represents the beauty pass's normals. |
| metalnessNode | <code>Node.&lt;float&gt;</code> | A node that represents the beauty pass's metalness. |
| camera | <code>Camera</code> | The camera the scene is rendered with. |

<a name="sepia"></a>

## sepia(color) ⇒ <code>Node.&lt;vec4&gt;</code>
Applies a sepia effect to the given color node.

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The updated color node.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| color | <code>Node.&lt;vec4&gt;</code> | The color node to apply the sepia for. |

## Classes

<dl>
<dt><a href="#SobelOperatorNode">SobelOperatorNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for detecting edges with a sobel filter.
A sobel filter should be applied after tone mapping and output color
space conversion.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#sobel">sobel(node)</a> ⇒ <code><a href="#SobelOperatorNode">SobelOperatorNode</a></code></dt>
<dd><p>TSL function for creating a sobel operator node which performs edge detection with a sobel filter.</p>
</dd>
</dl>

<a name="SobelOperatorNode"></a>

## SobelOperatorNode ⇐ <code>TempNode</code>
Post processing node for detecting edges with a sobel filter.
A sobel filter should be applied after tone mapping and output color
space conversion.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [SobelOperatorNode](#SobelOperatorNode) ⇐ <code>TempNode</code>
    * [new SobelOperatorNode(textureNode)](#new_SobelOperatorNode_new)
    * [.textureNode](#SobelOperatorNode+textureNode) : <code>TextureNode</code>
    * [.updateBeforeType](#SobelOperatorNode+updateBeforeType) : <code>string</code>
    * [.updateBefore(frame)](#SobelOperatorNode+updateBefore)
    * [.setup(builder)](#SobelOperatorNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_SobelOperatorNode_new"></a>

### new SobelOperatorNode(textureNode)
Constructs a new sobel operator node.


| Param | Type | Description |
| --- | --- | --- |
| textureNode | <code>TextureNode</code> | The texture node that represents the input of the effect. |

<a name="SobelOperatorNode+textureNode"></a>

### sobelOperatorNode.textureNode : <code>TextureNode</code>
The texture node that represents the input of the effect.

**Kind**: instance property of [<code>SobelOperatorNode</code>](#SobelOperatorNode)  
<a name="SobelOperatorNode+updateBeforeType"></a>

### sobelOperatorNode.updateBeforeType : <code>string</code>
The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node updates
its internal uniforms once per frame in `updateBefore()`.

**Kind**: instance property of [<code>SobelOperatorNode</code>](#SobelOperatorNode)  
**Default**: <code>&quot;&#x27;frame&#x27;&quot;</code>  
<a name="SobelOperatorNode+updateBefore"></a>

### sobelOperatorNode.updateBefore(frame)
This method is used to update the effect's uniforms once per frame.

**Kind**: instance method of [<code>SobelOperatorNode</code>](#SobelOperatorNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="SobelOperatorNode+setup"></a>

### sobelOperatorNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>SobelOperatorNode</code>](#SobelOperatorNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="sobel"></a>

## sobel(node) ⇒ [<code>SobelOperatorNode</code>](#SobelOperatorNode)
TSL function for creating a sobel operator node which performs edge detection with a sobel filter.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| node | <code>Node.&lt;vec4&gt;</code> | The node that represents the input of the effect. |

<a name="StereoCompositePassNode"></a>

## *StereoCompositePassNode ⇐ <code>PassNode</code>*
A special (abstract) render pass node that renders the scene
as a stereoscopic image. Unlike [StereoPassNode](StereoPassNode), this
node merges the image for the left and right eye
into a single one. That is required for effects like
anaglyph or parallax barrier.

**Kind**: global abstract class  
**Extends**: <code>PassNode</code>  

* *[StereoCompositePassNode](#StereoCompositePassNode) ⇐ <code>PassNode</code>*
    * *[new StereoCompositePassNode(scene, camera)](#new_StereoCompositePassNode_new)*
    * *[.isStereoCompositePassNode](#StereoCompositePassNode+isStereoCompositePassNode) : <code>boolean</code>*
    * *[.stereo](#StereoCompositePassNode+stereo) : <code>StereoCamera</code>*
    * *[._renderTargetL](#StereoCompositePassNode+_renderTargetL) : <code>RenderTarget</code>*
    * *[._renderTargetR](#StereoCompositePassNode+_renderTargetR) : <code>RenderTarget</code>*
    * *[._mapLeft](#StereoCompositePassNode+_mapLeft) : <code>TextureNode</code>*
    * *[._mapRight](#StereoCompositePassNode+_mapRight) : <code>TextureNode</code>*
    * *[._material](#StereoCompositePassNode+_material) : <code>NodeMaterial</code>*
    * *[.updateStereoCamera(coordinateSystem)](#StereoCompositePassNode+updateStereoCamera)*
    * *[.setSize(width, height)](#StereoCompositePassNode+setSize)*
    * *[.updateBefore(frame)](#StereoCompositePassNode+updateBefore)*
    * *[.dispose()](#StereoCompositePassNode+dispose)*

<a name="new_StereoCompositePassNode_new"></a>

### *new StereoCompositePassNode(scene, camera)*
Constructs a new stereo composite pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="StereoCompositePassNode+isStereoCompositePassNode"></a>

### *stereoCompositePassNode.isStereoCompositePassNode : <code>boolean</code>*
This flag can be used for type testing.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StereoCompositePassNode+stereo"></a>

### *stereoCompositePassNode.stereo : <code>StereoCamera</code>*
The internal stereo camera that is used to render the scene.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_renderTargetL"></a>

### *stereoCompositePassNode.\_renderTargetL : <code>RenderTarget</code>*
The render target for rendering the left eye's view.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_renderTargetR"></a>

### *stereoCompositePassNode.\_renderTargetR : <code>RenderTarget</code>*
The render target for rendering the right eye's view.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_mapLeft"></a>

### *stereoCompositePassNode.\_mapLeft : <code>TextureNode</code>*
A texture node representing the left's eye view.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_mapRight"></a>

### *stereoCompositePassNode.\_mapRight : <code>TextureNode</code>*
A texture node representing the right's eye view.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+_material"></a>

### *stereoCompositePassNode.\_material : <code>NodeMaterial</code>*
The node material that implements the composite. All
derived effect passes must provide an instance for rendering.

**Kind**: instance property of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
<a name="StereoCompositePassNode+updateStereoCamera"></a>

### *stereoCompositePassNode.updateStereoCamera(coordinateSystem)*
Updates the internal stereo camera.

**Kind**: instance method of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  

| Param | Type | Description |
| --- | --- | --- |
| coordinateSystem | <code>number</code> | The current coordinate system. |

<a name="StereoCompositePassNode+setSize"></a>

### *stereoCompositePassNode.setSize(width, height)*
Sets the size of the pass.

**Kind**: instance method of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the pass. |
| height | <code>number</code> | The height of the pass. |

<a name="StereoCompositePassNode+updateBefore"></a>

### *stereoCompositePassNode.updateBefore(frame)*
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="StereoCompositePassNode+dispose"></a>

### *stereoCompositePassNode.dispose()*
Frees internal resources. This method should be called
when the pass is no longer required.

**Kind**: instance method of [<code>StereoCompositePassNode</code>](#StereoCompositePassNode)  
## Classes

<dl>
<dt><a href="#StereoPassNode">StereoPassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>A special render pass node that renders the scene as a stereoscopic image.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#stereoPass">stereoPass(scene, camera)</a> ⇒ <code><a href="#StereoPassNode">StereoPassNode</a></code></dt>
<dd><p>TSL function for creating a stereo pass node for stereoscopic rendering.</p>
</dd>
</dl>

<a name="StereoPassNode"></a>

## StereoPassNode ⇐ <code>PassNode</code>
A special render pass node that renders the scene as a stereoscopic image.

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [StereoPassNode](#StereoPassNode) ⇐ <code>PassNode</code>
    * [new StereoPassNode(scene, camera)](#new_StereoPassNode_new)
    * [.isStereoPassNode](#StereoPassNode+isStereoPassNode) : <code>boolean</code>
    * [.stereo](#StereoPassNode+stereo) : <code>StereoCamera</code>
    * [.updateBefore(frame)](#StereoPassNode+updateBefore)

<a name="new_StereoPassNode_new"></a>

### new StereoPassNode(scene, camera)
Constructs a new stereo pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="StereoPassNode+isStereoPassNode"></a>

### stereoPassNode.isStereoPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>StereoPassNode</code>](#StereoPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="StereoPassNode+stereo"></a>

### stereoPassNode.stereo : <code>StereoCamera</code>
The internal stereo camera that is used to render the scene.

**Kind**: instance property of [<code>StereoPassNode</code>](#StereoPassNode)  
<a name="StereoPassNode+updateBefore"></a>

### stereoPassNode.updateBefore(frame)
This method is used to render the stereo effect once per frame.

**Kind**: instance method of [<code>StereoPassNode</code>](#StereoPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="stereoPass"></a>

## stereoPass(scene, camera) ⇒ [<code>StereoPassNode</code>](#StereoPassNode)
TSL function for creating a stereo pass node for stereoscopic rendering.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#TRAAPassNode">TRAAPassNode</a> ⇐ <code>PassNode</code></dt>
<dd><p>A special render pass node that renders the scene with TRAA (Temporal Reprojection Anti-Aliasing).</p>
<p>Note: The current implementation does not yet support MRT setups.</p>
<p>References:</p>
<ul>
<li><a href="https://alextardif.com/TAA.html">https://alextardif.com/TAA.html</a></li>
<li><a href="https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/">https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/</a></li>
</ul>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#traaPass">traaPass(scene, camera)</a> ⇒ <code><a href="#TRAAPassNode">TRAAPassNode</a></code></dt>
<dd><p>TSL function for creating a TRAA pass node for Temporal Reprojection Anti-Aliasing.</p>
</dd>
</dl>

<a name="TRAAPassNode"></a>

## TRAAPassNode ⇐ <code>PassNode</code>
A special render pass node that renders the scene with TRAA (Temporal Reprojection Anti-Aliasing).

Note: The current implementation does not yet support MRT setups.

References:
- [https://alextardif.com/TAA.html](https://alextardif.com/TAA.html)
- [https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/](https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/)

**Kind**: global class  
**Extends**: <code>PassNode</code>  

* [TRAAPassNode](#TRAAPassNode) ⇐ <code>PassNode</code>
    * [new TRAAPassNode(scene, camera)](#new_TRAAPassNode_new)
    * [.isTRAAPassNode](#TRAAPassNode+isTRAAPassNode) : <code>boolean</code>
    * [.clearColor](#TRAAPassNode+clearColor) : <code>Color</code>
    * [.clearAlpha](#TRAAPassNode+clearAlpha) : <code>number</code>
    * [.setSize(width, height)](#TRAAPassNode+setSize) ⇒ <code>boolean</code>
    * [.updateBefore(frame)](#TRAAPassNode+updateBefore)
    * [.setup(builder)](#TRAAPassNode+setup) ⇒ <code>PassTextureNode</code>
    * [.dispose()](#TRAAPassNode+dispose)

<a name="new_TRAAPassNode_new"></a>

### new TRAAPassNode(scene, camera)
Constructs a new TRAA pass node.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

<a name="TRAAPassNode+isTRAAPassNode"></a>

### traaPassNode.isTRAAPassNode : <code>boolean</code>
This flag can be used for type testing.

**Kind**: instance property of [<code>TRAAPassNode</code>](#TRAAPassNode)  
**Default**: <code>true</code>  
**Read only**: true  
<a name="TRAAPassNode+clearColor"></a>

### traaPassNode.clearColor : <code>Color</code>
The clear color of the pass.

**Kind**: instance property of [<code>TRAAPassNode</code>](#TRAAPassNode)  
**Default**: <code>0x000000</code>  
<a name="TRAAPassNode+clearAlpha"></a>

### traaPassNode.clearAlpha : <code>number</code>
The clear alpha of the pass.

**Kind**: instance property of [<code>TRAAPassNode</code>](#TRAAPassNode)  
**Default**: <code>0</code>  
<a name="TRAAPassNode+setSize"></a>

### traaPassNode.setSize(width, height) ⇒ <code>boolean</code>
Sets the size of the effect.

**Kind**: instance method of [<code>TRAAPassNode</code>](#TRAAPassNode)  
**Returns**: <code>boolean</code> - Whether the TRAA needs a restart or not. That is required after a resize since buffer data with different sizes can't be resolved.  

| Param | Type | Description |
| --- | --- | --- |
| width | <code>number</code> | The width of the effect. |
| height | <code>number</code> | The height of the effect. |

<a name="TRAAPassNode+updateBefore"></a>

### traaPassNode.updateBefore(frame)
This method is used to render the effect once per frame.

**Kind**: instance method of [<code>TRAAPassNode</code>](#TRAAPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| frame | <code>NodeFrame</code> | The current node frame. |

<a name="TRAAPassNode+setup"></a>

### traaPassNode.setup(builder) ⇒ <code>PassTextureNode</code>
This method is used to setup the effect's render targets and TSL code.

**Kind**: instance method of [<code>TRAAPassNode</code>](#TRAAPassNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="TRAAPassNode+dispose"></a>

### traaPassNode.dispose()
Frees internal resources. This method should be called
when the effect is no longer required.

**Kind**: instance method of [<code>TRAAPassNode</code>](#TRAAPassNode)  
<a name="traaPass"></a>

## traaPass(scene, camera) ⇒ [<code>TRAAPassNode</code>](#TRAAPassNode)
TSL function for creating a TRAA pass node for Temporal Reprojection Anti-Aliasing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to render. |
| camera | <code>Camera</code> | The camera to render the scene with. |

## Classes

<dl>
<dt><a href="#TransitionNode">TransitionNode</a> ⇐ <code>TempNode</code></dt>
<dd><p>Post processing node for creating a transition effect between scenes.</p>
</dd>
</dl>

## Functions

<dl>
<dt><a href="#transition">transition(nodeA, nodeB, mixTextureNode, mixRatio, threshold, useTexture)</a> ⇒ <code><a href="#TransitionNode">TransitionNode</a></code></dt>
<dd><p>TSL function for creating a transition node for post processing.</p>
</dd>
</dl>

<a name="TransitionNode"></a>

## TransitionNode ⇐ <code>TempNode</code>
Post processing node for creating a transition effect between scenes.

**Kind**: global class  
**Extends**: <code>TempNode</code>  

* [TransitionNode](#TransitionNode) ⇐ <code>TempNode</code>
    * [new TransitionNode(textureNodeA, textureNodeB, mixTextureNode, mixRatioNode, thresholdNode, useTextureNode)](#new_TransitionNode_new)
    * [.textureNodeA](#TransitionNode+textureNodeA) : <code>TextureNode</code>
    * [.textureNodeB](#TransitionNode+textureNodeB) : <code>TextureNode</code>
    * [.mixTextureNode](#TransitionNode+mixTextureNode) : <code>TextureNode</code>
    * [.mixRatioNode](#TransitionNode+mixRatioNode) : <code>Node.&lt;float&gt;</code>
    * [.thresholdNode](#TransitionNode+thresholdNode) : <code>Node.&lt;float&gt;</code>
    * [.useTextureNode](#TransitionNode+useTextureNode) : <code>Node.&lt;float&gt;</code>
    * [.setup(builder)](#TransitionNode+setup) ⇒ <code>ShaderCallNodeInternal</code>

<a name="new_TransitionNode_new"></a>

### new TransitionNode(textureNodeA, textureNodeB, mixTextureNode, mixRatioNode, thresholdNode, useTextureNode)
Constructs a new transition node.


| Param | Type | Description |
| --- | --- | --- |
| textureNodeA | <code>TextureNode</code> | A texture node that represents the beauty pass of the first scene. |
| textureNodeB | <code>TextureNode</code> | A texture node that represents the beauty pass of the second scene. |
| mixTextureNode | <code>TextureNode</code> | A texture node that defines how the transition effect should look like. |
| mixRatioNode | <code>Node.&lt;float&gt;</code> | The interpolation factor that controls the mix. |
| thresholdNode | <code>Node.&lt;float&gt;</code> | Can be used to tweak the linear interpolation. |
| useTextureNode | <code>Node.&lt;float&gt;</code> | Whether `mixTextureNode` should influence the transition or not. |

<a name="TransitionNode+textureNodeA"></a>

### transitionNode.textureNodeA : <code>TextureNode</code>
A texture node that represents the beauty pass of the first scene.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+textureNodeB"></a>

### transitionNode.textureNodeB : <code>TextureNode</code>
A texture node that represents the beauty pass of the second scene.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+mixTextureNode"></a>

### transitionNode.mixTextureNode : <code>TextureNode</code>
A texture that defines how the transition effect should look like.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+mixRatioNode"></a>

### transitionNode.mixRatioNode : <code>Node.&lt;float&gt;</code>
The interpolation factor that controls the mix.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+thresholdNode"></a>

### transitionNode.thresholdNode : <code>Node.&lt;float&gt;</code>
Can be used to tweak the linear interpolation.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+useTextureNode"></a>

### transitionNode.useTextureNode : <code>Node.&lt;float&gt;</code>
Whether `mixTextureNode` should influence the transition or not.

**Kind**: instance property of [<code>TransitionNode</code>](#TransitionNode)  
<a name="TransitionNode+setup"></a>

### transitionNode.setup(builder) ⇒ <code>ShaderCallNodeInternal</code>
This method is used to setup the effect's TSL code.

**Kind**: instance method of [<code>TransitionNode</code>](#TransitionNode)  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>NodeBuilder</code> | The current node builder. |

<a name="transition"></a>

## transition(nodeA, nodeB, mixTextureNode, mixRatio, threshold, useTexture) ⇒ [<code>TransitionNode</code>](#TransitionNode)
TSL function for creating a transition node for post processing.

**Kind**: global function  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| nodeA | <code>Node.&lt;vec4&gt;</code> | A texture node that represents the beauty pass of the first scene. |
| nodeB | <code>Node.&lt;vec4&gt;</code> | A texture node that represents the beauty pass of the second scene. |
| mixTextureNode | <code>Node.&lt;vec4&gt;</code> | A texture that defines how the transition effect should look like. |
| mixRatio | <code>Node.&lt;float&gt;</code> \| <code>number</code> | The interpolation factor that controls the mix. |
| threshold | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Can be used to tweak the linear interpolation. |
| useTexture | <code>Node.&lt;float&gt;</code> \| <code>number</code> | Whether `mixTextureNode` should influence the transition or not. |

<a name="hashBlur"></a>

## hashBlur(textureNode, [bluramount], [repeats]) ⇒ <code>Node.&lt;vec4&gt;</code>
Applies a hash blur effect to the given texture node.

Reference: [https://www.shadertoy.com/view/4lXXWn](https://www.shadertoy.com/view/4lXXWn).

**Kind**: global function  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The blurred texture node.  
**Tsl**:   

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| textureNode | <code>Node.&lt;vec4&gt;</code> |  | The texture node that should be blurred. |
| [bluramount] | <code>Node.&lt;float&gt;</code> | <code>float(0.1)</code> | This node determines the amount of blur. |
| [repeats] | <code>Node.&lt;float&gt;</code> | <code>float(45)</code> | This node determines the quality of the blur. A higher value produces a less grainy result but is also more expensive. |

<a name="TiledLightsNode"></a>

## TiledLightsNode ⇐ <code>LightsNode</code>
A custom version of `LightsNode` implementing tiled lighting. This node is used in
[TiledLighting](TiledLighting) to overwrite the renderer's default lighting with
a custom implementation.

**Kind**: global class  
**Extends**: <code>LightsNode</code>  

* [TiledLightsNode](#TiledLightsNode) ⇐ <code>LightsNode</code>
    * [new TiledLightsNode([maxLights], [tileSize])](#new_TiledLightsNode_new)
    * [.maxLights](#TiledLightsNode+maxLights) : <code>number</code>
    * [.tileSize](#TiledLightsNode+tileSize) : <code>number</code>

<a name="new_TiledLightsNode_new"></a>

### new TiledLightsNode([maxLights], [tileSize])
Constructs a new tiled lights node.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [maxLights] | <code>number</code> | <code>1024</code> | The maximum number of lights. |
| [tileSize] | <code>number</code> | <code>32</code> | The tile size. |

<a name="TiledLightsNode+maxLights"></a>

### tiledLightsNode.maxLights : <code>number</code>
The maximum number of lights.

**Kind**: instance property of [<code>TiledLightsNode</code>](#TiledLightsNode)  
**Default**: <code>1024</code>  
<a name="TiledLightsNode+tileSize"></a>

### tiledLightsNode.tileSize : <code>number</code>
The tile size.

**Kind**: instance property of [<code>TiledLightsNode</code>](#TiledLightsNode)  
**Default**: <code>32</code>  
<a name="module_Bayer"></a>

## Bayer
<a name="module_Bayer.bayer16"></a>

### Bayer.bayer16(uv) ⇒ <code>Node.&lt;vec4&gt;</code>
This TSL function can be used to sample a Bayer16 texture which is a 16x16 texture with a Bayer Matrix pattern.
It can be used for dithering effects but also as an alternative to blue-noise. When used with Ray Marching
specifically in [VolumeNodeMaterial#offsetNode](VolumeNodeMaterial#offsetNode), it reduces banding problem, thus being able to use
fewer steps without affecting the visuals as much.

**Kind**: static method of [<code>Bayer</code>](#module_Bayer)  
**Returns**: <code>Node.&lt;vec4&gt;</code> - The sampled bayer value.  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| uv | <code>Node.&lt;vec2&gt;</code> | The uv to sample the bayer16 texture. |

<a name="module_Raymarching"></a>

## Raymarching
<a name="module_Raymarching.RaymarchingBox"></a>

### Raymarching.RaymarchingBox(steps, callback)
TSL function for performing raymarching in a box-area using the specified number of steps
and a callback function.

```js
RaymarchingBox( count, ( { positionRay } ) => {

} );
```

**Kind**: static method of [<code>Raymarching</code>](#module_Raymarching)  
**Tsl**:   

| Param | Type | Description |
| --- | --- | --- |
| steps | <code>number</code> \| <code>Node</code> | The number of steps for raymarching. |
| callback | <code>function</code> \| <code>FunctionNode</code> | The callback function to execute at each step. |

<a name="module_BufferGeometryUtils"></a>

## BufferGeometryUtils

* [BufferGeometryUtils](#module_BufferGeometryUtils)
    * [~computeMikkTSpaceTangents(geometry, MikkTSpace, [negateSign])](#module_BufferGeometryUtils..computeMikkTSpaceTangents) ⇒ <code>BufferGeometry</code>
    * [~mergeGeometries(geometries, [useGroups])](#module_BufferGeometryUtils..mergeGeometries) ⇒ <code>BufferGeometry</code>
    * [~mergeAttributes(attributes)](#module_BufferGeometryUtils..mergeAttributes) ⇒ <code>BufferAttribute</code>
    * [~deepCloneAttribute(attribute)](#module_BufferGeometryUtils..deepCloneAttribute) ⇒ <code>BufferAttribute</code>
    * [~interleaveAttributes(attributes)](#module_BufferGeometryUtils..interleaveAttributes) ⇒ <code>Array.&lt;InterleavedBufferAttribute&gt;</code>
    * [~deinterleaveAttribute(attribute)](#module_BufferGeometryUtils..deinterleaveAttribute) ⇒ <code>BufferAttribute</code>
    * [~deinterleaveGeometry(geometry)](#module_BufferGeometryUtils..deinterleaveGeometry)
    * [~estimateBytesUsed(geometry)](#module_BufferGeometryUtils..estimateBytesUsed) ⇒ <code>number</code>
    * [~mergeVertices(geometry, [tolerance])](#module_BufferGeometryUtils..mergeVertices) ⇒ <code>BufferGeometry</code>
    * [~toTrianglesDrawMode(geometry, drawMode)](#module_BufferGeometryUtils..toTrianglesDrawMode) ⇒ <code>BufferGeometry</code>
    * [~computeMorphedAttributes(object)](#module_BufferGeometryUtils..computeMorphedAttributes) ⇒ <code>Object</code>
    * [~mergeGroups(geometry)](#module_BufferGeometryUtils..mergeGroups) ⇒ <code>BufferGeometry</code>
    * [~toCreasedNormals(geometry, [creaseAngle])](#module_BufferGeometryUtils..toCreasedNormals) ⇒ <code>BufferGeometry</code>

<a name="module_BufferGeometryUtils..computeMikkTSpaceTangents"></a>

### BufferGeometryUtils~computeMikkTSpaceTangents(geometry, MikkTSpace, [negateSign]) ⇒ <code>BufferGeometry</code>
Computes vertex tangents using the MikkTSpace algorithm. MikkTSpace generates the same tangents consistently,
and is used in most modelling tools and normal map bakers. Use MikkTSpace for materials with normal maps,
because inconsistent tangents may lead to subtle visual issues in the normal map, particularly around mirrored
UV seams.

In comparison to this method, [BufferGeometry#computeTangents](BufferGeometry#computeTangents) (a custom algorithm) generates tangents that
probably will not match the tangents in other software. The custom algorithm is sufficient for general use with a
custom material, and may be faster than MikkTSpace.

Returns the original BufferGeometry. Indexed geometries will be de-indexed. Requires position, normal, and uv attributes.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - The updated geometry.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to compute tangents for. |
| MikkTSpace | <code>Object</code> |  | Instance of `examples/jsm/libs/mikktspace.module.js`, or `mikktspace` npm package. Await `MikkTSpace.ready` before use. |
| [negateSign] | <code>boolean</code> | <code>true</code> | Whether to negate the sign component (.w) of each tangent. Required for normal map conventions in some formats, including glTF. |

<a name="module_BufferGeometryUtils..mergeGeometries"></a>

### BufferGeometryUtils~mergeGeometries(geometries, [useGroups]) ⇒ <code>BufferGeometry</code>
Merges a set of geometries into a single instance. All geometries must have compatible attributes.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - The merged geometry. Returns `null` if the merge does not succeed.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometries | <code>Array.&lt;BufferGeometry&gt;</code> |  | The geometries to merge. |
| [useGroups] | <code>boolean</code> | <code>false</code> | Whether to use groups or not. |

<a name="module_BufferGeometryUtils..mergeAttributes"></a>

### BufferGeometryUtils~mergeAttributes(attributes) ⇒ <code>BufferAttribute</code>
Merges a set of attributes into a single instance. All attributes must have compatible properties and types.
Instances of [InterleavedBufferAttribute](InterleavedBufferAttribute) are not supported.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferAttribute</code> - The merged attribute. Returns `null` if the merge does not succeed.  

| Param | Type | Description |
| --- | --- | --- |
| attributes | <code>Array.&lt;BufferAttribute&gt;</code> | The attributes to merge. |

<a name="module_BufferGeometryUtils..deepCloneAttribute"></a>

### BufferGeometryUtils~deepCloneAttribute(attribute) ⇒ <code>BufferAttribute</code>
Performs a deep clone of the given buffer attribute.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferAttribute</code> - The cloned attribute.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>BufferAttribute</code> | The attribute to clone. |

<a name="module_BufferGeometryUtils..interleaveAttributes"></a>

### BufferGeometryUtils~interleaveAttributes(attributes) ⇒ <code>Array.&lt;InterleavedBufferAttribute&gt;</code>
Interleaves a set of attributes and returns a new array of corresponding attributes that share a
single [InterleavedBuffer](InterleavedBuffer) instance. All attributes must have compatible types.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>Array.&lt;InterleavedBufferAttribute&gt;</code> - An array of interleaved attributes. If interleave does not succeed, the method returns `null`.  

| Param | Type | Description |
| --- | --- | --- |
| attributes | <code>Array.&lt;BufferAttribute&gt;</code> | The attributes to interleave. |

<a name="module_BufferGeometryUtils..deinterleaveAttribute"></a>

### BufferGeometryUtils~deinterleaveAttribute(attribute) ⇒ <code>BufferAttribute</code>
Returns a new, non-interleaved version of the given attribute.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferAttribute</code> - The non-interleaved attribute.  

| Param | Type | Description |
| --- | --- | --- |
| attribute | <code>InterleavedBufferAttribute</code> | The interleaved attribute. |

<a name="module_BufferGeometryUtils..deinterleaveGeometry"></a>

### BufferGeometryUtils~deinterleaveGeometry(geometry)
Deinterleaves all attributes on the given geometry.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to deinterleave. |

<a name="module_BufferGeometryUtils..estimateBytesUsed"></a>

### BufferGeometryUtils~estimateBytesUsed(geometry) ⇒ <code>number</code>
Returns the amount of bytes used by all attributes to represent the geometry.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>number</code> - The estimate bytes used.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry. |

<a name="module_BufferGeometryUtils..mergeVertices"></a>

### BufferGeometryUtils~mergeVertices(geometry, [tolerance]) ⇒ <code>BufferGeometry</code>
Returns a new geometry with vertices for which all similar vertex attributes (within tolerance) are merged.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - - The new geometry with merged vertices.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to merge vertices for. |
| [tolerance] | <code>number</code> | <code>1e-4</code> | The tolerance value. |

<a name="module_BufferGeometryUtils..toTrianglesDrawMode"></a>

### BufferGeometryUtils~toTrianglesDrawMode(geometry, drawMode) ⇒ <code>BufferGeometry</code>
Returns a new indexed geometry based on `TrianglesDrawMode` draw mode.
This mode corresponds to the `gl.TRIANGLES` primitive in WebGL.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - The new geometry using `TrianglesDrawMode`.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to convert. |
| drawMode | <code>number</code> | The current draw mode. |

<a name="module_BufferGeometryUtils..computeMorphedAttributes"></a>

### BufferGeometryUtils~computeMorphedAttributes(object) ⇒ <code>Object</code>
Calculates the morphed attributes of a morphed/skinned BufferGeometry.

Helpful for Raytracing or Decals (i.e. a `DecalGeometry` applied to a morphed Object with a `BufferGeometry`
will use the original `BufferGeometry`, not the morphed/skinned one, generating an incorrect result.
Using this function to create a shadow `Object3`D the `DecalGeometry` can be correctly generated).

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>Object</code> - An object with original position/normal attributes and morphed ones.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Mesh</code> \| <code>Line</code> \| <code>Points</code> | The 3D object to compute morph attributes for. |

<a name="module_BufferGeometryUtils..mergeGroups"></a>

### BufferGeometryUtils~mergeGroups(geometry) ⇒ <code>BufferGeometry</code>
Merges the [BufferGeometry#groups](BufferGeometry#groups) for the given geometry.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - - The updated geometry  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry to modify. |

<a name="module_BufferGeometryUtils..toCreasedNormals"></a>

### BufferGeometryUtils~toCreasedNormals(geometry, [creaseAngle]) ⇒ <code>BufferGeometry</code>
Modifies the supplied geometry if it is non-indexed, otherwise creates a new,
non-indexed geometry. Returns the geometry with smooth normals everywhere except
faces that meet at an angle greater than the crease angle.

**Kind**: inner method of [<code>BufferGeometryUtils</code>](#module_BufferGeometryUtils)  
**Returns**: <code>BufferGeometry</code> - - The updated geometry  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry to modify. |
| [creaseAngle] | <code>number</code> | <code>Math.PI/3</code> | The crease angle in radians. |

<a name="module_CameraUtils"></a>

## CameraUtils
<a name="module_CameraUtils..frameCorners"></a>

### CameraUtils~frameCorners(camera, bottomLeftCorner, bottomRightCorner, topLeftCorner, [estimateViewFrustum])
Set projection matrix and the orientation of a perspective camera
to exactly frame the corners of an arbitrary rectangle.
NOTE: This function ignores the standard parameters;
do not call `updateProjectionMatrix()` after this.

**Kind**: inner method of [<code>CameraUtils</code>](#module_CameraUtils)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| camera | <code>PerspectiveCamera</code> |  | The camera. |
| bottomLeftCorner | <code>Vector3</code> |  | The bottom-left corner point. |
| bottomRightCorner | <code>Vector3</code> |  | The bottom-right corner point. |
| topLeftCorner | <code>Vector3</code> |  | The top-left corner point. |
| [estimateViewFrustum] | <code>boolean</code> | <code>false</code> | If set to `true`, the function tries to estimate the camera's FOV. |

<a name="module_GeometryCompressionUtils"></a>

## GeometryCompressionUtils

* [GeometryCompressionUtils](#module_GeometryCompressionUtils)
    * [~compressNormals(geometry, encodeMethod)](#module_GeometryCompressionUtils..compressNormals)
    * [~compressPositions(geometry)](#module_GeometryCompressionUtils..compressPositions)
    * [~compressUvs(geometry)](#module_GeometryCompressionUtils..compressUvs)

<a name="module_GeometryCompressionUtils..compressNormals"></a>

### GeometryCompressionUtils~compressNormals(geometry, encodeMethod)
Compressed the given geometry's `normal` attribute by the selected encode method.

**Kind**: inner method of [<code>GeometryCompressionUtils</code>](#module_GeometryCompressionUtils)  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry whose normals should be compressed. |
| encodeMethod | <code>&#x27;DEFAULT&#x27;</code> \| <code>&#x27;OCT1Byte&#x27;</code> \| <code>&#x27;OCT2Byte&#x27;</code> \| <code>&#x27;ANGLES&#x27;</code> | The compression method. |

<a name="module_GeometryCompressionUtils..compressPositions"></a>

### GeometryCompressionUtils~compressPositions(geometry)
Compressed the given geometry's `position` attribute.

**Kind**: inner method of [<code>GeometryCompressionUtils</code>](#module_GeometryCompressionUtils)  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry whose position values should be compressed. |

<a name="module_GeometryCompressionUtils..compressUvs"></a>

### GeometryCompressionUtils~compressUvs(geometry)
Compressed the given geometry's `uv` attribute.

**Kind**: inner method of [<code>GeometryCompressionUtils</code>](#module_GeometryCompressionUtils)  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry whose texture coordinates should be compressed. |

<a name="module_GeometryUtils"></a>

## GeometryUtils

* [GeometryUtils](#module_GeometryUtils)
    * [~hilbert2D([center], [size], [iterations], [v0], [v1], [v2], [v3])](#module_GeometryUtils..hilbert2D) ⇒ <code>Array.&lt;Vector3&gt;</code>
    * [~hilbert3D([center], [size], [iterations], [v0], [v1], [v2], [v3], [v4], [v5], [v6], [v7])](#module_GeometryUtils..hilbert3D) ⇒ <code>Array.&lt;Vector3&gt;</code>
    * [~gosper([size])](#module_GeometryUtils..gosper) ⇒ <code>Array.&lt;number&gt;</code>

<a name="module_GeometryUtils..hilbert2D"></a>

### GeometryUtils~hilbert2D([center], [size], [iterations], [v0], [v1], [v2], [v3]) ⇒ <code>Array.&lt;Vector3&gt;</code>
Generates 2D-Coordinates along a Hilbert curve.

Based on work by: [http://www.openprocessing.org/sketch/15493](http://www.openprocessing.org/sketch/15493)

**Kind**: inner method of [<code>GeometryUtils</code>](#module_GeometryUtils)  
**Returns**: <code>Array.&lt;Vector3&gt;</code> - The Hilbert curve points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [center] | <code>Vector3</code> |  | Center of Hilbert curve. |
| [size] | <code>number</code> | <code>10</code> | Total width of Hilbert curve. |
| [iterations] | <code>number</code> | <code>10</code> | Number of subdivisions. |
| [v0] | <code>number</code> | <code>0</code> | Corner index -X, -Z. |
| [v1] | <code>number</code> | <code>1</code> | Corner index -X, +Z. |
| [v2] | <code>number</code> | <code>2</code> | Corner index +X, +Z. |
| [v3] | <code>number</code> | <code>3</code> | Corner index +X, -Z. |

<a name="module_GeometryUtils..hilbert3D"></a>

### GeometryUtils~hilbert3D([center], [size], [iterations], [v0], [v1], [v2], [v3], [v4], [v5], [v6], [v7]) ⇒ <code>Array.&lt;Vector3&gt;</code>
Generates 3D-Coordinates along a Hilbert curve.

Based on work by: [https://openprocessing.org/user/5654](https://openprocessing.org/user/5654)

**Kind**: inner method of [<code>GeometryUtils</code>](#module_GeometryUtils)  
**Returns**: <code>Array.&lt;Vector3&gt;</code> - - The Hilbert curve points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [center] | <code>Vector3</code> |  | Center of Hilbert curve. |
| [size] | <code>number</code> | <code>10</code> | Total width of Hilbert curve. |
| [iterations] | <code>number</code> | <code>1</code> | Number of subdivisions. |
| [v0] | <code>number</code> | <code>0</code> | Corner index -X, +Y, -Z. |
| [v1] | <code>number</code> | <code>1</code> | Corner index -X, +Y, +Z. |
| [v2] | <code>number</code> | <code>2</code> | Corner index -X, -Y, +Z. |
| [v3] | <code>number</code> | <code>3</code> | Corner index -X, -Y, -Z. |
| [v4] | <code>number</code> | <code>4</code> | Corner index +X, -Y, -Z. |
| [v5] | <code>number</code> | <code>5</code> | Corner index +X, -Y, +Z. |
| [v6] | <code>number</code> | <code>6</code> | Corner index +X, +Y, +Z. |
| [v7] | <code>number</code> | <code>7</code> | Corner index +X, +Y, -Z. |

<a name="module_GeometryUtils..gosper"></a>

### GeometryUtils~gosper([size]) ⇒ <code>Array.&lt;number&gt;</code>
Generates a Gosper curve (lying in the XY plane).

Reference: [https://gist.github.com/nitaku/6521802](https://gist.github.com/nitaku/6521802)

**Kind**: inner method of [<code>GeometryUtils</code>](#module_GeometryUtils)  
**Returns**: <code>Array.&lt;number&gt;</code> - The gosper island points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [size] | <code>number</code> | <code>1</code> | The size of a single gosper island. |

<a name="LDrawUtils"></a>

## LDrawUtils
Utility class for LDraw models.

**Kind**: global class  
<a name="LDrawUtils.mergeObject"></a>

### LDrawUtils.mergeObject(object) ⇒ <code>Group</code>
Merges geometries in the given object by materials and returns a new group object.
Use on not indexed geometries. The object buffers reference the old object ones.
Special treatment is done to the conditional lines generated by LDrawLoader.

**Kind**: static method of [<code>LDrawUtils</code>](#LDrawUtils)  
**Returns**: <code>Group</code> - The merged object.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The object to merge. |

<a name="SceneOptimizer"></a>

## SceneOptimizer
This class can be used to optimized scenes by converting
individual meshes into [BatchedMesh](BatchedMesh). This component
is an experimental attempt to implement auto-batching in three.js.

**Kind**: global class  

* [SceneOptimizer](#SceneOptimizer)
    * [new SceneOptimizer(scene, options)](#new_SceneOptimizer_new)
    * _instance_
        * [.removeEmptyNodes(object)](#SceneOptimizer+removeEmptyNodes)
        * [.disposeMeshes(meshesToRemove)](#SceneOptimizer+disposeMeshes)
        * [.toBatchedMesh()](#SceneOptimizer+toBatchedMesh) ⇒ <code>Scene</code>
        * *[.toInstancingMesh()](#SceneOptimizer+toInstancingMesh) ⇒ <code>Scene</code>*
    * _inner_
        * [~Options](#SceneOptimizer..Options) : <code>Object</code>

<a name="new_SceneOptimizer_new"></a>

### new SceneOptimizer(scene, options)
Constructs a new scene optimizer.


| Param | Type | Description |
| --- | --- | --- |
| scene | <code>Scene</code> | The scene to optimize. |
| options | [<code>Options</code>](#SceneOptimizer..Options) | The configuration options. |

<a name="SceneOptimizer+removeEmptyNodes"></a>

### sceneOptimizer.removeEmptyNodes(object)
Removes empty nodes from all descendants of the given 3D object.

**Kind**: instance method of [<code>SceneOptimizer</code>](#SceneOptimizer)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object to process. |

<a name="SceneOptimizer+disposeMeshes"></a>

### sceneOptimizer.disposeMeshes(meshesToRemove)
Removes the given array of meshes from the scene.

**Kind**: instance method of [<code>SceneOptimizer</code>](#SceneOptimizer)  

| Param | Type | Description |
| --- | --- | --- |
| meshesToRemove | <code>Set.&lt;Mesh&gt;</code> | The meshes to remove. |

<a name="SceneOptimizer+toBatchedMesh"></a>

### sceneOptimizer.toBatchedMesh() ⇒ <code>Scene</code>
Performs the auto-baching by identifying groups of meshes in the scene
that can be represented as a single [BatchedMesh](BatchedMesh). The method modifies
the scene by adding instances of `BatchedMesh` and removing the now redundant
individual meshes.

**Kind**: instance method of [<code>SceneOptimizer</code>](#SceneOptimizer)  
**Returns**: <code>Scene</code> - The optimized scene.  
<a name="SceneOptimizer+toInstancingMesh"></a>

### *sceneOptimizer.toInstancingMesh() ⇒ <code>Scene</code>*
Performs the auto-instancing by identifying groups of meshes in the scene
that can be represented as a single [InstancedMesh](InstancedMesh). The method modifies
the scene by adding instances of `InstancedMesh` and removing the now redundant
individual meshes.

This method is not yet implemented.

**Kind**: instance abstract method of [<code>SceneOptimizer</code>](#SceneOptimizer)  
**Returns**: <code>Scene</code> - The optimized scene.  
<a name="SceneOptimizer..Options"></a>

### SceneOptimizer~Options : <code>Object</code>
Constructor options of `SceneOptimizer`.

**Kind**: inner typedef of [<code>SceneOptimizer</code>](#SceneOptimizer)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [debug] | <code>boolean</code> | <code>false</code> | Whether to enable debug mode or not. |

<a name="module_SceneUtils"></a>

## SceneUtils

* [SceneUtils](#module_SceneUtils)
    * [~createMeshesFromInstancedMesh(instancedMesh)](#module_SceneUtils..createMeshesFromInstancedMesh) ⇒ <code>Group</code>
    * [~createMeshesFromMultiMaterialMesh(mesh)](#module_SceneUtils..createMeshesFromMultiMaterialMesh) ⇒ <code>Group</code>
    * [~createMultiMaterialObject(geometry, materials)](#module_SceneUtils..createMultiMaterialObject) ⇒ <code>Group</code>
    * [~reduceVertices(object, func, initialValue)](#module_SceneUtils..reduceVertices) ⇒ <code>any</code>
    * [~sortInstancedMesh(mesh, compareFn)](#module_SceneUtils..sortInstancedMesh)
    * [~traverseGenerator(object)](#module_SceneUtils..traverseGenerator)
    * [~traverseVisibleGenerator(object)](#module_SceneUtils..traverseVisibleGenerator)
    * [~traverseAncestorsGenerator(object)](#module_SceneUtils..traverseAncestorsGenerator)

<a name="module_SceneUtils..createMeshesFromInstancedMesh"></a>

### SceneUtils~createMeshesFromInstancedMesh(instancedMesh) ⇒ <code>Group</code>
This function creates a mesh for each instance of the given instanced mesh and
adds it to a group. Each mesh will honor the current 3D transformation of its
corresponding instance.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  
**Returns**: <code>Group</code> - A group of meshes.  

| Param | Type | Description |
| --- | --- | --- |
| instancedMesh | <code>InstancedMesh</code> | The instanced mesh. |

<a name="module_SceneUtils..createMeshesFromMultiMaterialMesh"></a>

### SceneUtils~createMeshesFromMultiMaterialMesh(mesh) ⇒ <code>Group</code>
This function creates a mesh for each geometry-group of the given multi-material mesh and
adds it to a group.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  
**Returns**: <code>Group</code> - A group of meshes.  

| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>Mesh</code> | The multi-material mesh. |

<a name="module_SceneUtils..createMultiMaterialObject"></a>

### SceneUtils~createMultiMaterialObject(geometry, materials) ⇒ <code>Group</code>
This function represents an alternative way to create 3D objects with multiple materials.
Normally, [BufferGeometry#groups](BufferGeometry#groups) are used which might introduce issues e.g. when
exporting the object to a 3D format. This function accepts a geometry and an array of
materials and creates for each material a mesh that is added to a group.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  
**Returns**: <code>Group</code> - A group representing a multi-material object.  

| Param | Type | Description |
| --- | --- | --- |
| geometry | <code>BufferGeometry</code> | The geometry. |
| materials | <code>Array.&lt;Material&gt;</code> | An array of materials. |

<a name="module_SceneUtils..reduceVertices"></a>

### SceneUtils~reduceVertices(object, func, initialValue) ⇒ <code>any</code>
Executes a reducer function for each vertex of the given 3D object.
`reduceVertices()` returns a single value: the function's accumulated result.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  
**Returns**: <code>any</code> - The result.  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | The 3D object that should be processed. It must have a geometry with a `position` attribute. |
| func | <code>function</code> | The reducer function. First argument is the current value, second argument the current vertex. |
| initialValue | <code>any</code> | The initial value. |

<a name="module_SceneUtils..sortInstancedMesh"></a>

### SceneUtils~sortInstancedMesh(mesh, compareFn)
Sorts the instances of the given instanced mesh.

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  

| Param | Type | Description |
| --- | --- | --- |
| mesh | <code>InstancedMesh</code> | The instanced mesh to sort. |
| compareFn | <code>function</code> | A custom compare function for the sort. |

<a name="module_SceneUtils..traverseGenerator"></a>

### SceneUtils~traverseGenerator(object)
Generator based alternative to [Object3D#traverse](Object3D#traverse).

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | Object to traverse. |

<a name="module_SceneUtils..traverseVisibleGenerator"></a>

### SceneUtils~traverseVisibleGenerator(object)
Generator based alternative to [Object3D#traverseVisible](Object3D#traverseVisible).

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | Object to traverse. |

<a name="module_SceneUtils..traverseAncestorsGenerator"></a>

### SceneUtils~traverseAncestorsGenerator(object)
Generator based alternative to [Object3D#traverseAncestors](Object3D#traverseAncestors).

**Kind**: inner method of [<code>SceneUtils</code>](#module_SceneUtils)  

| Param | Type | Description |
| --- | --- | --- |
| object | <code>Object3D</code> | Object to traverse. |

<a name="ShadowMapViewer"></a>

## ShadowMapViewer
This is a helper for visualising a given light's shadow map.
It works for shadow casting lights: DirectionalLight and SpotLight.
It renders out the shadow map and displays it on a HUD.

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
import the class from `ShadowMapViewerGPU.js`.

```js
const lightShadowMapViewer = new ShadowMapViewer( light );
lightShadowMapViewer.position.x = 10;
lightShadowMapViewer.position.y = SCREEN_HEIGHT - ( SHADOW_MAP_HEIGHT / 4 ) - 10;
lightShadowMapViewer.size.width = SHADOW_MAP_WIDTH / 4;
lightShadowMapViewer.size.height = SHADOW_MAP_HEIGHT / 4;
lightShadowMapViewer.update();
```

**Kind**: global class  

* [ShadowMapViewer](#ShadowMapViewer)
    * [new ShadowMapViewer(light)](#new_ShadowMapViewer_new)
    * [.enabled](#ShadowMapViewer+enabled) : <code>boolean</code>
    * [.size](#ShadowMapViewer+size) : <code>Object</code>
    * [.position](#ShadowMapViewer+position) : <code>Object</code>
    * [.render(renderer)](#ShadowMapViewer+render)
    * [.updateForWindowResize()](#ShadowMapViewer+updateForWindowResize)
    * [.update()](#ShadowMapViewer+update)

<a name="new_ShadowMapViewer_new"></a>

### new ShadowMapViewer(light)
Constructs a new shadow map viewer.


| Param | Type | Description |
| --- | --- | --- |
| light | <code>Light</code> | The shadow casting light. |

<a name="ShadowMapViewer+enabled"></a>

### shadowMapViewer.enabled : <code>boolean</code>
Whether to display the shadow map viewer or not.

**Kind**: instance property of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
**Default**: <code>true</code>  
<a name="ShadowMapViewer+size"></a>

### shadowMapViewer.size : <code>Object</code>
The size of the viewer. When changing this property, make sure
to call [update](#ShadowMapViewer+update).

**Kind**: instance property of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
**Default**: <code>true</code>  
<a name="ShadowMapViewer+position"></a>

### shadowMapViewer.position : <code>Object</code>
The position of the viewer. When changing this property, make sure
to call [update](#ShadowMapViewer+update).

**Kind**: instance property of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
**Default**: <code>true</code>  
<a name="ShadowMapViewer+render"></a>

### shadowMapViewer.render(renderer)
Renders the viewer. This method must be called in the app's animation loop.

**Kind**: instance method of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> | The renderer. |

<a name="ShadowMapViewer+updateForWindowResize"></a>

### shadowMapViewer.updateForWindowResize()
Resizes the viewer. This method should be called whenever the app's
window is resized.

**Kind**: instance method of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
<a name="ShadowMapViewer+update"></a>

### shadowMapViewer.update()
Updates the viewer.

**Kind**: instance method of [<code>ShadowMapViewer</code>](#ShadowMapViewer)  
<a name="module_SkeletonUtils"></a>

## SkeletonUtils

* [SkeletonUtils](#module_SkeletonUtils)
    * [~retarget(target, source, options)](#module_SkeletonUtils..retarget)
    * [~retargetClip(target, source, clip, options)](#module_SkeletonUtils..retargetClip) ⇒ <code>AnimationClip</code>
    * [~clone(source)](#module_SkeletonUtils..clone) ⇒ <code>Object3D</code>
    * [~RetargetOptions](#module_SkeletonUtils..RetargetOptions) : <code>Object</code>

<a name="module_SkeletonUtils..retarget"></a>

### SkeletonUtils~retarget(target, source, options)
Retargets the skeleton from the given source 3D object to the
target 3D object.

**Kind**: inner method of [<code>SkeletonUtils</code>](#module_SkeletonUtils)  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Object3D</code> | The target 3D object. |
| source | <code>Object3D</code> | The source 3D object. |
| options | [<code>RetargetOptions</code>](#module_SkeletonUtils..RetargetOptions) | The options. |

<a name="module_SkeletonUtils..retargetClip"></a>

### SkeletonUtils~retargetClip(target, source, clip, options) ⇒ <code>AnimationClip</code>
Retargets the animation clip of the source object to the
target 3D object.

**Kind**: inner method of [<code>SkeletonUtils</code>](#module_SkeletonUtils)  
**Returns**: <code>AnimationClip</code> - The retargeted animation clip.  

| Param | Type | Description |
| --- | --- | --- |
| target | <code>Object3D</code> | The target 3D object. |
| source | <code>Object3D</code> | The source 3D object. |
| clip | <code>AnimationClip</code> | The animation clip. |
| options | [<code>RetargetOptions</code>](#module_SkeletonUtils..RetargetOptions) | The options. |

<a name="module_SkeletonUtils..clone"></a>

### SkeletonUtils~clone(source) ⇒ <code>Object3D</code>
Clones the given 3D object and its descendants, ensuring that any `SkinnedMesh` instances are
correctly associated with their bones. Bones are also cloned, and must be descendants of the
object passed to this method. Other data, like geometries and materials, are reused by reference.

**Kind**: inner method of [<code>SkeletonUtils</code>](#module_SkeletonUtils)  
**Returns**: <code>Object3D</code> - The cloned 3D object.  

| Param | Type | Description |
| --- | --- | --- |
| source | <code>Object3D</code> | The 3D object to clone. |

<a name="module_SkeletonUtils..RetargetOptions"></a>

### SkeletonUtils~RetargetOptions : <code>Object</code>
Retarget options of `SkeletonUtils`.

**Kind**: inner typedef of [<code>SkeletonUtils</code>](#module_SkeletonUtils)  
**Properties**

| Name | Type | Default | Description |
| --- | --- | --- | --- |
| [useFirstFramePosition] | <code>boolean</code> | <code>false</code> | Whether to use the position of the first frame or not. |
| [fps] | <code>number</code> |  | The FPS of the clip. |
| [names] | <code>Object.&lt;string, string&gt;</code> |  | A dictionary for mapping target to source bone names. |
| [getBoneName] | <code>function</code> |  | A function for mapping bone names. Alternative to `names`. |
| [trim] | <code>Array.&lt;number&gt;</code> |  | Whether to trim the clip or not. If set the array should hold two values for the start and end. |
| [preserveBoneMatrix] | <code>boolean</code> | <code>true</code> | Whether to preserve bone matrices or not. |
| [preserveBonePositions] | <code>boolean</code> | <code>true</code> | Whether to preserve bone positions or not. |
| [useTargetMatrix] | <code>boolean</code> | <code>false</code> | Whether to use the target matrix or not. |
| [hip] | <code>string</code> | <code>&quot;&#x27;hip&#x27;&quot;</code> | The name of the source's hip bone. |
| [hipInfluence] | <code>Vector3</code> | <code>(1,1,1)</code> | The hip influence. |
| [scale] | <code>number</code> | <code>1</code> | The scale. |

<a name="module_SortUtils"></a>

## SortUtils
<a name="module_SortUtils.radixSort"></a>

### SortUtils.radixSort(arr, opt)
Hybrid radix sort from.

- [https://gist.github.com/sciecode/93ed864dd77c5c8803c6a86698d68dab](https://gist.github.com/sciecode/93ed864dd77c5c8803c6a86698d68dab)
- [https://github.com/mrdoob/three.js/pull/27202#issuecomment-1817640271](https://github.com/mrdoob/three.js/pull/27202#issuecomment-1817640271)

Expects unsigned 32b integer values.

**Kind**: static method of [<code>SortUtils</code>](#module_SortUtils)  

| Param | Type | Description |
| --- | --- | --- |
| arr | <code>Array.&lt;Object&gt;</code> | The array to sort. |
| opt | <code>Object</code> | The options |

<a name="module_UVsDebug"></a>

## UVsDebug
<a name="module_UVsDebug..UVsDebug"></a>

### UVsDebug~UVsDebug(geometry, [size]) ⇒ <code>HTMLCanvasElement</code>
Function for "unwrapping" and debugging three.js geometries UV mapping.

```js
document.body.appendChild( UVsDebug( new THREE.SphereGeometry() ) );
```

**Kind**: inner method of [<code>UVsDebug</code>](#module_UVsDebug)  
**Returns**: <code>HTMLCanvasElement</code> - A canvas element with visualized uv coordinates.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| geometry | <code>BufferGeometry</code> |  | The geometry whose uv coordinates should be inspected. |
| [size] | <code>number</code> | <code>1024</code> | The size of the debug canvas. |

<a name="module_WebGLTextureUtils"></a>

## WebGLTextureUtils
<a name="module_WebGLTextureUtils.decompress"></a>

### WebGLTextureUtils.decompress(texture, [maxTextureSize], [renderer]) ⇒ <code>CanvasTexture</code>
Returns an uncompressed version of the given compressed texture.

This module can only be used with [WebGLRenderer](WebGLRenderer). When using [WebGPURenderer](WebGPURenderer),
import the function from [WebGPUTextureUtils](WebGPUTextureUtils).

**Kind**: static method of [<code>WebGLTextureUtils</code>](#module_WebGLTextureUtils)  
**Returns**: <code>CanvasTexture</code> - The uncompressed texture.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| texture | <code>CompressedTexture</code> |  | The compressed texture. |
| [maxTextureSize] | <code>number</code> | <code>Infinity</code> | The maximum size of the uncompressed texture. |
| [renderer] | <code>WebGLRenderer</code> | <code></code> | A reference to a renderer. |

<a name="module_WebGPUTextureUtils"></a>

## WebGPUTextureUtils
<a name="module_WebGPUTextureUtils.decompress"></a>

### WebGPUTextureUtils.decompress(blitTexture, [maxTextureSize], [renderer]) ⇒ <code>Promise.&lt;CanvasTexture&gt;</code>
Returns an uncompressed version of the given compressed texture.

This module can only be used with [WebGPURenderer](WebGPURenderer). When using [WebGLRenderer](WebGLRenderer),
import the function from [WebGLTextureUtils](WebGLTextureUtils).

**Kind**: static method of [<code>WebGPUTextureUtils</code>](#module_WebGPUTextureUtils)  
**Returns**: <code>Promise.&lt;CanvasTexture&gt;</code> - A Promise that resolved with the uncompressed texture.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| blitTexture | <code>CompressedTexture</code> |  | The compressed texture. |
| [maxTextureSize] | <code>number</code> | <code>Infinity</code> | The maximum size of the uncompressed texture. |
| [renderer] | <code>WebGPURenderer</code> | <code></code> | A reference to a renderer. |

<a name="ARButton"></a>

## ARButton
A utility class for creating a button that allows to initiate
immersive AR sessions based on WebXR. The button can be created
with a factory method and then appended ot the website's DOM.

```js
document.body.appendChild( ARButton.createButton( renderer ) );
```

**Kind**: global class  
<a name="ARButton.createButton"></a>

### ARButton.createButton(renderer, [sessionInit]) ⇒ <code>HTMLElement</code>
Constructs a new AR button.

**Kind**: static method of [<code>ARButton</code>](#ARButton)  
**Returns**: <code>HTMLElement</code> - The button or an error message if `immersive-ar` isn't supported.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> \| <code>WebGPURenderer</code> | The renderer. |
| [sessionInit] | <code>XRSessionInit</code> | The a configuration object for the AR session. |

<a name="OculusHandModel"></a>

## OculusHandModel ⇐ <code>Object3D</code>
Represents an Oculus hand model.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [OculusHandModel](#OculusHandModel) ⇐ <code>Object3D</code>
    * [new OculusHandModel(controller, [loader], [onLoad])](#new_OculusHandModel_new)
    * [.controller](#OculusHandModel+controller) : <code>Group</code>
    * [.motionController](#OculusHandModel+motionController) : <code>MotionController</code>
    * [.envMap](#OculusHandModel+envMap) : <code>Texture</code>
    * [.loader](#OculusHandModel+loader) : <code>Loader</code>
    * [.onLoad](#OculusHandModel+onLoad) : <code>function</code>
    * [.path](#OculusHandModel+path) : <code>string</code>
    * [.mesh](#OculusHandModel+mesh) : <code>Mesh</code>
    * [.updateMatrixWorld([force])](#OculusHandModel+updateMatrixWorld)
    * [.getPointerPosition()](#OculusHandModel+getPointerPosition) ⇒ <code>Vector3</code> \| <code>null</code>
    * [.intersectBoxObject(boxObject)](#OculusHandModel+intersectBoxObject) ⇒ <code>boolean</code>
    * [.checkButton(button)](#OculusHandModel+checkButton)

<a name="new_OculusHandModel_new"></a>

### new OculusHandModel(controller, [loader], [onLoad])
Constructs a new Oculus hand model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| controller | <code>Group</code> |  | The hand controller. |
| [loader] | <code>Loader</code> | <code></code> | A loader that is used to load hand models. |
| [onLoad] | <code>function</code> | <code></code> | A callback that is executed when a hand model has been loaded. |

<a name="OculusHandModel+controller"></a>

### oculusHandModel.controller : <code>Group</code>
The hand controller.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
<a name="OculusHandModel+motionController"></a>

### oculusHandModel.motionController : <code>MotionController</code>
The motion controller.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+envMap"></a>

### oculusHandModel.envMap : <code>Texture</code>
The model's environment map.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+loader"></a>

### oculusHandModel.loader : <code>Loader</code>
A loader that is used to load hand models.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+onLoad"></a>

### oculusHandModel.onLoad : <code>function</code>
A callback that is executed when a hand model has been loaded.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+path"></a>

### oculusHandModel.path : <code>string</code>
The path to the model repository.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>&quot;null&quot;</code>  
<a name="OculusHandModel+mesh"></a>

### oculusHandModel.mesh : <code>Mesh</code>
The model mesh.

**Kind**: instance property of [<code>OculusHandModel</code>](#OculusHandModel)  
**Default**: <code>null</code>  
<a name="OculusHandModel+updateMatrixWorld"></a>

### oculusHandModel.updateMatrixWorld([force])
Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.

**Kind**: instance method of [<code>OculusHandModel</code>](#OculusHandModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of world matrices is forced even when [Object3D#matrixWorldAutoUpdate](Object3D#matrixWorldAutoUpdate) is set to `false`. |

<a name="OculusHandModel+getPointerPosition"></a>

### oculusHandModel.getPointerPosition() ⇒ <code>Vector3</code> \| <code>null</code>
Returns the pointer position which is the position of the index finger tip.

**Kind**: instance method of [<code>OculusHandModel</code>](#OculusHandModel)  
**Returns**: <code>Vector3</code> \| <code>null</code> - The pointer position. Returns `null` if not index finger tip joint was found.  
<a name="OculusHandModel+intersectBoxObject"></a>

### oculusHandModel.intersectBoxObject(boxObject) ⇒ <code>boolean</code>
Returns `true` if the current pointer position (the index finger tip) intersections
with the given box object.

**Kind**: instance method of [<code>OculusHandModel</code>](#OculusHandModel)  
**Returns**: <code>boolean</code> - Whether an intersection was found or not.  

| Param | Type | Description |
| --- | --- | --- |
| boxObject | <code>Mesh</code> | The box object. |

<a name="OculusHandModel+checkButton"></a>

### oculusHandModel.checkButton(button)
Executed actions depending on the interaction state with
the given button.

**Kind**: instance method of [<code>OculusHandModel</code>](#OculusHandModel)  

| Param | Type | Description |
| --- | --- | --- |
| button | <code>Object</code> | The button. |

<a name="OculusHandPointerModel"></a>

## OculusHandPointerModel ⇐ <code>Object3D</code>
Represents an Oculus hand pointer model.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [OculusHandPointerModel](#OculusHandPointerModel) ⇐ <code>Object3D</code>
    * [new OculusHandPointerModel(hand, controller)](#new_OculusHandPointerModel_new)
    * [.hand](#OculusHandPointerModel+hand) : <code>Group</code>
    * [.controller](#OculusHandPointerModel+controller) : <code>Group</code>
    * [.pointerGeometry](#OculusHandPointerModel+pointerGeometry) : <code>BufferGeometry</code>
    * [.pointerMesh](#OculusHandPointerModel+pointerMesh) : <code>Mesh</code>
    * [.pointerObject](#OculusHandPointerModel+pointerObject) : <code>Object3D</code>
    * [.pinched](#OculusHandPointerModel+pinched) : <code>boolean</code>
    * [.attached](#OculusHandPointerModel+attached) : <code>boolean</code>
    * [.cursorObject](#OculusHandPointerModel+cursorObject) : <code>Mesh</code>
    * [.raycaster](#OculusHandPointerModel+raycaster) : <code>Raycaster</code>
    * [.createPointer()](#OculusHandPointerModel+createPointer)
    * [.updateMatrixWorld([force])](#OculusHandPointerModel+updateMatrixWorld)
    * [.isPinched()](#OculusHandPointerModel+isPinched) ⇒ <code>boolean</code>
    * [.setAttached(attached)](#OculusHandPointerModel+setAttached)
    * [.isAttached()](#OculusHandPointerModel+isAttached) ⇒ <code>boolean</code>
    * [.intersectObject(object, [recursive])](#OculusHandPointerModel+intersectObject) ⇒ <code>Array.&lt;Raycaster~Intersection&gt;</code>
    * [.intersectObjects(objects, [recursive])](#OculusHandPointerModel+intersectObjects) ⇒ <code>Array.&lt;Raycaster~Intersection&gt;</code>
    * [.checkIntersections(objects, [recursive])](#OculusHandPointerModel+checkIntersections)
    * [.setCursor(distance)](#OculusHandPointerModel+setCursor)
    * [.dispose()](#OculusHandPointerModel+dispose)

<a name="new_OculusHandPointerModel_new"></a>

### new OculusHandPointerModel(hand, controller)
Constructs a new Oculus hand model.


| Param | Type | Description |
| --- | --- | --- |
| hand | <code>Group</code> | The hand controller. |
| controller | <code>Group</code> | The WebXR controller in target ray space. |

<a name="OculusHandPointerModel+hand"></a>

### oculusHandPointerModel.hand : <code>Group</code>
The hand controller.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
<a name="OculusHandPointerModel+controller"></a>

### oculusHandPointerModel.controller : <code>Group</code>
The WebXR controller in target ray space.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
<a name="OculusHandPointerModel+pointerGeometry"></a>

### oculusHandPointerModel.pointerGeometry : <code>BufferGeometry</code>
The pointer geometry.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+pointerMesh"></a>

### oculusHandPointerModel.pointerMesh : <code>Mesh</code>
The pointer mesh.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+pointerObject"></a>

### oculusHandPointerModel.pointerObject : <code>Object3D</code>
The pointer object that holds the pointer mesh.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+pinched"></a>

### oculusHandPointerModel.pinched : <code>boolean</code>
Whether the model is pinched or not.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>false</code>  
<a name="OculusHandPointerModel+attached"></a>

### oculusHandPointerModel.attached : <code>boolean</code>
Whether the model is attached or not.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>false</code>  
<a name="OculusHandPointerModel+cursorObject"></a>

### oculusHandPointerModel.cursorObject : <code>Mesh</code>
The cursor object.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+raycaster"></a>

### oculusHandPointerModel.raycaster : <code>Raycaster</code>
The internal raycaster used for detecting
intersections.

**Kind**: instance property of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Default**: <code>null</code>  
<a name="OculusHandPointerModel+createPointer"></a>

### oculusHandPointerModel.createPointer()
Creates a pointer mesh and adds it to this model.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
<a name="OculusHandPointerModel+updateMatrixWorld"></a>

### oculusHandPointerModel.updateMatrixWorld([force])
Overwritten with a custom implementation. Makes sure the internal pointer and raycaster are updated.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of world matrices is forced even when [Object3D#matrixWorldAutoUpdate](Object3D#matrixWorldAutoUpdate) is set to `false`. |

<a name="OculusHandPointerModel+isPinched"></a>

### oculusHandPointerModel.isPinched() ⇒ <code>boolean</code>
Returns `true` is the model is pinched.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Returns**: <code>boolean</code> - Whether the model is pinched or not.  
<a name="OculusHandPointerModel+setAttached"></a>

### oculusHandPointerModel.setAttached(attached)
Sets the attached state.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  

| Param | Type | Description |
| --- | --- | --- |
| attached | <code>boolean</code> | Whether the model is attached or not. |

<a name="OculusHandPointerModel+isAttached"></a>

### oculusHandPointerModel.isAttached() ⇒ <code>boolean</code>
Returns `true` is the model is attached.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Returns**: <code>boolean</code> - Whether the model is attached or not.  
<a name="OculusHandPointerModel+intersectObject"></a>

### oculusHandPointerModel.intersectObject(object, [recursive]) ⇒ <code>Array.&lt;Raycaster~Intersection&gt;</code>
Performs an intersection test with the model's raycaster and the given object.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Returns**: <code>Array.&lt;Raycaster~Intersection&gt;</code> - An array holding the intersection points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| object | <code>Object3D</code> |  | The 3D object to check for intersection with the ray. |
| [recursive] | <code>boolean</code> | <code>true</code> | If set to `true`, it also checks all descendants. Otherwise it only checks intersection with the object. |

<a name="OculusHandPointerModel+intersectObjects"></a>

### oculusHandPointerModel.intersectObjects(objects, [recursive]) ⇒ <code>Array.&lt;Raycaster~Intersection&gt;</code>
Performs an intersection test with the model's raycaster and the given objects.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
**Returns**: <code>Array.&lt;Raycaster~Intersection&gt;</code> - An array holding the intersection points.  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| objects | <code>Array.&lt;Object3D&gt;</code> |  | The 3D objects to check for intersection with the ray. |
| [recursive] | <code>boolean</code> | <code>true</code> | If set to `true`, it also checks all descendants. Otherwise it only checks intersection with the object. |

<a name="OculusHandPointerModel+checkIntersections"></a>

### oculusHandPointerModel.checkIntersections(objects, [recursive])
Checks for intersections between the model's raycaster and the given objects. The method
updates the cursor object to the intersection point.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| objects | <code>Array.&lt;Object3D&gt;</code> |  | The 3D objects to check for intersection with the ray. |
| [recursive] | <code>boolean</code> | <code>false</code> | If set to `true`, it also checks all descendants. Otherwise it only checks intersection with the object. |

<a name="OculusHandPointerModel+setCursor"></a>

### oculusHandPointerModel.setCursor(distance)
Sets the cursor to the given distance.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  

| Param | Type | Description |
| --- | --- | --- |
| distance | <code>number</code> | The distance to set the cursor to. |

<a name="OculusHandPointerModel+dispose"></a>

### oculusHandPointerModel.dispose()
Frees the GPU-related resources allocated by this instance. Call this
method whenever this instance is no longer used in your app.

**Kind**: instance method of [<code>OculusHandPointerModel</code>](#OculusHandPointerModel)  
<a name="module_Text2D"></a>

## Text2D
<a name="module_Text2D..createText"></a>

### Text2D~createText(message, height) ⇒ <code>Mesh</code>
A helper function for creating a simple plane mesh
that can be used as a text label. The mesh's material
holds a canvas texture that displays the given message.

**Kind**: inner method of [<code>Text2D</code>](#module_Text2D)  
**Returns**: <code>Mesh</code> - The plane mesh representing a text label.  

| Param | Type | Description |
| --- | --- | --- |
| message | <code>string</code> | The message to display. |
| height | <code>number</code> | The labels height. |

<a name="VRButton"></a>

## VRButton
A utility class for creating a button that allows to initiate
immersive VR sessions based on WebXR. The button can be created
with a factory method and then appended ot the website's DOM.

```js
document.body.appendChild( VRButton.createButton( renderer ) );
```

**Kind**: global class  

* [VRButton](#VRButton)
    * [.xrSessionIsGranted](#VRButton.xrSessionIsGranted) : <code>boolean</code>
    * [.createButton(renderer, [sessionInit])](#VRButton.createButton) ⇒ <code>HTMLElement</code>
    * [.registerSessionGrantedListener()](#VRButton.registerSessionGrantedListener)

<a name="VRButton.xrSessionIsGranted"></a>

### VRButton.xrSessionIsGranted : <code>boolean</code>
Whether a XR session has been granted or not.

**Kind**: static property of [<code>VRButton</code>](#VRButton)  
**Default**: <code>false</code>  
<a name="VRButton.createButton"></a>

### VRButton.createButton(renderer, [sessionInit]) ⇒ <code>HTMLElement</code>
Constructs a new VR button.

**Kind**: static method of [<code>VRButton</code>](#VRButton)  
**Returns**: <code>HTMLElement</code> - The button or an error message if `immersive-ar` isn't supported.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> \| <code>WebGPURenderer</code> | The renderer. |
| [sessionInit] | <code>XRSessionInit</code> | The a configuration object for the AR session. |

<a name="VRButton.registerSessionGrantedListener"></a>

### VRButton.registerSessionGrantedListener()
Registers a `sessiongranted` event listener. When a session is granted, the [VRButton#xrSessionIsGranted](VRButton#xrSessionIsGranted)
flag will evaluate to `true`. This method is automatically called by the module itself so there
should be no need to use it on app level.

**Kind**: static method of [<code>VRButton</code>](#VRButton)  
<a name="XRButton"></a>

## XRButton
A utility class for creating a button that allows to initiate
immersive XR sessions based on WebXR. The button can be created
with a factory method and then appended ot the website's DOM.

```js
document.body.appendChild( XRButton.createButton( renderer ) );
```

Compared to [ARButton](ARButton) and [VRButton](VRButton), this class will
try to offer an immersive AR session first. If the device does not
support this type of session, it uses an immersive VR session.

**Kind**: global class  
<a name="XRButton.createButton"></a>

### XRButton.createButton(renderer, [sessionInit]) ⇒ <code>HTMLElement</code>
Constructs a new XR button.

**Kind**: static method of [<code>XRButton</code>](#XRButton)  
**Returns**: <code>HTMLElement</code> - The button or an error message if WebXR isn't supported.  

| Param | Type | Description |
| --- | --- | --- |
| renderer | <code>WebGLRenderer</code> \| <code>WebGPURenderer</code> | The renderer. |
| [sessionInit] | <code>XRSessionInit</code> | The a configuration object for the AR session. |

## Classes

<dl>
<dt><a href="#XRControllerModel">XRControllerModel</a> ⇐ <code>Object3D</code></dt>
<dd><p>Represents a XR controller model.</p>
</dd>
<dt><a href="#XRControllerModelFactory">XRControllerModelFactory</a></dt>
<dd><p>Allows to create controller models for WebXR controllers that can be added as a visual
representation to your scene. <code>XRControllerModelFactory</code> will automatically fetch controller
models that match what the user is holding as closely as possible. The models should be
attached to the object returned from getControllerGrip in order to match the orientation of
the held device.</p>
<p>This module depends on the <a href="https://github.com/immersive-web/webxr-input-profiles/blob/main/packages/motion-controllers/README.md">motion-controllers</a>
third-part library.</p>
<pre><code class="language-js">const controllerModelFactory = new XRControllerModelFactory();

const controllerGrip = renderer.xr.getControllerGrip( 0 );
controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );
scene.add( controllerGrip );
</code></pre>
</dd>
</dl>

<a name="XRControllerModel"></a>

## XRControllerModel ⇐ <code>Object3D</code>
Represents a XR controller model.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [XRControllerModel](#XRControllerModel) ⇐ <code>Object3D</code>
    * [new XRControllerModel()](#new_XRControllerModel_new)
    * [.motionController](#XRControllerModel+motionController) : <code>MotionController</code>
    * [.envMap](#XRControllerModel+envMap) : <code>Texture</code>
    * [.setEnvironmentMap(envMap)](#XRControllerModel+setEnvironmentMap) ⇒ [<code>XRControllerModel</code>](#XRControllerModel)
    * [.updateMatrixWorld([force])](#XRControllerModel+updateMatrixWorld)

<a name="new_XRControllerModel_new"></a>

### new XRControllerModel()
Constructs a new XR controller model.

<a name="XRControllerModel+motionController"></a>

### xrControllerModel.motionController : <code>MotionController</code>
The motion controller.

**Kind**: instance property of [<code>XRControllerModel</code>](#XRControllerModel)  
**Default**: <code>null</code>  
<a name="XRControllerModel+envMap"></a>

### xrControllerModel.envMap : <code>Texture</code>
The controller's environment map.

**Kind**: instance property of [<code>XRControllerModel</code>](#XRControllerModel)  
**Default**: <code>null</code>  
<a name="XRControllerModel+setEnvironmentMap"></a>

### xrControllerModel.setEnvironmentMap(envMap) ⇒ [<code>XRControllerModel</code>](#XRControllerModel)
Sets an environment map that is applied to the controller model.

**Kind**: instance method of [<code>XRControllerModel</code>](#XRControllerModel)  
**Returns**: [<code>XRControllerModel</code>](#XRControllerModel) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| envMap | <code>Texture</code> | The environment map to apply. |

<a name="XRControllerModel+updateMatrixWorld"></a>

### xrControllerModel.updateMatrixWorld([force])
Overwritten with a custom implementation. Polls data from the XRInputSource and updates the
model's components to match the real world data.

**Kind**: instance method of [<code>XRControllerModel</code>](#XRControllerModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of world matrices is forced even when [Object3D#matrixWorldAutoUpdate](Object3D#matrixWorldAutoUpdate) is set to `false`. |

<a name="XRControllerModelFactory"></a>

## XRControllerModelFactory
Allows to create controller models for WebXR controllers that can be added as a visual
representation to your scene. `XRControllerModelFactory` will automatically fetch controller
models that match what the user is holding as closely as possible. The models should be
attached to the object returned from getControllerGrip in order to match the orientation of
the held device.

This module depends on the [motion-controllers](https://github.com/immersive-web/webxr-input-profiles/blob/main/packages/motion-controllers/README.md)
third-part library.

```js
const controllerModelFactory = new XRControllerModelFactory();

const controllerGrip = renderer.xr.getControllerGrip( 0 );
controllerGrip.add( controllerModelFactory.createControllerModel( controllerGrip ) );
scene.add( controllerGrip );
```

**Kind**: global class  

* [XRControllerModelFactory](#XRControllerModelFactory)
    * [new XRControllerModelFactory([gltfLoader], [onLoad])](#new_XRControllerModelFactory_new)
    * [.gltfLoader](#XRControllerModelFactory+gltfLoader) : <code>GLTFLoader</code>
    * [.path](#XRControllerModelFactory+path) : <code>string</code>
    * [.onLoad](#XRControllerModelFactory+onLoad) : <code>function</code>
    * [.setPath(path)](#XRControllerModelFactory+setPath) ⇒ [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)
    * [.createControllerModel(controller)](#XRControllerModelFactory+createControllerModel) ⇒ [<code>XRControllerModel</code>](#XRControllerModel)

<a name="new_XRControllerModelFactory_new"></a>

### new XRControllerModelFactory([gltfLoader], [onLoad])
Constructs a new XR controller model factory.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [gltfLoader] | <code>GLTFLoader</code> | <code></code> | A glTF loader that is used to load controller models. |
| [onLoad] | <code>function</code> | <code></code> | A callback that is executed when a controller model has been loaded. |

<a name="XRControllerModelFactory+gltfLoader"></a>

### xrControllerModelFactory.gltfLoader : <code>GLTFLoader</code>
A glTF loader that is used to load controller models.

**Kind**: instance property of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
**Default**: <code>null</code>  
<a name="XRControllerModelFactory+path"></a>

### xrControllerModelFactory.path : <code>string</code>
The path to the model repository.

**Kind**: instance property of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
<a name="XRControllerModelFactory+onLoad"></a>

### xrControllerModelFactory.onLoad : <code>function</code>
A callback that is executed when a controller model has been loaded.

**Kind**: instance property of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
**Default**: <code>null</code>  
<a name="XRControllerModelFactory+setPath"></a>

### xrControllerModelFactory.setPath(path) ⇒ [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)
Sets the path to the model repository.

**Kind**: instance method of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
**Returns**: [<code>XRControllerModelFactory</code>](#XRControllerModelFactory) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The path to set. |

<a name="XRControllerModelFactory+createControllerModel"></a>

### xrControllerModelFactory.createControllerModel(controller) ⇒ [<code>XRControllerModel</code>](#XRControllerModel)
Creates a controller model for the given WebXR controller.

**Kind**: instance method of [<code>XRControllerModelFactory</code>](#XRControllerModelFactory)  
**Returns**: [<code>XRControllerModel</code>](#XRControllerModel) - The XR controller model.  

| Param | Type | Description |
| --- | --- | --- |
| controller | <code>Group</code> | The controller. |

<a name="XRHandMeshModel"></a>

## XRHandMeshModel
Represents one of the hand model types [XRHandModelFactory](XRHandModelFactory) might produce
depending on the selected profile. `XRHandMeshModel` represents a hand with a
custom asset.

**Kind**: global class  

* [XRHandMeshModel](#XRHandMeshModel)
    * [new XRHandMeshModel(handModel, controller, path, handedness, [loader], [onLoad])](#new_XRHandMeshModel_new)
    * [.controller](#XRHandMeshModel+controller) : <code>Group</code>
    * [.handModel](#XRHandMeshModel+handModel) : <code>XRHandModel</code>
    * [.bones](#XRHandMeshModel+bones) : <code>Array.&lt;Bone&gt;</code>
    * [.updateMesh()](#XRHandMeshModel+updateMesh)

<a name="new_XRHandMeshModel_new"></a>

### new XRHandMeshModel(handModel, controller, path, handedness, [loader], [onLoad])
Constructs a new XR hand mesh model.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| handModel | <code>XRHandModel</code> |  | The hand model. |
| controller | <code>Group</code> |  | The WebXR controller. |
| path | <code>string</code> |  | The model path. |
| handedness | <code>XRHandedness</code> |  | The handedness of the XR input source. |
| [loader] | <code>Loader</code> | <code></code> | The loader. If not provided, an instance of `GLTFLoader` will be used to load models. |
| [onLoad] | <code>function</code> | <code></code> | A callback that is executed when a controller model has been loaded. |

<a name="XRHandMeshModel+controller"></a>

### xrHandMeshModel.controller : <code>Group</code>
The WebXR controller.

**Kind**: instance property of [<code>XRHandMeshModel</code>](#XRHandMeshModel)  
<a name="XRHandMeshModel+handModel"></a>

### xrHandMeshModel.handModel : <code>XRHandModel</code>
The hand model.

**Kind**: instance property of [<code>XRHandMeshModel</code>](#XRHandMeshModel)  
<a name="XRHandMeshModel+bones"></a>

### xrHandMeshModel.bones : <code>Array.&lt;Bone&gt;</code>
An array of bones representing the bones
of the hand skeleton.

**Kind**: instance property of [<code>XRHandMeshModel</code>](#XRHandMeshModel)  
<a name="XRHandMeshModel+updateMesh"></a>

### xrHandMeshModel.updateMesh()
Updates the mesh based on the tracked XR joints data.

**Kind**: instance method of [<code>XRHandMeshModel</code>](#XRHandMeshModel)  
## Classes

<dl>
<dt><a href="#XRHandModel">XRHandModel</a> ⇐ <code>Object3D</code></dt>
<dd><p>Represents a XR hand model.</p>
</dd>
<dt><a href="#XRHandModelFactory">XRHandModelFactory</a></dt>
<dd><p>Similar to <a href="XRControllerModelFactory">XRControllerModelFactory</a>, this class allows to create hand models
for WebXR controllers that can be added as a visual representation to your scene.</p>
<pre><code class="language-js">const handModelFactory = new XRHandModelFactory();

const hand = renderer.xr.getHand( 0 );
hand.add( handModelFactory.createHandModel( hand ) );
scene.add( hand );
</code></pre>
</dd>
</dl>

<a name="XRHandModel"></a>

## XRHandModel ⇐ <code>Object3D</code>
Represents a XR hand model.

**Kind**: global class  
**Extends**: <code>Object3D</code>  

* [XRHandModel](#XRHandModel) ⇐ <code>Object3D</code>
    * [new XRHandModel(controller)](#new_XRHandModel_new)
    * [.controller](#XRHandModel+controller) : <code>Group</code>
    * [.motionController](#XRHandModel+motionController) : <code>MotionController</code>
    * [.envMap](#XRHandModel+envMap) : <code>Texture</code>
    * [.mesh](#XRHandModel+mesh) : <code>Mesh</code>
    * [.updateMatrixWorld([force])](#XRHandModel+updateMatrixWorld)

<a name="new_XRHandModel_new"></a>

### new XRHandModel(controller)
Constructs a new XR hand model.


| Param | Type | Description |
| --- | --- | --- |
| controller | <code>Group</code> | The hand controller. |

<a name="XRHandModel+controller"></a>

### xrHandModel.controller : <code>Group</code>
The hand controller.

**Kind**: instance property of [<code>XRHandModel</code>](#XRHandModel)  
<a name="XRHandModel+motionController"></a>

### xrHandModel.motionController : <code>MotionController</code>
The motion controller.

**Kind**: instance property of [<code>XRHandModel</code>](#XRHandModel)  
**Default**: <code>null</code>  
<a name="XRHandModel+envMap"></a>

### xrHandModel.envMap : <code>Texture</code>
The controller's environment map.

**Kind**: instance property of [<code>XRHandModel</code>](#XRHandModel)  
**Default**: <code>null</code>  
<a name="XRHandModel+mesh"></a>

### xrHandModel.mesh : <code>Mesh</code>
The model mesh.

**Kind**: instance property of [<code>XRHandModel</code>](#XRHandModel)  
**Default**: <code>null</code>  
<a name="XRHandModel+updateMatrixWorld"></a>

### xrHandModel.updateMatrixWorld([force])
Overwritten with a custom implementation. Makes sure the motion controller updates the mesh.

**Kind**: instance method of [<code>XRHandModel</code>](#XRHandModel)  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [force] | <code>boolean</code> | <code>false</code> | When set to `true`, a recomputation of world matrices is forced even when [Object3D#matrixWorldAutoUpdate](Object3D#matrixWorldAutoUpdate) is set to `false`. |

<a name="XRHandModelFactory"></a>

## XRHandModelFactory
Similar to [XRControllerModelFactory](XRControllerModelFactory), this class allows to create hand models
for WebXR controllers that can be added as a visual representation to your scene.

```js
const handModelFactory = new XRHandModelFactory();

const hand = renderer.xr.getHand( 0 );
hand.add( handModelFactory.createHandModel( hand ) );
scene.add( hand );
```

**Kind**: global class  

* [XRHandModelFactory](#XRHandModelFactory)
    * [new XRHandModelFactory([gltfLoader], [onLoad])](#new_XRHandModelFactory_new)
    * [.gltfLoader](#XRHandModelFactory+gltfLoader) : <code>GLTFLoader</code>
    * [.path](#XRHandModelFactory+path) : <code>string</code>
    * [.onLoad](#XRHandModelFactory+onLoad) : <code>function</code>
    * [.setPath(path)](#XRHandModelFactory+setPath) ⇒ [<code>XRHandModelFactory</code>](#XRHandModelFactory)
    * [.createHandModel(controller, [profile])](#XRHandModelFactory+createHandModel) ⇒ [<code>XRHandModel</code>](#XRHandModel)

<a name="new_XRHandModelFactory_new"></a>

### new XRHandModelFactory([gltfLoader], [onLoad])
Constructs a new XR hand model factory.


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| [gltfLoader] | <code>GLTFLoader</code> | <code></code> | A glTF loader that is used to load hand models. |
| [onLoad] | <code>function</code> | <code></code> | A callback that is executed when a hand model has been loaded. |

<a name="XRHandModelFactory+gltfLoader"></a>

### xrHandModelFactory.gltfLoader : <code>GLTFLoader</code>
A glTF loader that is used to load hand models.

**Kind**: instance property of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Default**: <code>null</code>  
<a name="XRHandModelFactory+path"></a>

### xrHandModelFactory.path : <code>string</code>
The path to the model repository.

**Kind**: instance property of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Default**: <code>&quot;null&quot;</code>  
<a name="XRHandModelFactory+onLoad"></a>

### xrHandModelFactory.onLoad : <code>function</code>
A callback that is executed when a hand model has been loaded.

**Kind**: instance property of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Default**: <code>null</code>  
<a name="XRHandModelFactory+setPath"></a>

### xrHandModelFactory.setPath(path) ⇒ [<code>XRHandModelFactory</code>](#XRHandModelFactory)
Sets the path to the hand model repository.

**Kind**: instance method of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Returns**: [<code>XRHandModelFactory</code>](#XRHandModelFactory) - A reference to this instance.  

| Param | Type | Description |
| --- | --- | --- |
| path | <code>string</code> | The path to set. |

<a name="XRHandModelFactory+createHandModel"></a>

### xrHandModelFactory.createHandModel(controller, [profile]) ⇒ [<code>XRHandModel</code>](#XRHandModel)
Creates a controller model for the given WebXR hand controller.

**Kind**: instance method of [<code>XRHandModelFactory</code>](#XRHandModelFactory)  
**Returns**: [<code>XRHandModel</code>](#XRHandModel) - The XR hand model.  

| Param | Type | Description |
| --- | --- | --- |
| controller | <code>Group</code> | The hand controller. |
| [profile] | <code>&#x27;spheres&#x27;</code> \| <code>&#x27;boxes&#x27;</code> \| <code>&#x27;mesh&#x27;</code> | The model profile that defines the model type. |

<a name="XRHandPrimitiveModel"></a>

## XRHandPrimitiveModel
Represents one of the hand model types [XRHandModelFactory](XRHandModelFactory) might produce
depending on the selected profile. `XRHandPrimitiveModel` represents a hand
with sphere or box primitives according to the selected `primitive` option.

**Kind**: global class  

* [XRHandPrimitiveModel](#XRHandPrimitiveModel)
    * [new XRHandPrimitiveModel(handModel, controller, path, handedness, options)](#new_XRHandPrimitiveModel_new)
    * _instance_
        * [.controller](#XRHandPrimitiveModel+controller) : <code>Group</code>
        * [.handModel](#XRHandPrimitiveModel+handModel) : <code>XRHandModel</code>
        * [.envMap](#XRHandPrimitiveModel+envMap) : <code>Texture</code>
        * [.updateMesh()](#XRHandPrimitiveModel+updateMesh)
    * _inner_
        * [~Options](#XRHandPrimitiveModel..Options) : <code>Object</code>

<a name="new_XRHandPrimitiveModel_new"></a>

### new XRHandPrimitiveModel(handModel, controller, path, handedness, options)
Constructs a new XR hand primitive model.


| Param | Type | Description |
| --- | --- | --- |
| handModel | <code>XRHandModel</code> | The hand model. |
| controller | <code>Group</code> | The WebXR controller. |
| path | <code>string</code> | The model path. |
| handedness | <code>XRHandedness</code> | The handedness of the XR input source. |
| options | [<code>Options</code>](#XRHandPrimitiveModel..Options) | The model options. |

<a name="XRHandPrimitiveModel+controller"></a>

### xrHandPrimitiveModel.controller : <code>Group</code>
The WebXR controller.

**Kind**: instance property of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
<a name="XRHandPrimitiveModel+handModel"></a>

### xrHandPrimitiveModel.handModel : <code>XRHandModel</code>
The hand model.

**Kind**: instance property of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
<a name="XRHandPrimitiveModel+envMap"></a>

### xrHandPrimitiveModel.envMap : <code>Texture</code>
The model's environment map.

**Kind**: instance property of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
**Default**: <code>null</code>  
<a name="XRHandPrimitiveModel+updateMesh"></a>

### xrHandPrimitiveModel.updateMesh()
Updates the mesh based on the tracked XR joints data.

**Kind**: instance method of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
<a name="XRHandPrimitiveModel..Options"></a>

### XRHandPrimitiveModel~Options : <code>Object</code>
Constructor options of `XRHandPrimitiveModel`.

**Kind**: inner typedef of [<code>XRHandPrimitiveModel</code>](#XRHandPrimitiveModel)  
**Properties**

| Name | Type | Description |
| --- | --- | --- |
| [primitive] | <code>&#x27;box&#x27;</code> \| <code>&#x27;sphere&#x27;</code> | The primitive type. |

<a name="XRPlanes"></a>

## XRPlanes ⇐ <code>Object3D</code>
A utility class for the WebXR Plane Detection Module. If planes
are detected by WebXR, this class will automatically add them
as thin box meshes to the scene when below code snippet is used.

```js
const planes = new XRPlanes( renderer );
scene.add( planes );
```

**Kind**: global class  
**Extends**: <code>Object3D</code>  
<a name="new_XRPlanes_new"></a>

### new XRPlanes(renderer)
Constructs a new XR plane container.


